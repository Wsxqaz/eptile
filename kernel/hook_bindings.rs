/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        unsafe { ::core::slice::from_raw_parts(self.as_ptr(), len) }
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        unsafe { ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len) }
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        unsafe { ::core::mem::transmute(self) }
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        unsafe { ::core::mem::transmute(self) }
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const CONFIG_IP6_NF_MATCH_AH_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_861_MODULE: u32 = 1;
pub const CONFIG_MTD_SPI_NAND_MODULE: u32 = 1;
pub const CONFIG_RING_BUFFER: u32 = 1;
pub const CONFIG_SND_SOC_WM8804_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_H323_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_SECCOMP_FILTER: u32 = 1;
pub const CONFIG_IP6_NF_SECURITY_MODULE: u32 = 1;
pub const CONFIG_SND_PROC_FS: u32 = 1;
pub const CONFIG_VFIO_PCI_MMAP: u32 = 1;
pub const CONFIG_SCSI_DMA: u32 = 1;
pub const CONFIG_IQS624_POS_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_FAMILY_BRIDGE: u32 = 1;
pub const CONFIG_TWL6040_CORE: u32 = 1;
pub const CONFIG_DRM_PRIVACY_SCREEN: u32 = 1;
pub const CONFIG_ADMV4420_MODULE: u32 = 1;
pub const CONFIG_INTEL_IDLE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_IQS5XX_MODULE: u32 = 1;
pub const CONFIG_TCP_MD5SIG: u32 = 1;
pub const CONFIG_HID_GT683R_MODULE: u32 = 1;
pub const CONFIG_CC_HAS_SANCOV_TRACE_PC: u32 = 1;
pub const CONFIG_DEFAULT_INIT: &[u8; 1usize] = b"\0";
pub const CONFIG_MT7615_COMMON_MODULE: u32 = 1;
pub const CONFIG_MICROCODE: u32 = 1;
pub const CONFIG_ATM_ENI_MODULE: u32 = 1;
pub const CONFIG_SOUNDWIRE_MODULE: u32 = 1;
pub const CONFIG_MMA7455_MODULE: u32 = 1;
pub const CONFIG_VIDEO_EM28XX_V4L2_MODULE: u32 = 1;
pub const CONFIG_TI_DAC5571_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CS3308_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_IPMARK_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ADV7511_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_DEBUG_VM_PGTABLE: u32 = 1;
pub const CONFIG_MAX1118_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_INEXIO_MODULE: u32 = 1;
pub const CONFIG_RTLBTCOEXIST_MODULE: u32 = 1;
pub const CONFIG_BATMAN_ADV_NC: u32 = 1;
pub const CONFIG_NFT_NAT_MODULE: u32 = 1;
pub const CONFIG_DW_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_POLYNOMIAL_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_WM831X_MODULE: u32 = 1;
pub const CONFIG_ZRAM_WRITEBACK: u32 = 1;
pub const CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK: u32 = 1;
pub const CONFIG_TOUCHSCREEN_WM9705: u32 = 1;
pub const CONFIG_INPUT_KEYBOARD: u32 = 1;
pub const CONFIG_BAREUDP_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ABITUGURU_MODULE: u32 = 1;
pub const CONFIG_INET_TABLE_PERTURB_ORDER: u32 = 16;
pub const CONFIG_ARCH_SUPPORTS_INT128: u32 = 1;
pub const CONFIG_IP_NF_TARGET_SYNPROXY_MODULE: u32 = 1;
pub const CONFIG_MEMORY_ISOLATION: u32 = 1;
pub const CONFIG_SLUB_CPU_PARTIAL: u32 = 1;
pub const CONFIG_USB_C67X00_HCD_MODULE: u32 = 1;
pub const CONFIG_RFS_ACCEL: u32 = 1;
pub const CONFIG_COMEDI_TEST_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_RT288X: u32 = 1;
pub const CONFIG_IP_NF_TARGET_REDIRECT_MODULE: u32 = 1;
pub const CONFIG_SERIO_ALTERA_PS2_MODULE: u32 = 1;
pub const CONFIG_DRM_GMA500_MODULE: u32 = 1;
pub const CONFIG_SCSI_MPI3MR_MODULE: u32 = 1;
pub const CONFIG_ARCH_WANTS_THP_SWAP: u32 = 1;
pub const CONFIG_CRC32: u32 = 1;
pub const CONFIG_DRM_XE_JOB_TIMEOUT_MAX: u32 = 10000;
pub const CONFIG_SND_SOC_MAX98396_MODULE: u32 = 1;
pub const CONFIG_I2C_BOARDINFO: u32 = 1;
pub const CONFIG_ATH9K_HTC_DEBUGFS: u32 = 1;
pub const CONFIG_DWC_XLGMAC_PCI_MODULE: u32 = 1;
pub const CONFIG_TI_ADC12138_MODULE: u32 = 1;
pub const CONFIG_DMI_SYSFS_MODULE: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_LTLK_MODULE: u32 = 1;
pub const CONFIG_XEN_PV: u32 = 1;
pub const CONFIG_DRM_VKMS_MODULE: u32 = 1;
pub const CONFIG_CROS_EC_PROTO: u32 = 1;
pub const CONFIG_USB_ALI_M5632: u32 = 1;
pub const CONFIG_NFT_FIB_INET_MODULE: u32 = 1;
pub const CONFIG_DM_SNAPSHOT_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_WM831X_MODULE: u32 = 1;
pub const CONFIG_IP_VS_MH_MODULE: u32 = 1;
pub const CONFIG_MFD_WM831X_I2C: u32 = 1;
pub const CONFIG_IMA_APPRAISE_BOOTPARAM: u32 = 1;
pub const CONFIG_CAIF_MODULE: u32 = 1;
pub const CONFIG_MEMREGION: u32 = 1;
pub const CONFIG_PNFS_FLEXFILE_LAYOUT_MODULE: u32 = 1;
pub const CONFIG_IR_JVC_DECODER_MODULE: u32 = 1;
pub const CONFIG_ZERO_CALL_USED_REGS: u32 = 1;
pub const CONFIG_X86_MCE: u32 = 1;
pub const CONFIG_PCMCIA_QLOGIC_MODULE: u32 = 1;
pub const CONFIG_SIGNED_PE_FILE_VERIFICATION: u32 = 1;
pub const CONFIG_USB_CONFIGFS_NCM: u32 = 1;
pub const CONFIG_DRM_NOUVEAU_MODULE: u32 = 1;
pub const CONFIG_FSCACHE: u32 = 1;
pub const CONFIG_UNICODE: u32 = 1;
pub const CONFIG_COMEDI_USBDUX_MODULE: u32 = 1;
pub const CONFIG_PARPORT_NOT_PC: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CPU_MODULE: u32 = 1;
pub const CONFIG_DVB_ISL6405_MODULE: u32 = 1;
pub const CONFIG_B43_BCMA_PIO: u32 = 1;
pub const CONFIG_AD7192_MODULE: u32 = 1;
pub const CONFIG_MOUSE_ELAN_I2C_MODULE: u32 = 1;
pub const CONFIG_USB_SNP_CORE_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_PCF85363_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CURVE25519_X86_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX1668_MODULE: u32 = 1;
pub const CONFIG_BLK_SED_OPAL: u32 = 1;
pub const CONFIG_MEDIATEK_MT6370_ADC_MODULE: u32 = 1;
pub const CONFIG_GPIO_AMD8111_MODULE: u32 = 1;
pub const CONFIG_SUNRPC_SWAP: u32 = 1;
pub const CONFIG_FB_TILEBLITTING: u32 = 1;
pub const CONFIG_TCM_QLA2XXX_MODULE: u32 = 1;
pub const CONFIG_KEY_DH_OPERATIONS: u32 = 1;
pub const CONFIG_IR_MCE_KBD_DECODER_MODULE: u32 = 1;
pub const CONFIG_MFD_RT5033_MODULE: u32 = 1;
pub const CONFIG_HSR_MODULE: u32 = 1;
pub const CONFIG_IXGBE_DCB: u32 = 1;
pub const CONFIG_NET_DSA_TAG_QCA_MODULE: u32 = 1;
pub const CONFIG_SECCOMP: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_CONSERVATIVE: u32 = 1;
pub const CONFIG_HIGH_RES_TIMERS: u32 = 1;
pub const CONFIG_PCMCIA_AXNET_MODULE: u32 = 1;
pub const CONFIG_COMMON_CLK_WM831X_MODULE: u32 = 1;
pub const CONFIG_KGDB_HONOUR_BLOCKLIST: u32 = 1;
pub const CONFIG_BE2NET_LANCER: u32 = 1;
pub const CONFIG_PVPANIC_MMIO_MODULE: u32 = 1;
pub const CONFIG_VIDEO_WM8739_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_SET_MEMORY: u32 = 1;
pub const CONFIG_DRM_AMD_DC: u32 = 1;
pub const CONFIG_SECURITY_TOMOYO_MAX_AUDIT_LOG: u32 = 1024;
pub const CONFIG_BLK_DEV_DM: u32 = 1;
pub const CONFIG_RTC_DRV_88PM80X_MODULE: u32 = 1;
pub const CONFIG_SWIOTLB_DYNAMIC: u32 = 1;
pub const CONFIG_WWAN_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_KBL_RT5660_MACH_MODULE: u32 = 1;
pub const CONFIG_PWM_TWL_MODULE: u32 = 1;
pub const CONFIG_RT2800USB_RT3573: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SOF_SSP_AMP_MACH_MODULE: u32 = 1;
pub const CONFIG_VLAN_8021Q_MODULE: u32 = 1;
pub const CONFIG_IP_MULTIPLE_TABLES: u32 = 1;
pub const CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT: u32 = 1;
pub const CONFIG_VFIO_PCI_VGA: u32 = 1;
pub const CONFIG_ACPI_BGRT: u32 = 1;
pub const CONFIG_SND_SOC_PCM1789_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SOF_REALTEK_COMMON_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LTC4260_MODULE: u32 = 1;
pub const CONFIG_UEVENT_HELPER: u32 = 1;
pub const CONFIG_CRYPTO_KEYWRAP_MODULE: u32 = 1;
pub const CONFIG_XEN_DOM0: u32 = 1;
pub const CONFIG_FIRMWARE_MEMMAP: u32 = 1;
pub const CONFIG_SSB_SDIOHOST: u32 = 1;
pub const CONFIG_BT_RFCOMM_MODULE: u32 = 1;
pub const CONFIG_FIX_EARLYCON_MEM: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_HEARTBEAT_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MPQ7932_MODULE: u32 = 1;
pub const CONFIG_RAS_CEC: u32 = 1;
pub const CONFIG_INTEL_PUNIT_IPC_MODULE: u32 = 1;
pub const CONFIG_BLK_INLINE_ENCRYPTION: u32 = 1;
pub const CONFIG_FB_TFT_HX8353D_MODULE: u32 = 1;
pub const CONFIG_ND_PFN_MODULE: u32 = 1;
pub const CONFIG_CHARGER_LP8727_MODULE: u32 = 1;
pub const CONFIG_SCSI_INITIO_MODULE: u32 = 1;
pub const CONFIG_STK8BA50_MODULE: u32 = 1;
pub const CONFIG_DVB_TDA1004X_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_DA9211_MODULE: u32 = 1;
pub const CONFIG_RFD77402_MODULE: u32 = 1;
pub const CONFIG_INPUT_RETU_PWRBUTTON_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ELAN: u32 = 1;
pub const CONFIG_JOYSTICK_ADI_MODULE: u32 = 1;
pub const CONFIG_DVB_BCM3510_MODULE: u32 = 1;
pub const CONFIG_INOTIFY_USER: u32 = 1;
pub const CONFIG_SND_SOC_RT286_MODULE: u32 = 1;
pub const CONFIG_PWM_DWC_CORE_MODULE: u32 = 1;
pub const CONFIG_WDAT_WDT_MODULE: u32 = 1;
pub const CONFIG_SECURITY_NETWORK_XFRM: u32 = 1;
pub const CONFIG_MHI_BUS_EP_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_NETBIOS_NS_MODULE: u32 = 1;
pub const CONFIG_HDMI: u32 = 1;
pub const CONFIG_MULTIPLEXER_MODULE: u32 = 1;
pub const CONFIG_SCSI_DH: u32 = 1;
pub const CONFIG_SCSI_LOGGING: u32 = 1;
pub const CONFIG_DRM_I2C_NXP_TDA9950_MODULE: u32 = 1;
pub const CONFIG_SAMPLES: u32 = 1;
pub const CONFIG_SX9500_MODULE: u32 = 1;
pub const CONFIG_FB_CYBER2000_DDC: u32 = 1;
pub const CONFIG_BRIDGE_EBT_T_FILTER_MODULE: u32 = 1;
pub const CONFIG_NETWORK_FILESYSTEMS: u32 = 1;
pub const CONFIG_SND_SOC_AMD_YC_MACH_MODULE: u32 = 1;
pub const CONFIG_IRQ_POLL: u32 = 1;
pub const CONFIG_JOYSTICK_IFORCE_232_MODULE: u32 = 1;
pub const CONFIG_B53_SERDES_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_LOOPBACK_MODULE: u32 = 1;
pub const CONFIG_HID_MCP2221_MODULE: u32 = 1;
pub const CONFIG_TCG_TIS_SPI_CR50: u32 = 1;
pub const CONFIG_KVM_INTEL_MODULE: u32 = 1;
pub const CONFIG_ASUS_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_NF_FLOW_TABLE_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_MD4_MODULE: u32 = 1;
pub const CONFIG_BCMA_HOST_PCI: u32 = 1;
pub const CONFIG_AD7298_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_METEORLAKE_MODULE: u32 = 1;
pub const CONFIG_SATA_AHCI_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_USB_SI470X_MODULE: u32 = 1;
pub const CONFIG_THERMAL_GOV_BANG_BANG: u32 = 1;
pub const CONFIG_X86_MINIMUM_CPU_FAMILY: u32 = 64;
pub const CONFIG_AD7923_MODULE: u32 = 1;
pub const CONFIG_SND_I2S_HI6210_I2S_MODULE: u32 = 1;
pub const CONFIG_SCSI_BFA_FC_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_ONDEMAND: u32 = 1;
pub const CONFIG_KDB_DEFAULT_ENABLE: u32 = 1;
pub const CONFIG_MAX34408_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM95245_MODULE: u32 = 1;
pub const CONFIG_POWER_RESET_TPS65086: u32 = 1;
pub const CONFIG_USB_GSPCA_JL2005BCD_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MC13XXX_MODULE: u32 = 1;
pub const CONFIG_CM36651_MODULE: u32 = 1;
pub const CONFIG_AMD_PHY_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX18_ALSA_MODULE: u32 = 1;
pub const CONFIG_AD5770R_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBFUSB_MODULE: u32 = 1;
pub const CONFIG_FS_ENCRYPTION_INLINE_CRYPT: u32 = 1;
pub const CONFIG_MFD_CS47L24: u32 = 1;
pub const CONFIG_FB_CORE: u32 = 1;
pub const CONFIG_GLOB: u32 = 1;
pub const CONFIG_ARCH_WANT_LD_ORPHAN_WARN: u32 = 1;
pub const CONFIG_SND_SOC_CS42L73_MODULE: u32 = 1;
pub const CONFIG_SND_INTEL_SOUNDWIRE_ACPI_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_AEGIS128_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SY7636A_MODULE: u32 = 1;
pub const CONFIG_PARAVIRT_SPINLOCKS: u32 = 1;
pub const CONFIG_CGROUP_DEVICE: u32 = 1;
pub const CONFIG_WL12XX_MODULE: u32 = 1;
pub const CONFIG_X86_TSC: u32 = 1;
pub const CONFIG_104_QUAD_8_MODULE: u32 = 1;
pub const CONFIG_PPP_SYNC_TTY_MODULE: u32 = 1;
pub const CONFIG_SFC_SIENA_MCDI_MON: u32 = 1;
pub const CONFIG_FXLS8962AF_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUSPEND_POSSIBLE: u32 = 1;
pub const CONFIG_HID_PLANTRONICS_MODULE: u32 = 1;
pub const CONFIG_MFD_TPS65090: u32 = 1;
pub const CONFIG_MMU_LAZY_TLB_REFCOUNT: u32 = 1;
pub const CONFIG_DA9055_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_COMPAT_NETLINK_MESSAGES: u32 = 1;
pub const CONFIG_RC_CORE_MODULE: u32 = 1;
pub const CONFIG_TCG_VTPM_PROXY_MODULE: u32 = 1;
pub const CONFIG_USB_G_SERIAL_MODULE: u32 = 1;
pub const CONFIG_CGROUP_WRITEBACK: u32 = 1;
pub const CONFIG_PSTORE_DEFAULT_KMSG_BYTES: u32 = 10240;
pub const CONFIG_SND_SOC_TPA6130A2_MODULE: u32 = 1;
pub const CONFIG_MISC_ALCOR_PCI_MODULE: u32 = 1;
pub const CONFIG_MAC80211_STA_HASH_MAX_SIZE: u32 = 0;
pub const CONFIG_LEDS_PCA955X_MODULE: u32 = 1;
pub const CONFIG_HAVE_OBJTOOL_NOP_MCOUNT: u32 = 1;
pub const CONFIG_NLS_MAC_TURKISH_MODULE: u32 = 1;
pub const CONFIG_IXGBE_IPSEC: u32 = 1;
pub const CONFIG_IP_VS_NQ_MODULE: u32 = 1;
pub const CONFIG_DVB_DRXD_MODULE: u32 = 1;
pub const CONFIG_IR_IMON_DECODER_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_QEDR_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LTC4245_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_MMAP_RND_BITS: u32 = 1;
pub const CONFIG_TCG_TIS_CORE: u32 = 1;
pub const CONFIG_AMD_HSMP_MODULE: u32 = 1;
pub const CONFIG_YOGABOOK_MODULE: u32 = 1;
pub const CONFIG_HID_SPEEDLINK_MODULE: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_APOLLO_MODULE: u32 = 1;
pub const CONFIG_HIBERNATION: u32 = 1;
pub const CONFIG_BLK_DEV_NBD_MODULE: u32 = 1;
pub const CONFIG_NTB_EPF_MODULE: u32 = 1;
pub const CONFIG_PNPACPI: u32 = 1;
pub const CONFIG_USB_CDNS2_UDC_MODULE: u32 = 1;
pub const CONFIG_I8254_MODULE: u32 = 1;
pub const CONFIG_AD7280_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_SOF_MACH_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_NAVMAN_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_ATTR_SET: u32 = 1;
pub const CONFIG_RMI4_F12: u32 = 1;
pub const CONFIG_JOYSTICK_SPACEORB_MODULE: u32 = 1;
pub const CONFIG_ACPI_TAD_MODULE: u32 = 1;
pub const CONFIG_EDAC_I5400_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_HTCP_MODULE: u32 = 1;
pub const CONFIG_EXT4_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_SERIAL_RP2_MODULE: u32 = 1;
pub const CONFIG_SCSI_DEBUG_MODULE: u32 = 1;
pub const CONFIG_NET_SWITCHDEV: u32 = 1;
pub const CONFIG_SF_PDMA_MODULE: u32 = 1;
pub const CONFIG_PHYLINK_MODULE: u32 = 1;
pub const CONFIG_ZSTD_COMPRESS: u32 = 1;
pub const CONFIG_XEN_GRANT_DMA_ALLOC: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SOUNDWIRE_SOF_MACH_MODULE: u32 = 1;
pub const CONFIG_IPV6_IOAM6_LWTUNNEL: u32 = 1;
pub const CONFIG_DRM_I915_MODULE: u32 = 1;
pub const CONFIG_BINFMT_MISC_MODULE: u32 = 1;
pub const CONFIG_SENSORS_AD7314_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_KBL_MODULE: u32 = 1;
pub const CONFIG_RTW89_DEBUGMSG: u32 = 1;
pub const CONFIG_CXL_SUSPEND: u32 = 1;
pub const CONFIG_SND_SOC_PCM179X_I2C_MODULE: u32 = 1;
pub const CONFIG_CXL_PORT_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_HELPER_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MT6397_MODULE: u32 = 1;
pub const CONFIG_SSB_POSSIBLE: u32 = 1;
pub const CONFIG_SND_SOC_PEB2466_MODULE: u32 = 1;
pub const CONFIG_HPET_MMAP_DEFAULT: u32 = 1;
pub const CONFIG_NFS_V4_2: u32 = 1;
pub const CONFIG_USBIP_VUDC_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_T_NAT_MODULE: u32 = 1;
pub const CONFIG_VIDEO_SAA7134_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_SIP_MODULE: u32 = 1;
pub const CONFIG_HAVE_OBJTOOL: u32 = 1;
pub const CONFIG_USB_F_EEM_MODULE: u32 = 1;
pub const CONFIG_SENSORS_W83792D_MODULE: u32 = 1;
pub const CONFIG_SENSORS_INA3221_MODULE: u32 = 1;
pub const CONFIG_MMU_NOTIFIER: u32 = 1;
pub const CONFIG_SYSV68_PARTITION: u32 = 1;
pub const CONFIG_RADIO_SHARK_MODULE: u32 = 1;
pub const CONFIG_ASYMMETRIC_KEY_TYPE: u32 = 1;
pub const CONFIG_VFIO_VIRQFD: u32 = 1;
pub const CONFIG_SCSI_UFS_CRYPTO: u32 = 1;
pub const CONFIG_VHOST_VSOCK_MODULE: u32 = 1;
pub const CONFIG_NET_9P_RDMA_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_ELANTECH_SMBUS: u32 = 1;
pub const CONFIG_TRANSPARENT_HUGEPAGE_MADVISE: u32 = 1;
pub const CONFIG_DRM_RADEON_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_STATISTIC_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_PCIMIO_MODULE: u32 = 1;
pub const CONFIG_ACPI_PRMT: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_1032_MODULE: u32 = 1;
pub const CONFIG_TERANETICS_PHY_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_855_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_ILI9486_MODULE: u32 = 1;
pub const CONFIG_USER_EVENTS: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BYT_CHT_CX2072X_MACH_MODULE: u32 = 1;
pub const CONFIG_SPI_DYNAMIC: u32 = 1;
pub const CONFIG_ARCH_CORRECT_STACKTRACE_ON_KRETPROBE: u32 = 1;
pub const CONFIG_ATH9K_COMMON_SPECTRAL: u32 = 1;
pub const CONFIG_MPTCP_IPV6: u32 = 1;
pub const CONFIG_MTD_CMDLINE_PARTS_MODULE: u32 = 1;
pub const CONFIG_TMP006_MODULE: u32 = 1;
pub const CONFIG_SECURITY_YAMA: u32 = 1;
pub const CONFIG_VIDEO_SAA7127_MODULE: u32 = 1;
pub const CONFIG_I2C_ISMT_MODULE: u32 = 1;
pub const CONFIG_BLK_CGROUP_FC_APPID: u32 = 1;
pub const CONFIG_AD5758_MODULE: u32 = 1;
pub const CONFIG_UHID_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_ATMEL_ECC_MODULE: u32 = 1;
pub const CONFIG_NETCONSOLE_DYNAMIC: u32 = 1;
pub const CONFIG_UBSAN_BOUNDS: u32 = 1;
pub const CONFIG_EDAC_I5100_MODULE: u32 = 1;
pub const CONFIG_DVB_EC100_MODULE: u32 = 1;
pub const CONFIG_IP_NF_NAT_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_EDGEPORT_TI_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_HID_MODULE: u32 = 1;
pub const CONFIG_USB_CHIPIDEA_GENERIC_MODULE: u32 = 1;
pub const CONFIG_SIGNATURE: u32 = 1;
pub const CONFIG_RTC_DRV_PCF50633_MODULE: u32 = 1;
pub const CONFIG_HDLC_RAW_MODULE: u32 = 1;
pub const CONFIG_B43LEGACY_LEDS: u32 = 1;
pub const CONFIG_BME680_SPI_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_SAFE_MODULE: u32 = 1;
pub const CONFIG_NFC_NCI_UART_MODULE: u32 = 1;
pub const CONFIG_DVB_LGS8GL5_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_CROS_EC_MODULE: u32 = 1;
pub const CONFIG_INTEL_MEI_HDCP_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_NF_EBTABLES_MODULE: u32 = 1;
pub const CONFIG_HARDLOCKUP_DETECTOR_PERF: u32 = 1;
pub const CONFIG_DVB_LG2160_MODULE: u32 = 1;
pub const CONFIG_MTD_AMD76XROM_MODULE: u32 = 1;
pub const CONFIG_FW_LOADER_COMPRESS: u32 = 1;
pub const CONFIG_USB_OHCI_LITTLE_ENDIAN: u32 = 1;
pub const CONFIG_NET_SCH_FIFO: u32 = 1;
pub const CONFIG_WILC1000_SPI_MODULE: u32 = 1;
pub const CONFIG_REISERFS_FS_MODULE: u32 = 1;
pub const CONFIG_SWPHY: u32 = 1;
pub const CONFIG_STM_SOURCE_CONSOLE_MODULE: u32 = 1;
pub const CONFIG_TWL4030_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_THP_SWAP: u32 = 1;
pub const CONFIG_SATA_NV_MODULE: u32 = 1;
pub const CONFIG_FSNOTIFY: u32 = 1;
pub const CONFIG_ACPI_CONFIGFS_MODULE: u32 = 1;
pub const CONFIG_LEDS_MAX8997_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_LOOP_MIN_COUNT: u32 = 8;
pub const CONFIG_STP_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SQ905_MODULE: u32 = 1;
pub const CONFIG_MFD_TPS65910: u32 = 1;
pub const CONFIG_SPI_CADENCE_MODULE: u32 = 1;
pub const CONFIG_DVB_AU8522_MODULE: u32 = 1;
pub const CONFIG_INET6_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_NVDIMM_KEYS: u32 = 1;
pub const CONFIG_REGULATOR_MAX8925_MODULE: u32 = 1;
pub const CONFIG_INTEL_RAPL_MODULE: u32 = 1;
pub const CONFIG_VIDEO_I2C_MODULE: u32 = 1;
pub const CONFIG_SCSI_DC395x_MODULE: u32 = 1;
pub const CONFIG_AS_WRUSS: u32 = 1;
pub const CONFIG_DVB_M88RS2000_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_SIP_MODULE: u32 = 1;
pub const CONFIG_STACK_TRACER: u32 = 1;
pub const CONFIG_MEDIA_ATTACH: u32 = 1;
pub const CONFIG_SND_NM256_MODULE: u32 = 1;
pub const CONFIG_UCLAMP_BUCKETS_COUNT: u32 = 5;
pub const CONFIG_CRYPTO_MANAGER_DISABLE_TESTS: u32 = 1;
pub const CONFIG_SENSORS_RM3100_MODULE: u32 = 1;
pub const CONFIG_HIDRAW: u32 = 1;
pub const CONFIG_NET_SCH_FQ_CODEL_MODULE: u32 = 1;
pub const CONFIG_WIL6210_ISR_COR: u32 = 1;
pub const CONFIG_SENSORS_ADM1025_MODULE: u32 = 1;
pub const CONFIG_HAVE_KERNEL_LZMA: u32 = 1;
pub const CONFIG_CEC_GPIO_MODULE: u32 = 1;
pub const CONFIG_HID_PRODIKEYS_MODULE: u32 = 1;
pub const CONFIG_NET_TC_SKB_EXT: u32 = 1;
pub const CONFIG_RT2X00_LIB_LEDS: u32 = 1;
pub const CONFIG_LIQUIDIO_CORE_MODULE: u32 = 1;
pub const CONFIG_RTL8XXXU_UNTESTED: u32 = 1;
pub const CONFIG_NET_PTP_CLASSIFY: u32 = 1;
pub const CONFIG_UNIX_DIAG_MODULE: u32 = 1;
pub const CONFIG_TSYS02D_MODULE: u32 = 1;
pub const CONFIG_VCNL4000_MODULE: u32 = 1;
pub const CONFIG_AL3010_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM3168A_SPI_MODULE: u32 = 1;
pub const CONFIG_IP_VS_SED_MODULE: u32 = 1;
pub const CONFIG_GENERIC_SMP_IDLE_THREAD: u32 = 1;
pub const CONFIG_CRYPTO_SM3_GENERIC_MODULE: u32 = 1;
pub const CONFIG_HID_COUGAR_MODULE: u32 = 1;
pub const CONFIG_MOUSE_CYAPA_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_QUALCOMM: u32 = 1;
pub const CONFIG_DVB_DS3000_MODULE: u32 = 1;
pub const CONFIG_CHARGER_LT3651_MODULE: u32 = 1;
pub const CONFIG_INTEL_SCU_IPC: u32 = 1;
pub const CONFIG_FB_S1D13XXX_MODULE: u32 = 1;
pub const CONFIG_MTD_SST25L_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_NUMA_BALANCING: u32 = 1;
pub const CONFIG_SD_ADC_MODULATOR_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_LP3971_MODULE: u32 = 1;
pub const CONFIG_SND_USB_AUDIO_MIDI_V2: u32 = 1;
pub const CONFIG_DM_FLAKEY_MODULE: u32 = 1;
pub const CONFIG_FUNCTION_GRAPH_RETVAL: u32 = 1;
pub const CONFIG_VME_USER_MODULE: u32 = 1;
pub const CONFIG_PATA_OPTIDMA_MODULE: u32 = 1;
pub const CONFIG_MACVTAP_MODULE: u32 = 1;
pub const CONFIG_DYNAMIC_DEBUG: u32 = 1;
pub const CONFIG_LEDS_REGULATOR_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_T4VF_MODULE: u32 = 1;
pub const CONFIG_CPUMASK_OFFSTACK: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_CRASH_DUMP: u32 = 1;
pub const CONFIG_USB_SERIAL_FTDI_SIO_MODULE: u32 = 1;
pub const CONFIG_EXTCON_RT8973A_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_EZCHIP: u32 = 1;
pub const CONFIG_MFD_CS42L43_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_REDIRECT_MODULE: u32 = 1;
pub const CONFIG_XEN_COMPAT_XENFS: u32 = 1;
pub const CONFIG_XEN_SCSI_BACKEND_MODULE: u32 = 1;
pub const CONFIG_INTEL_TH_PCI_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_TIOCMD_MODULE: u32 = 1;
pub const CONFIG_MEDIA_DIGITAL_TV_SUPPORT: u32 = 1;
pub const CONFIG_RV_REACTORS: u32 = 1;
pub const CONFIG_8139CP_MODULE: u32 = 1;
pub const CONFIG_LDISC_AUTOLOAD: u32 = 1;
pub const CONFIG_GREYBUS_ES2_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CROS_EC_CODEC_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_RSA: u32 = 1;
pub const CONFIG_SND_HDA_SCODEC_CS35L56_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_QM1D1B0004_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_OCELOT_8021Q_MODULE: u32 = 1;
pub const CONFIG_FIB_RULES: u32 = 1;
pub const CONFIG_HID_ACRUX_FF: u32 = 1;
pub const CONFIG_PINCTRL_ALDERLAKE_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CRCT10DIF: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2408_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_OBEX: u32 = 1;
pub const CONFIG_RTC_DRV_MCP795_MODULE: u32 = 1;
pub const CONFIG_DVB_FIREDTV_INPUT: u32 = 1;
pub const CONFIG_SND_SOC_ADI_AXI_I2S_MODULE: u32 = 1;
pub const CONFIG_SND_ES1968_INPUT: u32 = 1;
pub const CONFIG_SCSI_MYRB_MODULE: u32 = 1;
pub const CONFIG_IP_VS_NFCT: u32 = 1;
pub const CONFIG_HID_EMS_FF_MODULE: u32 = 1;
pub const CONFIG_NTB_MSI: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_16XX_MODULE: u32 = 1;
pub const CONFIG_USB_AUTOSUSPEND_DELAY: u32 = 2;
pub const CONFIG_VLAN_8021Q_GVRP: u32 = 1;
pub const CONFIG_VDPA_USER_MODULE: u32 = 1;
pub const CONFIG_IWLWIFI_DEBUGFS: u32 = 1;
pub const CONFIG_IP_SET_HASH_NETIFACE_MODULE: u32 = 1;
pub const CONFIG_PSTORE_BLK_KMSG_SIZE: u32 = 64;
pub const CONFIG_IP6_NF_MANGLE_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_DSA_MODULE: u32 = 1;
pub const CONFIG_MTD_PLATRAM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ES8316_MODULE: u32 = 1;
pub const CONFIG_SYSFB_SIMPLEFB: u32 = 1;
pub const CONFIG_SIOX_BUS_GPIO_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_SI2157_MODULE: u32 = 1;
pub const CONFIG_SCSI_CONSTANTS: u32 = 1;
pub const CONFIG_HAVE_KVM_DIRTY_RING_ACQ_REL: u32 = 1;
pub const CONFIG_HAVE_IRQ_TIME_ACCOUNTING: u32 = 1;
pub const CONFIG_CFAG12864B_MODULE: u32 = 1;
pub const CONFIG_BT_MRVL_SDIO_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_REALM_MODULE: u32 = 1;
pub const CONFIG_MFD_ATC260X_MODULE: u32 = 1;
pub const CONFIG_SFC_FALCON_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBPA10X_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_OCELOT_MODULE: u32 = 1;
pub const CONFIG_MEGARAID_NEWGEN: u32 = 1;
pub const CONFIG_INTEL_TXT: u32 = 1;
pub const CONFIG_HID_GFRM_MODULE: u32 = 1;
pub const CONFIG_SQUASHFS_XATTR: u32 = 1;
pub const CONFIG_NET_DSA_MICROCHIP_KSZ_COMMON_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED: u32 = 1;
pub const CONFIG_IP_VS_RR_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_CHT_BSW_MAX98090_TI_MACH_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT1019_MODULE: u32 = 1;
pub const CONFIG_IPV6: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BDW_RT5650_MACH_MODULE: u32 = 1;
pub const CONFIG_ALTERA_PR_IP_CORE_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_QUALCOMM_MODULE: u32 = 1;
pub const CONFIG_HAVE_STACKPROTECTOR: u32 = 1;
pub const CONFIG_MAX1027_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_HFI1_MODULE: u32 = 1;
pub const CONFIG_VIDEO_S5K6A3_MODULE: u32 = 1;
pub const CONFIG_MT76x02_LIB_MODULE: u32 = 1;
pub const CONFIG_NET_9P_MODULE: u32 = 1;
pub const CONFIG_NET_HANDSHAKE: u32 = 1;
pub const CONFIG_REGULATOR_TPS62360_MODULE: u32 = 1;
pub const CONFIG_USB_GADGET_TARGET_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_AEAD: u32 = 1;
pub const CONFIG_FB_HECUBA_MODULE: u32 = 1;
pub const CONFIG_PATA_PARPORT_BPCK_MODULE: u32 = 1;
pub const CONFIG_AUDIT_ARCH: u32 = 1;
pub const CONFIG_NET_EMATCH_IPT_MODULE: u32 = 1;
pub const CONFIG_SENSORS_W83773G_MODULE: u32 = 1;
pub const CONFIG_COMPAT: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_ES8336_MODULE: u32 = 1;
pub const CONFIG_POWERCAP: u32 = 1;
pub const CONFIG_I2C_VIRTIO_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL: u32 = 1;
pub const CONFIG_MAGIC_SYSRQ_SERIAL: u32 = 1;
pub const CONFIG_TOUCHSCREEN_NOVATEK_NVT_TS_MODULE: u32 = 1;
pub const CONFIG_LIQUIDIO_VF_MODULE: u32 = 1;
pub const CONFIG_BQL: u32 = 1;
pub const CONFIG_ADJD_S311_MODULE: u32 = 1;
pub const CONFIG_INPUT_MOUSEDEV_PSAUX: u32 = 1;
pub const CONFIG_ARCH_WANT_OPTIMIZE_DAX_VMEMMAP: u32 = 1;
pub const CONFIG_RESET_TI_SYSCON_MODULE: u32 = 1;
pub const CONFIG_GPIO_PCA953X_IRQ: u32 = 1;
pub const CONFIG_HAVE_KERNEL_BZIP2: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_3501_MODULE: u32 = 1;
pub const CONFIG_DEFAULT_TCP_CONG: &[u8; 6usize] = b"cubic\0";
pub const CONFIG_MOST_NET_MODULE: u32 = 1;
pub const CONFIG_USB_EHCI_FSL_MODULE: u32 = 1;
pub const CONFIG_INTEL_CHTWC_INT33FE_MODULE: u32 = 1;
pub const CONFIG_MCP4725_MODULE: u32 = 1;
pub const CONFIG_UEVENT_HELPER_PATH: &[u8; 1usize] = b"\0";
pub const CONFIG_USB_UAS_MODULE: u32 = 1;
pub const CONFIG_U_SERIAL_CONSOLE: u32 = 1;
pub const CONFIG_VIDEO_MT9M001_MODULE: u32 = 1;
pub const CONFIG_ORANGEFS_FS_MODULE: u32 = 1;
pub const CONFIG_NTB_NETDEV_MODULE: u32 = 1;
pub const CONFIG_DEVTMPFS: u32 = 1;
pub const CONFIG_NET_CLS_FLOW_MODULE: u32 = 1;
pub const CONFIG_PROCESSOR_SELECT: u32 = 1;
pub const CONFIG_PCENGINES_APU2_MODULE: u32 = 1;
pub const CONFIG_X86_INTEL_TSX_MODE_OFF: u32 = 1;
pub const CONFIG_TIGON3_HWMON: u32 = 1;
pub const CONFIG_SENSORS_MAX8688_MODULE: u32 = 1;
pub const CONFIG_SENSORS_PC87427_MODULE: u32 = 1;
pub const CONFIG_INPUT_MAX77693_HAPTIC_MODULE: u32 = 1;
pub const CONFIG_SM_FTL_MODULE: u32 = 1;
pub const CONFIG_TI_ADC108S102_MODULE: u32 = 1;
pub const CONFIG_PNFS_FILE_LAYOUT_MODULE: u32 = 1;
pub const CONFIG_MCB_LPC_MODULE: u32 = 1;
pub const CONFIG_QED_SRIOV: u32 = 1;
pub const CONFIG_HSU_DMA: u32 = 1;
pub const CONFIG_I82092_MODULE: u32 = 1;
pub const CONFIG_NET_IPVTI_MODULE: u32 = 1;
pub const CONFIG_SCSI_PMCRAID_MODULE: u32 = 1;
pub const CONFIG_NFC_NXP_NCI_MODULE: u32 = 1;
pub const CONFIG_DVB_ISL6423_MODULE: u32 = 1;
pub const CONFIG_FB_S3_DDC: u32 = 1;
pub const CONFIG_USB_STORAGE_USBAT_MODULE: u32 = 1;
pub const CONFIG_DEBUG_INFO_BTF: u32 = 1;
pub const CONFIG_REISERFS_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_SND_FIREWIRE_DIGI00X_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_USER_MEM: u32 = 1;
pub const CONFIG_REGULATOR_ARIZONA_LDO1_MODULE: u32 = 1;
pub const CONFIG_GPIO_MAX7301_MODULE: u32 = 1;
pub const CONFIG_INPUT_88PM80X_ONKEY_MODULE: u32 = 1;
pub const CONFIG_APPLE_GMUX_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_AMD_TOPLEVEL_MODULE: u32 = 1;
pub const CONFIG_YENTA_RICOH: u32 = 1;
pub const CONFIG_SUNRPC_BACKCHANNEL: u32 = 1;
pub const CONFIG_NLS_ISO8859_7_MODULE: u32 = 1;
pub const CONFIG_HID_EVISION_MODULE: u32 = 1;
pub const CONFIG_QEDF_MODULE: u32 = 1;
pub const CONFIG_ANDROID_BINDER_IPC_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_SMBUS: u32 = 1;
pub const CONFIG_SND_SOC_TLV320AIC32X4_SPI_MODULE: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK_IDT82P33_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_PCBC_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_TARGET_REJECT_MODULE: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX: u32 = 16;
pub const CONFIG_PINCTRL_LYNXPOINT_MODULE: u32 = 1;
pub const CONFIG_UPROBES: u32 = 1;
pub const CONFIG_PWM_PCA9685_MODULE: u32 = 1;
pub const CONFIG_IR_SHARP_DECODER_MODULE: u32 = 1;
pub const CONFIG_HID_APPLEIR_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCL812_MODULE: u32 = 1;
pub const CONFIG_NFC_FDP_MODULE: u32 = 1;
pub const CONFIG_CHARGER_RT9471_MODULE: u32 = 1;
pub const CONFIG_ASYNC_MEMCPY_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MAX8998_MODULE: u32 = 1;
pub const CONFIG_ADIS16480_MODULE: u32 = 1;
pub const CONFIG_AD7292_MODULE: u32 = 1;
pub const CONFIG_X86_POWERNOW_K8: u32 = 1;
pub const CONFIG_ARCH_SPARSEMEM_ENABLE: u32 = 1;
pub const CONFIG_V4L_TEST_DRIVERS: u32 = 1;
pub const CONFIG_SENSORS_TDA38640_REGULATOR: u32 = 1;
pub const CONFIG_NFT_OSF_MODULE: u32 = 1;
pub const CONFIG_SC1200_WDT_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_REDIRECT: u32 = 1;
pub const CONFIG_DCDBAS_MODULE: u32 = 1;
pub const CONFIG_CIO_DAC_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1305_MODULE: u32 = 1;
pub const CONFIG_I2C_HID_ACPI_MODULE: u32 = 1;
pub const CONFIG_SFP_MODULE: u32 = 1;
pub const CONFIG_IR_NEC_DECODER_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_CPU: u32 = 1;
pub const CONFIG_SECURITY_LOCKDOWN_LSM: u32 = 1;
pub const CONFIG_MUX_ADGS1408_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_MOS7840_MODULE: u32 = 1;
pub const CONFIG_MAXLINEAR_GPHY_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM: u32 = 1;
pub const CONFIG_INET_DIAG_DESTROY: u32 = 1;
pub const CONFIG_NLS_MAC_CYRILLIC_MODULE: u32 = 1;
pub const CONFIG_MICROCHIP_T1S_PHY_MODULE: u32 = 1;
pub const CONFIG_USB_SL811_HCD_ISO: u32 = 1;
pub const CONFIG_PM_SLEEP_DEBUG: u32 = 1;
pub const CONFIG_SND_MAESTRO3_INPUT: u32 = 1;
pub const CONFIG_MEDIA_PCI_SUPPORT: u32 = 1;
pub const CONFIG_NVME_TARGET_AUTH: u32 = 1;
pub const CONFIG_WLAN: u32 = 1;
pub const CONFIG_EDAC_I10NM_MODULE: u32 = 1;
pub const CONFIG_AFFS_FS_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_1516_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_ATC260X_MODULE: u32 = 1;
pub const CONFIG_NFP_MODULE: u32 = 1;
pub const CONFIG_NAMESPACES: u32 = 1;
pub const CONFIG_VIDEO_AK881X_MODULE: u32 = 1;
pub const CONFIG_USB_U_AUDIO_MODULE: u32 = 1;
pub const CONFIG_VIDEO_HI846_MODULE: u32 = 1;
pub const CONFIG_BLK_RQ_ALLOC_TIME: u32 = 1;
pub const CONFIG_TIMERLAT_TRACER: u32 = 1;
pub const CONFIG_SENSORS_ADM1177_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2423_MODULE: u32 = 1;
pub const CONFIG_L2TP_DEBUGFS_MODULE: u32 = 1;
pub const CONFIG_XEN_512GB: u32 = 1;
pub const CONFIG_HAVE_CMPXCHG_DOUBLE: u32 = 1;
pub const CONFIG_AMD_PTDMA_MODULE: u32 = 1;
pub const CONFIG_CROS_EC_SYSFS_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_ABX80X_MODULE: u32 = 1;
pub const CONFIG_USB_NET_INT51X1_MODULE: u32 = 1;
pub const CONFIG_KGDB_SERIAL_CONSOLE: u32 = 1;
pub const CONFIG_PATA_PARPORT_KTTI_MODULE: u32 = 1;
pub const CONFIG_PATA_ATP867X_MODULE: u32 = 1;
pub const CONFIG_TYPEC_STUSB160X_MODULE: u32 = 1;
pub const CONFIG_ARCH_USE_MEMREMAP_PROT: u32 = 1;
pub const CONFIG_SND_SOC_CS35L56_SHARED_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_HUGE_VMAP: u32 = 1;
pub const CONFIG_FM10K_MODULE: u32 = 1;
pub const CONFIG_DW_DMAC_PCI_MODULE: u32 = 1;
pub const CONFIG_IA32_EMULATION: u32 = 1;
pub const CONFIG_SND_SOC_SIGMADSP_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_KTZ8866_MODULE: u32 = 1;
pub const CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY: u32 = 1;
pub const CONFIG_DRM_GEM_DMA_HELPER_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_MODULE: u32 = 1;
pub const CONFIG_FORTIFY_SOURCE: u32 = 1;
pub const CONFIG_COMEDI_CONTEC_PCI_DIO_MODULE: u32 = 1;
pub const CONFIG_AXP20X_ADC_MODULE: u32 = 1;
pub const CONFIG_SECURITY_DMESG_RESTRICT: u32 = 1;
pub const CONFIG_BLK_DEV_BSG: u32 = 1;
pub const CONFIG_CRYPTO_ADIANTUM_MODULE: u32 = 1;
pub const CONFIG_LEDS_WM8350_MODULE: u32 = 1;
pub const CONFIG_ENIC_MODULE: u32 = 1;
pub const CONFIG_SCSI_ISCI_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX6697_MODULE: u32 = 1;
pub const CONFIG_PATA_SERVERWORKS_MODULE: u32 = 1;
pub const CONFIG_CONNECTOR: u32 = 1;
pub const CONFIG_COMEDI_DAS16M1_MODULE: u32 = 1;
pub const CONFIG_SND_SST_ATOM_HIFI2_PLATFORM_ACPI_MODULE: u32 = 1;
pub const CONFIG_MEDIA_USB_SUPPORT: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_RATEEST_MODULE: u32 = 1;
pub const CONFIG_PCIEAER: u32 = 1;
pub const CONFIG_X86_AMD_PSTATE: u32 = 1;
pub const CONFIG_CRYPTO_ARCH_HAVE_LIB_CHACHA_MODULE: u32 = 1;
pub const CONFIG_EPIC100_MODULE: u32 = 1;
pub const CONFIG_SCTP_COOKIE_HMAC_SHA1: u32 = 1;
pub const CONFIG_BRIDGE_EBT_ARPREPLY_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP5_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_APPLE_MODULE: u32 = 1;
pub const CONFIG_B43LEGACY_DMA_AND_PIO_MODE: u32 = 1;
pub const CONFIG_RTC_DRV_SD3078_MODULE: u32 = 1;
pub const CONFIG_MEM_SOFT_DIRTY: u32 = 1;
pub const CONFIG_INTEGRITY: u32 = 1;
pub const CONFIG_MPL115_MODULE: u32 = 1;
pub const CONFIG_ZONEFS_FS_MODULE: u32 = 1;
pub const CONFIG_TQMX86_WDT_MODULE: u32 = 1;
pub const CONFIG_DVB_MAX_ADAPTERS: u32 = 8;
pub const CONFIG_SENSORS_SIS5595_MODULE: u32 = 1;
pub const CONFIG_EISA_PCI_EISA: u32 = 1;
pub const CONFIG_MPU3050_I2C_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_AEGIS128_AESNI_SSE2_MODULE: u32 = 1;
pub const CONFIG_CW1200_WLAN_SDIO_MODULE: u32 = 1;
pub const CONFIG_DM_MULTIPATH_QL_MODULE: u32 = 1;
pub const CONFIG_LEGACY_PTYS: u32 = 1;
pub const CONFIG_LIBERTAS_USB_MODULE: u32 = 1;
pub const CONFIG_JFS_FS_MODULE: u32 = 1;
pub const CONFIG_CAN_EMS_USB_MODULE: u32 = 1;
pub const CONFIG_XFRM_IPCOMP_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_MENU: u32 = 1;
pub const CONFIG_CRYPTO_RNG2: u32 = 1;
pub const CONFIG_UIO_CIF_MODULE: u32 = 1;
pub const CONFIG_USB_PWC_INPUT_EVDEV: u32 = 1;
pub const CONFIG_MDIO_I2C_MODULE: u32 = 1;
pub const CONFIG_FUSION_FC_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_NETLINK_QUEUE_MODULE: u32 = 1;
pub const CONFIG_MFD_CROS_EC_DEV_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_CSUM_MODULE: u32 = 1;
pub const CONFIG_RTLLIB_CRYPTO_CCMP_MODULE: u32 = 1;
pub const CONFIG_CEPH_LIB_USE_DNS_RESOLVER: u32 = 1;
pub const CONFIG_DVB_CXD2880_MODULE: u32 = 1;
pub const CONFIG_THERMAL_WRITABLE_TRIPS: u32 = 1;
pub const CONFIG_SCSI_MPT3SAS_MODULE: u32 = 1;
pub const CONFIG_NFTL_RW: u32 = 1;
pub const CONFIG_MFD_MC13XXX_MODULE: u32 = 1;
pub const CONFIG_NETWORK_PHY_TIMESTAMPING: u32 = 1;
pub const CONFIG_MSDOS_FS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ISL29028_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DT2811_MODULE: u32 = 1;
pub const CONFIG_USB_U_SERIAL_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_UART_MODULE: u32 = 1;
pub const CONFIG_FB_VGA16_MODULE: u32 = 1;
pub const CONFIG_SCSI_FLASHPOINT: u32 = 1;
pub const CONFIG_NET_CLS_CGROUP_MODULE: u32 = 1;
pub const CONFIG_TUN: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MICROCHIP: u32 = 1;
pub const CONFIG_NET_VENDOR_DAVICOM: u32 = 1;
pub const CONFIG_SOFTIRQ_ON_OWN_STACK: u32 = 1;
pub const CONFIG_SND_SOC_ES8328_MODULE: u32 = 1;
pub const CONFIG_MB1232_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_HDA_AUDIO_CODEC: u32 = 1;
pub const CONFIG_IP_VS_FO_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SUNPLUS_MODULE: u32 = 1;
pub const CONFIG_HYPERV_TIMER: u32 = 1;
pub const CONFIG_SND_SOC_SOF_INTEL_ATOM_HIFI_EP_MODULE: u32 = 1;
pub const CONFIG_VZ89X_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DAS6402_MODULE: u32 = 1;
pub const CONFIG_ATM_IDT77252_MODULE: u32 = 1;
pub const CONFIG_DVB_AU8522_V4L_MODULE: u32 = 1;
pub const CONFIG_AD9832_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_BRIDGED_PHY_MODULE: u32 = 1;
pub const CONFIG_IIO_KFIFO_BUF_MODULE: u32 = 1;
pub const CONFIG_ENCLOSURE_SERVICES_MODULE: u32 = 1;
pub const CONFIG_ADXL355_I2C_MODULE: u32 = 1;
pub const CONFIG_UCSI_ACPI_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TMP513_MODULE: u32 = 1;
pub const CONFIG_IPV6_PIMSM_V2: u32 = 1;
pub const CONFIG_CHARGER_BD99954_MODULE: u32 = 1;
pub const CONFIG_ARCH_ENABLE_THP_MIGRATION: u32 = 1;
pub const CONFIG_USB_XHCI_DBGCAP: u32 = 1;
pub const CONFIG_DVB_USB_DVBSKY_MODULE: u32 = 1;
pub const CONFIG_WIZNET_BUS_ANY: u32 = 1;
pub const CONFIG_BNX2_MODULE: u32 = 1;
pub const CONFIG_ZRAM_DEF_COMP_LZORLE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_DISK: u32 = 1;
pub const CONFIG_CAN_MODULE: u32 = 1;
pub const CONFIG_SND_VX222_MODULE: u32 = 1;
pub const CONFIG_CFG80211_MODULE: u32 = 1;
pub const CONFIG_PAGE_SIZE_LESS_THAN_256KB: u32 = 1;
pub const CONFIG_MACSEC_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CHACHA20POLY1305_MODULE: u32 = 1;
pub const CONFIG_SSB_BLOCKIO: u32 = 1;
pub const CONFIG_MTD_BLOCK_RO_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_CHELSIO_MODULE: u32 = 1;
pub const CONFIG_MFD_DA9063: u32 = 1;
pub const CONFIG_EQUALIZER_MODULE: u32 = 1;
pub const CONFIG_SAMPLE_TRACE_PRINTK_MODULE: u32 = 1;
pub const CONFIG_HUAWEI_WMI_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_HX8347D_MODULE: u32 = 1;
pub const CONFIG_COMEDI_JR3_PCI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TAS2562_MODULE: u32 = 1;
pub const CONFIG_SND_AU8810_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_NETNET_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX6621_MODULE: u32 = 1;
pub const CONFIG_CPU_IBPB_ENTRY: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_1250_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_6527_MODULE: u32 = 1;
pub const CONFIG_VFIO_PCI_IGD: u32 = 1;
pub const CONFIG_CALL_DEPTH_TRACKING: u32 = 1;
pub const CONFIG_SND_SOC_AK4118_MODULE: u32 = 1;
pub const CONFIG_DM_CRYPT_MODULE: u32 = 1;
pub const CONFIG_REED_SOLOMON_ENC8: u32 = 1;
pub const CONFIG_REGULATOR_PV88060_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250: u32 = 1;
pub const CONFIG_RTC_DRV_ISL12022_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TSCS454_MODULE: u32 = 1;
pub const CONFIG_PWM_CROS_EC_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_UBLK_MODULE: u32 = 1;
pub const CONFIG_MLXREG_HOTPLUG_MODULE: u32 = 1;
pub const CONFIG_XEN_GNTDEV_MODULE: u32 = 1;
pub const CONFIG_XEN_VIRTIO: u32 = 1;
pub const CONFIG_MTD_NAND_ECC_MXIC: u32 = 1;
pub const CONFIG_XZ_DEC_TEST_MODULE: u32 = 1;
pub const CONFIG_SENSORS_W83793_MODULE: u32 = 1;
pub const CONFIG_PI433_MODULE: u32 = 1;
pub const CONFIG_SPMI_HISI3670_MODULE: u32 = 1;
pub const CONFIG_B43LEGACY_PIO: u32 = 1;
pub const CONFIG_LZO_DECOMPRESS: u32 = 1;
pub const CONFIG_USB_EHCI_ROOT_HUB_TT: u32 = 1;
pub const CONFIG_LIBERTAS_THINFIRM_MODULE: u32 = 1;
pub const CONFIG_IP_VS_PROTO_AH: u32 = 1;
pub const CONFIG_SCSI_UFS_CDNS_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_IOMMU_SUPPORT: u32 = 1;
pub const CONFIG_TOUCHSCREEN_HYNITRON_CSTXXX_MODULE: u32 = 1;
pub const CONFIG_HID_BELKIN_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WCD_CLASSH_MODULE: u32 = 1;
pub const CONFIG_VIDEO_IR_I2C_MODULE: u32 = 1;
pub const CONFIG_ROMFS_BACKED_BY_BLOCK: u32 = 1;
pub const CONFIG_VFIO_IOMMU_TYPE1_MODULE: u32 = 1;
pub const CONFIG_DVB_STV0367_MODULE: u32 = 1;
pub const CONFIG_STMMAC_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_MFD_TPS6594_MODULE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_CAMERA_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV2640_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_862_MODULE: u32 = 1;
pub const CONFIG_CRAMFS_BLOCKDEV: u32 = 1;
pub const CONFIG_PDS_VDPA_MODULE: u32 = 1;
pub const CONFIG_NFSD_MODULE: u32 = 1;
pub const CONFIG_APPLE_MFI_FASTCHARGE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TSL2550_MODULE: u32 = 1;
pub const CONFIG_ITG3200_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_DA7219_MAX98357A_GENERIC_MODULE: u32 = 1;
pub const CONFIG_COMPAT_BINFMT_ELF: u32 = 1;
pub const CONFIG_VFIO_PCI_MODULE: u32 = 1;
pub const CONFIG_PWM_LPSS: u32 = 1;
pub const CONFIG_X86_DIRECT_GBPAGES: u32 = 1;
pub const CONFIG_VIDEO_IVTV_ALSA_MODULE: u32 = 1;
pub const CONFIG_PATA_MPIIX_MODULE: u32 = 1;
pub const CONFIG_ARCH_SELECTS_KEXEC_FILE: u32 = 1;
pub const CONFIG_USB_SERIAL_OPTION_MODULE: u32 = 1;
pub const CONFIG_HID_ACRUX_MODULE: u32 = 1;
pub const CONFIG_RD_LZMA: u32 = 1;
pub const CONFIG_USB_GSPCA_SE401_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_GEMINILAKE_MODULE: u32 = 1;
pub const CONFIG_USB: u32 = 1;
pub const CONFIG_PATA_SIL680_MODULE: u32 = 1;
pub const CONFIG_ACPI_IPMI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5651_MODULE: u32 = 1;
pub const CONFIG_CHARGER_MAX8998_MODULE: u32 = 1;
pub const CONFIG_SENSORS_CORSAIR_CPRO_MODULE: u32 = 1;
pub const CONFIG_CHARGER_AXP20X_MODULE: u32 = 1;
pub const CONFIG_MMC_SDHCI_PCI_MODULE: u32 = 1;
pub const CONFIG_USB_SPEEDTOUCH_MODULE: u32 = 1;
pub const CONFIG_I2C_XILINX_MODULE: u32 = 1;
pub const CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK: u32 = 1;
pub const CONFIG_REGULATOR_88PM8607_MODULE: u32 = 1;
pub const CONFIG_ALIM7101_WDT_MODULE: u32 = 1;
pub const CONFIG_ACPI_PCI_SLOT: u32 = 1;
pub const CONFIG_PM_WAKELOCKS_GC: u32 = 1;
pub const CONFIG_NFC_MRVL_I2C_MODULE: u32 = 1;
pub const CONFIG_MODULES_USE_ELF_RELA: u32 = 1;
pub const CONFIG_AD5686_MODULE: u32 = 1;
pub const CONFIG_SND_BCD2000_MODULE: u32 = 1;
pub const CONFIG_BTREE: u32 = 1;
pub const CONFIG_CRYPTO_HMAC: u32 = 1;
pub const CONFIG_SND_SOC_ADAU7118_MODULE: u32 = 1;
pub const CONFIG_PATA_PARPORT_ON20_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_REALTEK: u32 = 1;
pub const CONFIG_TYPEC_ANX7411_MODULE: u32 = 1;
pub const CONFIG_BLK_WBT: u32 = 1;
pub const CONFIG_SND_SOC_LPASS_MACRO_COMMON_MODULE: u32 = 1;
pub const CONFIG_INPUT_ADXL34X_SPI_MODULE: u32 = 1;
pub const CONFIG_ETHERNET: u32 = 1;
pub const CONFIG_MFD_INTEL_M10_BMC_PMCI_MODULE: u32 = 1;
pub const CONFIG_PATA_CMD640_PCI_MODULE: u32 = 1;
pub const CONFIG_KXSD9_SPI_MODULE: u32 = 1;
pub const CONFIG_VFIO_NOIOMMU: u32 = 1;
pub const CONFIG_NET_SCH_CODEL_MODULE: u32 = 1;
pub const CONFIG_JFFS2_LZO: u32 = 1;
pub const CONFIG_FRAMEBUFFER_CONSOLE_ROTATION: u32 = 1;
pub const CONFIG_NVME_TARGET_FC_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MP5990_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM3060_I2C_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TAS2781_COMLIB_MODULE: u32 = 1;
pub const CONFIG_INPUT_BMA150_MODULE: u32 = 1;
pub const CONFIG_USBIP_VHCI_HC_PORTS: u32 = 8;
pub const CONFIG_USB_GSPCA_JEILINJ_MODULE: u32 = 1;
pub const CONFIG_SCHED_OMIT_FRAME_POINTER: u32 = 1;
pub const CONFIG_SND_SOC_SOF_JASPERLAKE_MODULE: u32 = 1;
pub const CONFIG_HID_LOGITECH_HIDPP_MODULE: u32 = 1;
pub const CONFIG_BATTERY_CW2015_MODULE: u32 = 1;
pub const CONFIG_RETU_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SHA3: u32 = 1;
pub const CONFIG_UBIFS_FS_ZSTD: u32 = 1;
pub const CONFIG_BRANCH_PROFILE_NONE: u32 = 1;
pub const CONFIG_X86_IOPL_IOPERM: u32 = 1;
pub const CONFIG_AD3552R_MODULE: u32 = 1;
pub const CONFIG_SCSI_SCAN_ASYNC: u32 = 1;
pub const CONFIG_VIDEO_IMX274_MODULE: u32 = 1;
pub const CONFIG_SPI_DW_MMIO_MODULE: u32 = 1;
pub const CONFIG_CRC_ITU_T_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_GENERIC_LEDS: u32 = 1;
pub const CONFIG_NET_DROP_MONITOR: u32 = 1;
pub const CONFIG_HW_RANDOM_BA431_MODULE: u32 = 1;
pub const CONFIG_SND_HRTIMER_MODULE: u32 = 1;
pub const CONFIG_HAVE_DMA_CONTIGUOUS: u32 = 1;
pub const CONFIG_RAPIDIO_DISC_TIMEOUT: u32 = 30;
pub const CONFIG_DQL: u32 = 1;
pub const CONFIG_VXLAN_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_BROXTON_MODULE: u32 = 1;
pub const CONFIG_INTEL_MEI_VSC_MODULE: u32 = 1;
pub const CONFIG_PARPORT_PC_PCMCIA_MODULE: u32 = 1;
pub const CONFIG_FRAMEBUFFER_CONSOLE: u32 = 1;
pub const CONFIG_SND_SOC_PCM512x_I2C_MODULE: u32 = 1;
pub const CONFIG_RMI4_F55: u32 = 1;
pub const CONFIG_TYPEC_TCPCI_MAXIM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ADI_AXI_SPDIF_MODULE: u32 = 1;
pub const CONFIG_SENSORS_OXP_MODULE: u32 = 1;
pub const CONFIG_DM_ZERO_MODULE: u32 = 1;
pub const CONFIG_DVB_DIB8000_MODULE: u32 = 1;
pub const CONFIG_X86_SUPPORTS_MEMORY_FAILURE: u32 = 1;
pub const CONFIG_FPGA_DFL_FME_MGR_MODULE: u32 = 1;
pub const CONFIG_CROS_USBPD_LOGGER_MODULE: u32 = 1;
pub const CONFIG_SND_SEQUENCER_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_LP_MODULE: u32 = 1;
pub const CONFIG_SONY_FF: u32 = 1;
pub const CONFIG_PINCTRL_BAYTRAIL: u32 = 1;
pub const CONFIG_AD5064_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SRC4XXX_MODULE: u32 = 1;
pub const CONFIG_GAMEPORT_EMU10K1_MODULE: u32 = 1;
pub const CONFIG_SOCK_CGROUP_DATA: u32 = 1;
pub const CONFIG_WL1251_SPI_MODULE: u32 = 1;
pub const CONFIG_USB_CDNSP_HOST: u32 = 1;
pub const CONFIG_SND_BEBOB_MODULE: u32 = 1;
pub const CONFIG_COREDUMP: u32 = 1;
pub const CONFIG_NET_FOU_IP_TUNNELS: u32 = 1;
pub const CONFIG_USB_NET_GL620A_MODULE: u32 = 1;
pub const CONFIG_CLK_TWL_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_PXP: u32 = 1;
pub const CONFIG_MICREL_KS8995MA_MODULE: u32 = 1;
pub const CONFIG_AS_GFNI: u32 = 1;
pub const CONFIG_VMLINUX_MAP: u32 = 1;
pub const CONFIG_CROS_TYPEC_SWITCH_MODULE: u32 = 1;
pub const CONFIG_DVB_LGDT3306A_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_1500_MODULE: u32 = 1;
pub const CONFIG_POWER_RESET_MT6323: u32 = 1;
pub const CONFIG_SND_OPL3_LIB_MODULE: u32 = 1;
pub const CONFIG_IP_NF_ARPTABLES_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LTC2947_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_TCM: u32 = 1;
pub const CONFIG_REGULATOR_SKY81452_MODULE: u32 = 1;
pub const CONFIG_DVB_ASCOT2E_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_GP8PSK_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_GENERIC: u32 = 1;
pub const CONFIG_HID_CHERRY_MODULE: u32 = 1;
pub const CONFIG_PC87413_WDT_MODULE: u32 = 1;
pub const CONFIG_CAN_J1939_MODULE: u32 = 1;
pub const CONFIG_DRM_SUBALLOC_HELPER_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_SH1106_MODULE: u32 = 1;
pub const CONFIG_LEDS_LM3532_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_IMX_AUDMUX_MODULE: u32 = 1;
pub const CONFIG_JFFS2_COMPRESSION_OPTIONS: u32 = 1;
pub const CONFIG_CM3323_MODULE: u32 = 1;
pub const CONFIG_BATTERY_MAX17040_MODULE: u32 = 1;
pub const CONFIG_FTRACE_MCOUNT_USE_CC: u32 = 1;
pub const CONFIG_VBOXSF_FS_MODULE: u32 = 1;
pub const CONFIG_ACCESSIBILITY: u32 = 1;
pub const CONFIG_USERIO_MODULE: u32 = 1;
pub const CONFIG_MKISS_MODULE: u32 = 1;
pub const CONFIG_USE_PERCPU_NUMA_NODE_ID: u32 = 1;
pub const CONFIG_NFT_FIB_MODULE: u32 = 1;
pub const CONFIG_AD9467_MODULE: u32 = 1;
pub const CONFIG_HID_SUNPLUS_MODULE: u32 = 1;
pub const CONFIG_INPUT_ADXL34X_MODULE: u32 = 1;
pub const CONFIG_KSZ884X_PCI_MODULE: u32 = 1;
pub const CONFIG_PREEMPT_DYNAMIC: u32 = 1;
pub const CONFIG_HID_PICOLCD_MODULE: u32 = 1;
pub const CONFIG_BCMA_POSSIBLE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_RNDIS: u32 = 1;
pub const CONFIG_NF_LOG_IPV4_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_MCR20A_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_SFB_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_CIRRUS: u32 = 1;
pub const CONFIG_FUSION_CTL_MODULE: u32 = 1;
pub const CONFIG_TULIP_MODULE: u32 = 1;
pub const CONFIG_FB_SM750_MODULE: u32 = 1;
pub const CONFIG_AF_RXRPC_MODULE: u32 = 1;
pub const CONFIG_CC_HAS_AUTO_VAR_INIT_ZERO: u32 = 1;
pub const CONFIG_FUSE_DAX: u32 = 1;
pub const CONFIG_ZRAM_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CAST5_MODULE: u32 = 1;
pub const CONFIG_VGA_ARB: u32 = 1;
pub const CONFIG_SATA_HOST: u32 = 1;
pub const CONFIG_USB_CDNS_SUPPORT_MODULE: u32 = 1;
pub const CONFIG_SENSORS_CORETEMP_MODULE: u32 = 1;
pub const CONFIG_NF_TABLES_ARP: u32 = 1;
pub const CONFIG_SND_SOC_ACPI_MODULE: u32 = 1;
pub const CONFIG_FB_CARMINE_DRAM_EVAL: u32 = 1;
pub const CONFIG_FB_NVIDIA_BACKLIGHT: u32 = 1;
pub const CONFIG_SND_SOC_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_MV88E6060_MODULE: u32 = 1;
pub const CONFIG_FXAS21002C_I2C_MODULE: u32 = 1;
pub const CONFIG_CEC_CROS_EC_MODULE: u32 = 1;
pub const CONFIG_MAXIM_THERMOCOUPLE_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TPS51632_MODULE: u32 = 1;
pub const CONFIG_INV_ICM42600_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_SKYLAKE_MODULE: u32 = 1;
pub const CONFIG_FIREWIRE_SBP2_MODULE: u32 = 1;
pub const CONFIG_MFD_MAX77693: u32 = 1;
pub const CONFIG_SCSI_COMMON: u32 = 1;
pub const CONFIG_SECURITY_TOMOYO_POLICY_LOADER: &[u8; 18usize] = b"/sbin/tomoyo-init\0";
pub const CONFIG_SURFACE_PLATFORMS: u32 = 1;
pub const CONFIG_NET_IPGRE_DEMUX_MODULE: u32 = 1;
pub const CONFIG_COMEDI_MULTIQ3_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_XC5000_MODULE: u32 = 1;
pub const CONFIG_NET_POLL_CONTROLLER: u32 = 1;
pub const CONFIG_PRINTK: u32 = 1;
pub const CONFIG_SND_SOC_SOF_INTEL_MTL_MODULE: u32 = 1;
pub const CONFIG_MT7996E_MODULE: u32 = 1;
pub const CONFIG_SIEMENS_SIMATIC_IPC_MODULE: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_BNS_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_QCOM_LABIBB_MODULE: u32 = 1;
pub const CONFIG_6LOWPAN_NHC_ROUTING_MODULE: u32 = 1;
pub const CONFIG_SFC_MODULE: u32 = 1;
pub const CONFIG_PHANTOM_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_FINTEK: u32 = 1;
pub const CONFIG_PINCTRL_CANNONLAKE_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_IQS7211_MODULE: u32 = 1;
pub const CONFIG_BMC150_ACCEL_MODULE: u32 = 1;
pub const CONFIG_FORCEDETH_MODULE: u32 = 1;
pub const CONFIG_ACPI_LPIT: u32 = 1;
pub const CONFIG_COMEDI_DAS08_CS_MODULE: u32 = 1;
pub const CONFIG_FB_SYS_FILLRECT: u32 = 1;
pub const CONFIG_TIMERFD: u32 = 1;
pub const CONFIG_CRYPTO_LIB_CHACHA_GENERIC_MODULE: u32 = 1;
pub const CONFIG_SPI_AXI_SPI_ENGINE_MODULE: u32 = 1;
pub const CONFIG_HID_THRUSTMASTER_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RK3328_MODULE: u32 = 1;
pub const CONFIG_IPMI_PLAT_DATA: u32 = 1;
pub const CONFIG_USB_DYNAMIC_MINORS: u32 = 1;
pub const CONFIG_SENSORS_MAX16065_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP_I2C_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ES83XX_DSM_COMMON_MODULE: u32 = 1;
pub const CONFIG_HD44780_COMMON_MODULE: u32 = 1;
pub const CONFIG_SENSORS_I5K_AMB_MODULE: u32 = 1;
pub const CONFIG_DNS_RESOLVER: u32 = 1;
pub const CONFIG_SX_COMMON_MODULE: u32 = 1;
pub const CONFIG_FIRMWARE_TABLE: u32 = 1;
pub const CONFIG_B53_MMAP_DRIVER_MODULE: u32 = 1;
pub const CONFIG_ITCO_VENDOR_SUPPORT: u32 = 1;
pub const CONFIG_TRACEPOINTS: u32 = 1;
pub const CONFIG_NET_DSA_TAG_HELLCREEK_MODULE: u32 = 1;
pub const CONFIG_B43_PHY_LP: u32 = 1;
pub const CONFIG_MTD_CFI_I2: u32 = 1;
pub const CONFIG_IKHEADERS_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_AUTHENC_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ARIA_AESNI_AVX_X86_64_MODULE: u32 = 1;
pub const CONFIG_AT803X_PHY_MODULE: u32 = 1;
pub const CONFIG_DVB_SP8870_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CIRRUS_SCODEC_MODULE: u32 = 1;
pub const CONFIG_I6300ESB_WDT_MODULE: u32 = 1;
pub const CONFIG_GPIO_ML_IOH_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_MICROCHIP_KSZ_SPI_MODULE: u32 = 1;
pub const CONFIG_YENTA_MODULE: u32 = 1;
pub const CONFIG_USB_GPIO_VBUS_MODULE: u32 = 1;
pub const CONFIG_W1_MASTER_DS2482_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_SIDEWINDER_MODULE: u32 = 1;
pub const CONFIG_NET_EMATCH_STACK: u32 = 32;
pub const CONFIG_SRF04_MODULE: u32 = 1;
pub const CONFIG_CARL9170_LEDS: u32 = 1;
pub const CONFIG_XILINX_DMA_MODULE: u32 = 1;
pub const CONFIG_LEDS_SIEMENS_SIMATIC_IPC_ELKHARTLAKE_MODULE: u32 = 1;
pub const CONFIG_VIDEO_V4L2_SUBDEV_API: u32 = 1;
pub const CONFIG_UCLAMP_TASK_GROUP: u32 = 1;
pub const CONFIG_ATL1E_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_PREEMPT_TIMEOUT: u32 = 640;
pub const CONFIG_USB_STORAGE_ENE_UB6250_MODULE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_ACTIVITY_MODULE: u32 = 1;
pub const CONFIG_DVB_DDBRIDGE_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_CENTEURO_MODULE: u32 = 1;
pub const CONFIG_BRCMFMAC_SDIO: u32 = 1;
pub const CONFIG_ARCH_HAS_SYSCALL_WRAPPER: u32 = 1;
pub const CONFIG_LEDS_DA903X_MODULE: u32 = 1;
pub const CONFIG_DWMAC_GENERIC_MODULE: u32 = 1;
pub const CONFIG_MAX5821_MODULE: u32 = 1;
pub const CONFIG_RDS_RDMA_MODULE: u32 = 1;
pub const CONFIG_NFC_VIRTUAL_NCI_MODULE: u32 = 1;
pub const CONFIG_AD5592R_MODULE: u32 = 1;
pub const CONFIG_NUMA_BALANCING: u32 = 1;
pub const CONFIG_COMEDI_TESTS_MODULE: u32 = 1;
pub const CONFIG_I2C_DESIGNWARE_BAYTRAIL: u32 = 1;
pub const CONFIG_THINKPAD_ACPI_MODULE: u32 = 1;
pub const CONFIG_P54_COMMON_MODULE: u32 = 1;
pub const CONFIG_QRTR_SMD_MODULE: u32 = 1;
pub const CONFIG_GPIO_AAEON_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_I2S_TEST_MODULE: u32 = 1;
pub const CONFIG_COMPAT_32BIT_TIME: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_HASH: u32 = 1;
pub const CONFIG_RTW88_8822BU_MODULE: u32 = 1;
pub const CONFIG_SHMEM: u32 = 1;
pub const CONFIG_MTD_MODULE: u32 = 1;
pub const CONFIG_MIGRATION: u32 = 1;
pub const CONFIG_HAVE_ARCH_JUMP_LABEL: u32 = 1;
pub const CONFIG_LEDS_PCA9532_GPIO: u32 = 1;
pub const CONFIG_COMEDI_C6XDIGIO_MODULE: u32 = 1;
pub const CONFIG_BUILD_SALT: &[u8; 1usize] = b"\0";
pub const CONFIG_MMC_BLOCK_MINORS: u32 = 8;
pub const CONFIG_SND_XEN_FRONTEND_MODULE: u32 = 1;
pub const CONFIG_F2FS_FS_LZ4: u32 = 1;
pub const CONFIG_IIO_SSP_SENSORS_COMMONS_MODULE: u32 = 1;
pub const CONFIG_USB_HSO_MODULE: u32 = 1;
pub const CONFIG_ACPI_PFRUT_MODULE: u32 = 1;
pub const CONFIG_HID_PRIMAX_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_COFFEELAKE_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_PREL32_RELOCATIONS: u32 = 1;
pub const CONFIG_DECOMPRESS_LZMA: u32 = 1;
pub const CONFIG_SYSTEM_REVOCATION_LIST: u32 = 1;
pub const CONFIG_PCI_IOV: u32 = 1;
pub const CONFIG_WATCHDOG_SYSFS: u32 = 1;
pub const CONFIG_SENSORS_IIO_HWMON_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8776_MODULE: u32 = 1;
pub const CONFIG_GPIO_VIPERBOARD_MODULE: u32 = 1;
pub const CONFIG_QED_LL2: u32 = 1;
pub const CONFIG_DEVTMPFS_MOUNT: u32 = 1;
pub const CONFIG_IIO_BUFFER_DMAENGINE_MODULE: u32 = 1;
pub const CONFIG_SURFACE_GPE_MODULE: u32 = 1;
pub const CONFIG_PM_DEVFREQ_EVENT: u32 = 1;
pub const CONFIG_SND_HDA_DSP_LOADER: u32 = 1;
pub const CONFIG_EXCLUSIVE_SYSTEM_RAM: u32 = 1;
pub const CONFIG_SENSORS_AMC6821_MODULE: u32 = 1;
pub const CONFIG_MFD_SI476X_CORE_MODULE: u32 = 1;
pub const CONFIG_USB_IPHETH_MODULE: u32 = 1;
pub const CONFIG_IXGBEVF_IPSEC: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_850_MODULE: u32 = 1;
pub const CONFIG_DVB_CX22700_MODULE: u32 = 1;
pub const CONFIG_SOCK_VALIDATE_XMIT: u32 = 1;
pub const CONFIG_HAVE_PREEMPT_DYNAMIC: u32 = 1;
pub const CONFIG_DNOTIFY: u32 = 1;
pub const CONFIG_X86_VMX_FEATURE_NAMES: u32 = 1;
pub const CONFIG_BCM54140_PHY_MODULE: u32 = 1;
pub const CONFIG_ACRN_GUEST: u32 = 1;
pub const CONFIG_COMEDI_DAS800_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CTS: u32 = 1;
pub const CONFIG_KEYBOARD_LM8333_MODULE: u32 = 1;
pub const CONFIG_HID_VRC2_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AW88395_LIB_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM5102_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SOF_CML_RT1011_RT5682_MACH_MODULE: u32 = 1;
pub const CONFIG_SND_USB_PODHD_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_UMT_010_MODULE: u32 = 1;
pub const CONFIG_SUNGEM_PHY_MODULE: u32 = 1;
pub const CONFIG_EDD: u32 = 1;
pub const CONFIG_JOYSTICK_DB9_MODULE: u32 = 1;
pub const CONFIG_RTW88_8822C_MODULE: u32 = 1;
pub const CONFIG_MITIGATION_RFDS: u32 = 1;
pub const CONFIG_SND_SOC_SOF_DEBUG_PROBES_MODULE: u32 = 1;
pub const CONFIG_EFI_CUSTOM_SSDT_OVERLAYS: u32 = 1;
pub const CONFIG_RTC_DRV_R9701_MODULE: u32 = 1;
pub const CONFIG_NFC_S3FWRN5_I2C_MODULE: u32 = 1;
pub const CONFIG_SCSI_UFSHCD_MODULE: u32 = 1;
pub const CONFIG_THERMAL_STATISTICS: u32 = 1;
pub const CONFIG_ARCH_HAS_GENERIC_CRASHKERNEL_RESERVATION: u32 = 1;
pub const CONFIG_INPUT_MOUSEDEV: u32 = 1;
pub const CONFIG_GENERIC_NET_UTILS: u32 = 1;
pub const CONFIG_IPV6_ILA_MODULE: u32 = 1;
pub const CONFIG_FB_RADEON_BACKLIGHT: u32 = 1;
pub const CONFIG_REGULATOR_MC13XXX_CORE_MODULE: u32 = 1;
pub const CONFIG_INPUT_WM831X_ON_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_EKTF2127_MODULE: u32 = 1;
pub const CONFIG_ATA: u32 = 1;
pub const CONFIG_KEYBOARD_SUNKBD_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS42XX8_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_PALMAS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TPS40422_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_KMSAN: u32 = 1;
pub const CONFIG_GPIO_MAX730X_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DES_MODULE: u32 = 1;
pub const CONFIG_MFD_WM8994_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_3C589_MODULE: u32 = 1;
pub const CONFIG_USB_ROLE_SWITCH: u32 = 1;
pub const CONFIG_RTW88_PCI_MODULE: u32 = 1;
pub const CONFIG_INV_ICM42600_SPI_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_WM9712: u32 = 1;
pub const CONFIG_GPIOLIB_FASTPATH_LIMIT: u32 = 512;
pub const CONFIG_CEPH_LIB_MODULE: u32 = 1;
pub const CONFIG_INTEL_SPEED_SELECT_INTERFACE_MODULE: u32 = 1;
pub const CONFIG_REMOTEPROC: u32 = 1;
pub const CONFIG_GPIO_LP3943_MODULE: u32 = 1;
pub const CONFIG_STM_MODULE: u32 = 1;
pub const CONFIG_COMEDI_MF6X4_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_COMPRESS: u32 = 1;
pub const CONFIG_ND_BTT_MODULE: u32 = 1;
pub const CONFIG_XEN_MCE_LOG: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_437: u32 = 1;
pub const CONFIG_HAVE_ARCH_SOFT_DIRTY: u32 = 1;
pub const CONFIG_SND_SOC_INNO_RK3036_MODULE: u32 = 1;
pub const CONFIG_HYPERV_KEYBOARD_MODULE: u32 = 1;
pub const CONFIG_EFI_RCI2_TABLE: u32 = 1;
pub const CONFIG_INTEL_TH_GTH_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_DA9052_MODULE: u32 = 1;
pub const CONFIG_NATSEMI_MODULE: u32 = 1;
pub const CONFIG_PATA_TIMINGS: u32 = 1;
pub const CONFIG_ARCH_PROC_KCORE_TEXT: u32 = 1;
pub const CONFIG_GET_FREE_REGION: u32 = 1;
pub const CONFIG_VFIO_DEVICE_CDEV: u32 = 1;
pub const CONFIG_NET_CLS_U32_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_NETLINK_GLUE_CT: u32 = 1;
pub const CONFIG_MISDN_MODULE: u32 = 1;
pub const CONFIG_EXPORTFS: u32 = 1;
pub const CONFIG_REGULATOR_RT6245_MODULE: u32 = 1;
pub const CONFIG_MTD_UBI_WL_THRESHOLD: u32 = 4096;
pub const CONFIG_BMC150_MAGN_I2C_MODULE: u32 = 1;
pub const CONFIG_VIDEO_VISL_MODULE: u32 = 1;
pub const CONFIG_PATA_PARPORT_KBIC_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MAX8907_MODULE: u32 = 1;
pub const CONFIG_AD525X_DPOT_I2C_MODULE: u32 = 1;
pub const CONFIG_MMC_RICOH_MMC: u32 = 1;
pub const CONFIG_SQUASHFS_CHOICE_DECOMP_BY_MOUNT: u32 = 1;
pub const CONFIG_VIDEO_OV64A40_MODULE: u32 = 1;
pub const CONFIG_HID_SENSOR_HUB_MODULE: u32 = 1;
pub const CONFIG_SND_MIXER_OSS_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_PENMOUNT_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_MH_MODULE: u32 = 1;
pub const CONFIG_IP_MROUTE_COMMON: u32 = 1;
pub const CONFIG_SENSORS_PXE1610_MODULE: u32 = 1;
pub const CONFIG_NET_INGRESS: u32 = 1;
pub const CONFIG_FB_TFT_ST7789V_MODULE: u32 = 1;
pub const CONFIG_DVB_S921_MODULE: u32 = 1;
pub const CONFIG_MSI_WMI_MODULE: u32 = 1;
pub const CONFIG_IT87_WDT_MODULE: u32 = 1;
pub const CONFIG_LRU_CACHE_MODULE: u32 = 1;
pub const CONFIG_SCSI_CXGB3_ISCSI_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_INTEGRITY_T10: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_ERROR_INJECTION: u32 = 1;
pub const CONFIG_REGULATOR_LP3972_MODULE: u32 = 1;
pub const CONFIG_SND_DARLA24_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX1619_MODULE: u32 = 1;
pub const CONFIG_IPW2200_MONITOR: u32 = 1;
pub const CONFIG_USB_XEN_HCD_MODULE: u32 = 1;
pub const CONFIG_DVB_AF9013_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_SYM53C500_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_KEXEC_BZIMAGE_VERIFY_SIG: u32 = 1;
pub const CONFIG_OLD_SIGSUSPEND3: u32 = 1;
pub const CONFIG_SERIO: u32 = 1;
pub const CONFIG_DVB_USB_DTV5100_MODULE: u32 = 1;
pub const CONFIG_SCHEDSTATS: u32 = 1;
pub const CONFIG_TYPEC_UCSI_MODULE: u32 = 1;
pub const CONFIG_IBMASR_MODULE: u32 = 1;
pub const CONFIG_INPUT_MOUSE: u32 = 1;
pub const CONFIG_RTLWIFI_PCI_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_ISER_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_SMT: u32 = 1;
pub const CONFIG_FB_SYS_IMAGEBLIT: u32 = 1;
pub const CONFIG_VIDEO_TVEEPROM_MODULE: u32 = 1;
pub const CONFIG_X86: u32 = 1;
pub const CONFIG_PPS_CLIENT_PARPORT_MODULE: u32 = 1;
pub const CONFIG_VIDEO_LM3646_MODULE: u32 = 1;
pub const CONFIG_DEFXX_MODULE: u32 = 1;
pub const CONFIG_SND_AMD_ASOC_ACP70_MODULE: u32 = 1;
pub const CONFIG_SUNRPC_GSS_MODULE: u32 = 1;
pub const CONFIG_HID_LED_MODULE: u32 = 1;
pub const CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS: u32 = 1;
pub const CONFIG_TYPHOON_MODULE: u32 = 1;
pub const CONFIG_TIGON3_MODULE: u32 = 1;
pub const CONFIG_KCMP: u32 = 1;
pub const CONFIG_REGULATOR_RT4801_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CAST5_AVX_X86_64_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM90_MODULE: u32 = 1;
pub const CONFIG_XILINX_XADC_MODULE: u32 = 1;
pub const CONFIG_NETCONSOLE_MODULE: u32 = 1;
pub const CONFIG_RTC_INTF_SYSFS: u32 = 1;
pub const CONFIG_CHARGER_BQ24257_MODULE: u32 = 1;
pub const CONFIG_MMC_SDHCI_ACPI_MODULE: u32 = 1;
pub const CONFIG_BCMA_DRIVER_GPIO: u32 = 1;
pub const CONFIG_SND_SOC_SPDIF_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_LPASS_TX_MACRO_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_RS5C372_MODULE: u32 = 1;
pub const CONFIG_QED_MODULE: u32 = 1;
pub const CONFIG_NET_EMATCH_U32_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TAS2780_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TOUCHWIN_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_COMMON: u32 = 1;
pub const CONFIG_BLK_DEV_INITRD: u32 = 1;
pub const CONFIG_USB_EMI62_MODULE: u32 = 1;
pub const CONFIG_B43_PHY_N: u32 = 1;
pub const CONFIG_SCSI_IPS_MODULE: u32 = 1;
pub const CONFIG_X86_MCE_AMD: u32 = 1;
pub const CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE: u32 = 1;
pub const CONFIG_DM_BUFIO_MODULE: u32 = 1;
pub const CONFIG_I2C_ALGOPCA_MODULE: u32 = 1;
pub const CONFIG_CAN_GS_USB_MODULE: u32 = 1;
pub const CONFIG_SMB_SERVER_MODULE: u32 = 1;
pub const CONFIG_BT_ATH3K_MODULE: u32 = 1;
pub const CONFIG_PCPU_DEV_REFCNT: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_TIMER_MODULE: u32 = 1;
pub const CONFIG_MCB_PCI_MODULE: u32 = 1;
pub const CONFIG_DRM_VIRTIO_GPU_MODULE: u32 = 1;
pub const CONFIG_COMMON_CLK_PALMAS_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_M48T59_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8510_MODULE: u32 = 1;
pub const CONFIG_RT2800_LIB_MODULE: u32 = 1;
pub const CONFIG_EXTCON_ADC_JACK_MODULE: u32 = 1;
pub const CONFIG_DELL_WMI_LED_MODULE: u32 = 1;
pub const CONFIG_X86_X2APIC: u32 = 1;
pub const CONFIG_SND_SOC_TLV320AIC3X_MODULE: u32 = 1;
pub const CONFIG_SERIAL_LANTIQ_MODULE: u32 = 1;
pub const CONFIG_DEFAULT_SECURITY_APPARMOR: u32 = 1;
pub const CONFIG_NFS_DEBUG: u32 = 1;
pub const CONFIG_AD7949_MODULE: u32 = 1;
pub const CONFIG_EFI_DXE_MEM_ATTRIBUTES: u32 = 1;
pub const CONFIG_CRYPTO_BLOWFISH_COMMON_MODULE: u32 = 1;
pub const CONFIG_USB_RAREMONO_MODULE: u32 = 1;
pub const CONFIG_BT_INTEL_MODULE: u32 = 1;
pub const CONFIG_SECURITY_LANDLOCK: u32 = 1;
pub const CONFIG_CRC4_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_WM831X_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TPS65090_MODULE: u32 = 1;
pub const CONFIG_FUSION_LAN_MODULE: u32 = 1;
pub const CONFIG_DRM_BOCHS_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_DW2102_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_HASH: u32 = 1;
pub const CONFIG_PATA_PCMCIA_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_SANE_MODULE: u32 = 1;
pub const CONFIG_SERIO_PARKBD_MODULE: u32 = 1;
pub const CONFIG_GPIO_PCF857X_MODULE: u32 = 1;
pub const CONFIG_SND_OSSEMUL: u32 = 1;
pub const CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL_MODULE: u32 = 1;
pub const CONFIG_GDB_SCRIPTS: u32 = 1;
pub const CONFIG_BACKLIGHT_SAHARA_MODULE: u32 = 1;
pub const CONFIG_FB_SYSMEM_HELPERS: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TSC2004_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ADAU_UTILS_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_SURFACE3_SPI_MODULE: u32 = 1;
pub const CONFIG_IBM_RTL_MODULE: u32 = 1;
pub const CONFIG_TYPEC_MUX_PTN36502_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_MOS7720_MODULE: u32 = 1;
pub const CONFIG_XILLYBUS_MODULE: u32 = 1;
pub const CONFIG_SERIAL_DEV_BUS: u32 = 1;
pub const CONFIG_PREEMPT_NOTIFIERS: u32 = 1;
pub const CONFIG_NET_DSA_TAG_EDSA_MODULE: u32 = 1;
pub const CONFIG_XEN_PVHVM: u32 = 1;
pub const CONFIG_FB_ARC_MODULE: u32 = 1;
pub const CONFIG_SPI_XILINX_MODULE: u32 = 1;
pub const CONFIG_NF_CT_PROTO_DCCP: u32 = 1;
pub const CONFIG_ZLIB_INFLATE: u32 = 1;
pub const CONFIG_USB_FUNCTIONFS_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ARIA_MODULE: u32 = 1;
pub const CONFIG_LEDS_LM36274_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_SYNOPSYS: u32 = 1;
pub const CONFIG_HTE: u32 = 1;
pub const CONFIG_DVB_TUA6100_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SHTC1_MODULE: u32 = 1;
pub const CONFIG_NFT_FLOW_OFFLOAD_MODULE: u32 = 1;
pub const CONFIG_KVM_ASYNC_PF: u32 = 1;
pub const CONFIG_BMP280_MODULE: u32 = 1;
pub const CONFIG_SURFACE_3_POWER_OPREGION_MODULE: u32 = 1;
pub const CONFIG_CRC_T10DIF: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SOF_BOARD_HELPERS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_NCT6775_CORE_MODULE: u32 = 1;
pub const CONFIG_EXTCON_USBC_CROS_EC_MODULE: u32 = 1;
pub const CONFIG_RTW89_8851BE_MODULE: u32 = 1;
pub const CONFIG_AD7746_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_BRIDGE_MODULE: u32 = 1;
pub const CONFIG_MMA8452_MODULE: u32 = 1;
pub const CONFIG_THERMAL_GOV_FAIR_SHARE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_QT1010_MODULE: u32 = 1;
pub const CONFIG_ENCRYPTED_KEYS: u32 = 1;
pub const CONFIG_DVB_DYNAMIC_MINORS: u32 = 1;
pub const CONFIG_IIO_KX022A_I2C_MODULE: u32 = 1;
pub const CONFIG_GPIO_WM831X_MODULE: u32 = 1;
pub const CONFIG_SSB_PCIHOST_POSSIBLE: u32 = 1;
pub const CONFIG_LCD_LMS283GF05_MODULE: u32 = 1;
pub const CONFIG_HAVE_KVM_PM_NOTIFIER: u32 = 1;
pub const CONFIG_FXOS8700_SPI_MODULE: u32 = 1;
pub const CONFIG_HWMON: u32 = 1;
pub const CONFIG_AD5791_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_NAU8824_MODULE: u32 = 1;
pub const CONFIG_INTEL_GTT: u32 = 1;
pub const CONFIG_RTC_DRV_PCF85063_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_DLINK: u32 = 1;
pub const CONFIG_CRYPTO_TWOFISH_COMMON_MODULE: u32 = 1;
pub const CONFIG_AUDITSYSCALL: u32 = 1;
pub const CONFIG_USB_LJCA_MODULE: u32 = 1;
pub const CONFIG_LCD2S_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_3WIRE: u32 = 1;
pub const CONFIG_INTEL_SCU_IPC_UTIL_MODULE: u32 = 1;
pub const CONFIG_USB_PHY: u32 = 1;
pub const CONFIG_MANAGER_SBS_MODULE: u32 = 1;
pub const CONFIG_X86_ACPI_CPUFREQ_CPB: u32 = 1;
pub const CONFIG_NLS_ISO8859_2_MODULE: u32 = 1;
pub const CONFIG_MFD_DA9052_I2C: u32 = 1;
pub const CONFIG_QEDE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM63_MODULE: u32 = 1;
pub const CONFIG_IMA_MEASURE_ASYMMETRIC_KEYS: u32 = 1;
pub const CONFIG_RC_DEVICES: u32 = 1;
pub const CONFIG_XDP_SOCKETS_DIAG_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CRC32_PCLMUL_MODULE: u32 = 1;
pub const CONFIG_USB_VIDEO_CLASS_MODULE: u32 = 1;
pub const CONFIG_ACPI_DPTF: u32 = 1;
pub const CONFIG_EXTCON_INTEL_CHT_WC_MODULE: u32 = 1;
pub const CONFIG_CLKBLD_I8253: u32 = 1;
pub const CONFIG_ATM_NICSTAR_MODULE: u32 = 1;
pub const CONFIG_MCP4131_MODULE: u32 = 1;
pub const CONFIG_FB_ATY_GX: u32 = 1;
pub const CONFIG_RTC_INTF_PROC: u32 = 1;
pub const CONFIG_HID_PICOLCD_FB: u32 = 1;
pub const CONFIG_IR_RCMM_DECODER_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_TI_MODULE: u32 = 1;
pub const CONFIG_BCMGENET_MODULE: u32 = 1;
pub const CONFIG_KEXEC_SIG: u32 = 1;
pub const CONFIG_VIDEO_VP27SMPX_MODULE: u32 = 1;
pub const CONFIG_DRM_DISPLAY_HDCP_HELPER: u32 = 1;
pub const CONFIG_DYNAMIC_DEBUG_CORE: u32 = 1;
pub const CONFIG_PM_CLK: u32 = 1;
pub const CONFIG_SND_AMD_ACP_CONFIG_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_HID: u32 = 1;
pub const CONFIG_ARCH_USE_BUILTIN_BSWAP: u32 = 1;
pub const CONFIG_GPIO_SIM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SKYLAKE_COMMON_MODULE: u32 = 1;
pub const CONFIG_ATH12K_TRACING: u32 = 1;
pub const CONFIG_SENSORS_LTC2990_MODULE: u32 = 1;
pub const CONFIG_PERF_EVENTS_INTEL_RAPL_MODULE: u32 = 1;
pub const CONFIG_USB_DWC2_PCI_MODULE: u32 = 1;
pub const CONFIG_IR_TOY_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_MOS7715_PARPORT: u32 = 1;
pub const CONFIG_CRYPTO_SERPENT_MODULE: u32 = 1;
pub const CONFIG_DVB_SI2168_MODULE: u32 = 1;
pub const CONFIG_FUNCTION_PADDING_CFI: u32 = 11;
pub const CONFIG_CC_IMPLICIT_FALLTHROUGH: &[u8; 25usize] = b"-Wimplicit-fallthrough=5\0";
pub const CONFIG_CPU_IDLE_GOV_MENU: u32 = 1;
pub const CONFIG_MOST_USB_HDM_MODULE: u32 = 1;
pub const CONFIG_USB_EHSET_TEST_FIXTURE_MODULE: u32 = 1;
pub const CONFIG_MTD_PCI_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_OVS: u32 = 1;
pub const CONFIG_FB_TFT_TINYLCD_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_LPSS_MODULE: u32 = 1;
pub const CONFIG_ACPI_FAN: u32 = 1;
pub const CONFIG_SND_FM801_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_SENTELIC: u32 = 1;
pub const CONFIG_RTC_DRV_MAX8925_MODULE: u32 = 1;
pub const CONFIG_FB_MATROX_MYSTIQUE: u32 = 1;
pub const CONFIG_VIDEO_CS5345_MODULE: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR: u32 = 1;
pub const CONFIG_RTC_DRV_RX8010_MODULE: u32 = 1;
pub const CONFIG_DP83867_PHY_MODULE: u32 = 1;
pub const CONFIG_SPI_DW_DMA: u32 = 1;
pub const CONFIG_CC_HAS_ENTRY_PADDING: u32 = 1;
pub const CONFIG_STACKTRACE_SUPPORT: u32 = 1;
pub const CONFIG_ARCH_WANT_OPTIMIZE_HUGETLB_VMEMMAP: u32 = 1;
pub const CONFIG_SERIAL_8250_PCILIB: u32 = 1;
pub const CONFIG_FXLS8962AF_I2C_MODULE: u32 = 1;
pub const CONFIG_B44_PCI_AUTOSELECT: u32 = 1;
pub const CONFIG_DVB_USB_AF9035_MODULE: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_PCI224_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_TIO_MODULE: u32 = 1;
pub const CONFIG_MFD_TI_LP873X_MODULE: u32 = 1;
pub const CONFIG_SERIAL_MAX3100_MODULE: u32 = 1;
pub const CONFIG_LEDS_LP8788_MODULE: u32 = 1;
pub const CONFIG_SENSORS_EMC1403_MODULE: u32 = 1;
pub const CONFIG_MLXFW_MODULE: u32 = 1;
pub const CONFIG_RESET_CONTROLLER: u32 = 1;
pub const CONFIG_BNA_MODULE: u32 = 1;
pub const CONFIG_SURFACE_HID_MODULE: u32 = 1;
pub const CONFIG_SENSORS_DPS920AB_MODULE: u32 = 1;
pub const CONFIG_MAXSMP: u32 = 1;
pub const CONFIG_COMEDI_TESTS_EXAMPLE_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_PROBE_MODULE: u32 = 1;
pub const CONFIG_VCNL3020_MODULE: u32 = 1;
pub const CONFIG_OUTPUT_FORMAT: &[u8; 13usize] = b"elf64-x86-64\0";
pub const CONFIG_I2C_MUX_LTC4306_MODULE: u32 = 1;
pub const CONFIG_VIDEO_M52790_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_AES_TI_MODULE: u32 = 1;
pub const CONFIG_ACPI: u32 = 1;
pub const CONFIG_HTS221_SPI_MODULE: u32 = 1;
pub const CONFIG_SCSI_SYM53C8XX_2_MODULE: u32 = 1;
pub const CONFIG_MTK_T7XX_MODULE: u32 = 1;
pub const CONFIG_ZRAM_TRACK_ENTRY_ACTIME: u32 = 1;
pub const CONFIG_HAVE_IMA_KEXEC: u32 = 1;
pub const CONFIG_PCS_LYNX_MODULE: u32 = 1;
pub const CONFIG_SCSI_CXGB4_ISCSI_MODULE: u32 = 1;
pub const CONFIG_USB_CHIPIDEA_MSM_MODULE: u32 = 1;
pub const CONFIG_TABLET_USB_PEGASUS_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_IPMAC_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_HX8340BN_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SHT15_MODULE: u32 = 1;
pub const CONFIG_USB_UHCI_HCD: u32 = 1;
pub const CONFIG_NVRAM_MODULE: u32 = 1;
pub const CONFIG_NTFS3_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_INFINIBAND_VIRT_DMA: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CY8CTMA140_MODULE: u32 = 1;
pub const CONFIG_USB_ISP1760_MODULE: u32 = 1;
pub const CONFIG_CHARGER_BQ24735_MODULE: u32 = 1;
pub const CONFIG_LOCKD_MODULE: u32 = 1;
pub const CONFIG_LEDS_INTEL_SS4200_MODULE: u32 = 1;
pub const CONFIG_RTW88_DEBUGFS: u32 = 1;
pub const CONFIG_DM_WRITECACHE_MODULE: u32 = 1;
pub const CONFIG_MLX5_VDPA: u32 = 1;
pub const CONFIG_USB_F_FS_MODULE: u32 = 1;
pub const CONFIG_USB_CHIPIDEA_UDC: u32 = 1;
pub const CONFIG_DVB_FIREDTV_MODULE: u32 = 1;
pub const CONFIG_DVB_S5H1411_MODULE: u32 = 1;
pub const CONFIG_NF_CT_NETLINK_TIMEOUT_MODULE: u32 = 1;
pub const CONFIG_ARCH_MIGHT_HAVE_ACPI_PDC: u32 = 1;
pub const CONFIG_SOUND_OSS_CORE: u32 = 1;
pub const CONFIG_PCIE_DW_HOST: u32 = 1;
pub const CONFIG_SND_SOC_RT5682_SDW_MODULE: u32 = 1;
pub const CONFIG_AIC79XX_REG_PRETTY_PRINT: u32 = 1;
pub const CONFIG_MIPI_I3C_HCI_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LIB_ARC4_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LIB_AES: u32 = 1;
pub const CONFIG_TI_ADC0832_MODULE: u32 = 1;
pub const CONFIG_RT2800USB_RT35XX: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_SSM4567_MODULE: u32 = 1;
pub const CONFIG_FB_SAVAGE_MODULE: u32 = 1;
pub const CONFIG_INTEL_SCU_PCI: u32 = 1;
pub const CONFIG_SND_SOC_TAS2770_MODULE: u32 = 1;
pub const CONFIG_LIBERTAS_MODULE: u32 = 1;
pub const CONFIG_HPET_MMAP: u32 = 1;
pub const CONFIG_WLAN_VENDOR_RALINK: u32 = 1;
pub const CONFIG_NTB_PINGPONG_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS42L42_CORE_MODULE: u32 = 1;
pub const CONFIG_MT7603E_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_TV8532_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_KPP2: u32 = 1;
pub const CONFIG_IO_DELAY_0XED: u32 = 1;
pub const CONFIG_LATENCYTOP: u32 = 1;
pub const CONFIG_LTE_GDM724X_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_INTEL_APL_MODULE: u32 = 1;
pub const CONFIG_DRM_VMWGFX_MODULE: u32 = 1;
pub const CONFIG_DM9051_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_MICROCHIP: u32 = 1;
pub const CONFIG_NEED_SG_DMA_FLAGS: u32 = 1;
pub const CONFIG_HAVE_UACCESS_VALIDATION: u32 = 1;
pub const CONFIG_JFFS2_FS_MODULE: u32 = 1;
pub const CONFIG_STE10XP_MODULE: u32 = 1;
pub const CONFIG_KVM_GENERIC_MMU_NOTIFIER: u32 = 1;
pub const CONFIG_FUNCTION_ALIGNMENT: u32 = 16;
pub const CONFIG_NFT_REJECT_IPV6_MODULE: u32 = 1;
pub const CONFIG_HID_SAITEK_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8750_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MT6397_MODULE: u32 = 1;
pub const CONFIG_CASSINI_MODULE: u32 = 1;
pub const CONFIG_DRM_ACCEL_IVPU_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5660_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_HDA_PROBES_MODULE: u32 = 1;
pub const CONFIG_SCSI_DH_ALUA_MODULE: u32 = 1;
pub const CONFIG_MTRR: u32 = 1;
pub const CONFIG_USB_G_NCM_MODULE: u32 = 1;
pub const CONFIG_ADIS16203_MODULE: u32 = 1;
pub const CONFIG_MFD_MC13XXX_I2C_MODULE: u32 = 1;
pub const CONFIG_BT_RFCOMM_TTY: u32 = 1;
pub const CONFIG_LIBFCOE_MODULE: u32 = 1;
pub const CONFIG_NET_UDP_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_INTEGRITY_SIGNATURE: u32 = 1;
pub const CONFIG_INPUT_MAX8997_HAPTIC_MODULE: u32 = 1;
pub const CONFIG_ASUS_TF103C_DOCK_MODULE: u32 = 1;
pub const CONFIG_RPCSEC_GSS_KRB5_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ECC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_HDA_MLINK_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_LP8788_MODULE: u32 = 1;
pub const CONFIG_MTD_CFI_UTIL_MODULE: u32 = 1;
pub const CONFIG_IRSD200_MODULE: u32 = 1;
pub const CONFIG_USB_ISP1761_UDC: u32 = 1;
pub const CONFIG_USB_RAW_GADGET_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS4271_I2C_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_ROMANIAN_MODULE: u32 = 1;
pub const CONFIG_SND_LX6464ES_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_ADAPTEC: u32 = 1;
pub const CONFIG_CFG80211_REQUIRE_SIGNED_REGDB: u32 = 1;
pub const CONFIG_VIDEO_HI556_MODULE: u32 = 1;
pub const CONFIG_SENSORS_PCF8591_MODULE: u32 = 1;
pub const CONFIG_DVB_STV0299_MODULE: u32 = 1;
pub const CONFIG_NUMA_KEEP_MEMINFO: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE_NO_PATCHABLE: u32 = 1;
pub const CONFIG_IIO_CROS_EC_ACCEL_LEGACY_MODULE: u32 = 1;
pub const CONFIG_DRM_XE_TIMESLICE_MAX: u32 = 10000000;
pub const CONFIG_MOUSE_PS2_BYD: u32 = 1;
pub const CONFIG_IPW2200_RADIOTAP: u32 = 1;
pub const CONFIG_SSB_B43_PCI_BRIDGE: u32 = 1;
pub const CONFIG_ACER_WMI_MODULE: u32 = 1;
pub const CONFIG_PHY_CAN_TRANSCEIVER_MODULE: u32 = 1;
pub const CONFIG_KXSD9_MODULE: u32 = 1;
pub const CONFIG_CHARGER_TWL4030_MODULE: u32 = 1;
pub const CONFIG_USB_AN2720: u32 = 1;
pub const CONFIG_F2FS_STAT_FS: u32 = 1;
pub const CONFIG_SENSORS_UCD9200_MODULE: u32 = 1;
pub const CONFIG_EXTCON_INTEL_INT3496_MODULE: u32 = 1;
pub const CONFIG_MLX4_DEBUG: u32 = 1;
pub const CONFIG_BSD_PROCESS_ACCT: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_STRING_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_TPS6594_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_PS_MACH_MODULE: u32 = 1;
pub const CONFIG_SSB_DRIVER_PCICORE: u32 = 1;
pub const CONFIG_INPUT_TABLET: u32 = 1;
pub const CONFIG_HID_SENSOR_IIO_TRIGGER_MODULE: u32 = 1;
pub const CONFIG_SOCK_RX_QUEUE_MAPPING: u32 = 1;
pub const CONFIG_IIO_CROS_EC_SENSORS_LID_ANGLE_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MAX2165_MODULE: u32 = 1;
pub const CONFIG_PHY_INTEL_LGM_EMMC_MODULE: u32 = 1;
pub const CONFIG_GPIO_FXL6408_MODULE: u32 = 1;
pub const CONFIG_PLFXLC_MODULE: u32 = 1;
pub const CONFIG_MDIO_MODULE: u32 = 1;
pub const CONFIG_N_HDLC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ADAU7118_I2C_MODULE: u32 = 1;
pub const CONFIG_MTD_CFI_INTELEXT_MODULE: u32 = 1;
pub const CONFIG_MPTCP: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_HMAC: u32 = 1;
pub const CONFIG_ATM_LANAI_MODULE: u32 = 1;
pub const CONFIG_MISDN_HDLC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_GTM601_MODULE: u32 = 1;
pub const CONFIG_DRM_BRIDGE: u32 = 1;
pub const CONFIG_LLC2_MODULE: u32 = 1;
pub const CONFIG_FB_DEVICE: u32 = 1;
pub const CONFIG_IR_WINBOND_CIR_MODULE: u32 = 1;
pub const CONFIG_HPET_EMULATE_RTC: u32 = 1;
pub const CONFIG_USB_F_SERIAL_MODULE: u32 = 1;
pub const CONFIG_X86_MPPARSE: u32 = 1;
pub const CONFIG_RAVE_SP_CORE_MODULE: u32 = 1;
pub const CONFIG_BNXT_MODULE: u32 = 1;
pub const CONFIG_NITRO_ENCLAVES_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_SILAN: u32 = 1;
pub const CONFIG_SND_SOC_CS35L41_LIB_MODULE: u32 = 1;
pub const CONFIG_SENSORS_UCD9000_MODULE: u32 = 1;
pub const CONFIG_SOUNDWIRE_QCOM_MODULE: u32 = 1;
pub const CONFIG_SND_OXYGEN_LIB_MODULE: u32 = 1;
pub const CONFIG_US5182D_MODULE: u32 = 1;
pub const CONFIG_MLXREG_LC_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_CS47L90: u32 = 1;
pub const CONFIG_ADDRESS_MASKING: u32 = 1;
pub const CONFIG_SX9310_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MAX98357A_MODULE: u32 = 1;
pub const CONFIG_DLM_MODULE: u32 = 1;
pub const CONFIG_SERIAL_ARC_MODULE: u32 = 1;
pub const CONFIG_STK8312_MODULE: u32 = 1;
pub const CONFIG_DRM_ANALOGIX_ANX78XX_MODULE: u32 = 1;
pub const CONFIG_CAN_CC770_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_BPF_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_GOTOP: u32 = 1;
pub const CONFIG_SND_AMD_ASOC_REMBRANDT_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_PER_VMA_LOCK: u32 = 1;
pub const CONFIG_EEEPC_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_HID_ACCUTOUCH_MODULE: u32 = 1;
pub const CONFIG_BT_6LOWPAN_MODULE: u32 = 1;
pub const CONFIG_USB_STORAGE_MODULE: u32 = 1;
pub const CONFIG_GPIO_LP873X_MODULE: u32 = 1;
pub const CONFIG_MAG3110_MODULE: u32 = 1;
pub const CONFIG_HMC6352_MODULE: u32 = 1;
pub const CONFIG_ACRN_HSM_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_BROADCOM: u32 = 1;
pub const CONFIG_SYNTH_EVENTS: u32 = 1;
pub const CONFIG_SERIAL_FSL_LPUART_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_PCTV452E_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_SKIP_EGRESS: u32 = 1;
pub const CONFIG_JOYSTICK_PSXPAD_SPI_FF: u32 = 1;
pub const CONFIG_DVB_VES1820_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CPU_AUTOPROBE: u32 = 1;
pub const CONFIG_BOSCH_BNO055_MODULE: u32 = 1;
pub const CONFIG_BAYCOM_SER_HDX_MODULE: u32 = 1;
pub const CONFIG_SCHED_MC: u32 = 1;
pub const CONFIG_DELL_RBU_MODULE: u32 = 1;
pub const CONFIG_ALTERA_MBOX_MODULE: u32 = 1;
pub const CONFIG_SCSI_SAS_ATA: u32 = 1;
pub const CONFIG_AD7266_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_LABPC_PCI_MODULE: u32 = 1;
pub const CONFIG_BATTERY_DS2782_MODULE: u32 = 1;
pub const CONFIG_SECONDARY_TRUSTED_KEYRING: u32 = 1;
pub const CONFIG_DEV_DAX_PMEM_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_PERFORMANCE: u32 = 1;
pub const CONFIG_GPIO_ICH_MODULE: u32 = 1;
pub const CONFIG_EFI: u32 = 1;
pub const CONFIG_RATIONAL: u32 = 1;
pub const CONFIG_I2C_MUX_MODULE: u32 = 1;
pub const CONFIG_LMP91000_MODULE: u32 = 1;
pub const CONFIG_NVME_TARGET_LOOP_MODULE: u32 = 1;
pub const CONFIG_SATA_MV_MODULE: u32 = 1;
pub const CONFIG_ACPI_FFH: u32 = 1;
pub const CONFIG_DVB_TS2020_MODULE: u32 = 1;
pub const CONFIG_AGP_AMD64: u32 = 1;
pub const CONFIG_WLAN_VENDOR_INTEL: u32 = 1;
pub const CONFIG_HAVE_SETUP_PER_CPU_AREA: u32 = 1;
pub const CONFIG_SENSORS_DELTA_AHE50DC_FAN_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_MICROCHIP_KSZ_PTP: u32 = 1;
pub const CONFIG_TI_DAC082S085_MODULE: u32 = 1;
pub const CONFIG_AD74115_MODULE: u32 = 1;
pub const CONFIG_CHARGER_ISP1704_MODULE: u32 = 1;
pub const CONFIG_SND_VIRTIO_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_USERPTR: u32 = 1;
pub const CONFIG_SPI_SLAVE_TIME_MODULE: u32 = 1;
pub const CONFIG_SYSTEM_TRUSTED_KEYRING: u32 = 1;
pub const CONFIG_TYPEC_HD3SS3220_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_QM1D1C0042_MODULE: u32 = 1;
pub const CONFIG_WATCHDOG_CORE: u32 = 1;
pub const CONFIG_SND_SOC_FSL_SPDIF_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_SIMPLE_MODULE: u32 = 1;
pub const CONFIG_GENERIC_EARLY_IOREMAP: u32 = 1;
pub const CONFIG_DVB_TUNER_DIB0090_MODULE: u32 = 1;
pub const CONFIG_PCI_XEN: u32 = 1;
pub const CONFIG_PMIC_OPREGION: u32 = 1;
pub const CONFIG_SND_USB_AUDIO_MODULE: u32 = 1;
pub const CONFIG_LCD_AMS369FG06_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_EGALAX_SERIAL_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_ATUSB_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SMA1303_MODULE: u32 = 1;
pub const CONFIG_ARCNET_CAP_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX231XX_MODULE: u32 = 1;
pub const CONFIG_NULL_TTY_MODULE: u32 = 1;
pub const CONFIG_CC_HAS_UBSAN_BOUNDS_STRICT: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_TXPRT_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX31790_MODULE: u32 = 1;
pub const CONFIG_NVME_HWMON: u32 = 1;
pub const CONFIG_X25_MODULE: u32 = 1;
pub const CONFIG_VIDEO_IMX290_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_WANGXUN: u32 = 1;
pub const CONFIG_NET_L3_MASTER_DEV: u32 = 1;
pub const CONFIG_HID_SENSOR_INCLINOMETER_3D_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SBTSI_MODULE: u32 = 1;
pub const CONFIG_SENSORS_FTSTEUTATES_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_YEAH_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SOF_RT5682_MACH_MODULE: u32 = 1;
pub const CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE: u32 = 1;
pub const CONFIG_SENSORS_LTC2947_SPI_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_MODULE: u32 = 1;
pub const CONFIG_DA9063_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_HID_SENSOR_CUSTOM_SENSOR_MODULE: u32 = 1;
pub const CONFIG_SCSI_QLA_FC_MODULE: u32 = 1;
pub const CONFIG_VMAP_STACK: u32 = 1;
pub const CONFIG_TELCLOCK_MODULE: u32 = 1;
pub const CONFIG_I40EVF_MODULE: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_PC263_ISA_MODULE: u32 = 1;
pub const CONFIG_BE2NET_BE2: u32 = 1;
pub const CONFIG_BMG160_SPI_MODULE: u32 = 1;
pub const CONFIG_BLOCK: u32 = 1;
pub const CONFIG_IP_VS_LC_MODULE: u32 = 1;
pub const CONFIG_ARCH_STACKWALK: u32 = 1;
pub const CONFIG_USB_DWC3_PCI_MODULE: u32 = 1;
pub const CONFIG_RANDOM_KMALLOC_CACHES: u32 = 1;
pub const CONFIG_HID_APPLE_MODULE: u32 = 1;
pub const CONFIG_ADXL313_SPI_MODULE: u32 = 1;
pub const CONFIG_DVB_DIB9000_MODULE: u32 = 1;
pub const CONFIG_BNXT_FLOWER_OFFLOAD: u32 = 1;
pub const CONFIG_CRYPTO_SERPENT_AVX2_X86_64_MODULE: u32 = 1;
pub const CONFIG_STREAM_PARSER: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TDA827X_MODULE: u32 = 1;
pub const CONFIG_VMXNET3_MODULE: u32 = 1;
pub const CONFIG_INIT_ENV_ARG_LIMIT: u32 = 32;
pub const CONFIG_IP_NF_ARP_MANGLE_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_SSD1306_MODULE: u32 = 1;
pub const CONFIG_MFD_TPS6594_SPI_MODULE: u32 = 1;
pub const CONFIG_DRM_ACCEL: u32 = 1;
pub const CONFIG_P54_LEDS: u32 = 1;
pub const CONFIG_SAMPLE_TRACE_ARRAY_MODULE: u32 = 1;
pub const CONFIG_MOST_CDEV_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_88PM860X_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX34440_MODULE: u32 = 1;
pub const CONFIG_SENSORS_G760A_MODULE: u32 = 1;
pub const CONFIG_RDS_MODULE: u32 = 1;
pub const CONFIG_AK09911_MODULE: u32 = 1;
pub const CONFIG_F2FS_FS_LZORLE: u32 = 1;
pub const CONFIG_DVB_ATBM8830_MODULE: u32 = 1;
pub const CONFIG_MFD_TPS6594_I2C_MODULE: u32 = 1;
pub const CONFIG_PATA_EFAR_MODULE: u32 = 1;
pub const CONFIG_PCI_ENDPOINT_CONFIGFS: u32 = 1;
pub const CONFIG_HOLTEK_FF: u32 = 1;
pub const CONFIG_NET_SCH_FQ_PIE_MODULE: u32 = 1;
pub const CONFIG_EXFAT_FS_MODULE: u32 = 1;
pub const CONFIG_EEPROM_93XX46_MODULE: u32 = 1;
pub const CONFIG_LEDS_BD2606MVV_MODULE: u32 = 1;
pub const CONFIG_AF_UNIX_OOB: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SKYLAKE_SSP_CLK_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2430_MODULE: u32 = 1;
pub const CONFIG_DELL_WMI_PRIVACY: u32 = 1;
pub const CONFIG_COMEDI_DYNA_PCI10XX_MODULE: u32 = 1;
pub const CONFIG_ATL2_MODULE: u32 = 1;
pub const CONFIG_USER_NS: u32 = 1;
pub const CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH: u32 = 1;
pub const CONFIG_COMMON_CLK_MAX9485_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_USER_MODULE: u32 = 1;
pub const CONFIG_CHROMEOS_TBMC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TFA989X_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_PPTP_MODULE: u32 = 1;
pub const CONFIG_CPU_SUP_INTEL: u32 = 1;
pub const CONFIG_FUEL_GAUGE_MM8013_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_CDG_MODULE: u32 = 1;
pub const CONFIG_INTEL_WMI_SBL_FW_UPDATE_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TDA1997X_MODULE: u32 = 1;
pub const CONFIG_DVB_ZL10036_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX231XX_ALSA_MODULE: u32 = 1;
pub const CONFIG_CHARGER_DA9150_MODULE: u32 = 1;
pub const CONFIG_HFSPLUS_FS_MODULE: u32 = 1;
pub const CONFIG_TMPFS_POSIX_ACL: u32 = 1;
pub const CONFIG_STRICT_KERNEL_RWX: u32 = 1;
pub const CONFIG_HAVE_ARCH_KCSAN: u32 = 1;
pub const CONFIG_SENSORS_ADM9240_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CAFE_CCIC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ADAU7118_HW_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SKL_RT286_MACH_MODULE: u32 = 1;
pub const CONFIG_SND_USB_UA101_MODULE: u32 = 1;
pub const CONFIG_ACPI_APEI_PCIEAER: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP_CORE_MODULE: u32 = 1;
pub const CONFIG_NETLINK_DIAG_MODULE: u32 = 1;
pub const CONFIG_CAN_IFI_CANFD_MODULE: u32 = 1;
pub const CONFIG_BUG: u32 = 1;
pub const CONFIG_KS0108_PORT: u32 = 888;
pub const CONFIG_SCSI_AIC7XXX_MODULE: u32 = 1;
pub const CONFIG_CONTEXT_SWITCH_TRACER: u32 = 1;
pub const CONFIG_MAC80211_HAS_RC: u32 = 1;
pub const CONFIG_BATMAN_ADV_BLA: u32 = 1;
pub const CONFIG_KDB_KEYBOARD: u32 = 1;
pub const CONFIG_SND_SOC_SSM2602_SPI_MODULE: u32 = 1;
pub const CONFIG_LOGIWHEELS_FF: u32 = 1;
pub const CONFIG_SENSORS_INA209_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_DEBUG_WX: u32 = 1;
pub const CONFIG_USB_SL811_HCD_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_ADC_MODULE: u32 = 1;
pub const CONFIG_OCFS2_FS_O2CB_MODULE: u32 = 1;
pub const CONFIG_MDIO_GPIO_MODULE: u32 = 1;
pub const CONFIG_VIDEO_DW9807_VCM_MODULE: u32 = 1;
pub const CONFIG_XEN: u32 = 1;
pub const CONFIG_CRYPTO_CAST6_MODULE: u32 = 1;
pub const CONFIG_6LOWPAN_NHC_UDP_MODULE: u32 = 1;
pub const CONFIG_NET_EMATCH_META_MODULE: u32 = 1;
pub const CONFIG_KS8842_MODULE: u32 = 1;
pub const CONFIG_SCSI_IPR_DUMP: u32 = 1;
pub const CONFIG_I40E_DCB: u32 = 1;
pub const CONFIG_GREYBUS_LIGHT_MODULE: u32 = 1;
pub const CONFIG_TYPEC_WCOVE_MODULE: u32 = 1;
pub const CONFIG_MFD_MT6360_MODULE: u32 = 1;
pub const CONFIG_PANTHERLORD_FF: u32 = 1;
pub const CONFIG_I2C_DIOLAN_U2C_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_KBL_DA7219_MAX98357A_MACH_MODULE: u32 = 1;
pub const CONFIG_RC_XBOX_DVD_MODULE: u32 = 1;
pub const CONFIG_PM: u32 = 1;
pub const CONFIG_LTC1660_MODULE: u32 = 1;
pub const CONFIG_SND_CS46XX_NEW_DSP: u32 = 1;
pub const CONFIG_VIDEO_ADV7343_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CCS_PLL_MODULE: u32 = 1;
pub const CONFIG_MXC6255_MODULE: u32 = 1;
pub const CONFIG_PPS: u32 = 1;
pub const CONFIG_FB_RIVA_BACKLIGHT: u32 = 1;
pub const CONFIG_NETFILTER_XTABLES_COMPAT: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_PATTERN_MODULE: u32 = 1;
pub const CONFIG_GENERIC_ISA_DMA: u32 = 1;
pub const CONFIG_IEEE802154_CA8210_DEBUGFS: u32 = 1;
pub const CONFIG_NFC_PN544_MODULE: u32 = 1;
pub const CONFIG_CHARGER_MAX8903_MODULE: u32 = 1;
pub const CONFIG_USB_LCD_MODULE: u32 = 1;
pub const CONFIG_MEMCG: u32 = 1;
pub const CONFIG_SPI: u32 = 1;
pub const CONFIG_TCS3414_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MENF21BMC_HWMON_MODULE: u32 = 1;
pub const CONFIG_RTC_SYSTOHC_DEVICE: &[u8; 5usize] = b"rtc0\0";
pub const CONFIG_SENSORS_DS620_MODULE: u32 = 1;
pub const CONFIG_EVM_EXTRA_SMACK_XATTRS: u32 = 1;
pub const CONFIG_CRYPTO_BLAKE2S_X86: u32 = 1;
pub const CONFIG_V4L_MEM2MEM_DRIVERS: u32 = 1;
pub const CONFIG_X86_SPEEDSTEP_CENTRINO: u32 = 1;
pub const CONFIG_MFD_TPS65912_SPI: u32 = 1;
pub const CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT: u32 = 1;
pub const CONFIG_NFT_HASH_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_IRC_MODULE: u32 = 1;
pub const CONFIG_RENESAS_PHY_MODULE: u32 = 1;
pub const CONFIG_NOUVEAU_DEBUG_DEFAULT: u32 = 3;
pub const CONFIG_BACKLIGHT_AAT2870_MODULE: u32 = 1;
pub const CONFIG_PATA_NS87410_MODULE: u32 = 1;
pub const CONFIG_L2TP_IP_MODULE: u32 = 1;
pub const CONFIG_RADIO_SI476X_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SAFESETID: u32 = 1;
pub const CONFIG_GPIO_DS4520_MODULE: u32 = 1;
pub const CONFIG_MTD_REDBOOT_PARTS_MODULE: u32 = 1;
pub const CONFIG_DLHL60D_MODULE: u32 = 1;
pub const CONFIG_VBOXGUEST_MODULE: u32 = 1;
pub const CONFIG_BT_MSFTEXT: u32 = 1;
pub const CONFIG_MTD_UBI_FASTMAP: u32 = 1;
pub const CONFIG_XZ_DEC_MICROLZMA: u32 = 1;
pub const CONFIG_RPCSEC_GSS_KRB5_ENCTYPES_AES_SHA1: u32 = 1;
pub const CONFIG_SND_SOC_TLV320AIC23_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_IMG_SPDIF_IN_MODULE: u32 = 1;
pub const CONFIG_NET_FAILOVER: u32 = 1;
pub const CONFIG_SND_SOC_FSL_XCVR_MODULE: u32 = 1;
pub const CONFIG_USB_STV06XX_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_PURELIFI: u32 = 1;
pub const CONFIG_PPP_DEFLATE_MODULE: u32 = 1;
pub const CONFIG_USELIB: u32 = 1;
pub const CONFIG_REGULATOR_DA903X_MODULE: u32 = 1;
pub const CONFIG_VGA_SWITCHEROO: u32 = 1;
pub const CONFIG_PSAMPLE_MODULE: u32 = 1;
pub const CONFIG_USB_ISP1301_MODULE: u32 = 1;
pub const CONFIG_MFD_CS42L43_SDW_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_DA9052_MODULE: u32 = 1;
pub const CONFIG_B53_MDIO_DRIVER_MODULE: u32 = 1;
pub const CONFIG_IRQ_REMAP: u32 = 1;
pub const CONFIG_MLX5_TC_CT: u32 = 1;
pub const CONFIG_DVB_PT3_MODULE: u32 = 1;
pub const CONFIG_TEXTSEARCH_KMP_MODULE: u32 = 1;
pub const CONFIG_IO_URING: u32 = 1;
pub const CONFIG_MAX31856_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CRC64_ROCKSOFT: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_PC263_PCI_MODULE: u32 = 1;
pub const CONFIG_SND_MAESTRO3_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_SMEM_MODULE: u32 = 1;
pub const CONFIG_VT: u32 = 1;
pub const CONFIG_HAVE_KERNEL_ZSTD: u32 = 1;
pub const CONFIG_USB_NET_NET1080_MODULE: u32 = 1;
pub const CONFIG_VMAP_PFN: u32 = 1;
pub const CONFIG_HID_REDRAGON_MODULE: u32 = 1;
pub const CONFIG_DMABUF_HEAPS: u32 = 1;
pub const CONFIG_STK3310_MODULE: u32 = 1;
pub const CONFIG_SENSORS_F71805F_MODULE: u32 = 1;
pub const CONFIG_SECRETMEM: u32 = 1;
pub const CONFIG_SUNRPC_DEBUG: u32 = 1;
pub const CONFIG_AD7124_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CLASSIFY_MODULE: u32 = 1;
pub const CONFIG_INET6_ESP_OFFLOAD_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_IMG_SPDIF_OUT_MODULE: u32 = 1;
pub const CONFIG_SENSORS_INA238_MODULE: u32 = 1;
pub const CONFIG_CCS811_MODULE: u32 = 1;
pub const CONFIG_HID_TIVO_MODULE: u32 = 1;
pub const CONFIG_HID_ICADE_MODULE: u32 = 1;
pub const CONFIG_PCI_ATS: u32 = 1;
pub const CONFIG_MISDN_IPAC_MODULE: u32 = 1;
pub const CONFIG_F2FS_FS_SECURITY: u32 = 1;
pub const CONFIG_LTC2497_MODULE: u32 = 1;
pub const CONFIG_USB_NET_AQC111_MODULE: u32 = 1;
pub const CONFIG_MACB_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_CIRRUS_MODULE: u32 = 1;
pub const CONFIG_GPIO_PCI_IDIO_16_MODULE: u32 = 1;
pub const CONFIG_REGMAP_SPI: u32 = 1;
pub const CONFIG_BT_BREDR: u32 = 1;
pub const CONFIG_DMA_ACPI: u32 = 1;
pub const CONFIG_VIDEO_HEXIUM_GEMINI_MODULE: u32 = 1;
pub const CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED: u32 = 1;
pub const CONFIG_EXTCON_SM5502_MODULE: u32 = 1;
pub const CONFIG_MSCC_OCELOT_SWITCH_LIB_MODULE: u32 = 1;
pub const CONFIG_CB710_DEBUG_ASSUMPTIONS: u32 = 1;
pub const CONFIG_INTEL_SOC_PMIC_CHTWC: u32 = 1;
pub const CONFIG_SPLIT_PTLOCK_CPUS: u32 = 4;
pub const CONFIG_LEDS_AS3645A_MODULE: u32 = 1;
pub const CONFIG_USB_R8A66597_MODULE: u32 = 1;
pub const CONFIG_SBITMAP: u32 = 1;
pub const CONFIG_MAX77541_ADC_MODULE: u32 = 1;
pub const CONFIG_INPUT_DRV2665_HAPTICS_MODULE: u32 = 1;
pub const CONFIG_EDAC_E752X_MODULE: u32 = 1;
pub const CONFIG_GTP_MODULE: u32 = 1;
pub const CONFIG_WATCHDOG_PRETIMEOUT_GOV_SEL_MODULE: u32 = 1;
pub const CONFIG_EXTCON_MAX3355_MODULE: u32 = 1;
pub const CONFIG_MSPRO_BLOCK_MODULE: u32 = 1;
pub const CONFIG_DVB_TUNER_ITD1000_MODULE: u32 = 1;
pub const CONFIG_POWER_SUPPLY: u32 = 1;
pub const CONFIG_SPI_PCI1XXXX_MODULE: u32 = 1;
pub const CONFIG_DM_PERSISTENT_DATA_MODULE: u32 = 1;
pub const CONFIG_PATA_VIA_MODULE: u32 = 1;
pub const CONFIG_SCSI_UFSHCD_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_DAVICOM_PHY_MODULE: u32 = 1;
pub const CONFIG_SCTP_COOKIE_HMAC_MD5: u32 = 1;
pub const CONFIG_PARAVIRT_XXL: u32 = 1;
pub const CONFIG_KVM_GENERIC_MEMORY_ATTRIBUTES: u32 = 1;
pub const CONFIG_CIFS_XATTR: u32 = 1;
pub const CONFIG_CRYPTO_ZSTD_MODULE: u32 = 1;
pub const CONFIG_KEXEC_JUMP: u32 = 1;
pub const CONFIG_SENSORS_ADM1275_MODULE: u32 = 1;
pub const CONFIG_SND_DMAENGINE_PCM_MODULE: u32 = 1;
pub const CONFIG_I2C_PCA_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_NFQUEUE_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_BOOTPARAM: u32 = 1;
pub const CONFIG_ARCH_HAS_UACCESS_FLUSHCACHE: u32 = 1;
pub const CONFIG_DRM_ACCEL_QAIC_MODULE: u32 = 1;
pub const CONFIG_CAN_8DEV_USB_MODULE: u32 = 1;
pub const CONFIG_PAHOLE_HAS_SPLIT_BTF: u32 = 1;
pub const CONFIG_SND_HDA_INPUT_BEEP: u32 = 1;
pub const CONFIG_WEXT_CORE: u32 = 1;
pub const CONFIG_I2C_DESIGNWARE_CORE: u32 = 1;
pub const CONFIG_SIEMENS_SIMATIC_IPC_BATT_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_MR97310A_MODULE: u32 = 1;
pub const CONFIG_DVB_HOPPER_MODULE: u32 = 1;
pub const CONFIG_GENERIC_IRQ_CHIP: u32 = 1;
pub const CONFIG_ACPI_THERMAL_REL_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SKCIPHER2: u32 = 1;
pub const CONFIG_NETLABEL: u32 = 1;
pub const CONFIG_VIDEO_WM8775_MODULE: u32 = 1;
pub const CONFIG_CHARGER_SBS_MODULE: u32 = 1;
pub const CONFIG_NLS: u32 = 1;
pub const CONFIG_REGULATOR_MAX77826_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_QAT_4XXX_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_TIMEOUT: u32 = 1;
pub const CONFIG_ARCH_WANTS_NO_INSTR: u32 = 1;
pub const CONFIG_GPIO_SCH311X_MODULE: u32 = 1;
pub const CONFIG_MT76_SDIO_MODULE: u32 = 1;
pub const CONFIG_INPUT_PCAP_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_HDAC_HDMI_MODULE: u32 = 1;
pub const CONFIG_INPUT_PALMAS_PWRBUTTON_MODULE: u32 = 1;
pub const CONFIG_V4L2_FLASH_LED_CLASS_MODULE: u32 = 1;
pub const CONFIG_MFD_ARIZONA_MODULE: u32 = 1;
pub const CONFIG_VIDEO_COBALT_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_IPPORTNET_MODULE: u32 = 1;
pub const CONFIG_SMC_DIAG_MODULE: u32 = 1;
pub const CONFIG_SURFACE_DTX_MODULE: u32 = 1;
pub const CONFIG_LEDS_APU_MODULE: u32 = 1;
pub const CONFIG_SCHED_AUTOGROUP: u32 = 1;
pub const CONFIG_XILINX_LL_TEMAC_MODULE: u32 = 1;
pub const CONFIG_BCACHEFS_ERASURE_CODING: u32 = 1;
pub const CONFIG_COMEDI_PCL730_MODULE: u32 = 1;
pub const CONFIG_GPIO_TPS65912_MODULE: u32 = 1;
pub const CONFIG_SPI_SPIDEV_MODULE: u32 = 1;
pub const CONFIG_EFI_BOOTLOADER_CONTROL_MODULE: u32 = 1;
pub const CONFIG_AS_IS_GNU: u32 = 1;
pub const CONFIG_MEDIA_CAMERA_SUPPORT: u32 = 1;
pub const CONFIG_BT_MTKSDIO_MODULE: u32 = 1;
pub const CONFIG_EFI_HANDOVER_PROTOCOL: u32 = 1;
pub const CONFIG_PRISM2_USB_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MT6359_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MAX8893_MODULE: u32 = 1;
pub const CONFIG_ADM8211_MODULE: u32 = 1;
pub const CONFIG_IMA_SECURE_AND_OR_TRUSTED_BOOT: u32 = 1;
pub const CONFIG_MFD_WM8997: u32 = 1;
pub const CONFIG_HWPOISON_INJECT_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MAX98373_I2C_MODULE: u32 = 1;
pub const CONFIG_MAX1241_MODULE: u32 = 1;
pub const CONFIG_NTB_TOOL_MODULE: u32 = 1;
pub const CONFIG_VME_FAKE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX20730_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_ILI9325_MODULE: u32 = 1;
pub const CONFIG_RTL8188EE_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_DFL_MODULE: u32 = 1;
pub const CONFIG_DM_VERITY_VERIFY_ROOTHASH_SIG: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_SECMARK_MODULE: u32 = 1;
pub const CONFIG_HID_MAGICMOUSE_MODULE: u32 = 1;
pub const CONFIG_CROS_EC_SENSORHUB_MODULE: u32 = 1;
pub const CONFIG_MICROSEMI_PHY_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TW686X_MODULE: u32 = 1;
pub const CONFIG_TI_DAC7311_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AK4554_MODULE: u32 = 1;
pub const CONFIG_I2C_GPIO_MODULE: u32 = 1;
pub const CONFIG_MFD_CS47L35: u32 = 1;
pub const CONFIG_ADXL355_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TDA9840_MODULE: u32 = 1;
pub const CONFIG_INET_UDP_DIAG_MODULE: u32 = 1;
pub const CONFIG_MEDIA_SDR_SUPPORT: u32 = 1;
pub const CONFIG_USB_CONFIGFS_ACM: u32 = 1;
pub const CONFIG_CGROUP_BPF: u32 = 1;
pub const CONFIG_RAPIDIO_ENUM_BASIC_MODULE: u32 = 1;
pub const CONFIG_XEN_SAVE_RESTORE: u32 = 1;
pub const CONFIG_SND_SOC_TLV320AIC3X_SPI_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_ZD1301_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_ETURBO: u32 = 1;
pub const CONFIG_DELL_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_PPPOE_MODULE: u32 = 1;
pub const CONFIG_IPV6_SEG6_HMAC: u32 = 1;
pub const CONFIG_CRYPTO_CRCT10DIF_PCLMUL_MODULE: u32 = 1;
pub const CONFIG_LEDS_AW200XX_MODULE: u32 = 1;
pub const CONFIG_WL1251_SDIO_MODULE: u32 = 1;
pub const CONFIG_GPIO_TQMX86_MODULE: u32 = 1;
pub const CONFIG_PCI_REALLOC_ENABLE_AUTO: u32 = 1;
pub const CONFIG_X86_INTEL_PSTATE: u32 = 1;
pub const CONFIG_TMPFS_INODE64: u32 = 1;
pub const CONFIG_NTFS3_LZX_XPRESS: u32 = 1;
pub const CONFIG_SND_LAYLA24_MODULE: u32 = 1;
pub const CONFIG_ADXL355_SPI_MODULE: u32 = 1;
pub const CONFIG_NFC_PN533_USB_MODULE: u32 = 1;
pub const CONFIG_ZONE_DMA: u32 = 1;
pub const CONFIG_VIDEO_CX25821_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SPCA508_MODULE: u32 = 1;
pub const CONFIG_USB_LEGOTOWER_MODULE: u32 = 1;
pub const CONFIG_INTEL_RAPL_TPMI_MODULE: u32 = 1;
pub const CONFIG_I2C_ROBOTFUZZ_OSIF_MODULE: u32 = 1;
pub const CONFIG_MTD_DATAFLASH_MODULE: u32 = 1;
pub const CONFIG_DVB_DRX39XYJ_MODULE: u32 = 1;
pub const CONFIG_FB_MB862XX_I2C: u32 = 1;
pub const CONFIG_QLCNIC_HWMON: u32 = 1;
pub const CONFIG_ACPI_I2C_OPREGION: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_DA7219_MODULE: u32 = 1;
pub const CONFIG_UBSAN_ENUM: u32 = 1;
pub const CONFIG_DEV_DAX_HMEM_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_DIBUSB_MC_MODULE: u32 = 1;
pub const CONFIG_I2C_CBUS_GPIO_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_VP702X_MODULE: u32 = 1;
pub const CONFIG_CAN_CC770_ISA_MODULE: u32 = 1;
pub const CONFIG_ROCKER_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_OWNER_MODULE: u32 = 1;
pub const CONFIG_GPIO_WM8994_MODULE: u32 = 1;
pub const CONFIG_I2C_SIS5595_MODULE: u32 = 1;
pub const CONFIG_VMGENID_MODULE: u32 = 1;
pub const CONFIG_SND_SEQ_DEVICE_MODULE: u32 = 1;
pub const CONFIG_SUN_PARTITION: u32 = 1;
pub const CONFIG_IP_NF_TARGET_ECN_MODULE: u32 = 1;
pub const CONFIG_VIDEO_GC0308_MODULE: u32 = 1;
pub const CONFIG_SND_GINA24_MODULE: u32 = 1;
pub const CONFIG_NFC_NXP_NCI_I2C_MODULE: u32 = 1;
pub const CONFIG_SYN_COOKIES: u32 = 1;
pub const CONFIG_HAVE_NOINSTR_VALIDATION: u32 = 1;
pub const CONFIG_SENSORS_IR35221_MODULE: u32 = 1;
pub const CONFIG_REED_SOLOMON_DEC8: u32 = 1;
pub const CONFIG_IRQ_WORK: u32 = 1;
pub const CONFIG_ATH9K_MODULE: u32 = 1;
pub const CONFIG_PCI_MSI: u32 = 1;
pub const CONFIG_IP_ADVANCED_ROUTER: u32 = 1;
pub const CONFIG_MISDN_NETJET_MODULE: u32 = 1;
pub const CONFIG_ARCNET_COM20020_CS_MODULE: u32 = 1;
pub const CONFIG_COMEDI_CB_PCIDDA_MODULE: u32 = 1;
pub const CONFIG_DRM_XEN_FRONTEND_MODULE: u32 = 1;
pub const CONFIG_FB_SYS_COPYAREA: u32 = 1;
pub const CONFIG_CHTCRC_PMIC_OPREGION: u32 = 1;
pub const CONFIG_HAVE_ARCH_RANDOMIZE_KSTACK_OFFSET: u32 = 1;
pub const CONFIG_SENSORS_OCC_P8_I2C_MODULE: u32 = 1;
pub const CONFIG_X86_64_SMP: u32 = 1;
pub const CONFIG_HTU21_MODULE: u32 = 1;
pub const CONFIG_USB_EHCI_PCI: u32 = 1;
pub const CONFIG_XILINX_AXI_EMAC_MODULE: u32 = 1;
pub const CONFIG_PATA_CYPRESS_MODULE: u32 = 1;
pub const CONFIG_TYPEC_RT1711H_MODULE: u32 = 1;
pub const CONFIG_SPI_BITBANG_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MT2063_MODULE: u32 = 1;
pub const CONFIG_USB_STORAGE_ALAUDA_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_FUJITSU: u32 = 1;
pub const CONFIG_JOYSTICK_GRIP_MP_MODULE: u32 = 1;
pub const CONFIG_SPARSEMEM_EXTREME: u32 = 1;
pub const CONFIG_DMARD09_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2406_MODULE: u32 = 1;
pub const CONFIG_B44_PCICORE_AUTOSELECT: u32 = 1;
pub const CONFIG_IWLWIFI_MODULE: u32 = 1;
pub const CONFIG_USB_COMMON: u32 = 1;
pub const CONFIG_CYPRESS_FIRMWARE_MODULE: u32 = 1;
pub const CONFIG_BPF_KPROBE_OVERRIDE: u32 = 1;
pub const CONFIG_SENSORS_ADM1031_MODULE: u32 = 1;
pub const CONFIG_TASK_XACCT: u32 = 1;
pub const CONFIG_SND_SOC_RT9120_MODULE: u32 = 1;
pub const CONFIG_DRM_DISPLAY_HDMI_HELPER: u32 = 1;
pub const CONFIG_ARCNET_1051_MODULE: u32 = 1;
pub const CONFIG_LEDS_MT6370_RGB_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TDA18271_MODULE: u32 = 1;
pub const CONFIG_IP_SET_BITMAP_PORT_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_IPTABLES_MODULE: u32 = 1;
pub const CONFIG_LZ4_COMPRESS_MODULE: u32 = 1;
pub const CONFIG_DRM_GPUVM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SIGMADSP_REGMAP_MODULE: u32 = 1;
pub const CONFIG_KVM_VFIO: u32 = 1;
pub const CONFIG_SENSORS_FSP_3Y_MODULE: u32 = 1;
pub const CONFIG_PHY_QCOM_USB_HSIC_MODULE: u32 = 1;
pub const CONFIG_USB_HSIC_USB3503_MODULE: u32 = 1;
pub const CONFIG_X86_PCC_CPUFREQ: u32 = 1;
pub const CONFIG_QFMT_V1_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_ANCHOR: u32 = 1;
pub const CONFIG_DVB_IX2505V_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_ZYTRONIC: u32 = 1;
pub const CONFIG_SND_SONICVIBES_MODULE: u32 = 1;
pub const CONFIG_FIXED_PHY: u32 = 1;
pub const CONFIG_CHELSIO_T4_FCOE: u32 = 1;
pub const CONFIG_DVB_SP2_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SHT4x_MODULE: u32 = 1;
pub const CONFIG_GPIO_WS16C48_MODULE: u32 = 1;
pub const CONFIG_GPIO_ACPI: u32 = 1;
pub const CONFIG_MFD_MAX8998: u32 = 1;
pub const CONFIG_ARCH_HAS_SYNC_CORE_BEFORE_USERMODE: u32 = 1;
pub const CONFIG_SENSORS_TMP103_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_GAELIC_MODULE: u32 = 1;
pub const CONFIG_SND_UMP_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_USERSPACE: u32 = 1;
pub const CONFIG_ARCH_HAS_CPU_PASID: u32 = 1;
pub const CONFIG_FTRACE_SYSCALLS: u32 = 1;
pub const CONFIG_IMG_ASCII_LCD_MODULE: u32 = 1;
pub const CONFIG_AS_TPAUSE: u32 = 1;
pub const CONFIG_SND_SOC_TSCS42XX_MODULE: u32 = 1;
pub const CONFIG_SND_CA0106_MODULE: u32 = 1;
pub const CONFIG_VIDEO_VIA_CAMERA_MODULE: u32 = 1;
pub const CONFIG_LOG_CPU_MAX_BUF_SHIFT: u32 = 12;
pub const CONFIG_CRYPTO_JITTERENTROPY_MEMORY_BLOCKSIZE: u32 = 32;
pub const CONFIG_VIDEO_SAA6752HS_MODULE: u32 = 1;
pub const CONFIG_NF_DUP_IPV4_MODULE: u32 = 1;
pub const CONFIG_XEN_PVHVM_SMP: u32 = 1;
pub const CONFIG_BLK_DEV_DM_BUILTIN: u32 = 1;
pub const CONFIG_INTEL_CHTDC_TI_PWRBTN_MODULE: u32 = 1;
pub const CONFIG_HID_FT260_MODULE: u32 = 1;
pub const CONFIG_RPR0521_MODULE: u32 = 1;
pub const CONFIG_HMC425_MODULE: u32 = 1;
pub const CONFIG_COMEDI_FL512_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_IPW_MODULE: u32 = 1;
pub const CONFIG_I2C_PIIX4_MODULE: u32 = 1;
pub const CONFIG_EDAC_I7300_MODULE: u32 = 1;
pub const CONFIG_USB_HCD_SSB_MODULE: u32 = 1;
pub const CONFIG_INTEL_SOC_DTS_THERMAL_MODULE: u32 = 1;
pub const CONFIG_ARCNET_COM20020_PCI_MODULE: u32 = 1;
pub const CONFIG_SERIAL_UARTLITE_MODULE: u32 = 1;
pub const CONFIG_INET_IPCOMP_MODULE: u32 = 1;
pub const CONFIG_SENSORS_FSCHMD_MODULE: u32 = 1;
pub const CONFIG_TASKS_RCU: u32 = 1;
pub const CONFIG_INTEL_RAPL_CORE_MODULE: u32 = 1;
pub const CONFIG_DP83TD510_PHY_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_DIB0700_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_FUJITSU_MODULE: u32 = 1;
pub const CONFIG_VGA_ARB_MAX_GPUS: u32 = 16;
pub const CONFIG_PCMCIA_MODULE: u32 = 1;
pub const CONFIG_XEN_BLKDEV_BACKEND_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5514_SPI_MODULE: u32 = 1;
pub const CONFIG_GENERIC_PINCONF: u32 = 1;
pub const CONFIG_SCSI_EFCT_MODULE: u32 = 1;
pub const CONFIG_CAN_PEAK_USB_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBLUECARD_MODULE: u32 = 1;
pub const CONFIG_JFFS2_FS_XATTR: u32 = 1;
pub const CONFIG_HID_XIAOMI_MODULE: u32 = 1;
pub const CONFIG_XILLYBUS_PCIE_MODULE: u32 = 1;
pub const CONFIG_EVENT_TRACING: u32 = 1;
pub const CONFIG_MFD_INTEL_LPSS_MODULE: u32 = 1;
pub const CONFIG_PAGE_TABLE_ISOLATION: u32 = 1;
pub const CONFIG_ARCH_HAS_NMI_SAFE_THIS_CPU_OPS: u32 = 1;
pub const CONFIG_SND_ENS1370_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MAX77503_MODULE: u32 = 1;
pub const CONFIG_AD7476_MODULE: u32 = 1;
pub const CONFIG_ASYNC_PQ_MODULE: u32 = 1;
pub const CONFIG_HID_KEYTOUCH_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT712_SDCA_SDW_MODULE: u32 = 1;
pub const CONFIG_AS_SHA1_NI: u32 = 1;
pub const CONFIG_HID_CYPRESS_MODULE: u32 = 1;
pub const CONFIG_N_GSM_MODULE: u32 = 1;
pub const CONFIG_NFS_V4_2_SSC_HELPER: u32 = 1;
pub const CONFIG_REGULATOR_LM363X_MODULE: u32 = 1;
pub const CONFIG_SG_POOL: u32 = 1;
pub const CONFIG_BRIDGE_EBT_LIMIT_MODULE: u32 = 1;
pub const CONFIG_SURFACE_PRO3_BUTTON_MODULE: u32 = 1;
pub const CONFIG_DRM_KMS_HELPER: u32 = 1;
pub const CONFIG_SERIAL_IPOCTAL_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_INTEL_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_PACKET_ENGINES: u32 = 1;
pub const CONFIG_DRM_PANEL_RASPBERRYPI_TOUCHSCREEN_MODULE: u32 = 1;
pub const CONFIG_IPW2200_PROMISCUOUS: u32 = 1;
pub const CONFIG_DMA_COHERENT_POOL: u32 = 1;
pub const CONFIG_NF_SOCKET_IPV6_MODULE: u32 = 1;
pub const CONFIG_OCFS2_FS_USERSPACE_CLUSTER_MODULE: u32 = 1;
pub const CONFIG_INTEL_BXTWC_PMIC_TMU_MODULE: u32 = 1;
pub const CONFIG_INIT_ON_ALLOC_DEFAULT_ON: u32 = 1;
pub const CONFIG_PINCTRL_TIGERLAKE_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADL_PCI9111_MODULE: u32 = 1;
pub const CONFIG_ATA_OVER_ETH_MODULE: u32 = 1;
pub const CONFIG_BLK_MQ_PCI: u32 = 1;
pub const CONFIG_SPI_MXIC_MODULE: u32 = 1;
pub const CONFIG_USB_NET_PLUSB_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TDA7419_MODULE: u32 = 1;
pub const CONFIG_VIDEO_SAA711X_MODULE: u32 = 1;
pub const CONFIG_RTL8192C_COMMON_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_PWM_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LIB_CURVE25519_MODULE: u32 = 1;
pub const CONFIG_MFD_WM831X_SPI: u32 = 1;
pub const CONFIG_SENSORS_LM95234_MODULE: u32 = 1;
pub const CONFIG_ADXL372_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TW9910_MODULE: u32 = 1;
pub const CONFIG_MEN_A21_WDT_MODULE: u32 = 1;
pub const CONFIG_PREEMPT_VOLUNTARY: u32 = 1;
pub const CONFIG_DVB_BUDGET_CORE_MODULE: u32 = 1;
pub const CONFIG_NLS_ISO8859_1_MODULE: u32 = 1;
pub const CONFIG_LMK04832_MODULE: u32 = 1;
pub const CONFIG_MFD_WM8400: u32 = 1;
pub const CONFIG_MTD_INTEL_VR_NOR_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_WDT87XX_I2C_MODULE: u32 = 1;
pub const CONFIG_LRU_GEN: u32 = 1;
pub const CONFIG_MACINTOSH_DRIVERS: u32 = 1;
pub const CONFIG_NFC_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_RNBD: u32 = 1;
pub const CONFIG_ALX_MODULE: u32 = 1;
pub const CONFIG_CIFS_FSCACHE: u32 = 1;
pub const CONFIG_R8169_MODULE: u32 = 1;
pub const CONFIG_MAX30102_MODULE: u32 = 1;
pub const CONFIG_PCI_STUB_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_HYBLA_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_CTR: u32 = 1;
pub const CONFIG_DRM_I2C_NXP_TDA998X_MODULE: u32 = 1;
pub const CONFIG_MMC_CQHCI_MODULE: u32 = 1;
pub const CONFIG_HID_KENSINGTON_MODULE: u32 = 1;
pub const CONFIG_SMB_SERVER_KERBEROS5: u32 = 1;
pub const CONFIG_SND_SOC_RT700_MODULE: u32 = 1;
pub const CONFIG_USB_EHCI_HCD: u32 = 1;
pub const CONFIG_BATTERY_DS2760_MODULE: u32 = 1;
pub const CONFIG_TEXTSEARCH_BM_MODULE: u32 = 1;
pub const CONFIG_SENSORS_HMC5843_I2C_MODULE: u32 = 1;
pub const CONFIG_CHARGER_BQ25890_MODULE: u32 = 1;
pub const CONFIG_MFD_MP2629_MODULE: u32 = 1;
pub const CONFIG_FUJITSU_ES_MODULE: u32 = 1;
pub const CONFIG_ADRF6780_MODULE: u32 = 1;
pub const CONFIG_FS_IOMAP: u32 = 1;
pub const CONFIG_8139TOO_MODULE: u32 = 1;
pub const CONFIG_JFS_SECURITY: u32 = 1;
pub const CONFIG_SND_SOC_TLV320AIC32X4_I2C_MODULE: u32 = 1;
pub const CONFIG_PCI_EPF_NTB_MODULE: u32 = 1;
pub const CONFIG_KVM_PRIVATE_MEM: u32 = 1;
pub const CONFIG_AFS_FSCACHE: u32 = 1;
pub const CONFIG_SND_PDAUDIOCF_MODULE: u32 = 1;
pub const CONFIG_TCP_SIGPOOL: u32 = 1;
pub const CONFIG_NLS_MAC_INUIT_MODULE: u32 = 1;
pub const CONFIG_PHY_QCOM_USB_HS_MODULE: u32 = 1;
pub const CONFIG_MFD_SIMPLE_MFD_I2C_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_LL: u32 = 1;
pub const CONFIG_HAVE_EISA: u32 = 1;
pub const CONFIG_MODULE_SIG_KEY_TYPE_RSA: u32 = 1;
pub const CONFIG_HID_ZYDACRON_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_LP8755_MODULE: u32 = 1;
pub const CONFIG_PPP_MPPE_MODULE: u32 = 1;
pub const CONFIG_CAN_CALC_BITTIMING: u32 = 1;
pub const CONFIG_NFSD_V4_2_INTER_SSC: u32 = 1;
pub const CONFIG_HID_SENSOR_ACCEL_3D_MODULE: u32 = 1;
pub const CONFIG_DE2104X_MODULE: u32 = 1;
pub const CONFIG_KXSD9_I2C_MODULE: u32 = 1;
pub const CONFIG_ISA_BUS_API: u32 = 1;
pub const CONFIG_MEMORY_HOTPLUG: u32 = 1;
pub const CONFIG_SND_HDA_CS_DSP_CONTROLS_MODULE: u32 = 1;
pub const CONFIG_VMD_MODULE: u32 = 1;
pub const CONFIG_DVB_B2C2_FLEXCOP_MODULE: u32 = 1;
pub const CONFIG_COMPACT_UNEVICTABLE_DEFAULT: u32 = 1;
pub const CONFIG_RD_ZSTD: u32 = 1;
pub const CONFIG_UCSI_STM32G0_MODULE: u32 = 1;
pub const CONFIG_MOST_VIDEO_MODULE: u32 = 1;
pub const CONFIG_USB_NET_SR9700_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_PCI_ACPI: u32 = 1;
pub const CONFIG_SND_SOC_ADAU1372_MODULE: u32 = 1;
pub const CONFIG_MFD_TQMX86_MODULE: u32 = 1;
pub const CONFIG_SATA_ZPODD: u32 = 1;
pub const CONFIG_HID_CMEDIA_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8960_MODULE: u32 = 1;
pub const CONFIG_RFKILL: u32 = 1;
pub const CONFIG_AD5272_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TVP5150_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_FC0012_MODULE: u32 = 1;
pub const CONFIG_MT7915E_MODULE: u32 = 1;
pub const CONFIG_NETDEVICES: u32 = 1;
pub const CONFIG_ISA_BUS: u32 = 1;
pub const CONFIG_NET_KEY_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ADV7180_MODULE: u32 = 1;
pub const CONFIG_SMS_SIANO_MDTV_MODULE: u32 = 1;
pub const CONFIG_EXTCON_INTEL_MRFLD_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WCD9335_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_TARGET_HL_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_CONNCOUNT_MODULE: u32 = 1;
pub const CONFIG_ATM_IDT77252_USE_SUNI: u32 = 1;
pub const CONFIG_SND_OPL3_LIB_SEQ_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_KCOV: u32 = 1;
pub const CONFIG_CGROUP_FREEZER: u32 = 1;
pub const CONFIG_VIDEO_UPD64083_MODULE: u32 = 1;
pub const CONFIG_SERIAL_ALTERA_JTAGUART_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_MELFAS_MIP4_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_STACKLEAK: u32 = 1;
pub const CONFIG_EVENTFD: u32 = 1;
pub const CONFIG_CRYPTO_DEV_PADLOCK_SHA_MODULE: u32 = 1;
pub const CONFIG_SPI_DESIGNWARE_MODULE: u32 = 1;
pub const CONFIG_MTD_CK804XROM_MODULE: u32 = 1;
pub const CONFIG_NVME_TARGET_TCP_TLS: u32 = 1;
pub const CONFIG_RTL8192CE_MODULE: u32 = 1;
pub const CONFIG_WAN: u32 = 1;
pub const CONFIG_VLAN_8021Q_MVRP: u32 = 1;
pub const CONFIG_RTL8821AE_MODULE: u32 = 1;
pub const CONFIG_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_ADXRS290_MODULE: u32 = 1;
pub const CONFIG_IPV6_SIT_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_IRDMA_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TPS65912_MODULE: u32 = 1;
pub const CONFIG_QTNFMAC_PCIE_MODULE: u32 = 1;
pub const CONFIG_EEPROM_EE1004_MODULE: u32 = 1;
pub const CONFIG_XFRM: u32 = 1;
pub const CONFIG_SENSORS_K8TEMP_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_BT_SCO_MODULE: u32 = 1;
pub const CONFIG_ASYNC_TX_DMA: u32 = 1;
pub const CONFIG_COMEDI_DAS16_MODULE: u32 = 1;
pub const CONFIG_GPIO_LATCH_MODULE: u32 = 1;
pub const CONFIG_CAIF_USB_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_PMEM_API: u32 = 1;
pub const CONFIG_USB_F_UAC2_MODULE: u32 = 1;
pub const CONFIG_LINEAR_RANGES: u32 = 1;
pub const CONFIG_DM_UNSTRIPED_MODULE: u32 = 1;
pub const CONFIG_HAVE_KPROBES_ON_FTRACE: u32 = 1;
pub const CONFIG_REGULATOR_PV88090_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_IP_MODULE: u32 = 1;
pub const CONFIG_TINYDRM_ST7586_MODULE: u32 = 1;
pub const CONFIG_YENTA_TOSHIBA: u32 = 1;
pub const CONFIG_USB_MR800_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_AS5011_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV5695_MODULE: u32 = 1;
pub const CONFIG_MTD_NETtel_MODULE: u32 = 1;
pub const CONFIG_MFD_VX855_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_CONSOLE: u32 = 1;
pub const CONFIG_PATA_PARPORT_FIT3_MODULE: u32 = 1;
pub const CONFIG_DRM_BUDDY_MODULE: u32 = 1;
pub const CONFIG_IPV6_MULTIPLE_TABLES: u32 = 1;
pub const CONFIG_USB_ANNOUNCE_NEW_DEVICES: u32 = 1;
pub const CONFIG_CRYPTO_GENIV: u32 = 1;
pub const CONFIG_USB_SERIAL_WHITEHEAT_MODULE: u32 = 1;
pub const CONFIG_NET_CLS_ROUTE4_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TVP514X_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_XRS700X_MDIO_MODULE: u32 = 1;
pub const CONFIG_HSA_AMD_P2P: u32 = 1;
pub const CONFIG_JUMP_LABEL: u32 = 1;
pub const CONFIG_NTFS3_FS_MODULE: u32 = 1;
pub const CONFIG_HID_UDRAW_PS3_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_FMVJ18X_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_QT1070_MODULE: u32 = 1;
pub const CONFIG_MFD_KEMPLD_MODULE: u32 = 1;
pub const CONFIG_LEDS_PCA995X_MODULE: u32 = 1;
pub const CONFIG_USB_NET2272_MODULE: u32 = 1;
pub const CONFIG_CHARGER_CROS_PCHG_MODULE: u32 = 1;
pub const CONFIG_OVERLAY_FS_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_NETPORT_MODULE: u32 = 1;
pub const CONFIG_CIFS_ALLOW_INSECURE_LEGACY: u32 = 1;
pub const CONFIG_DEBUG_INFO_COMPRESSED_NONE: u32 = 1;
pub const CONFIG_TCG_INFINEON_MODULE: u32 = 1;
pub const CONFIG_ATH9K_HTC_MODULE: u32 = 1;
pub const CONFIG_IP_VS_DH_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8753_MODULE: u32 = 1;
pub const CONFIG_BRCMFMAC_PROTO_MSGBUF: u32 = 1;
pub const CONFIG_AX25_DAMA_SLAVE: u32 = 1;
pub const CONFIG_AD5380_MODULE: u32 = 1;
pub const CONFIG_RT2800PCI_RT3290: u32 = 1;
pub const CONFIG_SX9324_MODULE: u32 = 1;
pub const CONFIG_VIDEO_MEM2MEM_DEINTERLACE_MODULE: u32 = 1;
pub const CONFIG_RADIO_WL128X_MODULE: u32 = 1;
pub const CONFIG_PPPOE_HASH_BITS_4: u32 = 1;
pub const CONFIG_COMMON_CLK_CS2000_CP_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ES8326_MODULE: u32 = 1;
pub const CONFIG_DA311_MODULE: u32 = 1;
pub const CONFIG_IP_NF_TARGET_MASQUERADE_MODULE: u32 = 1;
pub const CONFIG_AIC79XX_RESET_DELAY_MS: u32 = 5000;
pub const CONFIG_UIO_HV_GENERIC_MODULE: u32 = 1;
pub const CONFIG_ARCNET_COM20020_MODULE: u32 = 1;
pub const CONFIG_MFD_AAT2870_CORE: u32 = 1;
pub const CONFIG_MT7921S_MODULE: u32 = 1;
pub const CONFIG_HAVE_EBPF_JIT: u32 = 1;
pub const CONFIG_NF_CONNTRACK_BROADCAST_MODULE: u32 = 1;
pub const CONFIG_ECRYPT_FS: u32 = 1;
pub const CONFIG_NFT_FWD_NETDEV_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LZ4_MODULE: u32 = 1;
pub const CONFIG_PROC_PAGE_MONITOR: u32 = 1;
pub const CONFIG_USB_CONFIGFS_ECM: u32 = 1;
pub const CONFIG_MFD_MAX8907_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_EXTENDED: u32 = 1;
pub const CONFIG_GAMEPORT_FM801_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_MASQUERADE_MODULE: u32 = 1;
pub const CONFIG_PWM_IQS620A_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MAX6916_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_MAGELLAN_MODULE: u32 = 1;
pub const CONFIG_AD7887_MODULE: u32 = 1;
pub const CONFIG_AD7780_MODULE: u32 = 1;
pub const CONFIG_ADXL313_I2C_MODULE: u32 = 1;
pub const CONFIG_FTL_MODULE: u32 = 1;
pub const CONFIG_IIO_BUFFER_DMA_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ARCH_HAVE_LIB_CURVE25519_MODULE: u32 = 1;
pub const CONFIG_TXGBE_MODULE: u32 = 1;
pub const CONFIG_XEN_MEMORY_HOTPLUG_LIMIT: u32 = 512;
pub const CONFIG_IGB_HWMON: u32 = 1;
pub const CONFIG_DM_CACHE_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_R820T_MODULE: u32 = 1;
pub const CONFIG_MTD_SPI_NOR_USE_4K_SECTORS: u32 = 1;
pub const CONFIG_TYPEC_DP_ALTMODE_MODULE: u32 = 1;
pub const CONFIG_MOST_I2C_MODULE: u32 = 1;
pub const CONFIG_IPMI_DEVICE_INTERFACE_MODULE: u32 = 1;
pub const CONFIG_BPF: u32 = 1;
pub const CONFIG_9P_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_OCTEON_EP_MODULE: u32 = 1;
pub const CONFIG_STM_SOURCE_HEARTBEAT_MODULE: u32 = 1;
pub const CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV: u32 = 1;
pub const CONFIG_DELL_WMI_DDV_MODULE: u32 = 1;
pub const CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK: u32 = 1;
pub const CONFIG_C2PORT_MODULE: u32 = 1;
pub const CONFIG_EVM_ATTR_FSUUID: u32 = 1;
pub const CONFIG_DM_DELAY_MODULE: u32 = 1;
pub const CONFIG_XEN_GRANT_DMA_OPS: u32 = 1;
pub const CONFIG_BLK_DEV_RNBD_SERVER_MODULE: u32 = 1;
pub const CONFIG_MEMORY_HOTPLUG_DEFAULT_ONLINE: u32 = 1;
pub const CONFIG_X86_CMOV: u32 = 1;
pub const CONFIG_USB_SERIAL_CH341_MODULE: u32 = 1;
pub const CONFIG_HID_SENSOR_IIO_COMMON_MODULE: u32 = 1;
pub const CONFIG_CAIF_DRIVERS: u32 = 1;
pub const CONFIG_NET_DSA_TAG_SJA1105_MODULE: u32 = 1;
pub const CONFIG_ACPI_HOTPLUG_CPU: u32 = 1;
pub const CONFIG_XILINX_SDFEC_MODULE: u32 = 1;
pub const CONFIG_PM_TRACE_RTC: u32 = 1;
pub const CONFIG_RD_LZO: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_1564_MODULE: u32 = 1;
pub const CONFIG_USB_RAINSHADOW_CEC_MODULE: u32 = 1;
pub const CONFIG_JFFS2_FS_SECURITY: u32 = 1;
pub const CONFIG_USB_G_NOKIA_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_IPPORT_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_NHPOLY1305_SSE2_MODULE: u32 = 1;
pub const CONFIG_CAIF_TTY_MODULE: u32 = 1;
pub const CONFIG_KPROBE_EVENTS: u32 = 1;
pub const CONFIG_SENSORS_SHT21_MODULE: u32 = 1;
pub const CONFIG_USB_IOWARRIOR_MODULE: u32 = 1;
pub const CONFIG_SND_HDSP_MODULE: u32 = 1;
pub const CONFIG_BATTERY_DA9052_MODULE: u32 = 1;
pub const CONFIG_SERIO_CT82C710_MODULE: u32 = 1;
pub const CONFIG_OPENVSWITCH_GENEVE_MODULE: u32 = 1;
pub const CONFIG_MLX4_CORE_GEN2: u32 = 1;
pub const CONFIG_USBPCWATCHDOG_MODULE: u32 = 1;
pub const CONFIG_CAN_KVASER_PCIEFD_MODULE: u32 = 1;
pub const CONFIG_MODULE_SIG_ALL: u32 = 1;
pub const CONFIG_USB_EZUSB_FX2_MODULE: u32 = 1;
pub const CONFIG_SND_USB_TONEPORT_MODULE: u32 = 1;
pub const CONFIG_F2FS_FS_ZSTD: u32 = 1;
pub const CONFIG_SND_USB_USX2Y_MODULE: u32 = 1;
pub const CONFIG_SCSI_SPI_ATTRS_MODULE: u32 = 1;
pub const CONFIG_FB_CYBER2000_MODULE: u32 = 1;
pub const CONFIG_BCMA_DRIVER_GMAC_CMN: u32 = 1;
pub const CONFIG_RTL8XXXU_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_COPY_MC: u32 = 1;
pub const CONFIG_GREENASIA_FF: u32 = 1;
pub const CONFIG_MFD_CS47L92: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_GRAPH_RETVAL: u32 = 1;
pub const CONFIG_SND_SOC_SOF_BROADWELL_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_CEDARFORK_MODULE: u32 = 1;
pub const CONFIG_SCSI_HPSA_MODULE: u32 = 1;
pub const CONFIG_XEN_GNTDEV_DMABUF: u32 = 1;
pub const CONFIG_EROFS_FS_ZIP_DEFLATE: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_ACNTSA_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AW88395_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_IMG_I2S_IN_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TDA38640_MODULE: u32 = 1;
pub const CONFIG_RAPIDIO_TSI721_MODULE: u32 = 1;
pub const CONFIG_SND_KORG1212_MODULE: u32 = 1;
pub const CONFIG_SENSORS_VIA_CPUTEMP_MODULE: u32 = 1;
pub const CONFIG_MLX5_EN_ARFS: u32 = 1;
pub const CONFIG_NF_CONNTRACK_SECMARK: u32 = 1;
pub const CONFIG_GP2AP020A00F_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_T3_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV7640_MODULE: u32 = 1;
pub const CONFIG_INSTRUCTION_DECODER: u32 = 1;
pub const CONFIG_CRYPTO_SHA512: u32 = 1;
pub const CONFIG_SND_SOC_IMG_PISTACHIO_INTERNAL_DAC_MODULE: u32 = 1;
pub const CONFIG_CAN_ISOTP_MODULE: u32 = 1;
pub const CONFIG_PHONET_MODULE: u32 = 1;
pub const CONFIG_MWIFIEX_PCIE_MODULE: u32 = 1;
pub const CONFIG_CAN_C_CAN_PCI_MODULE: u32 = 1;
pub const CONFIG_CAN_VXCAN_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AC97_BUS: u32 = 1;
pub const CONFIG_TRUSTED_KEYS: u32 = 1;
pub const CONFIG_TEE_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_CLASS_DEVICE: u32 = 1;
pub const CONFIG_CC_HAS_ASM_INLINE: u32 = 1;
pub const CONFIG_B43_HWRNG: u32 = 1;
pub const CONFIG_NVME_AUTH_MODULE: u32 = 1;
pub const CONFIG_VHOST_MODULE: u32 = 1;
pub const CONFIG_USB_M5602_MODULE: u32 = 1;
pub const CONFIG_RT2X00_LIB_USB_MODULE: u32 = 1;
pub const CONFIG_UIO_MF624_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_HDA_LINK: u32 = 1;
pub const CONFIG_WM8350_POWER_MODULE: u32 = 1;
pub const CONFIG_SPI_DLN2_MODULE: u32 = 1;
pub const CONFIG_INPUT_CMA3000_I2C_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_NULL: u32 = 1;
pub const CONFIG_INTEL_WMI_THUNDERBOLT_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_AF9005_REMOTE_MODULE: u32 = 1;
pub const CONFIG_GPIO_CDEV_V1: u32 = 1;
pub const CONFIG_B43_PHY_G: u32 = 1;
pub const CONFIG_NET_VENDOR_SEEQ: u32 = 1;
pub const CONFIG_NF_DEFRAG_IPV4_MODULE: u32 = 1;
pub const CONFIG_USER_RETURN_NOTIFIER: u32 = 1;
pub const CONFIG_INTEL_IOMMU_FLOPPY_WA: u32 = 1;
pub const CONFIG_BT_QCA_MODULE: u32 = 1;
pub const CONFIG_USB_IDMOUSE_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MT6370_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WSA883X_MODULE: u32 = 1;
pub const CONFIG_SND_FIREWIRE_TASCAM_MODULE: u32 = 1;
pub const CONFIG_MISDN_INFINEON_MODULE: u32 = 1;
pub const CONFIG_HID_LCPOWER_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_HWSIM_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_CONSOLE: u32 = 1;
pub const CONFIG_MOUSE_ELAN_I2C_SMBUS: u32 = 1;
pub const CONFIG_ARCH_CLOCKSOURCE_INIT: u32 = 1;
pub const CONFIG_ATH11K_MODULE: u32 = 1;
pub const CONFIG_NFC_MRVL_MODULE: u32 = 1;
pub const CONFIG_ACPI_APEI_EINJ_MODULE: u32 = 1;
pub const CONFIG_PVH: u32 = 1;
pub const CONFIG_STM_PROTO_BASIC_MODULE: u32 = 1;
pub const CONFIG_PERSISTENT_KEYRINGS: u32 = 1;
pub const CONFIG_REGULATOR_RTQ6752_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_CONNMARK_MODULE: u32 = 1;
pub const CONFIG_BFS_FS_MODULE: u32 = 1;
pub const CONFIG_FS_ENCRYPTION: u32 = 1;
pub const CONFIG_SND_ES1938_MODULE: u32 = 1;
pub const CONFIG_PM_DEBUG: u32 = 1;
pub const CONFIG_VIDEO_TW9906_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_VITESSE_VSC73XX_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_BT_AOSPEXT: u32 = 1;
pub const CONFIG_DVB_BUDGET_AV_MODULE: u32 = 1;
pub const CONFIG_IPV6_ROUTE_INFO: u32 = 1;
pub const CONFIG_MFD_WM8350_I2C: u32 = 1;
pub const CONFIG_RTW88_8821CS_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_ADVANCED: u32 = 1;
pub const CONFIG_CRYPTO_DEFLATE: u32 = 1;
pub const CONFIG_GENERIC_STRNLEN_USER: u32 = 1;
pub const CONFIG_MFD_WM8350: u32 = 1;
pub const CONFIG_NFT_DUP_NETDEV_MODULE: u32 = 1;
pub const CONFIG_USB_APPLEDISPLAY_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_KLSI_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_TCPMSS_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DA9063_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SMPRO_MODULE: u32 = 1;
pub const CONFIG_IGB_MODULE: u32 = 1;
pub const CONFIG_MTD_CFI_MODULE: u32 = 1;
pub const CONFIG_COMEDI_USBDUXSIGMA_MODULE: u32 = 1;
pub const CONFIG_QCOM_VADC_COMMON_MODULE: u32 = 1;
pub const CONFIG_AD7768_1_MODULE: u32 = 1;
pub const CONFIG_RPMSG_VIRTIO_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_IPCOMP_MODULE: u32 = 1;
pub const CONFIG_IPV6_ROUTER_PREF: u32 = 1;
pub const CONFIG_JFFS2_FS_DEBUG: u32 = 0;
pub const CONFIG_BT_HCIBTSDIO_MODULE: u32 = 1;
pub const CONFIG_DRM_QXL_MODULE: u32 = 1;
pub const CONFIG_CHARGER_RT5033_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_RSI: u32 = 1;
pub const CONFIG_KVM_MAX_NR_VCPUS: u32 = 4096;
pub const CONFIG_SLIP_COMPRESSED: u32 = 1;
pub const CONFIG_CRYPTO_JITTERENTROPY: u32 = 1;
pub const CONFIG_JOYSTICK_PSXPAD_SPI_MODULE: u32 = 1;
pub const CONFIG_NTB_INTEL_MODULE: u32 = 1;
pub const CONFIG_SND_VX_LIB_MODULE: u32 = 1;
pub const CONFIG_ATM_MPOA_MODULE: u32 = 1;
pub const CONFIG_TYPEC_MODULE: u32 = 1;
pub const CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION: u32 = 1;
pub const CONFIG_CHARGER_WILCO_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_L2TP_MODULE: u32 = 1;
pub const CONFIG_DVB_MXL692_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_SERDEV: u32 = 1;
pub const CONFIG_LEDS_AAEON_MODULE: u32 = 1;
pub const CONFIG_INPUT_ARIZONA_HAPTICS_MODULE: u32 = 1;
pub const CONFIG_DM_SWITCH_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_GCM: u32 = 1;
pub const CONFIG_SND_INDIGOIO_MODULE: u32 = 1;
pub const CONFIG_NE2K_PCI_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV2680_MODULE: u32 = 1;
pub const CONFIG_MOUSE_SYNAPTICS_USB_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_NETLINK_LOG_MODULE: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE: u32 = 1;
pub const CONFIG_PWM_LPSS_PCI: u32 = 1;
pub const CONFIG_MLX5_DPLL_MODULE: u32 = 1;
pub const CONFIG_CDROM: u32 = 1;
pub const CONFIG_PCIEAER_CXL: u32 = 1;
pub const CONFIG_PINCTRL_CHERRYVIEW: u32 = 1;
pub const CONFIG_NLS_ISO8859_14_MODULE: u32 = 1;
pub const CONFIG_DS1803_MODULE: u32 = 1;
pub const CONFIG_MTD_PHRAM_MODULE: u32 = 1;
pub const CONFIG_MAGIC_SYSRQ: u32 = 1;
pub const CONFIG_MFD_88PM860X: u32 = 1;
pub const CONFIG_CROS_EC_CHARDEV_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_FS: u32 = 1;
pub const CONFIG_E100_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TPS6586X_MODULE: u32 = 1;
pub const CONFIG_ATH11K_TRACING: u32 = 1;
pub const CONFIG_THERMAL_EMULATION: u32 = 1;
pub const CONFIG_MDIO_THUNDER_MODULE: u32 = 1;
pub const CONFIG_DMI: u32 = 1;
pub const CONFIG_IPV6_SIT_6RD: u32 = 1;
pub const CONFIG_SND_SOC_NAU8540_MODULE: u32 = 1;
pub const CONFIG_WIL6210_TRACING: u32 = 1;
pub const CONFIG_DW_XDATA_PCIE_MODULE: u32 = 1;
pub const CONFIG_PARPORT_SERIAL_MODULE: u32 = 1;
pub const CONFIG_SND_DICE_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_KPP: u32 = 1;
pub const CONFIG_PNFS_BLOCK_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_RDC: u32 = 1;
pub const CONFIG_MACHZ_WDT_MODULE: u32 = 1;
pub const CONFIG_SENSORS_IR38064_REGULATOR: u32 = 1;
pub const CONFIG_PGTABLE_LEVELS: u32 = 5;
pub const CONFIG_CPUSETS: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_MARK_MODULE: u32 = 1;
pub const CONFIG_FB_MATROX_MODULE: u32 = 1;
pub const CONFIG_ISDN: u32 = 1;
pub const CONFIG_VIDEO_PVRUSB2_SYSFS: u32 = 1;
pub const CONFIG_ATLAS_PH_SENSOR_MODULE: u32 = 1;
pub const CONFIG_FUNCTION_PROFILER: u32 = 1;
pub const CONFIG_SMBFS_MODULE: u32 = 1;
pub const CONFIG_MAC80211_RC_DEFAULT_MINSTREL: u32 = 1;
pub const CONFIG_SENSORS_MP2975_REGULATOR: u32 = 1;
pub const CONFIG_NVME_MULTIPATH: u32 = 1;
pub const CONFIG_FW_UPLOAD: u32 = 1;
pub const CONFIG_RMI4_F03_SERIO_MODULE: u32 = 1;
pub const CONFIG_SPARSE_IRQ: u32 = 1;
pub const CONFIG_MMA7455_I2C_MODULE: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_PC236_MODULE: u32 = 1;
pub const CONFIG_DVB_LGS8GXX_MODULE: u32 = 1;
pub const CONFIG_IR_SERIAL_TRANSMITTER: u32 = 1;
pub const CONFIG_XILLYUSB_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_MQPRIO_LIB_MODULE: u32 = 1;
pub const CONFIG_CAN_M_CAN_PCI_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP_MODULE: u32 = 1;
pub const CONFIG_INPUT_IDEAPAD_SLIDEBAR_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_MODULE: u32 = 1;
pub const CONFIG_SSFDC_MODULE: u32 = 1;
pub const CONFIG_IP_NF_MANGLE_MODULE: u32 = 1;
pub const CONFIG_LEDS_USER_MODULE: u32 = 1;
pub const CONFIG_TIFM_7XX1_MODULE: u32 = 1;
pub const CONFIG_SCSI_UFS_DWC_TC_PCI_MODULE: u32 = 1;
pub const CONFIG_USB_MASS_STORAGE_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SKYLAKE_HDAUDIO_CODEC: u32 = 1;
pub const CONFIG_BT_HCIBCM4377_MODULE: u32 = 1;
pub const CONFIG_HID_PICOLCD_LEDS: u32 = 1;
pub const CONFIG_COMEDI_CB_DAS16_CS_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1286_MODULE: u32 = 1;
pub const CONFIG_FCOE_FNIC_MODULE: u32 = 1;
pub const CONFIG_INTEL_SMARTCONNECT_MODULE: u32 = 1;
pub const CONFIG_ATH10K_DEBUGFS: u32 = 1;
pub const CONFIG_BCM_KONA_USB2_PHY_MODULE: u32 = 1;
pub const CONFIG_MOXA_INTELLIO_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_MCS5000_MODULE: u32 = 1;
pub const CONFIG_DVB_VES1X93_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_ILI9341_MODULE: u32 = 1;
pub const CONFIG_SECURITY_PERF_EVENTS_RESTRICT: u32 = 1;
pub const CONFIG_DRM_UDL_MODULE: u32 = 1;
pub const CONFIG_SECURITYFS: u32 = 1;
pub const CONFIG_LIBERTAS_MESH: u32 = 1;
pub const CONFIG_VIDEO_FB_IVTV_FORCE_PAT: u32 = 1;
pub const CONFIG_RCU_STALL_COMMON: u32 = 1;
pub const CONFIG_MCP9600_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_PCIDIO_MODULE: u32 = 1;
pub const CONFIG_BT_DEBUGFS: u32 = 1;
pub const CONFIG_CPU_SUP_AMD: u32 = 1;
pub const CONFIG_DRM_PANEL_AUO_A030JTN01_MODULE: u32 = 1;
pub const CONFIG_MFD_INTEL_QUARK_I2C_GPIO_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_VLAN_MODULE: u32 = 1;
pub const CONFIG_PCIEPORTBUS: u32 = 1;
pub const CONFIG_MEDIA_SUPPORT_MODULE: u32 = 1;
pub const CONFIG_NFT_FIB_IPV6_MODULE: u32 = 1;
pub const CONFIG_SENSORS_F75375S_MODULE: u32 = 1;
pub const CONFIG_DEBUG_BUGVERBOSE: u32 = 1;
pub const CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK: u32 = 1;
pub const CONFIG_CRYPTO_XCTR_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ST_MIPID02_MODULE: u32 = 1;
pub const CONFIG_ACPI_CUSTOM_DSDT_FILE: &[u8; 1usize] = b"\0";
pub const CONFIG_IIO_KX022A_MODULE: u32 = 1;
pub const CONFIG_IP_NF_FILTER_MODULE: u32 = 1;
pub const CONFIG_BH1780_MODULE: u32 = 1;
pub const CONFIG_HID_ZEROPLUS_MODULE: u32 = 1;
pub const CONFIG_REED_SOLOMON_DEC16: u32 = 1;
pub const CONFIG_INTEL_UNCORE_FREQ_CONTROL_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_MERRIFIELD_MODULE: u32 = 1;
pub const CONFIG_DYNAMIC_MEMORY_LAYOUT: u32 = 1;
pub const CONFIG_SENSORS_MC13783_ADC_MODULE: u32 = 1;
pub const CONFIG_DM_INTEGRITY_MODULE: u32 = 1;
pub const CONFIG_RV: u32 = 1;
pub const CONFIG_MFD_WCD934X_MODULE: u32 = 1;
pub const CONFIG_SATA_SX4_MODULE: u32 = 1;
pub const CONFIG_MAC802154_MODULE: u32 = 1;
pub const CONFIG_IBM_ASM_MODULE: u32 = 1;
pub const CONFIG_IP5XXX_POWER_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_LENGTH_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_PKTTYPE_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_POLYVAL_MODULE: u32 = 1;
pub const CONFIG_SENSORS_NCT6775_I2C_MODULE: u32 = 1;
pub const CONFIG_XFRM_ESPINTCP: u32 = 1;
pub const CONFIG_HID_SENSOR_GYRO_3D_MODULE: u32 = 1;
pub const CONFIG_HAVE_BUILDTIME_MCOUNT_SORT: u32 = 1;
pub const CONFIG_COMEDI_8255_SA_MODULE: u32 = 1;
pub const CONFIG_MPRLS0025PA_MODULE: u32 = 1;
pub const CONFIG_AFE4403_MODULE: u32 = 1;
pub const CONFIG_MODULES_TREE_LOOKUP: u32 = 1;
pub const CONFIG_FAT_FS: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_CA0132_MODULE: u32 = 1;
pub const CONFIG_FCOE_MODULE: u32 = 1;
pub const CONFIG_CAN_SJA1000_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SIG: u32 = 1;
pub const CONFIG_SND_HDA_INTEL_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_QAT_DH895xCCVF_MODULE: u32 = 1;
pub const CONFIG_BLK_DEBUG_FS_ZONED: u32 = 1;
pub const CONFIG_ACPI_ADXL: u32 = 1;
pub const CONFIG_TEXTSEARCH_FSM_MODULE: u32 = 1;
pub const CONFIG_USB_HSIC_USB4604_MODULE: u32 = 1;
pub const CONFIG_PECI_MODULE: u32 = 1;
pub const CONFIG_MISDN_DSP_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM75_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_CXGB4_MODULE: u32 = 1;
pub const CONFIG_PANEL_PROFILE: u32 = 5;
pub const CONFIG_DVB_STV0910_MODULE: u32 = 1;
pub const CONFIG_LSI_ET1011C_PHY_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5616_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_RAW_MODULE: u32 = 1;
pub const CONFIG_BUILDTIME_TABLE_SORT: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_SOFT_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX127_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_EC168_MODULE: u32 = 1;
pub const CONFIG_TDX_GUEST_DRIVER_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1742_MODULE: u32 = 1;
pub const CONFIG_BMI323_I2C_MODULE: u32 = 1;
pub const CONFIG_HSC030PA_SPI_MODULE: u32 = 1;
pub const CONFIG_NVMEM: u32 = 1;
pub const CONFIG_INET_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_X86_INTERNODE_CACHE_SHIFT: u32 = 6;
pub const CONFIG_BMA220_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SERPENT_SSE2_X86_64_MODULE: u32 = 1;
pub const CONFIG_NF_LOG_ARP_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_PADLOCK: u32 = 1;
pub const CONFIG_SENSORS_PMBUS_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_CC_PLATFORM: u32 = 1;
pub const CONFIG_MT76x0_COMMON_MODULE: u32 = 1;
pub const CONFIG_EEPROM_93CX6_MODULE: u32 = 1;
pub const CONFIG_GPIO_WM8350_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_CA8210_MODULE: u32 = 1;
pub const CONFIG_LTC2309_MODULE: u32 = 1;
pub const CONFIG_NET_9P_VIRTIO_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_SKBMOD_MODULE: u32 = 1;
pub const CONFIG_PINCONF: u32 = 1;
pub const CONFIG_MFD_DA9052_SPI: u32 = 1;
pub const CONFIG_X86_CHECK_BIOS_CORRUPTION: u32 = 1;
pub const CONFIG_IIO_ST_LSM6DSX_I2C_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_SMSC_LAN9303_I2C_MODULE: u32 = 1;
pub const CONFIG_BLOCK_HOLDER_DEPRECATED: u32 = 1;
pub const CONFIG_MLX4_CORE_MODULE: u32 = 1;
pub const CONFIG_UBSAN_BOOL: u32 = 1;
pub const CONFIG_AD4130_MODULE: u32 = 1;
pub const CONFIG_GPIO_MENZ127_MODULE: u32 = 1;
pub const CONFIG_DW_I3C_MASTER_MODULE: u32 = 1;
pub const CONFIG_RETHUNK: u32 = 1;
pub const CONFIG_INTEL_SAR_INT1092_MODULE: u32 = 1;
pub const CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK: i32 = -1;
pub const CONFIG_SND_MIA_MODULE: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK_OCP_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS: u32 = 1;
pub const CONFIG_ROMFS_FS_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_USERFAULTFD_WP: u32 = 1;
pub const CONFIG_OID_REGISTRY: u32 = 1;
pub const CONFIG_MFD_88PM805_MODULE: u32 = 1;
pub const CONFIG_SGI_GRU_MODULE: u32 = 1;
pub const CONFIG_SOUNDWIRE_GENERIC_ALLOCATION_MODULE: u32 = 1;
pub const CONFIG_PHY_PXA_28NM_HSIC_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_DTT200U_MODULE: u32 = 1;
pub const CONFIG_CIFS_UPCALL: u32 = 1;
pub const CONFIG_GREYBUS_VIBRATOR_MODULE: u32 = 1;
pub const CONFIG_THUNDER_NIC_PF_MODULE: u32 = 1;
pub const CONFIG_RADIO_TEA575X_MODULE: u32 = 1;
pub const CONFIG_LIB80211_MODULE: u32 = 1;
pub const CONFIG_MT7921E_MODULE: u32 = 1;
pub const CONFIG_RUSTC_VERSION_TEXT: &[u8; 36usize] = b"rustc 1.75.0 (82e1608df 2023-12-21)\0";
pub const CONFIG_INTEGRITY_PLATFORM_KEYRING: u32 = 1;
pub const CONFIG_MEDIA_CEC_SUPPORT: u32 = 1;
pub const CONFIG_MFD_CORE: u32 = 1;
pub const CONFIG_AS_SHA256_NI: u32 = 1;
pub const CONFIG_HAVE_KERNEL_XZ: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_PC236_ISA_MODULE: u32 = 1;
pub const CONFIG_USB_CXACRU_MODULE: u32 = 1;
pub const CONFIG_WINMATE_FM07_KEYS_MODULE: u32 = 1;
pub const CONFIG_X86_PKG_TEMP_THERMAL_MODULE: u32 = 1;
pub const CONFIG_RAID_ATTRS_MODULE: u32 = 1;
pub const CONFIG_CAN_NETLINK: u32 = 1;
pub const CONFIG_RFKILL_LEDS: u32 = 1;
pub const CONFIG_BT_HCIBTUSB_BCM: u32 = 1;
pub const CONFIG_SND_SOC_LPASS_RX_MACRO_MODULE: u32 = 1;
pub const CONFIG_CONSOLE_TRANSLATIONS: u32 = 1;
pub const CONFIG_PATA_CMD64X_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_TM2_TOUCHKEY_MODULE: u32 = 1;
pub const CONFIG_MTD_CFI_STAA_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_ATOMIC_RMW: u32 = 1;
pub const CONFIG_TCG_CRB: u32 = 1;
pub const CONFIG_MT7925U_MODULE: u32 = 1;
pub const CONFIG_BMA400_I2C_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_SJA1105_VL: u32 = 1;
pub const CONFIG_REGULATOR_AD5398_MODULE: u32 = 1;
pub const CONFIG_CHARGER_SURFACE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_IR36021_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_LSM9DS0_MODULE: u32 = 1;
pub const CONFIG_USB_F_UVC_MODULE: u32 = 1;
pub const CONFIG_RAID6_PQ_MODULE: u32 = 1;
pub const CONFIG_SBC_FITPC2_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_HW_RANDOM_TIMERIOMEM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_VANGOGH_MACH_MODULE: u32 = 1;
pub const CONFIG_ST_UVIS25_SPI_MODULE: u32 = 1;
pub const CONFIG_FXLS8962AF_SPI_MODULE: u32 = 1;
pub const CONFIG_NET_IPGRE_MODULE: u32 = 1;
pub const CONFIG_ADT7316_MODULE: u32 = 1;
pub const CONFIG_LIBERTAS_SDIO_MODULE: u32 = 1;
pub const CONFIG_MDIO_MSCC_MIIM_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_QAT_MODULE: u32 = 1;
pub const CONFIG_FUSION: u32 = 1;
pub const CONFIG_MTDRAM_TOTAL_SIZE: u32 = 4096;
pub const CONFIG_TINYDRM_ST7735R_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TEA6420_MODULE: u32 = 1;
pub const CONFIG_IPV6_SEG6_BPF: u32 = 1;
pub const CONFIG_SWIOTLB_XEN: u32 = 1;
pub const CONFIG_DM_INIT: u32 = 1;
pub const CONFIG_BRIDGE_EBT_IP6_MODULE: u32 = 1;
pub const CONFIG_IQS620AT_TEMP_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_SNMP_BASIC_MODULE: u32 = 1;
pub const CONFIG_SND_X86: u32 = 1;
pub const CONFIG_PCMCIA_LOAD_CIS: u32 = 1;
pub const CONFIG_NFT_FIB_NETDEV_MODULE: u32 = 1;
pub const CONFIG_XEN_SYMS: u32 = 1;
pub const CONFIG_SERIAL_EARLYCON: u32 = 1;
pub const CONFIG_VIDEO_OV9640_MODULE: u32 = 1;
pub const CONFIG_CLS_U32_MARK: u32 = 1;
pub const CONFIG_DVB_CX24120_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_NI: u32 = 1;
pub const CONFIG_SND_SOC_ARIZONA_MODULE: u32 = 1;
pub const CONFIG_SND_ICE1712_MODULE: u32 = 1;
pub const CONFIG_CC_HAS_KASAN_SW_TAGS: u32 = 1;
pub const CONFIG_BACKLIGHT_MAX8925_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_AKCIPHER: u32 = 1;
pub const CONFIG_LIBERTAS_SPI_MODULE: u32 = 1;
pub const CONFIG_SCSI_ACARD_MODULE: u32 = 1;
pub const CONFIG_EROFS_FS_ZIP: u32 = 1;
pub const CONFIG_SND_HDA_SCODEC_CS35L41_I2C_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SIGMADSP_I2C_MODULE: u32 = 1;
pub const CONFIG_ETHTOOL_NETLINK: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_BACKLIGHT_MODULE: u32 = 1;
pub const CONFIG_ACPI_CPU_FREQ_PSS: u32 = 1;
pub const CONFIG_HDC3020_MODULE: u32 = 1;
pub const CONFIG_CAN_ETAS_ES58X_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ: u32 = 1;
pub const CONFIG_USB_OHCI_HCD: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_KEXEC_FILE: u32 = 1;
pub const CONFIG_VIA_RHINE_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_MODULE: u32 = 1;
pub const CONFIG_VHOST_RING_MODULE: u32 = 1;
pub const CONFIG_NR_CPUS_DEFAULT: u32 = 8192;
pub const CONFIG_DVB_DUMMY_FE_MODULE: u32 = 1;
pub const CONFIG_DM_MIRROR_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_BLOWFISH_MODULE: u32 = 1;
pub const CONFIG_FB_SIS_MODULE: u32 = 1;
pub const CONFIG_ATH11K_PCI_MODULE: u32 = 1;
pub const CONFIG_ARCH_CPUIDLE_HALTPOLL: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE: u32 = 1;
pub const CONFIG_MLXSW_CORE_HWMON: u32 = 1;
pub const CONFIG_MMU_GATHER_MERGE_VMAS: u32 = 1;
pub const CONFIG_AIC7XXX_DEBUG_MASK: u32 = 0;
pub const CONFIG_SENSORS_LTC3815_MODULE: u32 = 1;
pub const CONFIG_CROS_EC_DEBUGFS_MODULE: u32 = 1;
pub const CONFIG_USB_F_TCM_MODULE: u32 = 1;
pub const CONFIG_USB_PCI: u32 = 1;
pub const CONFIG_COMEDI_DAS08_PCI_MODULE: u32 = 1;
pub const CONFIG_NLS_ASCII_MODULE: u32 = 1;
pub const CONFIG_RFKILL_GPIO_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_DA9055_MODULE: u32 = 1;
pub const CONFIG_USB_G_PRINTER_MODULE: u32 = 1;
pub const CONFIG_B43_MODULE: u32 = 1;
pub const CONFIG_FPGA_MGR_ALTERA_CVP_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_GRIP_MODULE: u32 = 1;
pub const CONFIG_BAYCOM_SER_FDX_MODULE: u32 = 1;
pub const CONFIG_MEDIA_ALTERA_CI_MODULE: u32 = 1;
pub const CONFIG_TIPC_DIAG_MODULE: u32 = 1;
pub const CONFIG_NF_REJECT_IPV4_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_M41T94_MODULE: u32 = 1;
pub const CONFIG_AD_SIGMA_DELTA_MODULE: u32 = 1;
pub const CONFIG_HAVE_CALL_THUNKS: u32 = 1;
pub const CONFIG_RANDOMIZE_MEMORY: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS_MAX: u32 = 32;
pub const CONFIG_SND_SOC_FSL_SSI_MODULE: u32 = 1;
pub const CONFIG_USB_LAN78XX_MODULE: u32 = 1;
pub const CONFIG_NFT_CONNLIMIT_MODULE: u32 = 1;
pub const CONFIG_BPF_EVENTS: u32 = 1;
pub const CONFIG_SND_SOC_ZL38060_MODULE: u32 = 1;
pub const CONFIG_BOOT_CONFIG: u32 = 1;
pub const CONFIG_GREYBUS_I2C_MODULE: u32 = 1;
pub const CONFIG_VIDEO_HEXIUM_ORION_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_NHPOLY1305_MODULE: u32 = 1;
pub const CONFIG_IIO_CROS_EC_SENSORS_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE: u32 = 1;
pub const CONFIG_MODULE_DECOMPRESS: u32 = 1;
pub const CONFIG_BACKLIGHT_GPIO_MODULE: u32 = 1;
pub const CONFIG_INTEL_MEI_ME_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_QIB_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBTUSB_MTK: u32 = 1;
pub const CONFIG_6LOWPAN_NHC_MOBILITY_MODULE: u32 = 1;
pub const CONFIG_LAPBETHER_MODULE: u32 = 1;
pub const CONFIG_USB_SI4713_MODULE: u32 = 1;
pub const CONFIG_SATA_SVW_MODULE: u32 = 1;
pub const CONFIG_MAX11100_MODULE: u32 = 1;
pub const CONFIG_VIDEO_RJ54N1_MODULE: u32 = 1;
pub const CONFIG_AD5360_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_MRF24J40_MODULE: u32 = 1;
pub const CONFIG_TRACE_IRQFLAGS_SUPPORT: u32 = 1;
pub const CONFIG_MTD_NAND_CORE_MODULE: u32 = 1;
pub const CONFIG_MFD_SYSCON: u32 = 1;
pub const CONFIG_SND_SOC_TAS5720_MODULE: u32 = 1;
pub const CONFIG_MTD_PHYSMAP_MODULE: u32 = 1;
pub const CONFIG_MS5611_SPI_MODULE: u32 = 1;
pub const CONFIG_NFS_V3_ACL: u32 = 1;
pub const CONFIG_HDLC_X25_MODULE: u32 = 1;
pub const CONFIG_IPV6_SEG6_LWTUNNEL: u32 = 1;
pub const CONFIG_KVM_SW_PROTECTED_VM: u32 = 1;
pub const CONFIG_CHARGER_GPIO_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_INTEL_TGL_MODULE: u32 = 1;
pub const CONFIG_INPUT_GPIO_DECODER_MODULE: u32 = 1;
pub const CONFIG_INFTL_MODULE: u32 = 1;
pub const CONFIG_KVM_HYPERV: u32 = 1;
pub const CONFIG_NFT_NUMGEN_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADT7462_MODULE: u32 = 1;
pub const CONFIG_DETECT_HUNG_TASK: u32 = 1;
pub const CONFIG_MAX11410_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MAX14577_MODULE: u32 = 1;
pub const CONFIG_SENSORS_NCT7802_MODULE: u32 = 1;
pub const CONFIG_CAN_MCP251X_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CCM_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_ADVANCED: u32 = 1;
pub const CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT: u32 = 1;
pub const CONFIG_USB_NET_CDC_SUBSET_MODULE: u32 = 1;
pub const CONFIG_BT_VIRTIO_MODULE: u32 = 1;
pub const CONFIG_BT_RTL_MODULE: u32 = 1;
pub const CONFIG_MMA9551_CORE_MODULE: u32 = 1;
pub const CONFIG_VIDEO_VIMC_MODULE: u32 = 1;
pub const CONFIG_KVM_GUEST: u32 = 1;
pub const CONFIG_SIEMENS_SIMATIC_IPC_BATT_APOLLOLAKE_MODULE: u32 = 1;
pub const CONFIG_QFMT_V2_MODULE: u32 = 1;
pub const CONFIG_USB_S2255_MODULE: u32 = 1;
pub const CONFIG_INET_DCCP_DIAG_MODULE: u32 = 1;
pub const CONFIG_TAP_MODULE: u32 = 1;
pub const CONFIG_MLX5_CLS_ACT: u32 = 1;
pub const CONFIG_ARCNET_COM90xxIO_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNMARK_MODULE: u32 = 1;
pub const CONFIG_ATH9K_HW_MODULE: u32 = 1;
pub const CONFIG_BLK_CGROUP: u32 = 1;
pub const CONFIG_USB_SERIAL_MCT_U232_MODULE: u32 = 1;
pub const CONFIG_PCIE_BUS_DEFAULT: u32 = 1;
pub const CONFIG_UIO_PDRV_GENIRQ_MODULE: u32 = 1;
pub const CONFIG_BATTERY_SURFACE_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBT3C_MODULE: u32 = 1;
pub const CONFIG_LEDS_TRIGGERS: u32 = 1;
pub const CONFIG_NET_FOU_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_RNG: u32 = 1;
pub const CONFIG_USB_SERIAL_GARMIN_MODULE: u32 = 1;
pub const CONFIG_W1_MASTER_GPIO_MODULE: u32 = 1;
pub const CONFIG_MTD_ESB2ROM_MODULE: u32 = 1;
pub const CONFIG_XFS_QUOTA: u32 = 1;
pub const CONFIG_COMEDI_ISA_DRIVERS: u32 = 1;
pub const CONFIG_JOYSTICK_QWIIC_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_COBRA_MODULE: u32 = 1;
pub const CONFIG_ATH10K_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SMACK: u32 = 1;
pub const CONFIG_F2FS_UNFAIR_RWSEM: u32 = 1;
pub const CONFIG_DRM_AMDGPU_CIK: u32 = 1;
pub const CONFIG_WINBOND_840_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS42L42_SDW_MODULE: u32 = 1;
pub const CONFIG_GPIO_VIRTIO_MODULE: u32 = 1;
pub const CONFIG_ACPI_VIOT: u32 = 1;
pub const CONFIG_REGULATOR_MAX77857_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP_SPI_MODULE: u32 = 1;
pub const CONFIG_TI_TLC4541_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_INLINE_CRYPTO: u32 = 1;
pub const CONFIG_SCSI_3W_9XXX_MODULE: u32 = 1;
pub const CONFIG_DRM_TTM_HELPER_MODULE: u32 = 1;
pub const CONFIG_HSA_AMD_SVM: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN: u32 = 8;
pub const CONFIG_VIDEO_KS0127_MODULE: u32 = 1;
pub const CONFIG_MVMDIO_MODULE: u32 = 1;
pub const CONFIG_NVME_TCP_TLS: u32 = 1;
pub const CONFIG_HWLAT_TRACER: u32 = 1;
pub const CONFIG_CRYPTO_LIB_UTILS: u32 = 1;
pub const CONFIG_HID_BPF: u32 = 1;
pub const CONFIG_SENSORS_IRPS5401_MODULE: u32 = 1;
pub const CONFIG_SND_USB: u32 = 1;
pub const CONFIG_LOGIG940_FF: u32 = 1;
pub const CONFIG_PCIE_EDR: u32 = 1;
pub const CONFIG_VIDEOBUF2_MEMOPS_MODULE: u32 = 1;
pub const CONFIG_CEC_SECO_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS3232_HWMON: u32 = 1;
pub const CONFIG_RD_GZIP: u32 = 1;
pub const CONFIG_CRYPTO_DEV_SAFEXCEL_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_E2I: u32 = 1;
pub const CONFIG_ARCH_HAS_CPU_RELAX: u32 = 1;
pub const CONFIG_HAVE_REGS_AND_STACK_ACCESS_API: u32 = 1;
pub const CONFIG_BLK_PM: u32 = 1;
pub const CONFIG_BCMA_HOST_PCI_POSSIBLE: u32 = 1;
pub const CONFIG_SND_SOC_TFA9879_MODULE: u32 = 1;
pub const CONFIG_BLK_CGROUP_IOPRIO: u32 = 1;
pub const CONFIG_CRYPTO_ARCH_HAVE_LIB_POLY1305_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LTC4261_MODULE: u32 = 1;
pub const CONFIG_MMC_SDRICOH_CS_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADV_PCI1720_MODULE: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_PARANOID_LOAD: u32 = 1;
pub const CONFIG_MISDN_W6692_MODULE: u32 = 1;
pub const CONFIG_QCOM_PMIC_PDCHARGER_ULOG_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_MODULE: u32 = 1;
pub const CONFIG_THRUSTMASTER_FF: u32 = 1;
pub const CONFIG_MDIO_BUS: u32 = 1;
pub const CONFIG_TREE_RCU: u32 = 1;
pub const CONFIG_PWM_SYSFS: u32 = 1;
pub const CONFIG_TINYDRM_ILI9163_MODULE: u32 = 1;
pub const CONFIG_SOC_TI: u32 = 1;
pub const CONFIG_GNSS_MODULE: u32 = 1;
pub const CONFIG_ALLOW_DEV_COREDUMP: u32 = 1;
pub const CONFIG_ADXL313_MODULE: u32 = 1;
pub const CONFIG_CHARGER_MT6360_MODULE: u32 = 1;
pub const CONFIG_I2C_MUX_GPIO_MODULE: u32 = 1;
pub const CONFIG_SWIOTLB: u32 = 1;
pub const CONFIG_PLX_DMA_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_NAU8822_MODULE: u32 = 1;
pub const CONFIG_SND_USB_CAIAQ_MODULE: u32 = 1;
pub const CONFIG_USB_STORAGE_CYPRESS_ATACB_MODULE: u32 = 1;
pub const CONFIG_EXT4_FS_SECURITY: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_DUMMY_MODULE: u32 = 1;
pub const CONFIG_ATH9K_HWRNG: u32 = 1;
pub const CONFIG_LTC2983_MODULE: u32 = 1;
pub const CONFIG_GRO_CELLS: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_HASH_DEFAULT: u32 = 1;
pub const CONFIG_SCSI_MVUMI_MODULE: u32 = 1;
pub const CONFIG_DVB_S5H1432_MODULE: u32 = 1;
pub const CONFIG_NET_TEAM_MODE_ACTIVEBACKUP_MODULE: u32 = 1;
pub const CONFIG_9P_FS_SECURITY: u32 = 1;
pub const CONFIG_PCI_P2PDMA: u32 = 1;
pub const CONFIG_IR_XMP_DECODER_MODULE: u32 = 1;
pub const CONFIG_FW_LOADER_SYSFS: u32 = 1;
pub const CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN: u32 = 1;
pub const CONFIG_LV0104CS_MODULE: u32 = 1;
pub const CONFIG_BEFS_FS_MODULE: u32 = 1;
pub const CONFIG_SND_ALI5451_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_USER_MAD_MODULE: u32 = 1;
pub const CONFIG_ALIBABA_ENI_VDPA_MODULE: u32 = 1;
pub const CONFIG_GENERIC_ADC_THERMAL_MODULE: u32 = 1;
pub const CONFIG_RTW89_8852BE_MODULE: u32 = 1;
pub const CONFIG_HID_ROCCAT_MODULE: u32 = 1;
pub const CONFIG_F71808E_WDT_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_NETLINK_EVENTS: u32 = 1;
pub const CONFIG_HID_SENSOR_TEMP_MODULE: u32 = 1;
pub const CONFIG_MTD_HYPERBUS_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_MD5: u32 = 1;
pub const CONFIG_IMA_DEFAULT_TEMPLATE: &[u8; 7usize] = b"ima-ng\0";
pub const CONFIG_VIDEO_CS53L32A_MODULE: u32 = 1;
pub const CONFIG_IR_REDRAT3_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_VICAM_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_AD7879_SPI_MODULE: u32 = 1;
pub const CONFIG_TRANSPARENT_HUGEPAGE: u32 = 1;
pub const CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE: u32 = 1;
pub const CONFIG_VSOCKETS_LOOPBACK_MODULE: u32 = 1;
pub const CONFIG_USB_F_SS_LB_MODULE: u32 = 1;
pub const CONFIG_ISCSI_TCP_MODULE: u32 = 1;
pub const CONFIG_ATA_ACPI: u32 = 1;
pub const CONFIG_USB_PCI_AMD: u32 = 1;
pub const CONFIG_NET_SCH_SKBPRIO_MODULE: u32 = 1;
pub const CONFIG_PATA_ALI_MODULE: u32 = 1;
pub const CONFIG_X86_EXTENDED_PLATFORM: u32 = 1;
pub const CONFIG_SENSORS_MPQ7932_REGULATOR: u32 = 1;
pub const CONFIG_GPIO_JANZ_TTL_MODULE: u32 = 1;
pub const CONFIG_MAX30208_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_ATMEL_I2C_MODULE: u32 = 1;
pub const CONFIG_RTW88_8822CS_MODULE: u32 = 1;
pub const CONFIG_XEN_FRONT_PGDIR_SHBUF_MODULE: u32 = 1;
pub const CONFIG_P2SB: u32 = 1;
pub const CONFIG_USB_CHIPIDEA_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SOF_MAXIM_COMMON_MODULE: u32 = 1;
pub const CONFIG_MFD_WL1273_CORE_MODULE: u32 = 1;
pub const CONFIG_RT2800USB_RT53XX: u32 = 1;
pub const CONFIG_NET_VENDOR_CORTINA: u32 = 1;
pub const CONFIG_ADUX1020_MODULE: u32 = 1;
pub const CONFIG_NOA1305_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS35L41_SPI_MODULE: u32 = 1;
pub const CONFIG_DRM_XE_ENABLE_SCHEDTIMEOUT_LIMIT: u32 = 1;
pub const CONFIG_VIDEO_MGB4_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT715_SDCA_SDW_MODULE: u32 = 1;
pub const CONFIG_SND_ECHO3G_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_FC0011_MODULE: u32 = 1;
pub const CONFIG_ACPI_PROCESSOR: u32 = 1;
pub const CONFIG_DVB_TDA10023_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV9734_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TEA5767_MODULE: u32 = 1;
pub const CONFIG_BATMAN_ADV_MODULE: u32 = 1;
pub const CONFIG_ELFCORE: u32 = 1;
pub const CONFIG_REGULATOR_BD9571MWV_MODULE: u32 = 1;
pub const CONFIG_HIBERNATION_SNAPSHOT_DEV: u32 = 1;
pub const CONFIG_HAVE_KVM: u32 = 1;
pub const CONFIG_SND_FIREWIRE: u32 = 1;
pub const CONFIG_PAGE_POISONING: u32 = 1;
pub const CONFIG_VF610_DAC_MODULE: u32 = 1;
pub const CONFIG_EDAC_SKX_MODULE: u32 = 1;
pub const CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER: u32 = 1;
pub const CONFIG_COMEDI_PCMDA12_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_ACP3x_MODULE: u32 = 1;
pub const CONFIG_PCCARD_MODULE: u32 = 1;
pub const CONFIG_SYSFB: u32 = 1;
pub const CONFIG_HID_VIVALDI_COMMON_MODULE: u32 = 1;
pub const CONFIG_CPU_SRSO: u32 = 1;
pub const CONFIG_USB_GSPCA_OV519_MODULE: u32 = 1;
pub const CONFIG_DM_LOG_WRITES_MODULE: u32 = 1;
pub const CONFIG_BINFMT_ELF: u32 = 1;
pub const CONFIG_RTC_DRV_RX4581_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS4349_MODULE: u32 = 1;
pub const CONFIG_NET_CLS_FLOWER_MODULE: u32 = 1;
pub const CONFIG_SCSI_PROC_FS: u32 = 1;
pub const CONFIG_RMI4_F11: u32 = 1;
pub const CONFIG_I2C_HID_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS42L43_MODULE: u32 = 1;
pub const CONFIG_MD_RAID456_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_PCF50633_MODULE: u32 = 1;
pub const CONFIG_IIO_TRIGGER: u32 = 1;
pub const CONFIG_SENSORS_BEL_PFE_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_IFORCE_USB_MODULE: u32 = 1;
pub const CONFIG_SCHED_TRACER: u32 = 1;
pub const CONFIG_RTS5208_MODULE: u32 = 1;
pub const CONFIG_CICADA_PHY_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_STINGER_MODULE: u32 = 1;
pub const CONFIG_HAVE_PERF_REGS: u32 = 1;
pub const CONFIG_V4L2_ASYNC_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_DENVERTON_MODULE: u32 = 1;
pub const CONFIG_CIFS_DEBUG: u32 = 1;
pub const CONFIG_DRM_I915_USERFAULT_AUTOSUSPEND: u32 = 250;
pub const CONFIG_MEDIA_ANALOG_TV_SUPPORT: u32 = 1;
pub const CONFIG_IP_PIMSM_V1: u32 = 1;
pub const CONFIG_HAVE_KVM_MSI: u32 = 1;
pub const CONFIG_WATCH_QUEUE: u32 = 1;
pub const CONFIG_BMA400_MODULE: u32 = 1;
pub const CONFIG_BCACHE_MODULE: u32 = 1;
pub const CONFIG_INET6_AH_MODULE: u32 = 1;
pub const CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT: u32 = 1;
pub const CONFIG_SENSORS_MAX197_MODULE: u32 = 1;
pub const CONFIG_RAPIDIO_CHMAN_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_RT4831_MODULE: u32 = 1;
pub const CONFIG_SURFACE_AGGREGATOR_REGISTRY_MODULE: u32 = 1;
pub const CONFIG_TARGET_CORE_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_MSCC_FELIX_DSA_LIB_MODULE: u32 = 1;
pub const CONFIG_HID_XINMO_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_BNXT_RE_MODULE: u32 = 1;
pub const CONFIG_NFS_V4_SECURITY_LABEL: u32 = 1;
pub const CONFIG_USB_SERIAL_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX88_ALSA_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_ALTEON: u32 = 1;
pub const CONFIG_NFT_DUP_IPV4_MODULE: u32 = 1;
pub const CONFIG_SENSORS_GL518SM_MODULE: u32 = 1;
pub const CONFIG_MLX5_CORE_IPOIB: u32 = 1;
pub const CONFIG_IIO_ST_LSM9DS0_I2C_MODULE: u32 = 1;
pub const CONFIG_USB_MON_MODULE: u32 = 1;
pub const CONFIG_COMEDI_CB_PCIMDAS_MODULE: u32 = 1;
pub const CONFIG_NTB_IDT_MODULE: u32 = 1;
pub const CONFIG_VGASTATE_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_FIXED_VOLTAGE_MODULE: u32 = 1;
pub const CONFIG_INET_MPTCP_DIAG_MODULE: u32 = 1;
pub const CONFIG_LCD_L4F00242T03_MODULE: u32 = 1;
pub const CONFIG_XEN_PVCALLS_FRONTEND_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_RENESAS: u32 = 1;
pub const CONFIG_VIDEO_SAA717X_MODULE: u32 = 1;
pub const CONFIG_TCG_TIS_I2C_MODULE: u32 = 1;
pub const CONFIG_INTEL_LDMA: u32 = 1;
pub const CONFIG_VIDEO_ET8EK8_MODULE: u32 = 1;
pub const CONFIG_KEYS: u32 = 1;
pub const CONFIG_XEN_PV_SMP: u32 = 1;
pub const CONFIG_FXOS8700_I2C_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TPS6507X_MODULE: u32 = 1;
pub const CONFIG_BE2ISCSI_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_ETF_MODULE: u32 = 1;
pub const CONFIG_INET_XFRM_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_FM3130_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MAX9860_MODULE: u32 = 1;
pub const CONFIG_RMI4_2D_SENSOR: u32 = 1;
pub const CONFIG_ACPI_PROCESSOR_CSTATE: u32 = 1;
pub const CONFIG_TMP007_MODULE: u32 = 1;
pub const CONFIG_XEN_EFI: u32 = 1;
pub const CONFIG_IPMI_POWEROFF_MODULE: u32 = 1;
pub const CONFIG_FUN_CORE_MODULE: u32 = 1;
pub const CONFIG_SND_VMASTER: u32 = 1;
pub const CONFIG_NETFILTER_XT_MARK_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XTABLES_MODULE: u32 = 1;
pub const CONFIG_DRM_PANEL_ORIENTATION_QUIRKS: u32 = 1;
pub const CONFIG_IP_VS_LBLC_MODULE: u32 = 1;
pub const CONFIG_SYSTEM_BLACKLIST_KEYRING: u32 = 1;
pub const CONFIG_HAVE_KVM_IRQ_BYPASS: u32 = 1;
pub const CONFIG_BLK_DEV_NULL_BLK_MODULE: u32 = 1;
pub const CONFIG_DP83640_PHY_MODULE: u32 = 1;
pub const CONFIG_SOFTLOCKUP_DETECTOR: u32 = 1;
pub const CONFIG_NFC_PN533_I2C_MODULE: u32 = 1;
pub const CONFIG_USB_ISP1760_HCD: u32 = 1;
pub const CONFIG_MFD_AXP20X_I2C_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_OPERA1_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_AMD_COMMON_MODULE: u32 = 1;
pub const CONFIG_SENSORS_INSPUR_IPSPS_MODULE: u32 = 1;
pub const CONFIG_ROHM_BM1390_MODULE: u32 = 1;
pub const CONFIG_LEDS_PWM_MULTICOLOR_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ECHAINIV_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_AUDITSYSCALL: u32 = 1;
pub const CONFIG_LEDS_BD2802_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_MC13783_MODULE: u32 = 1;
pub const CONFIG_CXL_REGION: u32 = 1;
pub const CONFIG_VIDEO_CADENCE_CSI2TX_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_STOWAWAY_MODULE: u32 = 1;
pub const CONFIG_WILCO_EC_DEBUGFS_MODULE: u32 = 1;
pub const CONFIG_FB_RIVA_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_GOLDFISH_MODULE: u32 = 1;
pub const CONFIG_ATM_HE_MODULE: u32 = 1;
pub const CONFIG_BATTERY_UG3105_MODULE: u32 = 1;
pub const CONFIG_SPI_AX88796C_MODULE: u32 = 1;
pub const CONFIG_GNSS_SIRF_SERIAL_MODULE: u32 = 1;
pub const CONFIG_PCI_EPF_MHI_MODULE: u32 = 1;
pub const CONFIG_IPMI_SI_MODULE: u32 = 1;
pub const CONFIG_TI_ADS1015_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_PMEM_MODULE: u32 = 1;
pub const CONFIG_USB_STORAGE_DATAFAB_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT274_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_AF9005_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_MT6370_MODULE: u32 = 1;
pub const CONFIG_MFD_RC5T583: u32 = 1;
pub const CONFIG_TCP_CONG_VEGAS_MODULE: u32 = 1;
pub const CONFIG_LEDS_88PM860X_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_USER_API_HASH_MODULE: u32 = 1;
pub const CONFIG_SENSORS_PLI1209BC_REGULATOR: u32 = 1;
pub const CONFIG_SENSORS_IBMPEX_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_TAPRIO_MODULE: u32 = 1;
pub const CONFIG_BOOT_PRINTK_DELAY: u32 = 1;
pub const CONFIG_CHARGER_88PM860X_MODULE: u32 = 1;
pub const CONFIG_IWLMVM_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_COLIBRI_VF50_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADM1026_MODULE: u32 = 1;
pub const CONFIG_PATA_NINJA32_MODULE: u32 = 1;
pub const CONFIG_BARCO_P50_GPIO_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_RENOIR_MACH_MODULE: u32 = 1;
pub const CONFIG_IIO_MUX_MODULE: u32 = 1;
pub const CONFIG_NVIDIA_SHIELD_FF: u32 = 1;
pub const CONFIG_SENSORS_ADT7470_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_CCP_DD_MODULE: u32 = 1;
pub const CONFIG_PM_SLEEP_SMP: u32 = 1;
pub const CONFIG_SPI_PXA2XX_PCI_MODULE: u32 = 1;
pub const CONFIG_FB_PM3_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV7740_MODULE: u32 = 1;
pub const CONFIG_MT7663S_MODULE: u32 = 1;
pub const CONFIG_X86_16BIT: u32 = 1;
pub const CONFIG_CRYPTO_HW: u32 = 1;
pub const CONFIG_SND_SOC_RT715_SDW_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_GATE_MODULE: u32 = 1;
pub const CONFIG_USB_EG20T_MODULE: u32 = 1;
pub const CONFIG_USB_STORAGE_KARMA_MODULE: u32 = 1;
pub const CONFIG_TTPCI_EEPROM_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP4_SPI_MODULE: u32 = 1;
pub const CONFIG_NTB_PERF_MODULE: u32 = 1;
pub const CONFIG_SURFACE_KBD_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_INTEL_LNL_MODULE: u32 = 1;
pub const CONFIG_TEHUTI_MODULE: u32 = 1;
pub const CONFIG_PUNIT_ATOM_DEBUG_MODULE: u32 = 1;
pub const CONFIG_SIS900_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_MAGN_SPI_3AXIS_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_LPASS_VA_MACRO_MODULE: u32 = 1;
pub const CONFIG_TYPEC_MUX_PI3USB30532_MODULE: u32 = 1;
pub const CONFIG_PCSPKR_PLATFORM: u32 = 1;
pub const CONFIG_INFINIBAND_EFA_MODULE: u32 = 1;
pub const CONFIG_LEDS_LP3952_MODULE: u32 = 1;
pub const CONFIG_KFENCE_STRESS_TEST_FAULTS: u32 = 0;
pub const CONFIG_NET_DSA_AR9331_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TPS68470_MODULE: u32 = 1;
pub const CONFIG_HAVE_LIVEPATCH: u32 = 1;
pub const CONFIG_MEGARAID_LEGACY_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_POLY1305_X86_64_MODULE: u32 = 1;
pub const CONFIG_DVB_AV7110_IR: u32 = 1;
pub const CONFIG_CARDBUS: u32 = 1;
pub const CONFIG_SPI_ALTERA_CORE_MODULE: u32 = 1;
pub const CONFIG_ATH9K_AHB: u32 = 1;
pub const CONFIG_SENSORS_BPA_RS600_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ISL29018_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_MICROCHIP_KSZ8863_SMI_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1307_CENTURY: u32 = 1;
pub const CONFIG_IIO_SSP_SENSORHUB_MODULE: u32 = 1;
pub const CONFIG_HID_GREENASIA_MODULE: u32 = 1;
pub const CONFIG_CHARGER_MAX77976_MODULE: u32 = 1;
pub const CONFIG_PROC_VMCORE_DEVICE_DUMP: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ILI210X_MODULE: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE_WITH_ARGS: u32 = 1;
pub const CONFIG_XEN_ACPI_PROCESSOR: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SKL_MODULE: u32 = 1;
pub const CONFIG_INTEGRITY_ASYMMETRIC_KEYS: u32 = 1;
pub const CONFIG_HWSPINLOCK: u32 = 1;
pub const CONFIG_SERIAL_RP2_NR_UARTS: u32 = 32;
pub const CONFIG_CACHEFILES_ERROR_INJECTION: u32 = 1;
pub const CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE: u32 = 438;
pub const CONFIG_BACKLIGHT_DA903X_MODULE: u32 = 1;
pub const CONFIG_CPU_IDLE_GOV_HALTPOLL: u32 = 1;
pub const CONFIG_KALLSYMS_ABSOLUTE_PERCPU: u32 = 1;
pub const CONFIG_INTEL_POWERCLAMP_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DEFAULT_BUF_SIZE_KB: u32 = 2048;
pub const CONFIG_CPU_IBRS_ENTRY: u32 = 1;
pub const CONFIG_NFC_ST21NFCA_I2C_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_ADP5520_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_FSL_ESAI_MODULE: u32 = 1;
pub const CONFIG_IIO_INV_SENSORS_TIMESTAMP_MODULE: u32 = 1;
pub const CONFIG_REMOTE_TARGET_MODULE: u32 = 1;
pub const CONFIG_SMS_USB_DRV_MODULE: u32 = 1;
pub const CONFIG_I2C_CP2615_MODULE: u32 = 1;
pub const CONFIG_ACPI_AC: u32 = 1;
pub const CONFIG_HARDIRQS_SW_RESEND: u32 = 1;
pub const CONFIG_TLS_MODULE: u32 = 1;
pub const CONFIG_ACPI_HOTPLUG_IOAPIC: u32 = 1;
pub const CONFIG_HID_STEELSERIES_MODULE: u32 = 1;
pub const CONFIG_JFFS2_FS_WRITEBUFFER: u32 = 1;
pub const CONFIG_BMI160_SPI_MODULE: u32 = 1;
pub const CONFIG_ADXL372_I2C_MODULE: u32 = 1;
pub const CONFIG_SPI_MASTER: u32 = 1;
pub const CONFIG_FB_TFT_RA8875_MODULE: u32 = 1;
pub const CONFIG_ATH12K_MODULE: u32 = 1;
pub const CONFIG_RUST_PHYLIB_ABSTRACTIONS: u32 = 1;
pub const CONFIG_USB_SERIAL_OPTICON_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CHV3_CODEC_MODULE: u32 = 1;
pub const CONFIG_RTL8180_MODULE: u32 = 1;
pub const CONFIG_DS4424_MODULE: u32 = 1;
pub const CONFIG_LWTUNNEL: u32 = 1;
pub const CONFIG_MLX5_VDPA_NET_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_AT86RF230_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_ARIZONA_MICSUPP_MODULE: u32 = 1;
pub const CONFIG_AD5504_MODULE: u32 = 1;
pub const CONFIG_REGMAP_SLIMBUS_MODULE: u32 = 1;
pub const CONFIG_SERIAL_SC16IS7XX_I2C: u32 = 1;
pub const CONFIG_DVB_TC90522_MODULE: u32 = 1;
pub const CONFIG_W1_MASTER_SGI_MODULE: u32 = 1;
pub const CONFIG_HID_CREATIVE_SB0540_MODULE: u32 = 1;
pub const CONFIG_DVB_NXT200X_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM87_MODULE: u32 = 1;
pub const CONFIG_PALMAS_GPADC_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_THROTTLING: u32 = 1;
pub const CONFIG_MHI_NET_MODULE: u32 = 1;
pub const CONFIG_VT_HW_CONSOLE_BINDING: u32 = 1;
pub const CONFIG_AIX_PARTITION: u32 = 1;
pub const CONFIG_GPIO_104_IDIO_16_MODULE: u32 = 1;
pub const CONFIG_NET_TEAM_MODE_BROADCAST_MODULE: u32 = 1;
pub const CONFIG_MPLS: u32 = 1;
pub const CONFIG_NF_TABLES_NETDEV: u32 = 1;
pub const CONFIG_CHARGER_SMB347_MODULE: u32 = 1;
pub const CONFIG_NFC_S3FWRN5_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TW9903_MODULE: u32 = 1;
pub const CONFIG_WFX_MODULE: u32 = 1;
pub const CONFIG_ATH9K_CHANNEL_CONTEXT: u32 = 1;
pub const CONFIG_NET_ACT_GACT_MODULE: u32 = 1;
pub const CONFIG_SLIP_MODE_SLIP6: u32 = 1;
pub const CONFIG_RTL8192E_MODULE: u32 = 1;
pub const CONFIG_HID_GYRATION_MODULE: u32 = 1;
pub const CONFIG_PA12203001_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ADP1653_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AK4642_MODULE: u32 = 1;
pub const CONFIG_GPIO_WHISKEY_COVE_MODULE: u32 = 1;
pub const CONFIG_SMPRO_MISC_MODULE: u32 = 1;
pub const CONFIG_SRAM: u32 = 1;
pub const CONFIG_USB_WDM_MODULE: u32 = 1;
pub const CONFIG_PATA_TOSHIBA_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBCM203X_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_WM8400_MODULE: u32 = 1;
pub const CONFIG_THERMAL_HWMON: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_COMPOSITE_MODULE: u32 = 1;
pub const CONFIG_DM_CLONE_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM186X_I2C_MODULE: u32 = 1;
pub const CONFIG_VIDEO_S5C73M3_MODULE: u32 = 1;
pub const CONFIG_RAVE_SP_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_I2C_MUX_PCA9541_MODULE: u32 = 1;
pub const CONFIG_MAX1363_MODULE: u32 = 1;
pub const CONFIG_SND_USB_HIFACE_MODULE: u32 = 1;
pub const CONFIG_VIDEO_EM28XX_DVB_MODULE: u32 = 1;
pub const CONFIG_LENOVO_YMC_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_KOBIL_SCT_MODULE: u32 = 1;
pub const CONFIG_HDLC_FR_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SKCIPHER: u32 = 1;
pub const CONFIG_USB_SERIAL_UPD78F0730_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_STREEBOG_MODULE: u32 = 1;
pub const CONFIG_FB_ATY128_BACKLIGHT: u32 = 1;
pub const CONFIG_USB_GSPCA_TOUPTEK_MODULE: u32 = 1;
pub const CONFIG_GENEVE_MODULE: u32 = 1;
pub const CONFIG_ZSWAP_COMPRESSOR_DEFAULT_LZO: u32 = 1;
pub const CONFIG_XZ_DEC_X86: u32 = 1;
pub const CONFIG_MFD_CS47L90: u32 = 1;
pub const CONFIG_MTD_RAW_NAND_MODULE: u32 = 1;
pub const CONFIG_VIRT_CPU_ACCOUNTING: u32 = 1;
pub const CONFIG_MLX5_INFINIBAND_MODULE: u32 = 1;
pub const CONFIG_RMI4_SPI_MODULE: u32 = 1;
pub const CONFIG_MAC80211_LEDS: u32 = 1;
pub const CONFIG_ARCH_HAS_CPU_FINALIZE_INIT: u32 = 1;
pub const CONFIG_INPUT_JOYDEV_MODULE: u32 = 1;
pub const CONFIG_FB_MATROX_MAVEN_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_QCOM_USB_VBUS_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV2685_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_LKKBD_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TPROXY_MODULE: u32 = 1;
pub const CONFIG_HIBERNATE_CALLBACKS: u32 = 1;
pub const CONFIG_MEN_Z188_ADC_MODULE: u32 = 1;
pub const CONFIG_LEDS_MC13783_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SOF_ES8336_MACH_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_DW_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS42L56_MODULE: u32 = 1;
pub const CONFIG_IP_DCCP_MODULE: u32 = 1;
pub const CONFIG_LIBIPW_MODULE: u32 = 1;
pub const CONFIG_FIREWIRE_OHCI_MODULE: u32 = 1;
pub const CONFIG_ATH10K_USB_MODULE: u32 = 1;
pub const CONFIG_EISA: u32 = 1;
pub const CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS: u32 = 0;
pub const CONFIG_CONSOLE_LOGLEVEL_QUIET: u32 = 3;
pub const CONFIG_USB_ACM_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADL_PCI9118_MODULE: u32 = 1;
pub const CONFIG_USB_RTL8150_MODULE: u32 = 1;
pub const CONFIG_NVME_CORE_MODULE: u32 = 1;
pub const CONFIG_INTEL_TURBO_MAX_3: u32 = 1;
pub const CONFIG_GPIO_MAX7300_MODULE: u32 = 1;
pub const CONFIG_USB_MSI2500_MODULE: u32 = 1;
pub const CONFIG_TI_DAC7612_MODULE: u32 = 1;
pub const CONFIG_CRC16: u32 = 1;
pub const CONFIG_BACKLIGHT_SKY81452_MODULE: u32 = 1;
pub const CONFIG_USB_NET_AX8817X_MODULE: u32 = 1;
pub const CONFIG_SND_EMU10K1_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CALIBRATE_DELAY: u32 = 1;
pub const CONFIG_DM_EBS_MODULE: u32 = 1;
pub const CONFIG_UPROBE_EVENTS: u32 = 1;
pub const CONFIG_NLS_ISO8859_6_MODULE: u32 = 1;
pub const CONFIG_NET_CLS: u32 = 1;
pub const CONFIG_ADF4350_MODULE: u32 = 1;
pub const CONFIG_DEVTMPFS_SAFE: u32 = 1;
pub const CONFIG_XFS_RT: u32 = 1;
pub const CONFIG_MAX31865_MODULE: u32 = 1;
pub const CONFIG_SI7005_MODULE: u32 = 1;
pub const CONFIG_COMEDI_S626_MODULE: u32 = 1;
pub const CONFIG_SND_INDIGO_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM1789_I2C_MODULE: u32 = 1;
pub const CONFIG_ICE_SWITCHDEV: u32 = 1;
pub const CONFIG_AX25_MODULE: u32 = 1;
pub const CONFIG_NVME_HOST_AUTH: u32 = 1;
pub const CONFIG_AD7293_MODULE: u32 = 1;
pub const CONFIG_SND_YMFPCI_MODULE: u32 = 1;
pub const CONFIG_TMPFS: u32 = 1;
pub const CONFIG_MFD_LM3533_MODULE: u32 = 1;
pub const CONFIG_HP206C_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8731_SPI_MODULE: u32 = 1;
pub const CONFIG_LEDS_TPS6105X_MODULE: u32 = 1;
pub const CONFIG_NFT_CT_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TAS2781_FMWLIB_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_NETERION: u32 = 1;
pub const CONFIG_CADENCE_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_RANDSTRUCT_NONE: u32 = 1;
pub const CONFIG_USB_OHCI_HCD_PLATFORM: u32 = 1;
pub const CONFIG_SND_SOC_WM8711_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_EARLY_DEBUG: u32 = 1;
pub const CONFIG_VIDEO_EM28XX_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_936_MODULE: u32 = 1;
pub const CONFIG_HAMACHI_MODULE: u32 = 1;
pub const CONFIG_ET131X_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SSM2518_MODULE: u32 = 1;
pub const CONFIG_IR_ITE_CIR_MODULE: u32 = 1;
pub const CONFIG_WCN36XX_MODULE: u32 = 1;
pub const CONFIG_FPGA_REGION_MODULE: u32 = 1;
pub const CONFIG_DVB_BUDGET_MODULE: u32 = 1;
pub const CONFIG_FUTEX: u32 = 1;
pub const CONFIG_IP_VS_MH_TAB_INDEX: u32 = 12;
pub const CONFIG_COMEDI_NI_AT_A2150_MODULE: u32 = 1;
pub const CONFIG_DRM_VRAM_HELPER_MODULE: u32 = 1;
pub const CONFIG_GENERIC_PHY_MIPI_DPHY: u32 = 1;
pub const CONFIG_COMEDI_NI_LABPC_ISA_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_HX8357D_MODULE: u32 = 1;
pub const CONFIG_SND_BCM63XX_I2S_WHISTLER_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_PCI: u32 = 1;
pub const CONFIG_TCP_CONG_NV_MODULE: u32 = 1;
pub const CONFIG_HID_SENSOR_ALS_MODULE: u32 = 1;
pub const CONFIG_UNIX_SCM: u32 = 1;
pub const CONFIG_MCP320X_MODULE: u32 = 1;
pub const CONFIG_MISDN_HFCMULTI_MODULE: u32 = 1;
pub const CONFIG_MMC_SPI_MODULE: u32 = 1;
pub const CONFIG_CONSOLE_LOGLEVEL_DEFAULT: u32 = 7;
pub const CONFIG_QCOM_HIDMA_MODULE: u32 = 1;
pub const CONFIG_VIDEO_HI847_MODULE: u32 = 1;
pub const CONFIG_MWAVE_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_3C574_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SQ930X_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TAS2764_MODULE: u32 = 1;
pub const CONFIG_RTL8192SE_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_CATPT_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_SPACEBALL_MODULE: u32 = 1;
pub const CONFIG_REGMAP_I2C: u32 = 1;
pub const CONFIG_AD5449_MODULE: u32 = 1;
pub const CONFIG_ZPA2326_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_FAST_MULTIPLIER: u32 = 1;
pub const CONFIG_TOUCHSCREEN_HYCON_HY46XX_MODULE: u32 = 1;
pub const CONFIG_INPUT_MATRIXKMAP_MODULE: u32 = 1;
pub const CONFIG_ATH9K_DEBUGFS: u32 = 1;
pub const CONFIG_MFD_BCM590XX_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_MSCC_SEVILLE_MODULE: u32 = 1;
pub const CONFIG_DVB_CXD2099_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_REALTEK: u32 = 1;
pub const CONFIG_VIDEO_VIVID_CEC: u32 = 1;
pub const CONFIG_MFD_SM501_GPIO: u32 = 1;
pub const CONFIG_DVB_DM1105_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG: u32 = 1;
pub const CONFIG_MFD_RDC321X_MODULE: u32 = 1;
pub const CONFIG_AD5421_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_XPAD_FF: u32 = 1;
pub const CONFIG_COMMON_CLK_SI544_MODULE: u32 = 1;
pub const CONFIG_SCSI_AHA1740_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_HL_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_LP8788_MODULE: u32 = 1;
pub const CONFIG_MEGARAID_SAS_MODULE: u32 = 1;
pub const CONFIG_MT792x_LIB_MODULE: u32 = 1;
pub const CONFIG_PATA_HPT3X2N_MODULE: u32 = 1;
pub const CONFIG_INTEL_TH_MODULE: u32 = 1;
pub const CONFIG_DVB_CORE_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ME_DAQ_MODULE: u32 = 1;
pub const CONFIG_SDR_PLATFORM_DRIVERS: u32 = 1;
pub const CONFIG_CAN_JANZ_ICAN3_MODULE: u32 = 1;
pub const CONFIG_USB_NET2280_MODULE: u32 = 1;
pub const CONFIG_ISL29003_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_USER_API_MODULE: u32 = 1;
pub const CONFIG_RTC_HCTOSYS: u32 = 1;
pub const CONFIG_I2C_OCORES_MODULE: u32 = 1;
pub const CONFIG_NAU7802_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_CAPTURE_ERROR: u32 = 1;
pub const CONFIG_SECURITY_NETWORK: u32 = 1;
pub const CONFIG_SND_SOC_SOF_INTEL_HIFI_EP_IPC_MODULE: u32 = 1;
pub const CONFIG_MFD_MAX77541_MODULE: u32 = 1;
pub const CONFIG_DRM_VBOXVIDEO_MODULE: u32 = 1;
pub const CONFIG_SENSORS_NZXT_SMART2_MODULE: u32 = 1;
pub const CONFIG_SERIAL_CORE_CONSOLE: u32 = 1;
pub const CONFIG_INTEL_XWAY_PHY_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_PCI_CPCI: u32 = 1;
pub const CONFIG_ACPI_CPPC_LIB: u32 = 1;
pub const CONFIG_HUGETLB_PAGE: u32 = 1;
pub const CONFIG_MTD_SM_COMMON_MODULE: u32 = 1;
pub const CONFIG_HW_RANDOM_TPM: u32 = 1;
pub const CONFIG_SENSORS_XGENE_MODULE: u32 = 1;
pub const CONFIG_DVB_SMIPCIE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MP2888_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_GUNZE_MODULE: u32 = 1;
pub const CONFIG_NFC_ST_NCI_SPI_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM78_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_EMULEX: u32 = 1;
pub const CONFIG_WIZNET_W5100_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LIB_POLY1305_MODULE: u32 = 1;
pub const CONFIG_REGMAP_IRQ: u32 = 1;
pub const CONFIG_SENSORS_K10TEMP_MODULE: u32 = 1;
pub const CONFIG_USB_HID_MODULE: u32 = 1;
pub const CONFIG_LD_ORPHAN_WARN_LEVEL: &[u8; 5usize] = b"warn\0";
pub const CONFIG_DVB_USB_AF9015_MODULE: u32 = 1;
pub const CONFIG_DELL_SMBIOS_MODULE: u32 = 1;
pub const CONFIG_FRAMER_MODULE: u32 = 1;
pub const CONFIG_ICE_HWTS: u32 = 1;
pub const CONFIG_FPGA_MODULE: u32 = 1;
pub const CONFIG_MLX5_EN_IPSEC: u32 = 1;
pub const CONFIG_SND_SOC_AMD_RV_RT5682_MACH_MODULE: u32 = 1;
pub const CONFIG_UBIFS_FS_MODULE: u32 = 1;
pub const CONFIG_DRM_AMDGPU_SI: u32 = 1;
pub const CONFIG_RTL8192CU_MODULE: u32 = 1;
pub const CONFIG_ATM_DRIVERS: u32 = 1;
pub const CONFIG_MELLANOX_PLATFORM: u32 = 1;
pub const CONFIG_BLK_DEV_RBD_MODULE: u32 = 1;
pub const CONFIG_SENSORS_HMC5843_MODULE: u32 = 1;
pub const CONFIG_SERIO_PS2MULT_MODULE: u32 = 1;
pub const CONFIG_VSOCKETS_DIAG_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TPS6105X_MODULE: u32 = 1;
pub const CONFIG_USER_STACKTRACE_SUPPORT: u32 = 1;
pub const CONFIG_CAN_UCAN_MODULE: u32 = 1;
pub const CONFIG_MEGARAID_MAILBOX_MODULE: u32 = 1;
pub const CONFIG_NF_TABLES_MODULE: u32 = 1;
pub const CONFIG_BATMAN_ADV_MCAST: u32 = 1;
pub const CONFIG_SLUB_DEBUG: u32 = 1;
pub const CONFIG_TYPEC_WUSB3801_MODULE: u32 = 1;
pub const CONFIG_IT8712F_WDT_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_M41T80_WDT: u32 = 1;
pub const CONFIG_OBJAGG_MODULE: u32 = 1;
pub const CONFIG_WIZNET_W5300_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_670X_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_MD: u32 = 1;
pub const CONFIG_UCS2_STRING: u32 = 1;
pub const CONFIG_SENSEAIR_SUNRISE_CO2_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TAS5805M_MODULE: u32 = 1;
pub const CONFIG_MMC_VUB300_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_AIRCABLE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_PIM4328_MODULE: u32 = 1;
pub const CONFIG_IP_SET_BITMAP_IP_MODULE: u32 = 1;
pub const CONFIG_FIELDBUS_DEV_MODULE: u32 = 1;
pub const CONFIG_GPIO_VX855_MODULE: u32 = 1;
pub const CONFIG_MAC_EMUMOUSEBTN_MODULE: u32 = 1;
pub const CONFIG_RAPIDIO_CPS_XX_MODULE: u32 = 1;
pub const CONFIG_WQ_CPU_INTENSIVE_REPORT: u32 = 1;
pub const CONFIG_MMC_MTK_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8978_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_CZ_DA7219MX98357_MACH_MODULE: u32 = 1;
pub const CONFIG_IMA_APPRAISE_MODSIG: u32 = 1;
pub const CONFIG_ANON_VMA_NAME: u32 = 1;
pub const CONFIG_BNXT_DCB: u32 = 1;
pub const CONFIG_HIST_TRIGGERS: u32 = 1;
pub const CONFIG_MTD_SBC_GXX_MODULE: u32 = 1;
pub const CONFIG_NFC_NCI_SPI_MODULE: u32 = 1;
pub const CONFIG_USB_F_RNDIS_MODULE: u32 = 1;
pub const CONFIG_ACPI_FPDT: u32 = 1;
pub const CONFIG_NET_SCH_INGRESS_MODULE: u32 = 1;
pub const CONFIG_BCMA_MODULE: u32 = 1;
pub const CONFIG_DMADEVICES: u32 = 1;
pub const CONFIG_XENFS_MODULE: u32 = 1;
pub const CONFIG_AXP288_CHARGER_MODULE: u32 = 1;
pub const CONFIG_SCA3000_MODULE: u32 = 1;
pub const CONFIG_ATH10K_SDIO_MODULE: u32 = 1;
pub const CONFIG_CORTINA_PHY_MODULE: u32 = 1;
pub const CONFIG_SCSI_AACRAID_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_KBL_DA7219_MAX98927_MACH_MODULE: u32 = 1;
pub const CONFIG_VIDEO_AK7375_MODULE: u32 = 1;
pub const CONFIG_MISDN_HFCUSB_MODULE: u32 = 1;
pub const CONFIG_ACPI_APEI_MEMORY_FAILURE: u32 = 1;
pub const CONFIG_PAHOLE_VERSION: u32 = 126;
pub const CONFIG_BACKLIGHT_LM3639_MODULE: u32 = 1;
pub const CONFIG_NCN26000_PHY_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_EVENTS: u32 = 1;
pub const CONFIG_MOUSE_PS2_ELANTECH: u32 = 1;
pub const CONFIG_DEBUG_INFO_DWARF5: u32 = 1;
pub const CONFIG_MFD_DA9062_MODULE: u32 = 1;
pub const CONFIG_PINCTRL: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_CFI_CLANG: u32 = 1;
pub const CONFIG_HID_SENSOR_DEVICE_ROTATION_MODULE: u32 = 1;
pub const CONFIG_IPV6_NDISC_NODETYPE: u32 = 1;
pub const CONFIG_HFS_FS_MODULE: u32 = 1;
pub const CONFIG_PATA_PARPORT_EPAT_MODULE: u32 = 1;
pub const CONFIG_RTW89_8852C_MODULE: u32 = 1;
pub const CONFIG_INTEL_VBTN_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8985_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MSM6242_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_TECHNISAT_USB2_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX6620_MODULE: u32 = 1;
pub const CONFIG_PCI_LABEL: u32 = 1;
pub const CONFIG_CRYPTO_ARCH_HAVE_LIB_BLAKE2S: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_1251_MODULE: u32 = 1;
pub const CONFIG_USB_F_MIDI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS35L41_MODULE: u32 = 1;
pub const CONFIG_EDAC_X38_MODULE: u32 = 1;
pub const CONFIG_FANOTIFY: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MXL301RF_MODULE: u32 = 1;
pub const CONFIG_SPI_BUTTERFLY_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_ACP5x_MODULE: u32 = 1;
pub const CONFIG_HAVE_OBJTOOL_MCOUNT: u32 = 1;
pub const CONFIG_SONYPI_COMPAT: u32 = 1;
pub const CONFIG_IP_VS_PROTO_SCTP: u32 = 1;
pub const CONFIG_SP5100_TCO_MODULE: u32 = 1;
pub const CONFIG_WIL6210_DEBUGFS: u32 = 1;
pub const CONFIG_GREYBUS_PWM_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNLABEL_MODULE: u32 = 1;
pub const CONFIG_ARCH_WANT_DEFAULT_BPF_JIT: u32 = 1;
pub const CONFIG_SGETMASK_SYSCALL: u32 = 1;
pub const CONFIG_AD5696_I2C_MODULE: u32 = 1;
pub const CONFIG_SATA_SIL_MODULE: u32 = 1;
pub const CONFIG_ALTERA_STAPL_MODULE: u32 = 1;
pub const CONFIG_USERFAULTFD: u32 = 1;
pub const CONFIG_CGROUP_SCHED: u32 = 1;
pub const CONFIG_SND_HDA_RECONFIG: u32 = 1;
pub const CONFIG_VIDEO_ADV7842_MODULE: u32 = 1;
pub const CONFIG_QUEUED_RWLOCKS: u32 = 1;
pub const CONFIG_SYSVIPC: u32 = 1;
pub const CONFIG_COMEDI_NI_LABPC_CS_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS250X_MODULE: u32 = 1;
pub const CONFIG_RAID6_PQ_BENCHMARK: u32 = 1;
pub const CONFIG_ARCH_HAS_GIGANTIC_PAGE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_ECM_SUBSET: u32 = 1;
pub const CONFIG_MTD_UBI_BLOCK: u32 = 1;
pub const CONFIG_HAVE_DEBUG_KMEMLEAK: u32 = 1;
pub const CONFIG_JOYSTICK_INTERACT_MODULE: u32 = 1;
pub const CONFIG_SMSC911X_MODULE: u32 = 1;
pub const CONFIG_GPIO_MAX3191X_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DT282X_MODULE: u32 = 1;
pub const CONFIG_DVB_TDA10071_MODULE: u32 = 1;
pub const CONFIG_HDLC_CISCO_MODULE: u32 = 1;
pub const CONFIG_SQUASHFS_ZSTD: u32 = 1;
pub const CONFIG_MLX4_INFINIBAND_MODULE: u32 = 1;
pub const CONFIG_DVB_OR51211_MODULE: u32 = 1;
pub const CONFIG_RT2X00_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_863_MODULE: u32 = 1;
pub const CONFIG_SND_DESIGNWARE_I2S_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADT7X10_MODULE: u32 = 1;
pub const CONFIG_USB_G_HID_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_GPIO_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_FTP_MODULE: u32 = 1;
pub const CONFIG_PAGE_SIZE_LESS_THAN_64KB: u32 = 1;
pub const CONFIG_FPGA_BRIDGE_MODULE: u32 = 1;
pub const CONFIG_NFC_MRVL_UART_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_T4_MODULE: u32 = 1;
pub const CONFIG_MODULES: u32 = 1;
pub const CONFIG_RPMSG_MODULE: u32 = 1;
pub const CONFIG_IP_NF_MATCH_ECN_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_PHONET: u32 = 1;
pub const CONFIG_ADVANTECH_EC_WDT_MODULE: u32 = 1;
pub const CONFIG_DWC_XLGMAC_MODULE: u32 = 1;
pub const CONFIG_IFCVF_MODULE: u32 = 1;
pub const CONFIG_VIDEO_IMX219_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MAX8660_MODULE: u32 = 1;
pub const CONFIG_USB_GADGET_MODULE: u32 = 1;
pub const CONFIG_FB_IMSTT: u32 = 1;
pub const CONFIG_USB_GSPCA_SPCA506_MODULE: u32 = 1;
pub const CONFIG_CHROMEOS_PRIVACY_SCREEN_MODULE: u32 = 1;
pub const CONFIG_CAN_CC770_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_PATA_ARTOP_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_NEWTON_MODULE: u32 = 1;
pub const CONFIG_CONTEXT_TRACKING: u32 = 1;
pub const CONFIG_HARDLOCKUP_DETECTOR: u32 = 1;
pub const CONFIG_VIDEO_CX88_DVB_MODULE: u32 = 1;
pub const CONFIG_GPIO_DA9055_MODULE: u32 = 1;
pub const CONFIG_ISL76682_MODULE: u32 = 1;
pub const CONFIG_MQ_IOSCHED_DEADLINE: u32 = 1;
pub const CONFIG_VIDEO_EM28XX_ALSA_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MXL5005S_MODULE: u32 = 1;
pub const CONFIG_INPUT_TWL4030_VIBRA_MODULE: u32 = 1;
pub const CONFIG_USB_HIDDEV: u32 = 1;
pub const CONFIG_IOMMU_IOVA: u32 = 1;
pub const CONFIG_INFINIBAND_IPOIB_MODULE: u32 = 1;
pub const CONFIG_TYPEC_MUX_INTEL_PMC_MODULE: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE_COLUMNS: u32 = 80;
pub const CONFIG_SENSORS_APDS990X_MODULE: u32 = 1;
pub const CONFIG_USB_ETH_RNDIS: u32 = 1;
pub const CONFIG_AD7606_IFACE_PARALLEL_MODULE: u32 = 1;
pub const CONFIG_DVB_SI21XX_MODULE: u32 = 1;
pub const CONFIG_XXHASH: u32 = 1;
pub const CONFIG_PATA_WINBOND_MODULE: u32 = 1;
pub const CONFIG_ACPI_THERMAL_LIB: u32 = 1;
pub const CONFIG_SOUND_MODULE: u32 = 1;
pub const CONFIG_NFT_MASQ_MODULE: u32 = 1;
pub const CONFIG_COMEDI_RTI802_MODULE: u32 = 1;
pub const CONFIG_SPS30_MODULE: u32 = 1;
pub const CONFIG_NFT_QUOTA_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_AUO_PIXCIR_MODULE: u32 = 1;
pub const CONFIG_JOLIET: u32 = 1;
pub const CONFIG_SERIAL_SC16IS7XX_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_VP7045_MODULE: u32 = 1;
pub const CONFIG_USB_NET2272_DMA: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SOF_NUVOTON_COMMON_MODULE: u32 = 1;
pub const CONFIG_RTW88_8821C_MODULE: u32 = 1;
pub const CONFIG_SCHED_CORE: u32 = 1;
pub const CONFIG_KPROBES_ON_FTRACE: u32 = 1;
pub const CONFIG_BNX2X_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TDA9887_MODULE: u32 = 1;
pub const CONFIG_ADVANTECH_WDT_MODULE: u32 = 1;
pub const CONFIG_NFC_PN532_UART_MODULE: u32 = 1;
pub const CONFIG_PVPANIC_PCI_MODULE: u32 = 1;
pub const CONFIG_AD5624R_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_LEGACY_MACH_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_LUNARLAKE_MODULE: u32 = 1;
pub const CONFIG_ARCH_HIBERNATION_POSSIBLE: u32 = 1;
pub const CONFIG_SND_SOC_SI476X_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_LME2510_MODULE: u32 = 1;
pub const CONFIG_ARCH_USE_SYM_ANNOTATIONS: u32 = 1;
pub const CONFIG_PROC_CHILDREN: u32 = 1;
pub const CONFIG_PDC_ADMA_MODULE: u32 = 1;
pub const CONFIG_IA32_FEAT_CTL: u32 = 1;
pub const CONFIG_SND_VXPOCKET_MODULE: u32 = 1;
pub const CONFIG_ADIN1110_MODULE: u32 = 1;
pub const CONFIG_SND_USB_LINE6_MODULE: u32 = 1;
pub const CONFIG_UNIX: u32 = 1;
pub const CONFIG_USB_CATC_MODULE: u32 = 1;
pub const CONFIG_USB_NET_DRIVERS_MODULE: u32 = 1;
pub const CONFIG_FPGA_DFL_PCI_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CADENCE_CSI2RX_MODULE: u32 = 1;
pub const CONFIG_CC_CAN_LINK: u32 = 1;
pub const CONFIG_QNX6FS_FS_MODULE: u32 = 1;
pub const CONFIG_NVSW_SN2201_MODULE: u32 = 1;
pub const CONFIG_SCSI_FDOMAIN_PCI_MODULE: u32 = 1;
pub const CONFIG_LD_IS_BFD: u32 = 1;
pub const CONFIG_AXP20X_POWER_MODULE: u32 = 1;
pub const CONFIG_SQUASHFS_DECOMP_MULTI: u32 = 1;
pub const CONFIG_NO_HZ_COMMON: u32 = 1;
pub const CONFIG_MINIX_FS_MODULE: u32 = 1;
pub const CONFIG_RCU_LAZY_DEFAULT_OFF: u32 = 1;
pub const CONFIG_DRM_MIPI_DSI: u32 = 1;
pub const CONFIG_BRCMSMAC_MODULE: u32 = 1;
pub const CONFIG_XEN_DEV_EVTCHN_MODULE: u32 = 1;
pub const CONFIG_HAVE_CLK: u32 = 1;
pub const CONFIG_CRYPTO_HASH2: u32 = 1;
pub const CONFIG_MMC_SDHCI_F_SDH30_MODULE: u32 = 1;
pub const CONFIG_CARL9170_MODULE: u32 = 1;
pub const CONFIG_LEDS_CLASS_MULTICOLOR_MODULE: u32 = 1;
pub const CONFIG_DW_EDMA_PCIE_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_CONEXANT_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_VERTEXCOM: u32 = 1;
pub const CONFIG_RMI4_F54: u32 = 1;
pub const CONFIG_SND_SOC_SOF_ICELAKE_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LZ4HC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT1015_MODULE: u32 = 1;
pub const CONFIG_DVB_CX24117_MODULE: u32 = 1;
pub const CONFIG_THERMAL_GOV_STEP_WISE: u32 = 1;
pub const CONFIG_SND_RME9652_MODULE: u32 = 1;
pub const CONFIG_MTD_ABSENT_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBTUSB_POLL_SYNC: u32 = 1;
pub const CONFIG_IMA_DEFAULT_HASH_SHA256: u32 = 1;
pub const CONFIG_TOUCHSCREEN_88PM860X_MODULE: u32 = 1;
pub const CONFIG_DEFAULT_HOSTNAME: &[u8; 7usize] = b"(none)\0";
pub const CONFIG_COMMON_CLK_SI5351_MODULE: u32 = 1;
pub const CONFIG_NLS_KOI8_R_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADT7410_MODULE: u32 = 1;
pub const CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS: u32 = 2;
pub const CONFIG_THUNDER_NIC_VF_MODULE: u32 = 1;
pub const CONFIG_CC_HAS_NO_PROFILE_FN_ATTR: u32 = 1;
pub const CONFIG_IP_SET_HASH_NETPORTNET_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SONIXB_MODULE: u32 = 1;
pub const CONFIG_CAN_RX_OFFLOAD: u32 = 1;
pub const CONFIG_DVB_USB_RTL28XXU_MODULE: u32 = 1;
pub const CONFIG_DRM_ANALOGIX_DP_MODULE: u32 = 1;
pub const CONFIG_MMC_REALTEK_PCI_MODULE: u32 = 1;
pub const CONFIG_USB_STORAGE_ISD200_MODULE: u32 = 1;
pub const CONFIG_MCP4821_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_POWERSAVE: u32 = 1;
pub const CONFIG_REGULATOR_RT5120_MODULE: u32 = 1;
pub const CONFIG_SEL3350_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_OV534_9_MODULE: u32 = 1;
pub const CONFIG_RIONET_MODULE: u32 = 1;
pub const CONFIG_NFS_FS_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_TWOFISH_X86_64_MODULE: u32 = 1;
pub const CONFIG_MEDIA_SUPPORT_FILTER: u32 = 1;
pub const CONFIG_USB_NET_SMSC95XX_MODULE: u32 = 1;
pub const CONFIG_CRASH_DUMP: u32 = 1;
pub const CONFIG_MEMBARRIER: u32 = 1;
pub const CONFIG_FB_SM712_MODULE: u32 = 1;
pub const CONFIG_CEC_CORE_MODULE: u32 = 1;
pub const CONFIG_MLX_WDT_MODULE: u32 = 1;
pub const CONFIG_AMD_SFH_HID_MODULE: u32 = 1;
pub const CONFIG_LEDS_LM3533_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_ADDR_TRANS: u32 = 1;
pub const CONFIG_BLK_DEV_IO_TRACE: u32 = 1;
pub const CONFIG_CROS_EC_TYPEC_MODULE: u32 = 1;
pub const CONFIG_UBSAN_BOUNDS_STRICT: u32 = 1;
pub const CONFIG_XPS: u32 = 1;
pub const CONFIG_CRYPTO_DEV_QAT_DH895xCC_MODULE: u32 = 1;
pub const CONFIG_COMEDI_8255_PCI_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_SKBEDIT_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADV_PCI1723_MODULE: u32 = 1;
pub const CONFIG_INET_ESP_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_DEVELOP: u32 = 1;
pub const CONFIG_SGL_ALLOC: u32 = 1;
pub const CONFIG_AD7816_MODULE: u32 = 1;
pub const CONFIG_HPET_TIMER: u32 = 1;
pub const CONFIG_TSM_REPORTS_MODULE: u32 = 1;
pub const CONFIG_LCD_TDO24M_MODULE: u32 = 1;
pub const CONFIG_LZ4_DECOMPRESS: u32 = 1;
pub const CONFIG_INPUT_GPIO_BEEPER_MODULE: u32 = 1;
pub const CONFIG_NFC_HCI_MODULE: u32 = 1;
pub const CONFIG_GPIO_MAX732X_MODULE: u32 = 1;
pub const CONFIG_HSI_MODULE: u32 = 1;
pub const CONFIG_NF_TPROXY_IPV6_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_ZONES: u32 = 1;
pub const CONFIG_DP83848_PHY_MODULE: u32 = 1;
pub const CONFIG_EFI_RUNTIME_MAP: u32 = 1;
pub const CONFIG_AD5110_MODULE: u32 = 1;
pub const CONFIG_FONT_SUPPORT: u32 = 1;
pub const CONFIG_ADVISE_SYSCALLS: u32 = 1;
pub const CONFIG_MD: u32 = 1;
pub const CONFIG_CROS_EC_I2C_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ALGAPI: u32 = 1;
pub const CONFIG_CEC_PIN: u32 = 1;
pub const CONFIG_SENSORS_AAEON_MODULE: u32 = 1;
pub const CONFIG_FDDI: u32 = 1;
pub const CONFIG_IR_SERIAL_MODULE: u32 = 1;
pub const CONFIG_SENSORS_VT8231_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_CORE_SYNC: u32 = 1;
pub const CONFIG_DVB_BUDGET_CI_MODULE: u32 = 1;
pub const CONFIG_COMEDI_KE_COUNTER_MODULE: u32 = 1;
pub const CONFIG_EDAC_I3200_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WSA884X_MODULE: u32 = 1;
pub const CONFIG_RTW88_CORE_MODULE: u32 = 1;
pub const CONFIG_CEPH_FSCACHE: u32 = 1;
pub const CONFIG_INPUT_KXTJ9_MODULE: u32 = 1;
pub const CONFIG_CAN_ESD_USB_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ADV7604_MODULE: u32 = 1;
pub const CONFIG_DYNAMIC_PHYSICAL_MASK: u32 = 1;
pub const CONFIG_SND_SEQ_MIDI_EMUL_MODULE: u32 = 1;
pub const CONFIG_ZSWAP_ZPOOL_DEFAULT_ZBUD: u32 = 1;
pub const CONFIG_BSD_PROCESS_ACCT_V3: u32 = 1;
pub const CONFIG_DRM_I915_MAX_REQUEST_BUSYWAIT: u32 = 8000;
pub const CONFIG_MODULE_SIG_FORMAT: u32 = 1;
pub const CONFIG_SENSORS_PM6764TR_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_WIZNET: u32 = 1;
pub const CONFIG_SCSI_DMX3191D_MODULE: u32 = 1;
pub const CONFIG_FONTS: u32 = 1;
pub const CONFIG_MMC_ALCOR_MODULE: u32 = 1;
pub const CONFIG_USB_G_DBGP_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ADAU1372_I2C_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8731_I2C_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CGROUP_MODULE: u32 = 1;
pub const CONFIG_X86_USER_SHADOW_STACK: u32 = 1;
pub const CONFIG_AD2S90_MODULE: u32 = 1;
pub const CONFIG_MLXSW_I2C_MODULE: u32 = 1;
pub const CONFIG_USB_CYPRESS_CY7C63_MODULE: u32 = 1;
pub const CONFIG_IOMMU_SVA: u32 = 1;
pub const CONFIG_OPT3001_MODULE: u32 = 1;
pub const CONFIG_EEPROM_AT25_MODULE: u32 = 1;
pub const CONFIG_SCHED_MM_CID: u32 = 1;
pub const CONFIG_SERIAL_8250_MID: u32 = 1;
pub const CONFIG_RD_BZIP2: u32 = 1;
pub const CONFIG_REGULATOR_SLG51000_MODULE: u32 = 1;
pub const CONFIG_MFD_VIPERBOARD_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MAX98373_SDW_MODULE: u32 = 1;
pub const CONFIG_WANT_DEV_COREDUMP: u32 = 1;
pub const CONFIG_INPUT_UINPUT: u32 = 1;
pub const CONFIG_SERIAL_ARC_NR_PORTS: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CHECKSUM_MODULE: u32 = 1;
pub const CONFIG_CHARGER_TPS65090_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ADI_MODULE: u32 = 1;
pub const CONFIG_SOUNDWIRE_INTEL_MODULE: u32 = 1;
pub const CONFIG_UNWINDER_FRAME_POINTER: u32 = 1;
pub const CONFIG_SKB_EXTENSIONS: u32 = 1;
pub const CONFIG_PM_OPP: u32 = 1;
pub const CONFIG_IOSF_MBI_DEBUG: u32 = 1;
pub const CONFIG_POWER_RESET_RESTART: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_GPIO_MODULE: u32 = 1;
pub const CONFIG_RTLWIFI_USB_MODULE: u32 = 1;
pub const CONFIG_TCG_ATMEL_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_MSCC_OCELOT_EXT_MODULE: u32 = 1;
pub const CONFIG_TINYDRM_MI0283QT_MODULE: u32 = 1;
pub const CONFIG_GPIO_CDEV: u32 = 1;
pub const CONFIG_AFE4404_MODULE: u32 = 1;
pub const CONFIG_WPCM450_SOC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS35L56_SDW_MODULE: u32 = 1;
pub const CONFIG_DVB_MB86A16_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_SIMPLE_MODULE: u32 = 1;
pub const CONFIG_SND_OXYGEN_MODULE: u32 = 1;
pub const CONFIG_CC_VERSION_TEXT: &[u8; 45usize] =
    b"gcc (GCC) 14.2.1 20240912 (Red Hat 14.2.1-3)\0";
pub const CONFIG_KEYBOARD_ATKBD: u32 = 1;
pub const CONFIG_SCSI_QLA_ISCSI_MODULE: u32 = 1;
pub const CONFIG_CROS_EC_UART_MODULE: u32 = 1;
pub const CONFIG_NVMEM_RAVE_SP_EEPROM_MODULE: u32 = 1;
pub const CONFIG_AD5446_MODULE: u32 = 1;
pub const CONFIG_X86_PLATFORM_DEVICES: u32 = 1;
pub const CONFIG_IIO_ST_MAGN_I2C_3AXIS_MODULE: u32 = 1;
pub const CONFIG_LIBNVDIMM: u32 = 1;
pub const CONFIG_NET_IP_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_ADDR_TRANS_CONFIGFS: u32 = 1;
pub const CONFIG_WANXL_MODULE: u32 = 1;
pub const CONFIG_MTD_CFI_I1: u32 = 1;
pub const CONFIG_NF_NAT_MODULE: u32 = 1;
pub const CONFIG_LEDS_PWM_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2780_MODULE: u32 = 1;
pub const CONFIG_UBIFS_FS_ZLIB: u32 = 1;
pub const CONFIG_W83877F_WDT_MODULE: u32 = 1;
pub const CONFIG_WAFER_WDT_MODULE: u32 = 1;
pub const CONFIG_MTD_MCHP48L640_MODULE: u32 = 1;
pub const CONFIG_BLOCK_LEGACY_AUTOLOAD: u32 = 1;
pub const CONFIG_VIDEO_UPD64031A_MODULE: u32 = 1;
pub const CONFIG_SYSTEM_REVOCATION_KEYS: &[u8; 1usize] = b"\0";
pub const CONFIG_BATTERY_88PM860X_MODULE: u32 = 1;
pub const CONFIG_MCP3564_MODULE: u32 = 1;
pub const CONFIG_CHARGER_RT9467_MODULE: u32 = 1;
pub const CONFIG_CROS_EC_SPI_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_INTEGRITY: u32 = 1;
pub const CONFIG_DVB_USB_AZ6027_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_OKI: u32 = 1;
pub const CONFIG_MOUSE_BCM5974_MODULE: u32 = 1;
pub const CONFIG_CPU_IDLE: u32 = 1;
pub const CONFIG_SND_HDA_SCODEC_CS35L41_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_INTERSIL: u32 = 1;
pub const CONFIG_NTB_MODULE: u32 = 1;
pub const CONFIG_DRM_XE_TIMESLICE_MIN: u32 = 1;
pub const CONFIG_SENSORS_INTEL_M10_BMC_HWMON_MODULE: u32 = 1;
pub const CONFIG_BATTERY_RX51_MODULE: u32 = 1;
pub const CONFIG_NFC_ST21NFCA_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_RPFILTER_MODULE: u32 = 1;
pub const CONFIG_NF_TABLES_INET: u32 = 1;
pub const CONFIG_ATLAS_EZO_SENSOR_MODULE: u32 = 1;
pub const CONFIG_NFS_COMMON: u32 = 1;
pub const CONFIG_CHR_DEV_SCH_MODULE: u32 = 1;
pub const CONFIG_SENSORS_XDPE122_MODULE: u32 = 1;
pub const CONFIG_SPI_INTEL_PCI_MODULE: u32 = 1;
pub const CONFIG_6LOWPAN_NHC_IPV6_MODULE: u32 = 1;
pub const CONFIG_REGULATOR: u32 = 1;
pub const CONFIG_SND_SOC_MSM8916_WCD_DIGITAL_MODULE: u32 = 1;
pub const CONFIG_NF_TABLES_IPV6: u32 = 1;
pub const CONFIG_FAIR_GROUP_SCHED: u32 = 1;
pub const CONFIG_SENSORS_HIH6130_MODULE: u32 = 1;
pub const CONFIG_RT2800USB_MODULE: u32 = 1;
pub const CONFIG_HID_MACALLY_MODULE: u32 = 1;
pub const CONFIG_BATTERY_SBS_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_HASH: u32 = 1;
pub const CONFIG_HAVE_STACK_VALIDATION: u32 = 1;
pub const CONFIG_PSTORE_ZONE_MODULE: u32 = 1;
pub const CONFIG_AL3320A_MODULE: u32 = 1;
pub const CONFIG_DP83TG720_PHY_MODULE: u32 = 1;
pub const CONFIG_EFI_PARTITION: u32 = 1;
pub const CONFIG_PROBE_EVENTS: u32 = 1;
pub const CONFIG_SSB_PCMCIAHOST_POSSIBLE: u32 = 1;
pub const CONFIG_NETDEVSIM_MODULE: u32 = 1;
pub const CONFIG_TRACE_CLOCK: u32 = 1;
pub const CONFIG_VIDEO_OV5693_MODULE: u32 = 1;
pub const CONFIG_HID_STEAM_MODULE: u32 = 1;
pub const CONFIG_TCG_TIS_I2C_INFINEON_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_HDMI_MODULE: u32 = 1;
pub const CONFIG_BCMA_BLOCKIO: u32 = 1;
pub const CONFIG_MODULE_SIG_HASH: &[u8; 7usize] = b"sha512\0";
pub const CONFIG_TI_ADS7950_MODULE: u32 = 1;
pub const CONFIG_LOG_BUF_SHIFT: u32 = 18;
pub const CONFIG_PATA_IT8213_MODULE: u32 = 1;
pub const CONFIG_MEMORY_HOTREMOVE: u32 = 1;
pub const CONFIG_PM_NOTIFIER_ERROR_INJECT_MODULE: u32 = 1;
pub const CONFIG_RAPIDIO_CPS_GEN2_MODULE: u32 = 1;
pub const CONFIG_SND_CMIPCI_MODULE: u32 = 1;
pub const CONFIG_RTW88_USB_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ATH: u32 = 1;
pub const CONFIG_USB_RTL8153_ECM_MODULE: u32 = 1;
pub const CONFIG_ACPI_DEBUGGER_USER: u32 = 1;
pub const CONFIG_BH1750_MODULE: u32 = 1;
pub const CONFIG_HZ_1000: u32 = 1;
pub const CONFIG_NFP_NET_IPSEC: u32 = 1;
pub const CONFIG_HPET: u32 = 1;
pub const CONFIG_ACPI_WMI_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_857_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_DSCP_MODULE: u32 = 1;
pub const CONFIG_SND_EMU10K1X_MODULE: u32 = 1;
pub const CONFIG_EXTRA_FIRMWARE: &[u8; 1usize] = b"\0";
pub const CONFIG_NET_CLS_MATCHALL_MODULE: u32 = 1;
pub const CONFIG_TCG_TPM: u32 = 1;
pub const CONFIG_SND_SOC_SIMPLE_MUX_MODULE: u32 = 1;
pub const CONFIG_SPI_SLAVE_SYSTEM_CONTROL_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_8390: u32 = 1;
pub const CONFIG_MFD_WM5102: u32 = 1;
pub const CONFIG_MODULE_COMPRESS_ZSTD: u32 = 1;
pub const CONFIG_IPV6_MROUTE: u32 = 1;
pub const CONFIG_XEN_PCIDEV_BACKEND_MODULE: u32 = 1;
pub const CONFIG_PROC_EVENTS: u32 = 1;
pub const CONFIG_ACPI_VIDEO_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SHT3x_MODULE: u32 = 1;
pub const CONFIG_HAVE_KCSAN_COMPILER: u32 = 1;
pub const CONFIG_VFAT_FS: u32 = 1;
pub const CONFIG_MUSB_PIO_ONLY: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_ACPI: u32 = 1;
pub const CONFIG_IIO_ST_GYRO_SPI_3AXIS_MODULE: u32 = 1;
pub const CONFIG_NF_FLOW_TABLE_INET_MODULE: u32 = 1;
pub const CONFIG_PID_NS: u32 = 1;
pub const CONFIG_SND_SOC_DMIC_MODULE: u32 = 1;
pub const CONFIG_ST_UVIS25_MODULE: u32 = 1;
pub const CONFIG_MD_RAID1_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_2200_MODULE: u32 = 1;
pub const CONFIG_RTW88_8822B_MODULE: u32 = 1;
pub const CONFIG_BLK_CGROUP_IOCOST: u32 = 1;
pub const CONFIG_CRYPTO_VMAC_MODULE: u32 = 1;
pub const CONFIG_I2C_CHT_WC_MODULE: u32 = 1;
pub const CONFIG_PSI: u32 = 1;
pub const CONFIG_SENSORS_ACPI_POWER_MODULE: u32 = 1;
pub const CONFIG_KEXEC: u32 = 1;
pub const CONFIG_ACPI_CMPC_MODULE: u32 = 1;
pub const CONFIG_MEDIA_PLATFORM_DRIVERS: u32 = 1;
pub const CONFIG_IIO_CONFIGFS_MODULE: u32 = 1;
pub const CONFIG_RADIO_TEF6862_MODULE: u32 = 1;
pub const CONFIG_SPI_MUX_MODULE: u32 = 1;
pub const CONFIG_CRC32_SLICEBY8: u32 = 1;
pub const CONFIG_FB_DDC_MODULE: u32 = 1;
pub const CONFIG_MFD_DA9150_MODULE: u32 = 1;
pub const CONFIG_MT7921U_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DAS08_MODULE: u32 = 1;
pub const CONFIG_USB_LIBCOMPOSITE_MODULE: u32 = 1;
pub const CONFIG_SCSI_MPT2SAS_MODULE: u32 = 1;
pub const CONFIG_BMI323_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ADAU1761_I2C_MODULE: u32 = 1;
pub const CONFIG_HVC_XEN: u32 = 1;
pub const CONFIG_SLAB_FREELIST_HARDENED: u32 = 1;
pub const CONFIG_DPOT_DAC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WSA881X_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SM3_MODULE: u32 = 1;
pub const CONFIG_XILINX_VCU_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_WM9713: u32 = 1;
pub const CONFIG_FPGA_MGR_ALTERA_PS_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT1017_SDCA_SDW_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_FQ_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_HASWELL_MACH_MODULE: u32 = 1;
pub const CONFIG_FPGA_MGR_XILINX_SPI_MODULE: u32 = 1;
pub const CONFIG_VIDEO_HDPVR_MODULE: u32 = 1;
pub const CONFIG_XEN_SCRUB_PAGES_DEFAULT: u32 = 1;
pub const CONFIG_MFD_TPS65912: u32 = 1;
pub const CONFIG_ROMFS_ON_BLOCK: u32 = 1;
pub const CONFIG_EDAC_AMD64_MODULE: u32 = 1;
pub const CONFIG_NET_SB1000_MODULE: u32 = 1;
pub const CONFIG_MT7925E_MODULE: u32 = 1;
pub const CONFIG_GPIO_ARIZONA_MODULE: u32 = 1;
pub const CONFIG_HID_NVIDIA_SHIELD_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_SR: u32 = 1;
pub const CONFIG_CPU_RMAP: u32 = 1;
pub const CONFIG_SND_HWDEP_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_MP3309C_MODULE: u32 = 1;
pub const CONFIG_MODULE_SIG_SHA512: u32 = 1;
pub const CONFIG_SND_SOC_TAS2781_I2C_MODULE: u32 = 1;
pub const CONFIG_INTEL_TH_PTI_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CPU: u32 = 1;
pub const CONFIG_GENERIC_IRQ_MATRIX_ALLOCATOR: u32 = 1;
pub const CONFIG_SND_LAYLA20_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_LOOP: u32 = 1;
pub const CONFIG_DVB_BT8XX_MODULE: u32 = 1;
pub const CONFIG_IPMI_HANDLER_MODULE: u32 = 1;
pub const CONFIG_LEDS_LM3642_MODULE: u32 = 1;
pub const CONFIG_B44_MODULE: u32 = 1;
pub const CONFIG_AMD_MEM_ENCRYPT: u32 = 1;
pub const CONFIG_DEFAULT_HUNG_TASK_TIMEOUT: u32 = 120;
pub const CONFIG_SYSV_FS_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_PCI_LEGACY: u32 = 1;
pub const CONFIG_SENSORS_THMC50_MODULE: u32 = 1;
pub const CONFIG_ARCH_HIBERNATION_HEADER: u32 = 1;
pub const CONFIG_HAVE_OPTPROBES: u32 = 1;
pub const CONFIG_HAVE_FENTRY: u32 = 1;
pub const CONFIG_L2TP_ETH_MODULE: u32 = 1;
pub const CONFIG_RUST_IS_AVAILABLE: u32 = 1;
pub const CONFIG_DRM_I915_HEARTBEAT_INTERVAL: u32 = 2500;
pub const CONFIG_COMEDI_ADDI_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_I8K: u32 = 1;
pub const CONFIG_PATA_ATIIXP_MODULE: u32 = 1;
pub const CONFIG_SCSI_QLOGIC_1280_MODULE: u32 = 1;
pub const CONFIG_SPI_MEM: u32 = 1;
pub const CONFIG_DELL_SMO8800_MODULE: u32 = 1;
pub const CONFIG_HYPERV_UTILS_MODULE: u32 = 1;
pub const CONFIG_INV_MPU6050_SPI_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_IRC_MODULE: u32 = 1;
pub const CONFIG_60XX_WDT_MODULE: u32 = 1;
pub const CONFIG_COMMON_CLK_SI5341_MODULE: u32 = 1;
pub const CONFIG_ACPI_HMAT: u32 = 1;
pub const CONFIG_VIDEO_ADV7393_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_XC2028_MODULE: u32 = 1;
pub const CONFIG_INPUT_MISC: u32 = 1;
pub const CONFIG_SND_COMPRESS_OFFLOAD_MODULE: u32 = 1;
pub const CONFIG_IR_NUVOTON_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SCH5627_MODULE: u32 = 1;
pub const CONFIG_ADIS16080_MODULE: u32 = 1;
pub const CONFIG_I2C_AMD756_MODULE: u32 = 1;
pub const CONFIG_ICE_MODULE: u32 = 1;
pub const CONFIG_UIO_PRUSS_MODULE: u32 = 1;
pub const CONFIG_E1000E_MODULE: u32 = 1;
pub const CONFIG_MFD_LP8788: u32 = 1;
pub const CONFIG_MS5611_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_METEORLAKE_MODULE: u32 = 1;
pub const CONFIG_DNET_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TC358743_MODULE: u32 = 1;
pub const CONFIG_INPUT_VIVALDIFMAP: u32 = 1;
pub const CONFIG_MT76x0U_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CAST6_AVX_X86_64_MODULE: u32 = 1;
pub const CONFIG_DVB_STV0288_MODULE: u32 = 1;
pub const CONFIG_USB_SL811_CS_MODULE: u32 = 1;
pub const CONFIG_MULTIUSER: u32 = 1;
pub const CONFIG_CROS_HPS_I2C_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_PCAP_MODULE: u32 = 1;
pub const CONFIG_SUSPEND: u32 = 1;
pub const CONFIG_GENERIC_VDSO_TIME_NS: u32 = 1;
pub const CONFIG_SUNRPC_XPRT_RDMA_MODULE: u32 = 1;
pub const CONFIG_CROSS_MEMORY_ATTACH: u32 = 1;
pub const CONFIG_MTD_NAND_ECC: u32 = 1;
pub const CONFIG_CRYPTO_CBC: u32 = 1;
pub const CONFIG_SENSORS_LM93_MODULE: u32 = 1;
pub const CONFIG_LEDS_LM3601X_MODULE: u32 = 1;
pub const CONFIG_BT_CMTP_MODULE: u32 = 1;
pub const CONFIG_VIDEO_IMX214_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_APL_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_TIGERLAKE_MODULE: u32 = 1;
pub const CONFIG_KS0108_DELAY: u32 = 2;
pub const CONFIG_VIDEO_CX88_VP3054_MODULE: u32 = 1;
pub const CONFIG_MEDIA_CONTROLLER: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_HMARK_MODULE: u32 = 1;
pub const CONFIG_INPUT_RT5120_PWRKEY_MODULE: u32 = 1;
pub const CONFIG_INPUT_MMA8450_MODULE: u32 = 1;
pub const CONFIG_SURFACE_AGGREGATOR_BUS: u32 = 1;
pub const CONFIG_WWAN_DEBUGFS: u32 = 1;
pub const CONFIG_MRP_MODULE: u32 = 1;
pub const CONFIG_I8253_LOCK: u32 = 1;
pub const CONFIG_SMSC_SCH311X_WDT_MODULE: u32 = 1;
pub const CONFIG_AK8975_MODULE: u32 = 1;
pub const CONFIG_AIC79XX_CMDS_PER_DEVICE: u32 = 32;
pub const CONFIG_IP6_NF_MATCH_RT_MODULE: u32 = 1;
pub const CONFIG_SCSI_IPR_MODULE: u32 = 1;
pub const CONFIG_SQUASHFS_DECOMP_SINGLE: u32 = 1;
pub const CONFIG_SENSORS_ISL68137_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_RUNTIME_UARTS: u32 = 32;
pub const CONFIG_HDC2010_MODULE: u32 = 1;
pub const CONFIG_NS83820_MODULE: u32 = 1;
pub const CONFIG_PREEMPT_BUILD: u32 = 1;
pub const CONFIG_IDLE_INJECT: u32 = 1;
pub const CONFIG_ARCH_HAS_NONLEAF_PMD_YOUNG: u32 = 1;
pub const CONFIG_SND_SOC_RT1015P_MODULE: u32 = 1;
pub const CONFIG_CLANG_VERSION: u32 = 0;
pub const CONFIG_STEAM_FF: u32 = 1;
pub const CONFIG_TSL4531_MODULE: u32 = 1;
pub const CONFIG_CDNS_I3C_MASTER_MODULE: u32 = 1;
pub const CONFIG_KPROBES: u32 = 1;
pub const CONFIG_FS_MBCACHE: u32 = 1;
pub const CONFIG_XEN_HAVE_VPMU: u32 = 1;
pub const CONFIG_T5403_MODULE: u32 = 1;
pub const CONFIG_SENSORS_JC42_MODULE: u32 = 1;
pub const CONFIG_DS1682_MODULE: u32 = 1;
pub const CONFIG_MFD_AS3711: u32 = 1;
pub const CONFIG_GFS2_FS_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TUA9001_MODULE: u32 = 1;
pub const CONFIG_RTC_CLASS: u32 = 1;
pub const CONFIG_DVB_TUNER_DIB0070_MODULE: u32 = 1;
pub const CONFIG_DRM_MGAG200_MODULE: u32 = 1;
pub const CONFIG_VIDEO_IPU3_CIO2_MODULE: u32 = 1;
pub const CONFIG_CHARGER_BQ2515X_MODULE: u32 = 1;
pub const CONFIG_FB_MB862XX_PCI_GDC: u32 = 1;
pub const CONFIG_CRC7_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_RNG_DEFAULT: u32 = 1;
pub const CONFIG_SENSORS_LTC4215_MODULE: u32 = 1;
pub const CONFIG_SLICOSS_MODULE: u32 = 1;
pub const CONFIG_KVM_AMD_MODULE: u32 = 1;
pub const CONFIG_USB_EMI26_MODULE: u32 = 1;
pub const CONFIG_IP_VS_PROTO_ESP: u32 = 1;
pub const CONFIG_F2FS_FS_LZO: u32 = 1;
pub const CONFIG_PCNET32_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_IT913X_MODULE: u32 = 1;
pub const CONFIG_MWIFIEX_USB_MODULE: u32 = 1;
pub const CONFIG_SAMSUNG_Q10_MODULE: u32 = 1;
pub const CONFIG_TMPFS_XATTR: u32 = 1;
pub const CONFIG_EXT4_USE_FOR_EXT2: u32 = 1;
pub const CONFIG_EDAC_I82975X_MODULE: u32 = 1;
pub const CONFIG_UBUNTU_ODM_DRIVERS: u32 = 1;
pub const CONFIG_PCMCIA_NMCLAN_MODULE: u32 = 1;
pub const CONFIG_CAN_M_CAN_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_MT76x2_COMMON_MODULE: u32 = 1;
pub const CONFIG_NET_TEAM_MODULE: u32 = 1;
pub const CONFIG_FB_UVESA_MODULE: u32 = 1;
pub const CONFIG_XFRM_USER_COMPAT_MODULE: u32 = 1;
pub const CONFIG_INTEL_BXT_PMIC_THERMAL_MODULE: u32 = 1;
pub const CONFIG_AD5593R_MODULE: u32 = 1;
pub const CONFIG_LCD_ILI922X_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TSC2007_MODULE: u32 = 1;
pub const CONFIG_SND_RME96_MODULE: u32 = 1;
pub const CONFIG_CAN_KVASER_USB_MODULE: u32 = 1;
pub const CONFIG_DCA_MODULE: u32 = 1;
pub const CONFIG_I2C_ALI1535_MODULE: u32 = 1;
pub const CONFIG_I2C_I801_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_FAMILY_ARP: u32 = 1;
pub const CONFIG_FB_TFT_SEPS525_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_CAFE_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_STOP_TIMEOUT: u32 = 100;
pub const CONFIG_BCM_NET_PHYLIB_MODULE: u32 = 1;
pub const CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS: u32 = 16;
pub const CONFIG_ATH10K_SPECTRAL: u32 = 1;
pub const CONFIG_SND_SOC_CS4234_MODULE: u32 = 1;
pub const CONFIG_W1_MODULE: u32 = 1;
pub const CONFIG_VIDEO_SAA7134_ALSA_MODULE: u32 = 1;
pub const CONFIG_RT2800PCI_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_VC032X_MODULE: u32 = 1;
pub const CONFIG_USB_MAX3420_UDC_MODULE: u32 = 1;
pub const CONFIG_OPENVSWITCH_GRE_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_UAC1_LEGACY: u32 = 1;
pub const CONFIG_SND_SOC_PCM5102A_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_CS42L43_MODULE: u32 = 1;
pub const CONFIG_V4L2_FWNODE_MODULE: u32 = 1;
pub const CONFIG_IOMMU_HELPER: u32 = 1;
pub const CONFIG_DVB_ISL6421_MODULE: u32 = 1;
pub const CONFIG_VIDEO_AU0828_RC: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_NETDEV_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1374_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_ELKHARTLAKE_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_KDF800108_CTR: u32 = 1;
pub const CONFIG_SENSORS_STTS751_MODULE: u32 = 1;
pub const CONFIG_MLX5_ESWITCH: u32 = 1;
pub const CONFIG_INFINIBAND_OPA_VNIC_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_BOOTROM_MODULE: u32 = 1;
pub const CONFIG_PATA_ACPI_MODULE: u32 = 1;
pub const CONFIG_GENERIC_TRACER: u32 = 1;
pub const CONFIG_CFG80211_USE_KERNEL_REGDB_KEYS: u32 = 1;
pub const CONFIG_INTEL_IFS_MODULE: u32 = 1;
pub const CONFIG_DRM_PANEL_ILITEK_ILI9341_MODULE: u32 = 1;
pub const CONFIG_TRACE_EVENT_INJECT: u32 = 1;
pub const CONFIG_NLS_ISO8859_5_MODULE: u32 = 1;
pub const CONFIG_DRM_VGEM_MODULE: u32 = 1;
pub const CONFIG_IP_VS_WLC_MODULE: u32 = 1;
pub const CONFIG_HAVE_KVM_NO_POLL: u32 = 1;
pub const CONFIG_VIDEO_AD5820_MODULE: u32 = 1;
pub const CONFIG_MT792x_USB_MODULE: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_TRACER: u32 = 1;
pub const CONFIG_GENERIC_PHY: u32 = 1;
pub const CONFIG_THERMAL_NETLINK: u32 = 1;
pub const CONFIG_MLXSW_SPECTRUM_MODULE: u32 = 1;
pub const CONFIG_CPU_ISOLATION: u32 = 1;
pub const CONFIG_NF_NAT_TFTP_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_IAA_CRYPTO_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_MULTIPORT_MODULE: u32 = 1;
pub const CONFIG_NR_CPUS_RANGE_END: u32 = 8192;
pub const CONFIG_CHARGER_MAX14577_MODULE: u32 = 1;
pub const CONFIG_INTEL_MEI_GSC_PROXY_MODULE: u32 = 1;
pub const CONFIG_MTD_SPI_NOR_MODULE: u32 = 1;
pub const CONFIG_STACK_VALIDATION: u32 = 1;
pub const CONFIG_CHARGER_MANAGER: u32 = 1;
pub const CONFIG_FW_LOADER_COMPRESS_XZ: u32 = 1;
pub const CONFIG_NET_SCH_NETEM_MODULE: u32 = 1;
pub const CONFIG_ACPI_PROCESSOR_AGGREGATOR_MODULE: u32 = 1;
pub const CONFIG_X86_MEM_ENCRYPT: u32 = 1;
pub const CONFIG_USB_STORAGE_REALTEK_MODULE: u32 = 1;
pub const CONFIG_DRM_DISPLAY_DP_HELPER: u32 = 1;
pub const CONFIG_SND_SOC_AC97_CODEC_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CAMELLIA_MODULE: u32 = 1;
pub const CONFIG_LRU_GEN_ENABLED: u32 = 1;
pub const CONFIG_SND_EMU10K1_SEQ_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1307_MODULE: u32 = 1;
pub const CONFIG_I2C_SIS630_MODULE: u32 = 1;
pub const CONFIG_NFSD_V4: u32 = 1;
pub const CONFIG_I2C_SI4713_MODULE: u32 = 1;
pub const CONFIG_ZOPT2201_MODULE: u32 = 1;
pub const CONFIG_PMBUS_MODULE: u32 = 1;
pub const CONFIG_EFI_MIXED: u32 = 1;
pub const CONFIG_SENSORS_LTC2991_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_ILLINOIS_MODULE: u32 = 1;
pub const CONFIG_ZEROPLUS_FF: u32 = 1;
pub const CONFIG_BCM_NET_PHYPTP_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_REDIRECT_MODULE: u32 = 1;
pub const CONFIG_R8169_LEDS: u32 = 1;
pub const CONFIG_CRYPTO_MANAGER2: u32 = 1;
pub const CONFIG_INFINIBAND_QIB_DCA: u32 = 1;
pub const CONFIG_USB_GADGET_VBUS_DRAW: u32 = 2;
pub const CONFIG_SATA_DWC_MODULE: u32 = 1;
pub const CONFIG_NFC_MEI_PHY_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_PTE_SPECIAL: u32 = 1;
pub const CONFIG_NET_VENDOR_MYRI: u32 = 1;
pub const CONFIG_KEXEC_FILE: u32 = 1;
pub const CONFIG_NF_NAT_MASQUERADE: u32 = 1;
pub const CONFIG_SND_SOC_FSL_MICFIL_MODULE: u32 = 1;
pub const CONFIG_DRAGONRISE_FF: u32 = 1;
pub const CONFIG_CLZ_TAB: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_3M: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_EGALAX: u32 = 1;
pub const CONFIG_TYPEC_FUSB302_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_SUR40_MODULE: u32 = 1;
pub const CONFIG_FUN_ETH_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_DNAT_MODULE: u32 = 1;
pub const CONFIG_CHARGER_MP2629_MODULE: u32 = 1;
pub const CONFIG_CXL_BUS_MODULE: u32 = 1;
pub const CONFIG_GENERIC_PCI_IOMAP: u32 = 1;
pub const CONFIG_HID_PLAYSTATION_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_LOG_MODULE: u32 = 1;
pub const CONFIG_SLUB: u32 = 1;
pub const CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS: u32 = 1;
pub const CONFIG_SENSORS_AD7418_MODULE: u32 = 1;
pub const CONFIG_MLX5_MACSEC: u32 = 1;
pub const CONFIG_NET_SCH_HHF_MODULE: u32 = 1;
pub const CONFIG_CONFIGFS_FS: u32 = 1;
pub const CONFIG_CRYPTO_TEST_MODULE: u32 = 1;
pub const CONFIG_MTD_UBI_MODULE: u32 = 1;
pub const CONFIG_MODULE_SIG_KEY: &[u8; 1usize] = b"\0";
pub const CONFIG_INTEL_IDXD_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_USB_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_RV3032_MODULE: u32 = 1;
pub const CONFIG_ADXL367_I2C_MODULE: u32 = 1;
pub const CONFIG_XZ_DEC_BCJ: u32 = 1;
pub const CONFIG_USB_F_MIDI2_MODULE: u32 = 1;
pub const CONFIG_SLIP_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_LTO_CLANG_THIN: u32 = 1;
pub const CONFIG_PM_SLEEP: u32 = 1;
pub const CONFIG_F2FS_FS_XATTR: u32 = 1;
pub const CONFIG_SENSORS_FAM15H_POWER_MODULE: u32 = 1;
pub const CONFIG_I2C: u32 = 1;
pub const CONFIG_MFD_WM5110: u32 = 1;
pub const CONFIG_CRASH_HOTPLUG: u32 = 1;
pub const CONFIG_COMPAL_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_IP_VS_TWOS_MODULE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_MTD: u32 = 1;
pub const CONFIG_ZSWAP_ZPOOL_DEFAULT: &[u8; 5usize] = b"zbud\0";
pub const CONFIG_JFFS2_ZLIB: u32 = 1;
pub const CONFIG_SCSI_CHELSIO_FCOE_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_PCNET_MODULE: u32 = 1;
pub const CONFIG_EDAC_DECODE_MCE_MODULE: u32 = 1;
pub const CONFIG_FPGA_DFL_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TC358743_CEC: u32 = 1;
pub const CONFIG_SENSORS_VT1211_MODULE: u32 = 1;
pub const CONFIG_GPIO_AMDPT_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS35L41_I2C_MODULE: u32 = 1;
pub const CONFIG_B44_PCI: u32 = 1;
pub const CONFIG_CRYPTO_DEV_AMLOGIC_GXL_MODULE: u32 = 1;
pub const CONFIG_CROS_EC_MKBP_PROXIMITY_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_STATS: u32 = 1;
pub const CONFIG_PPP_MULTILINK: u32 = 1;
pub const CONFIG_INFINIBAND_RDMAVT_MODULE: u32 = 1;
pub const CONFIG_X86_UV: u32 = 1;
pub const CONFIG_SND_SOC_CS35L34_MODULE: u32 = 1;
pub const CONFIG_MTD_ONENAND_GENERIC_MODULE: u32 = 1;
pub const CONFIG_IPACK_BUS_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_GLK_RT5682_MAX98357A_MACH_MODULE: u32 = 1;
pub const CONFIG_MFD_OCELOT_MODULE: u32 = 1;
pub const CONFIG_MMU_GATHER_TABLE_FREE: u32 = 1;
pub const CONFIG_BINFMT_SCRIPT: u32 = 1;
pub const CONFIG_EFI_STUB: u32 = 1;
pub const CONFIG_SATA_PROMISE_MODULE: u32 = 1;
pub const CONFIG_EISA_NAMES: u32 = 1;
pub const CONFIG_KVM_WERROR: u32 = 1;
pub const CONFIG_PARPORT_1284: u32 = 1;
pub const CONFIG_MOUSE_PS2_CYPRESS: u32 = 1;
pub const CONFIG_FONT_ACORN_8x8: u32 = 1;
pub const CONFIG_SENSORS_POWR1220_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX25840_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_CFM: u32 = 1;
pub const CONFIG_INTEL_PMT_CLASS_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV5670_MODULE: u32 = 1;
pub const CONFIG_GENERIC_PENDING_IRQ: u32 = 1;
pub const CONFIG_INTERRUPT_CNT_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_FENCE_TIMEOUT: u32 = 10000;
pub const CONFIG_I2C_AMD756_S4882_MODULE: u32 = 1;
pub const CONFIG_PARPORT_PC_MODULE: u32 = 1;
pub const CONFIG_BFQ_GROUP_IOSCHED: u32 = 1;
pub const CONFIG_CAVIUM_PTP_MODULE: u32 = 1;
pub const CONFIG_NET_TEAM_MODE_LOADBALANCE_MODULE: u32 = 1;
pub const CONFIG_PSTORE_BLK_BLKDEV: &[u8; 1usize] = b"\0";
pub const CONFIG_DVB_MN88472_MODULE: u32 = 1;
pub const CONFIG_PPS_CLIENT_GPIO_MODULE: u32 = 1;
pub const CONFIG_IIO_SW_TRIGGER_MODULE: u32 = 1;
pub const CONFIG_X86_NEED_RELOCS: u32 = 1;
pub const CONFIG_EARLY_PRINTK_DBGP: u32 = 1;
pub const CONFIG_BMI323_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ADV7175_MODULE: u32 = 1;
pub const CONFIG_SCSI_SRP_ATTRS_MODULE: u32 = 1;
pub const CONFIG_FRAME_POINTER: u32 = 1;
pub const CONFIG_SND_SOC_SOF_INTEL_CNL_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_IMAGIS_MODULE: u32 = 1;
pub const CONFIG_NET_IPGRE_BROADCAST: u32 = 1;
pub const CONFIG_CC_HAS_RETURN_THUNK: u32 = 1;
pub const CONFIG_BT_HIDP_MODULE: u32 = 1;
pub const CONFIG_PD6729_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_CS47L15: u32 = 1;
pub const CONFIG_KS8851_MLL_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX231XX_RC: u32 = 1;
pub const CONFIG_VIDEO_ADV7842_CEC: u32 = 1;
pub const CONFIG_MOUSE_PS2_LOGIPS2PP: u32 = 1;
pub const CONFIG_MFD_BD9571MWV_MODULE: u32 = 1;
pub const CONFIG_IIO_BUFFER_HW_CONSUMER_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ECDSA_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DT2817_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_AMD_VANGOGH_MODULE: u32 = 1;
pub const CONFIG_SND_PCXHR_MODULE: u32 = 1;
pub const CONFIG_TINYDRM_HX8357D_MODULE: u32 = 1;
pub const CONFIG_DRM_XE_FORCE_PROBE: &[u8; 1usize] = b"\0";
pub const CONFIG_STMMAC_PCI_MODULE: u32 = 1;
pub const CONFIG_UFS_FS_MODULE: u32 = 1;
pub const CONFIG_TYPEC_MUX_GPIO_SBU_MODULE: u32 = 1;
pub const CONFIG_VM_EVENT_COUNTERS: u32 = 1;
pub const CONFIG_MEDIA_COMMON_OPTIONS: u32 = 1;
pub const CONFIG_NFC_MICROREAD_MODULE: u32 = 1;
pub const CONFIG_HID_MAYFLASH_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ALVIUM_CSI2_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_SX8654_MODULE: u32 = 1;
pub const CONFIG_RELAY: u32 = 1;
pub const CONFIG_AD9834_MODULE: u32 = 1;
pub const CONFIG_BATTERY_GOLDFISH_MODULE: u32 = 1;
pub const CONFIG_IWLDVM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RTQ9128_MODULE: u32 = 1;
pub const CONFIG_HAVE_MMIOTRACE_SUPPORT: u32 = 1;
pub const CONFIG_SCHED_STACK_END_CHECK: u32 = 1;
pub const CONFIG_ASUS_NB_WMI_MODULE: u32 = 1;
pub const CONFIG_RMI4_F30: u32 = 1;
pub const CONFIG_USB_GSPCA_FINEPIX_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ECB: u32 = 1;
pub const CONFIG_SND_SOC_TLV320AIC32X4_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_ETOMS_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SHA512_SSSE3: u32 = 1;
pub const CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT: u32 = 1;
pub const CONFIG_REGULATOR_MAX77693_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_HDA_MODULE: u32 = 1;
pub const CONFIG_MFD_PALMAS: u32 = 1;
pub const CONFIG_WLAN_VENDOR_BROADCOM: u32 = 1;
pub const CONFIG_PM_STD_PARTITION: &[u8; 1usize] = b"\0";
pub const CONFIG_SQUASHFS_LZO: u32 = 1;
pub const CONFIG_BMI088_ACCEL_MODULE: u32 = 1;
pub const CONFIG_SND_DYNAMIC_MINORS: u32 = 1;
pub const CONFIG_FUJITSU_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_TCM_FILEIO_MODULE: u32 = 1;
pub const CONFIG_SND_PCM_IEC958: u32 = 1;
pub const CONFIG_NET_VENDOR_XIRCOM: u32 = 1;
pub const CONFIG_MAX5432_MODULE: u32 = 1;
pub const CONFIG_SCSI_STEX_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_AG6XX: u32 = 1;
pub const CONFIG_6LOWPAN_NHC_HOP_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_PCI_CPCI_ZT5550_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_ATH3K: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_CRASH_HOTPLUG: u32 = 1;
pub const CONFIG_NF_CONNTRACK_AMANDA_MODULE: u32 = 1;
pub const CONFIG_SND_ATIIXP_MODEM_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_VDPA_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SM4_GENERIC_MODULE: u32 = 1;
pub const CONFIG_HID_NTI_MODULE: u32 = 1;
pub const CONFIG_DEBUG_FS: u32 = 1;
pub const CONFIG_RDMA_RXE_MODULE: u32 = 1;
pub const CONFIG_TYPEC_MUX_NB7VPQ904M_MODULE: u32 = 1;
pub const CONFIG_FEALNX_MODULE: u32 = 1;
pub const CONFIG_ACPI_EXTLOG_MODULE: u32 = 1;
pub const CONFIG_USB_FUNCTIONFS_RNDIS: u32 = 1;
pub const CONFIG_NET_VENDOR_AMD: u32 = 1;
pub const CONFIG_HAVE_KERNEL_LZ4: u32 = 1;
pub const CONFIG_NET_PKTGEN_MODULE: u32 = 1;
pub const CONFIG_HP_WMI_MODULE: u32 = 1;
pub const CONFIG_INTEL_ISH_HID_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_DENALI_PCI_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_EDGEPORT_MODULE: u32 = 1;
pub const CONFIG_DRM_TTM_MODULE: u32 = 1;
pub const CONFIG_BASE_FULL: u32 = 1;
pub const CONFIG_SND_SOC_MAX98520_MODULE: u32 = 1;
pub const CONFIG_FB_CFB_IMAGEBLIT: u32 = 1;
pub const CONFIG_MAX5487_MODULE: u32 = 1;
pub const CONFIG_ZLIB_DEFLATE: u32 = 1;
pub const CONFIG_NFT_REJECT_INET_MODULE: u32 = 1;
pub const CONFIG_SUNRPC_MODULE: u32 = 1;
pub const CONFIG_SOLARIS_X86_PARTITION: u32 = 1;
pub const CONFIG_MLXSW_CORE_MODULE: u32 = 1;
pub const CONFIG_ARCNET_RAW_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TSC2007_IIO: u32 = 1;
pub const CONFIG_PMIC_DA903X: u32 = 1;
pub const CONFIG_SCSI_DH_RDAC_MODULE: u32 = 1;
pub const CONFIG_SENSORS_W83795_MODULE: u32 = 1;
pub const CONFIG_XFRM_INTERFACE_MODULE: u32 = 1;
pub const CONFIG_BATTERY_BQ27XXX_MODULE: u32 = 1;
pub const CONFIG_SENSORS_Q54SJ108A2_MODULE: u32 = 1;
pub const CONFIG_X86_P4_CLOCKMOD_MODULE: u32 = 1;
pub const CONFIG_RPMSG_NS_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ADAU1761_SPI_MODULE: u32 = 1;
pub const CONFIG_INPUT_ATI_REMOTE2_MODULE: u32 = 1;
pub const CONFIG_RPMSG_TTY_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS35L45_I2C_MODULE: u32 = 1;
pub const CONFIG_CNIC_MODULE: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK_MOCK_MODULE: u32 = 1;
pub const CONFIG_ACPI_TABLE_UPGRADE: u32 = 1;
pub const CONFIG_RSI_SDIO_MODULE: u32 = 1;
pub const CONFIG_OSF_PARTITION: u32 = 1;
pub const CONFIG_HID_MALTRON_MODULE: u32 = 1;
pub const CONFIG_ARCH_USES_HIGH_VMA_FLAGS: u32 = 1;
pub const CONFIG_CACHESTAT_SYSCALL: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_AUDIO_MODULE: u32 = 1;
pub const CONFIG_RSEQ: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_864_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MP2856_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CY8CTMG110_MODULE: u32 = 1;
pub const CONFIG_IIO_BUFFER: u32 = 1;
pub const CONFIG_IWL3945_MODULE: u32 = 1;
pub const CONFIG_IP_VS_LBLCR_MODULE: u32 = 1;
pub const CONFIG_GPIO_SYSFS: u32 = 1;
pub const CONFIG_BE2NET_SKYHAWK: u32 = 1;
pub const CONFIG_USB_YUREX_MODULE: u32 = 1;
pub const CONFIG_XEN_BACKEND: u32 = 1;
pub const CONFIG_FW_LOADER: u32 = 1;
pub const CONFIG_REGULATOR_MT6331_MODULE: u32 = 1;
pub const CONFIG_ATH11K_SPECTRAL: u32 = 1;
pub const CONFIG_IIO_SW_DEVICE_MODULE: u32 = 1;
pub const CONFIG_USB_G_DBGP_SERIAL: u32 = 1;
pub const CONFIG_IP6_NF_NAT_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_WM8350_MODULE: u32 = 1;
pub const CONFIG_LTC2471_MODULE: u32 = 1;
pub const CONFIG_RANDOMIZE_MEMORY_PHYSICAL_PADDING: u32 = 10;
pub const CONFIG_SENSORS_ADS7828_MODULE: u32 = 1;
pub const CONFIG_KALLSYMS: u32 = 1;
pub const CONFIG_COMMON_CLK: u32 = 1;
pub const CONFIG_ICP10100_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SPCA501_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_PCI_PCIE: u32 = 1;
pub const CONFIG_BMG160_I2C_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_RV8803_MODULE: u32 = 1;
pub const CONFIG_STACKPROTECTOR_STRONG: u32 = 1;
pub const CONFIG_PCI: u32 = 1;
pub const CONFIG_RTC_HCTOSYS_DEVICE: &[u8; 5usize] = b"rtc0\0";
pub const CONFIG_NET_VENDOR_FUNGIBLE: u32 = 1;
pub const CONFIG_CONTIG_ALLOC: u32 = 1;
pub const CONFIG_STACKDEPOT_MAX_FRAMES: u32 = 64;
pub const CONFIG_CRYPTO_XTS: u32 = 1;
pub const CONFIG_SENSORS_ZL6100_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RL6231_MODULE: u32 = 1;
pub const CONFIG_PWM: u32 = 1;
pub const CONFIG_BATTERY_DS2781_MODULE: u32 = 1;
pub const CONFIG_CHARGER_PCF50633_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_RECENT_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_PROBE_WORK_QUEUE: u32 = 1;
pub const CONFIG_NET_VENDOR_ASIX: u32 = 1;
pub const CONFIG_DECOMPRESS_XZ: u32 = 1;
pub const CONFIG_SERIAL_DEV_CTRL_TTYPORT: u32 = 1;
pub const CONFIG_PCI_QUIRKS: u32 = 1;
pub const CONFIG_BT_BCM_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_PKTTYPE_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_USNIC_MODULE: u32 = 1;
pub const CONFIG_MII_MODULE: u32 = 1;
pub const CONFIG_LEDS_IS31FL319X_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_TCA8418_MODULE: u32 = 1;
pub const CONFIG_MD_BITMAP_FILE: u32 = 1;
pub const CONFIG_SIGNALFD: u32 = 1;
pub const CONFIG_ADXL372_SPI_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MAX8997_MODULE: u32 = 1;
pub const CONFIG_NET_CORE: u32 = 1;
pub const CONFIG_MOUSE_PS2_ALPS: u32 = 1;
pub const CONFIG_BPF_JIT_DEFAULT_ON: u32 = 1;
pub const CONFIG_PATA_PARPORT_ON26_MODULE: u32 = 1;
pub const CONFIG_KEXEC_CORE: u32 = 1;
pub const CONFIG_HAVE_UNSTABLE_SCHED_CLOCK: u32 = 1;
pub const CONFIG_EXT4_FS: u32 = 1;
pub const CONFIG_MAC80211_DEBUGFS: u32 = 1;
pub const CONFIG_NET_SCH_DRR_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT298_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LTC4151_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_802_3_MODULE: u32 = 1;
pub const CONFIG_DP83TC811_PHY_MODULE: u32 = 1;
pub const CONFIG_DELL_SMBIOS_SMM: u32 = 1;
pub const CONFIG_CPU5_WDT_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_VMWARE_PVRDMA_MODULE: u32 = 1;
pub const CONFIG_LCD_OTM3225A_MODULE: u32 = 1;
pub const CONFIG_MEMORY_BALLOON: u32 = 1;
pub const CONFIG_DMARD06_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_65XX_MODULE: u32 = 1;
pub const CONFIG_MMC_USDHI6ROL0_MODULE: u32 = 1;
pub const CONFIG_SERIAL_SC16IS7XX_SPI: u32 = 1;
pub const CONFIG_UNINLINE_SPIN_UNLOCK: u32 = 1;
pub const CONFIG_VIDEO_CX88_BLACKBIRD_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM512x_SPI_MODULE: u32 = 1;
pub const CONFIG_HAVE_HW_BREAKPOINT: u32 = 1;
pub const CONFIG_KRETPROBES: u32 = 1;
pub const CONFIG_SND_JACK_INPUT_DEV: u32 = 1;
pub const CONFIG_SCSI_MYRS_MODULE: u32 = 1;
pub const CONFIG_MTD_LPDDR_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SHA1: u32 = 1;
pub const CONFIG_MFD_MT6397_MODULE: u32 = 1;
pub const CONFIG_GPIO_104_DIO_48E_MODULE: u32 = 1;
pub const CONFIG_HID_PENMOUNT_MODULE: u32 = 1;
pub const CONFIG_IPMI_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_MD_CLUSTER_MODULE: u32 = 1;
pub const CONFIG_VIDEO_DW9714_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_JOYDUMP_MODULE: u32 = 1;
pub const CONFIG_CPU_UNRET_ENTRY: u32 = 1;
pub const CONFIG_INFINIBAND_USER_ACCESS_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_MT7530_MODULE: u32 = 1;
pub const CONFIG_VMWARE_VMCI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AUDIO_IIO_AUX_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_T4_DCB: u32 = 1;
pub const CONFIG_BPQETHER_MODULE: u32 = 1;
pub const CONFIG_USB_ADUTUX_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_NOKIA_MODULE: u32 = 1;
pub const CONFIG_VIDEO_UDA1342_MODULE: u32 = 1;
pub const CONFIG_HSI_BOARDINFO: u32 = 1;
pub const CONFIG_KGDB_LOW_LEVEL_TRAP: u32 = 1;
pub const CONFIG_MT7601U_MODULE: u32 = 1;
pub const CONFIG_CAN_C_CAN_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_ARCH_WANT_GENERAL_HUGETLB: u32 = 1;
pub const CONFIG_SENSORS_SMSC47M192_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_VITESSE_VSC73XX_SPI_MODULE: u32 = 1;
pub const CONFIG_ADT7316_SPI_MODULE: u32 = 1;
pub const CONFIG_SPS30_I2C_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_SSD1305_MODULE: u32 = 1;
pub const CONFIG_WIREGUARD_MODULE: u32 = 1;
pub const CONFIG_NLS_KOI8_U_MODULE: u32 = 1;
pub const CONFIG_RADIO_SHARK2_MODULE: u32 = 1;
pub const CONFIG_CRC8_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_ZONED: u32 = 1;
pub const CONFIG_NVIDIA_WMI_EC_BACKLIGHT_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS42L51_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SCH5636_MODULE: u32 = 1;
pub const CONFIG_HAVE_SAMPLE_FTRACE_DIRECT: u32 = 1;
pub const CONFIG_PKCS7_TEST_KEY_MODULE: u32 = 1;
pub const CONFIG_USB_BELKIN: u32 = 1;
pub const CONFIG_NET_DSA_QCA8K_MODULE: u32 = 1;
pub const CONFIG_SATA_PMP: u32 = 1;
pub const CONFIG_XZ_DEC: u32 = 1;
pub const CONFIG_SMS_SIANO_DEBUGFS: u32 = 1;
pub const CONFIG_IPW2100_MONITOR: u32 = 1;
pub const CONFIG_QLA3XXX_MODULE: u32 = 1;
pub const CONFIG_BPF_LSM: u32 = 1;
pub const CONFIG_CAN_VCAN_MODULE: u32 = 1;
pub const CONFIG_DPTF_POWER_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_FIRMWARE_MODULE: u32 = 1;
pub const CONFIG_SPI_MICROCHIP_CORE_MODULE: u32 = 1;
pub const CONFIG_ATH_COMMON_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_TI: u32 = 1;
pub const CONFIG_CROS_EC_LPC_MODULE: u32 = 1;
pub const CONFIG_LOCKD_V4: u32 = 1;
pub const CONFIG_DRM_XE_DISPLAY: u32 = 1;
pub const CONFIG_SENSORS_LTC2945_MODULE: u32 = 1;
pub const CONFIG_DUMMY_MODULE: u32 = 1;
pub const CONFIG_EDAC_IGEN6_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AK5558_MODULE: u32 = 1;
pub const CONFIG_DEV_DAX_HMEM_DEVICES: u32 = 1;
pub const CONFIG_MFD_MADERA_I2C_MODULE: u32 = 1;
pub const CONFIG_COMEDI_TESTS_NI_ROUTES_MODULE: u32 = 1;
pub const CONFIG_W1_MASTER_AMD_AXI_MODULE: u32 = 1;
pub const CONFIG_CODA_FS_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_INTEL_ICL_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2431_MODULE: u32 = 1;
pub const CONFIG_ADI_AXI_ADC_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_ALACRITECH: u32 = 1;
pub const CONFIG_I2C_MUX_MLXCPLD_MODULE: u32 = 1;
pub const CONFIG_LEDS_LM3530_MODULE: u32 = 1;
pub const CONFIG_DVB_TUNER_CX24113_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_MARK_T_MODULE: u32 = 1;
pub const CONFIG_FPGA_DFL_EMIF_MODULE: u32 = 1;
pub const CONFIG_WATCHDOG: u32 = 1;
pub const CONFIG_BATTERY_MAX17042_MODULE: u32 = 1;
pub const CONFIG_SCSI_ADVANSYS_MODULE: u32 = 1;
pub const CONFIG_DVB_B2C2_FLEXCOP_PCI_MODULE: u32 = 1;
pub const CONFIG_INTEL_TCC_COOLING_MODULE: u32 = 1;
pub const CONFIG_SENSORS_IR38064_MODULE: u32 = 1;
pub const CONFIG_MT7663_USB_SDIO_COMMON_MODULE: u32 = 1;
pub const CONFIG_HAS_IOMEM: u32 = 1;
pub const CONFIG_SND_RAWMIDI_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_PCI_ACPI_IBM_MODULE: u32 = 1;
pub const CONFIG_MFD_ARIZONA_SPI_MODULE: u32 = 1;
pub const CONFIG_NF_LOG_IPV6_MODULE: u32 = 1;
pub const CONFIG_LRU_GEN_WALKS_MMU: u32 = 1;
pub const CONFIG_LTR390_MODULE: u32 = 1;
pub const CONFIG_MOST_SND_MODULE: u32 = 1;
pub const CONFIG_DRM_PANEL_WIDECHIPS_WS2401_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_SOCKET_MODULE: u32 = 1;
pub const CONFIG_TRACING_MAP: u32 = 1;
pub const CONFIG_CRYPTO_RSA: u32 = 1;
pub const CONFIG_USB_GSPCA_STK1135_MODULE: u32 = 1;
pub const CONFIG_8139TOO_8129: u32 = 1;
pub const CONFIG_SND_HDA_INPUT_BEEP_MODE: u32 = 0;
pub const CONFIG_VIRT_DRIVERS: u32 = 1;
pub const CONFIG_VALIDATE_FS_PARSER: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_RT5514_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LTC4222_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_SPLIT_STARTUP: u32 = 1;
pub const CONFIG_COMEDI_PCL724_MODULE: u32 = 1;
pub const CONFIG_GPIO_LJCA_MODULE: u32 = 1;
pub const CONFIG_IP_VS_OVF_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_INTEL: u32 = 1;
pub const CONFIG_IIO_TIGHTLOOP_TRIGGER_MODULE: u32 = 1;
pub const CONFIG_IR_FINTEK_MODULE: u32 = 1;
pub const CONFIG_GENERIC_IRQ_PROBE: u32 = 1;
pub const CONFIG_ATH6KL_USB_MODULE: u32 = 1;
pub const CONFIG_FUSION_LOGGING: u32 = 1;
pub const CONFIG_ABP060MG_MODULE: u32 = 1;
pub const CONFIG_USB_NET_CDC_EEM_MODULE: u32 = 1;
pub const CONFIG_BRCM_TRACING: u32 = 1;
pub const CONFIG_USB_STORAGE_SDDR09_MODULE: u32 = 1;
pub const CONFIG_GPIO_EXAR_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SIG2: u32 = 1;
pub const CONFIG_HYPERV_STORAGE_MODULE: u32 = 1;
pub const CONFIG_IP_NF_MATCH_TTL_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_MCS_MODULE: u32 = 1;
pub const CONFIG_ASYNC_RAID6_RECOV_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_STA32X_MODULE: u32 = 1;
pub const CONFIG_MENZ069_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_PCI_HYPERV_INTERFACE_MODULE: u32 = 1;
pub const CONFIG_HAVE_MOVE_PUD: u32 = 1;
pub const CONFIG_SI7020_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8782_MODULE: u32 = 1;
pub const CONFIG_VIDEOMODE_HELPERS: u32 = 1;
pub const CONFIG_NET_ACT_CTINFO_MODULE: u32 = 1;
pub const CONFIG_CEPH_FS_SECURITY_LABEL: u32 = 1;
pub const CONFIG_QCOM_EMAC_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ACOMP2: u32 = 1;
pub const CONFIG_VHOST_TASK: u32 = 1;
pub const CONFIG_FB_TFT_SSD1289_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV4689_MODULE: u32 = 1;
pub const CONFIG_PWM_LPSS_PLATFORM: u32 = 1;
pub const CONFIG_EDD_OFF: u32 = 1;
pub const CONFIG_GART_IOMMU: u32 = 1;
pub const CONFIG_CHARGER_RT9455_MODULE: u32 = 1;
pub const CONFIG_SCSI_SYM53C8XX_MAX_TAGS: u32 = 64;
pub const CONFIG_FB_CARMINE_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_MTK_PMIC_MODULE: u32 = 1;
pub const CONFIG_CW1200_WLAN_SPI_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_ECC_SW_BCH: u32 = 1;
pub const CONFIG_VIDEO_OV13858_MODULE: u32 = 1;
pub const CONFIG_NFTL_MODULE: u32 = 1;
pub const CONFIG_TI_ADS131E08_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_ADC_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_MRP: u32 = 1;
pub const CONFIG_PCI_MMCONFIG: u32 = 1;
pub const CONFIG_VIDEO_OV08D10_MODULE: u32 = 1;
pub const CONFIG_SFC_SIENA_MCDI_LOGGING: u32 = 1;
pub const CONFIG_VSOCKMON_MODULE: u32 = 1;
pub const CONFIG_PM_TRACE: u32 = 1;
pub const CONFIG_SND_SOC_STA350_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV7251_MODULE: u32 = 1;
pub const CONFIG_SCSI_AM53C974_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TRACE_MODULE: u32 = 1;
pub const CONFIG_HVC_IRQ: u32 = 1;
pub const CONFIG_HAVE_ARCH_KASAN_VMALLOC: u32 = 1;
pub const CONFIG_IAQCORE_MODULE: u32 = 1;
pub const CONFIG_IWLWIFI_DEVICE_TRACING: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CHIPONE_ICN8505_MODULE: u32 = 1;
pub const CONFIG_ARCH_CONFIGURES_CPU_MITIGATIONS: u32 = 1;
pub const CONFIG_ACPI_NFIT_MODULE: u32 = 1;
pub const CONFIG_USB_GADGETFS_MODULE: u32 = 1;
pub const CONFIG_MFD_AAEON_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_NAU8810_MODULE: u32 = 1;
pub const CONFIG_SND_RME32_MODULE: u32 = 1;
pub const CONFIG_PROC_KCORE: u32 = 1;
pub const CONFIG_RETPOLINE: u32 = 1;
pub const CONFIG_RTC_DRV_X1205_MODULE: u32 = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_1: u32 = 1;
pub const CONFIG_LPC_ICH_MODULE: u32 = 1;
pub const CONFIG_NUMA: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_FRAG_MODULE: u32 = 1;
pub const CONFIG_ADMV1014_MODULE: u32 = 1;
pub const CONFIG_HDC100X_MODULE: u32 = 1;
pub const CONFIG_LEDS_MT6323_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_CYBERJACK_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_PRIO_MODULE: u32 = 1;
pub const CONFIG_ANDROID_BINDER_DEVICES: &[u8; 1usize] = b"\0";
pub const CONFIG_JSA1212_MODULE: u32 = 1;
pub const CONFIG_SCHED_HRTICK: u32 = 1;
pub const CONFIG_TOUCHSCREEN_EXC3000_MODULE: u32 = 1;
pub const CONFIG_SATA_ULI_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_GVT: u32 = 1;
pub const CONFIG_DVB_DRXK_MODULE: u32 = 1;
pub const CONFIG_MMA7455_SPI_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_IUU_MODULE: u32 = 1;
pub const CONFIG_VIDEO_GO7007_USB_S2250_BOARD_MODULE: u32 = 1;
pub const CONFIG_EPOLL: u32 = 1;
pub const CONFIG_FB_MATROX_G: u32 = 1;
pub const CONFIG_SCSI_AIC79XX_MODULE: u32 = 1;
pub const CONFIG_NET_IFE_MODULE: u32 = 1;
pub const CONFIG_RADIO_MAXIRADIO_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LZO: u32 = 1;
pub const CONFIG_SND_PCM_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_TWOFISH_AVX_X86_64_MODULE: u32 = 1;
pub const CONFIG_INTEL_MEI_GSC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT711_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_CANNONLAKE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_HS3001_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AK4458_MODULE: u32 = 1;
pub const CONFIG_TCM_USER2_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DEFAULT_BUF_MAXSIZE_KB: u32 = 20480;
pub const CONFIG_BRIDGE_EBT_SNAT_MODULE: u32 = 1;
pub const CONFIG_SATA_MOBILE_LPM_POLICY: u32 = 3;
pub const CONFIG_SURFACE_ACPI_NOTIFY_MODULE: u32 = 1;
pub const CONFIG_CONTEXT_TRACKING_USER: u32 = 1;
pub const CONFIG_TCG_TIS_ST33ZP24_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_AU8820_MODULE: u32 = 1;
pub const CONFIG_APERTURE_HELPERS: u32 = 1;
pub const CONFIG_RAPIDIO: u32 = 1;
pub const CONFIG_INFINIBAND_OCRDMA_MODULE: u32 = 1;
pub const CONFIG_LTC2496_MODULE: u32 = 1;
pub const CONFIG_DA280_MODULE: u32 = 1;
pub const CONFIG_SND_SEQ_MIDI_EVENT_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_FS_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ES7134_MODULE: u32 = 1;
pub const CONFIG_VIDEO_DT3155_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SM4_AESNI_AVX2_X86_64_MODULE: u32 = 1;
pub const CONFIG_SDIO_UART_MODULE: u32 = 1;
pub const CONFIG_NFC_MRVL_SPI_MODULE: u32 = 1;
pub const CONFIG_KVM_COMPAT: u32 = 1;
pub const CONFIG_PARTITION_ADVANCED: u32 = 1;
pub const CONFIG_FAILOVER: u32 = 1;
pub const CONFIG_EZX_PCAP: u32 = 1;
pub const CONFIG_SENSORS_SCH56XX_COMMON_MODULE: u32 = 1;
pub const CONFIG_RTW88_8822BS_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_DCCP_MODULE: u32 = 1;
pub const CONFIG_ICPLUS_PHY_MODULE: u32 = 1;
pub const CONFIG_CEC_CH7322_MODULE: u32 = 1;
pub const CONFIG_CGROUP_HUGETLB: u32 = 1;
pub const CONFIG_UNIXWARE_DISKLABEL: u32 = 1;
pub const CONFIG_UV_SYSFS_MODULE: u32 = 1;
pub const CONFIG_SCTP_DEFAULT_COOKIE_HMAC_SHA1: u32 = 1;
pub const CONFIG_USB_U_ETHER_MODULE: u32 = 1;
pub const CONFIG_X86_NUMACHIP: u32 = 1;
pub const CONFIG_COMEDI_USBDUXFAST_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_LP872X_MODULE: u32 = 1;
pub const CONFIG_EXTCON_AXP288_MODULE: u32 = 1;
pub const CONFIG_BT_BNEP_MC_FILTER: u32 = 1;
pub const CONFIG_CRYPTO_CRC32_MODULE: u32 = 1;
pub const CONFIG_SCSI_ISCSI_ATTRS_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_DENALI_MODULE: u32 = 1;
pub const CONFIG_RUST_OVERFLOW_CHECKS: u32 = 1;
pub const CONFIG_USB_SERIAL_EMPEG_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_MAX7359_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_RTRS_CLIENT_MODULE: u32 = 1;
pub const CONFIG_IR_SONY_DECODER_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_852_MODULE: u32 = 1;
pub const CONFIG_TCG_TIS: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_IDEALTEK: u32 = 1;
pub const CONFIG_VIDEO_PVRUSB2_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_KSZ_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_COMMENT_MODULE: u32 = 1;
pub const CONFIG_NFS_SWAP: u32 = 1;
pub const CONFIG_FB_SSD1307_MODULE: u32 = 1;
pub const CONFIG_USB_ISP116X_HCD_MODULE: u32 = 1;
pub const CONFIG_RANDOMIZE_KSTACK_OFFSET_DEFAULT: u32 = 1;
pub const CONFIG_GENERIC_PTDUMP: u32 = 1;
pub const CONFIG_AMD_WBRF: u32 = 1;
pub const CONFIG_I2C_ISCH_MODULE: u32 = 1;
pub const CONFIG_USB_NET_RNDIS_HOST_MODULE: u32 = 1;
pub const CONFIG_NET: u32 = 1;
pub const CONFIG_ATARI_PARTITION: u32 = 1;
pub const CONFIG_MS5611_I2C_MODULE: u32 = 1;
pub const CONFIG_MTD_SPI_NOR_SWP_DISABLE_ON_VOLATILE: u32 = 1;
pub const CONFIG_SQUASHFS_FILE_DIRECT: u32 = 1;
pub const CONFIG_USB_OHCI_HCD_PCI: u32 = 1;
pub const CONFIG_USB_CHIPIDEA_NPCM_MODULE: u32 = 1;
pub const CONFIG_INPUT_EVDEV: u32 = 1;
pub const CONFIG_UNACCEPTED_MEMORY: u32 = 1;
pub const CONFIG_FS_ENCRYPTION_ALGS: u32 = 1;
pub const CONFIG_INTEL_ISH_FIRMWARE_DOWNLOADER_MODULE: u32 = 1;
pub const CONFIG_SND_JACK: u32 = 1;
pub const CONFIG_LEDS_SGM3140_MODULE: u32 = 1;
pub const CONFIG_AD5933_MODULE: u32 = 1;
pub const CONFIG_IDEAPAD_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_CC_HAS_AUTO_VAR_INIT_PATTERN: u32 = 1;
pub const CONFIG_SECURITY_PATH: u32 = 1;
pub const CONFIG_SND_SOC_CX2072X_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_DA9062_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TCPMSS_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_SSD1351_MODULE: u32 = 1;
pub const CONFIG_B43LEGACY_DMA: u32 = 1;
pub const CONFIG_LIDAR_LITE_V2_MODULE: u32 = 1;
pub const CONFIG_BMP280_SPI_MODULE: u32 = 1;
pub const CONFIG_NCSI_OEM_CMD_GET_MAC: u32 = 1;
pub const CONFIG_ACPI_SLEEP: u32 = 1;
pub const CONFIG_REGULATOR_TPS65132_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_VIRTUAL_CONSUMER_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_DSCP_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_WP512_MODULE: u32 = 1;
pub const CONFIG_CFAG12864B_RATE: u32 = 20;
pub const CONFIG_C2PORT_DURAMAR_2150_MODULE: u32 = 1;
pub const CONFIG_CHARLCD_BL_FLASH: u32 = 1;
pub const CONFIG_VIRTIO_DMA_SHARED_BUFFER_MODULE: u32 = 1;
pub const CONFIG_HID_DRAGONRISE_MODULE: u32 = 1;
pub const CONFIG_X86_ESPFIX64: u32 = 1;
pub const CONFIG_CRYPTO_LIB_BLAKE2S_GENERIC: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNTRACK_MODULE: u32 = 1;
pub const CONFIG_GPIO_RDC321X_MODULE: u32 = 1;
pub const CONFIG_SERIAL_KGDB_NMI: u32 = 1;
pub const CONFIG_COMEDI_ADQ12B_MODULE: u32 = 1;
pub const CONFIG_VIDEO_BT848_MODULE: u32 = 1;
pub const CONFIG_ITCO_WDT_MODULE: u32 = 1;
pub const CONFIG_AMD_XGBE_DCB: u32 = 1;
pub const CONFIG_COMEDI_NI_LABPC_MODULE: u32 = 1;
pub const CONFIG_IR_IGUANA_MODULE: u32 = 1;
pub const CONFIG_WANT_COMPAT_NETLINK_MESSAGES: u32 = 1;
pub const CONFIG_CHARGER_LP8788_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_RATEEST_MODULE: u32 = 1;
pub const CONFIG_SPI_LOOPBACK_TEST_MODULE: u32 = 1;
pub const CONFIG_FW_LOADER_USER_HELPER: u32 = 1;
pub const CONFIG_SND_ALOOP_MODULE: u32 = 1;
pub const CONFIG_ATH9K_STATION_STATISTICS: u32 = 1;
pub const CONFIG_USB_KBD_MODULE: u32 = 1;
pub const CONFIG_CAN_CTUCANFD_MODULE: u32 = 1;
pub const CONFIG_HPFS_FS_MODULE: u32 = 1;
pub const CONFIG_VIDEO_APTINA_PLL_MODULE: u32 = 1;
pub const CONFIG_PINMUX: u32 = 1;
pub const CONFIG_USB_LD_MODULE: u32 = 1;
pub const CONFIG_LAN743X_MODULE: u32 = 1;
pub const CONFIG_MTD_GEN_PROBE_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_HW_PTE_YOUNG: u32 = 1;
pub const CONFIG_SCSI_UFS_BSG: u32 = 1;
pub const CONFIG_SENSORS_NPCM7XX_MODULE: u32 = 1;
pub const CONFIG_QUOTA_TREE_MODULE: u32 = 1;
pub const CONFIG_FB_VIA_MODULE: u32 = 1;
pub const CONFIG_CAIF_NETDEV_MODULE: u32 = 1;
pub const CONFIG_INPUT_PCSPKR_MODULE: u32 = 1;
pub const CONFIG_IRQ_DOMAIN_HIERARCHY: u32 = 1;
pub const CONFIG_HVC_XEN_FRONTEND: u32 = 1;
pub const CONFIG_ATA_FORCE: u32 = 1;
pub const CONFIG_NETFILTER_BPF_LINK: u32 = 1;
pub const CONFIG_FPROBE: u32 = 1;
pub const CONFIG_DVB_AV7110_OSD: u32 = 1;
pub const CONFIG_DRM_MIPI_DBI_MODULE: u32 = 1;
pub const CONFIG_SERIO_PCIPS2_MODULE: u32 = 1;
pub const CONFIG_MPILIB: u32 = 1;
pub const CONFIG_USB_NET_CDCETHER_MODULE: u32 = 1;
pub const CONFIG_MMA9551_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_PXRC_MODULE: u32 = 1;
pub const CONFIG_PACKET: u32 = 1;
pub const CONFIG_BCACHEFS_SIX_OPTIMISTIC_SPIN: u32 = 1;
pub const CONFIG_MODULE_SRCVERSION_ALL: u32 = 1;
pub const CONFIG_RTC_DRV_M48T86_MODULE: u32 = 1;
pub const CONFIG_XFRM_ALGO_MODULE: u32 = 1;
pub const CONFIG_SND_SIMPLE_CARD_UTILS_MODULE: u32 = 1;
pub const CONFIG_INTEL_SKL_INT3472_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_TIMESTAMP: u32 = 1;
pub const CONFIG_ST_UVIS25_I2C_MODULE: u32 = 1;
pub const CONFIG_SPI_AMD_MODULE: u32 = 1;
pub const CONFIG_RMI4_I2C_MODULE: u32 = 1;
pub const CONFIG_BLK_ICQ: u32 = 1;
pub const CONFIG_HAVE_CLK_PREPARE: u32 = 1;
pub const CONFIG_VIDEO_CX88_MPEG_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_AKCIPHER2: u32 = 1;
pub const CONFIG_TAHVO_USB_MODULE: u32 = 1;
pub const CONFIG_NODES_SHIFT: u32 = 10;
pub const CONFIG_MWIFIEX_SDIO_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_IPRANGE_MODULE: u32 = 1;
pub const CONFIG_INTEL_IOATDMA_MODULE: u32 = 1;
pub const CONFIG_MANA_INFINIBAND_MODULE: u32 = 1;
pub const CONFIG_NET_CLS_BASIC_MODULE: u32 = 1;
pub const CONFIG_FPROBE_EVENTS: u32 = 1;
pub const CONFIG_AXP288_ADC_MODULE: u32 = 1;
pub const CONFIG_HARDLOCKUP_DETECTOR_COUNTS_HRTIMER: u32 = 1;
pub const CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE: u32 = 1;
pub const CONFIG_BACKLIGHT_LM3533_MODULE: u32 = 1;
pub const CONFIG_FB_IOMEM_FOPS: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2405_MODULE: u32 = 1;
pub const CONFIG_MMC_SDHCI_XENON_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_GENERIC_MODULE: u32 = 1;
pub const CONFIG_AD5764_MODULE: u32 = 1;
pub const CONFIG_I2C_TINY_USB_MODULE: u32 = 1;
pub const CONFIG_X86_ANDROID_TABLETS_MODULE: u32 = 1;
pub const CONFIG_DRM_XE_PREEMPT_TIMEOUT: u32 = 640000;
pub const CONFIG_NETROM_MODULE: u32 = 1;
pub const CONFIG_ARCH_WANT_PMD_MKWRITE: u32 = 1;
pub const CONFIG_MMC35240_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_EHL_RT5660_MACH_MODULE: u32 = 1;
pub const CONFIG_FUSION_SPI_MODULE: u32 = 1;
pub const CONFIG_BTRFS_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_EROFS_FS_PCPU_KTHREAD: u32 = 1;
pub const CONFIG_SND_HDA_CORE_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_OV534_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_TCA6416_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DT3000_MODULE: u32 = 1;
pub const CONFIG_HTS221_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_GL861_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_GVT_KVMGT_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_JITTERENTROPY_OSR: u32 = 1;
pub const CONFIG_IMA_APPRAISE: u32 = 1;
pub const CONFIG_ALTERA_MSGDMA_MODULE: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE_ROWS: u32 = 25;
pub const CONFIG_PINCTRL_MCP23S08_SPI_MODULE: u32 = 1;
pub const CONFIG_MFD_ARIZONA_I2C_MODULE: u32 = 1;
pub const CONFIG_USB_XHCI_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TLV320AIC23_I2C_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_TFTP_MODULE: u32 = 1;
pub const CONFIG_NFS_V3_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MAX6902_MODULE: u32 = 1;
pub const CONFIG_MFD_MAX8997: u32 = 1;
pub const CONFIG_PHY_TUSB1210_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ADV7604_CEC: u32 = 1;
pub const CONFIG_DVB_USB_ANYSEE_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_949_MODULE: u32 = 1;
pub const CONFIG_DVB_CX24110_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TMP102_MODULE: u32 = 1;
pub const CONFIG_NOP_TRACER: u32 = 1;
pub const CONFIG_HAVE_KVM_PFNCACHE: u32 = 1;
pub const CONFIG_LOOPBACK_TARGET_MODULE: u32 = 1;
pub const CONFIG_ISL29020_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TSL2563_MODULE: u32 = 1;
pub const CONFIG_HID_CORSAIR_MODULE: u32 = 1;
pub const CONFIG_PWM_CRC: u32 = 1;
pub const CONFIG_SND_HDA_PATCH_LOADER: u32 = 1;
pub const CONFIG_SND_SOC_AMD_ACP6x_MODULE: u32 = 1;
pub const CONFIG_XEN_XENBUS_FRONTEND: u32 = 1;
pub const CONFIG_INET: u32 = 1;
pub const CONFIG_CRYPTO_PCRYPT_MODULE: u32 = 1;
pub const CONFIG_HID_SENSOR_PRESS_MODULE: u32 = 1;
pub const CONFIG_COMEDI_CB_PCIMDDA_MODULE: u32 = 1;
pub const CONFIG_IP_ROUTE_VERBOSE: u32 = 1;
pub const CONFIG_XZ_DEC_POWERPC: u32 = 1;
pub const CONFIG_USB_MAX3421_HCD_MODULE: u32 = 1;
pub const CONFIG_DVB_RTL2832_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_MT7530_MMIO_MODULE: u32 = 1;
pub const CONFIG_INTEL_PCH_THERMAL_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ASUS_EC_MODULE: u32 = 1;
pub const CONFIG_MCTP_TRANSPORT_I3C_MODULE: u32 = 1;
pub const CONFIG_USB_MUSB_HDRC_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_NET: u32 = 1;
pub const CONFIG_MEMORY_NOTIFIER_ERROR_INJECT_MODULE: u32 = 1;
pub const CONFIG_PECI_CPU_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_SIS_I2C_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_ADDRTYPE_MODULE: u32 = 1;
pub const CONFIG_MCP4728_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_HUAWEI: u32 = 1;
pub const CONFIG_PREVENT_FIRMWARE_BUILD: u32 = 1;
pub const CONFIG_SERIAL_8250_PNP: u32 = 1;
pub const CONFIG_USB_NET_MCS7830_MODULE: u32 = 1;
pub const CONFIG_VIDEOBUF2_DVB_MODULE: u32 = 1;
pub const CONFIG_RSI_COEX: u32 = 1;
pub const CONFIG_SND_ENS1371_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_TWOFISH_MODULE: u32 = 1;
pub const CONFIG_FREEZER: u32 = 1;
pub const CONFIG_SENSORS_I5500_MODULE: u32 = 1;
pub const CONFIG_USB_F_SUBSET_MODULE: u32 = 1;
pub const CONFIG_FIREWIRE_NET_MODULE: u32 = 1;
pub const CONFIG_HAVE_HARDLOCKUP_DETECTOR_PERF: u32 = 1;
pub const CONFIG_COMEDI_ADV_PCI1724_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2413_MODULE: u32 = 1;
pub const CONFIG_USB_TEST_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_MAX11801_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8737_MODULE: u32 = 1;
pub const CONFIG_ADAPTEC_STARFIRE_MODULE: u32 = 1;
pub const CONFIG_BT_MODULE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_TTY_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_BCM590XX_MODULE: u32 = 1;
pub const CONFIG_BT_HCIVHCI_MODULE: u32 = 1;
pub const CONFIG_INPUT_CM109_MODULE: u32 = 1;
pub const CONFIG_AXP288_FUEL_GAUGE_MODULE: u32 = 1;
pub const CONFIG_PCI_DOMAINS: u32 = 1;
pub const CONFIG_WWAN_HWSIM_MODULE: u32 = 1;
pub const CONFIG_MS5637_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_88PM800_MODULE: u32 = 1;
pub const CONFIG_NFT_QUEUE_MODULE: u32 = 1;
pub const CONFIG_LCD_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_MXL111SF_MODULE: u32 = 1;
pub const CONFIG_TPS6594_ESM_MODULE: u32 = 1;
pub const CONFIG_SENSORS_IT87_MODULE: u32 = 1;
pub const CONFIG_LPC_SCH_MODULE: u32 = 1;
pub const CONFIG_NET_CLS_ACT: u32 = 1;
pub const CONFIG_MLX90614_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5682_I2C_MODULE: u32 = 1;
pub const CONFIG_HID_BIGBEN_FF_MODULE: u32 = 1;
pub const CONFIG_REED_SOLOMON_MODULE: u32 = 1;
pub const CONFIG_SCSI_FDOMAIN_MODULE: u32 = 1;
pub const CONFIG_CIFS_DFS_UPCALL: u32 = 1;
pub const CONFIG_NET_VENDOR_CHELSIO: u32 = 1;
pub const CONFIG_LZ4HC_COMPRESS_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADL_PCI6208_MODULE: u32 = 1;
pub const CONFIG_HDLC_RAW_ETH_MODULE: u32 = 1;
pub const CONFIG_COMEDI_MODULE: u32 = 1;
pub const CONFIG_MFD_INTEL_PMC_BXT_MODULE: u32 = 1;
pub const CONFIG_XEN_PV_MSR_SAFE: u32 = 1;
pub const CONFIG_PINCTRL_LEWISBURG_MODULE: u32 = 1;
pub const CONFIG_EFIVAR_FS: u32 = 1;
pub const CONFIG_BRIDGE_EBT_BROUTE_MODULE: u32 = 1;
pub const CONFIG_USB_NET_SMSC75XX_MODULE: u32 = 1;
pub const CONFIG_BE2NET_MODULE: u32 = 1;
pub const CONFIG_PARPORT_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_VMAP_STACK: u32 = 1;
pub const CONFIG_SND_SOC_AMD_MACH_COMMON_MODULE: u32 = 1;
pub const CONFIG_VORTEX_MODULE: u32 = 1;
pub const CONFIG_IPVTAP_MODULE: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_DECTLK_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_IPVS_MODULE: u32 = 1;
pub const CONFIG_DEV_DAX_KMEM_MODULE: u32 = 1;
pub const CONFIG_TIPC_MEDIA_UDP: u32 = 1;
pub const CONFIG_VMWARE_VMCI_VSOCKETS_MODULE: u32 = 1;
pub const CONFIG_X86_DEBUGCTLMSR: u32 = 1;
pub const CONFIG_HDLC_MODULE: u32 = 1;
pub const CONFIG_NET_CLS_BPF_MODULE: u32 = 1;
pub const CONFIG_ATM_SOLOS_MODULE: u32 = 1;
pub const CONFIG_8139TOO_PIO: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_GLK_DA7219_MAX98357A_MACH_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_BRCM_PREPEND_MODULE: u32 = 1;
pub const CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN: &[u8; 11usize] = b"kernel.org\0";
pub const CONFIG_BT_LE_L2CAP_ECRED: u32 = 1;
pub const CONFIG_IP_SET_MAX: u32 = 256;
pub const CONFIG_HAPPYMEAL_MODULE: u32 = 1;
pub const CONFIG_HID_WACOM_MODULE: u32 = 1;
pub const CONFIG_USB_F_ACM_MODULE: u32 = 1;
pub const CONFIG_QLCNIC_DCB: u32 = 1;
pub const CONFIG_USB_SERIAL_CP210X_MODULE: u32 = 1;
pub const CONFIG_SND_PCMCIA: u32 = 1;
pub const CONFIG_HMM_MIRROR: u32 = 1;
pub const CONFIG_NET_SCH_SFQ_MODULE: u32 = 1;
pub const CONFIG_RTC_LIB: u32 = 1;
pub const CONFIG_DEVFREQ_GOV_POWERSAVE: u32 = 1;
pub const CONFIG_FW_LOADER_PAGED_BUF: u32 = 1;
pub const CONFIG_NET_SCH_CBS_MODULE: u32 = 1;
pub const CONFIG_CHT_WC_PMIC_OPREGION: u32 = 1;
pub const CONFIG_NVDIMM_DAX: u32 = 1;
pub const CONFIG_MFD_RT5120_MODULE: u32 = 1;
pub const CONFIG_X86_LOCAL_APIC: u32 = 1;
pub const CONFIG_ACER_WIRELESS_MODULE: u32 = 1;
pub const CONFIG_USB_GOKU_MODULE: u32 = 1;
pub const CONFIG_USB_UEAGLEATM_MODULE: u32 = 1;
pub const CONFIG_SPI_LANTIQ_SSC_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_POLICY_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADV_PCI1760_MODULE: u32 = 1;
pub const CONFIG_MWL8K_MODULE: u32 = 1;
pub const CONFIG_EFI_EMBEDDED_FIRMWARE: u32 = 1;
pub const CONFIG_HAVE_KPROBES: u32 = 1;
pub const CONFIG_NUMA_BALANCING_DEFAULT_ENABLED: u32 = 1;
pub const CONFIG_FB_TFT_AGM1264K_FL_MODULE: u32 = 1;
pub const CONFIG_SND_DESIGNWARE_PCM: u32 = 1;
pub const CONFIG_SENSORS_LTC2992_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS: u32 = 1;
pub const CONFIG_INTEL_TCC: u32 = 1;
pub const CONFIG_TPS65010_MODULE: u32 = 1;
pub const CONFIG_IP_ROUTE_CLASSID: u32 = 1;
pub const CONFIG_MOUSE_SYNAPTICS_I2C_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TEE_MODULE: u32 = 1;
pub const CONFIG_SND_USB_VARIAX_MODULE: u32 = 1;
pub const CONFIG_HPWDT_NMI_DECODING: u32 = 1;
pub const CONFIG_ENC28J60_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_TOUCHKIT: u32 = 1;
pub const CONFIG_PWM_LP3943_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_XSENS_MT_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX88_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_ITM: u32 = 1;
pub const CONFIG_X86_UMIP: u32 = 1;
pub const CONFIG_CRYPTO_AES: u32 = 1;
pub const CONFIG_HAVE_GENERIC_VDSO: u32 = 1;
pub const CONFIG_BACKLIGHT_LP855X_MODULE: u32 = 1;
pub const CONFIG_DVB_DIB7000P_MODULE: u32 = 1;
pub const CONFIG_MLX5_EN_TLS: u32 = 1;
pub const CONFIG_GPIOLIB: u32 = 1;
pub const CONFIG_SSB_MODULE: u32 = 1;
pub const CONFIG_ZONE_DEVICE: u32 = 1;
pub const CONFIG_REGULATOR_ISL6271A_MODULE: u32 = 1;
pub const CONFIG_MFD_INTEL_M10_BMC_CORE_MODULE: u32 = 1;
pub const CONFIG_FUTEX_PI: u32 = 1;
pub const CONFIG_SND_SOC_WM8961_MODULE: u32 = 1;
pub const CONFIG_FB_MATROX_I2C_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_MXIC_MODULE: u32 = 1;
pub const CONFIG_BMC150_ACCEL_SPI_MODULE: u32 = 1;
pub const CONFIG_I2C_STUB_MODULE: u32 = 1;
pub const CONFIG_EXTCON_MAX8997_MODULE: u32 = 1;
pub const CONFIG_REGMAP_SPI_AVMM_MODULE: u32 = 1;
pub const CONFIG_DM_BIO_PRISON_MODULE: u32 = 1;
pub const CONFIG_TMPFS_QUOTA: u32 = 1;
pub const CONFIG_INPUT_DRV2667_HAPTICS_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CPU_VULNERABILITIES: u32 = 1;
pub const CONFIG_VIDEO_MT9T112_MODULE: u32 = 1;
pub const CONFIG_VIDEO_EM28XX_RC_MODULE: u32 = 1;
pub const CONFIG_NFT_LIMIT_MODULE: u32 = 1;
pub const CONFIG_DA_MON_EVENTS: u32 = 1;
pub const CONFIG_HAVE_ARCH_WITHIN_STACK_FRAMES: u32 = 1;
pub const CONFIG_RADIO_TEA5764_MODULE: u32 = 1;
pub const CONFIG_AQTION_MODULE: u32 = 1;
pub const CONFIG_DVB_LNBH25_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_MCP23S08_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SPCA1528_MODULE: u32 = 1;
pub const CONFIG_LEDS_TLC591XX_MODULE: u32 = 1;
pub const CONFIG_FB_SVGALIB_MODULE: u32 = 1;
pub const CONFIG_BMC150_MAGN_MODULE: u32 = 1;
pub const CONFIG_TI_ADC128S052_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_KABYLAKE_MODULE: u32 = 1;
pub const CONFIG_MHI_WWAN_MBIM_MODULE: u32 = 1;
pub const CONFIG_MHI_BUS_PCI_GENERIC_MODULE: u32 = 1;
pub const CONFIG_KEY_NOTIFICATIONS: u32 = 1;
pub const CONFIG_AD2S1210_MODULE: u32 = 1;
pub const CONFIG_HID_PID: u32 = 1;
pub const CONFIG_SND_SOC_RT700_SDW_MODULE: u32 = 1;
pub const CONFIG_NV_TCO_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_QT2_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_HIRSCHMANN_HELLCREEK_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM179X_MODULE: u32 = 1;
pub const CONFIG_SMSC9420_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCI_DRIVERS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX6639_MODULE: u32 = 1;
pub const CONFIG_ATH11K_AHB_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_NAU8825_MODULE: u32 = 1;
pub const CONFIG_CHT_DC_TI_PMIC_OPREGION: u32 = 1;
pub const CONFIG_AUTOFS_FS_MODULE: u32 = 1;
pub const CONFIG_SCD30_SERIAL_MODULE: u32 = 1;
pub const CONFIG_GAMEPORT_MODULE: u32 = 1;
pub const CONFIG_ISO9660_FS_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_CT_MODULE: u32 = 1;
pub const CONFIG_SKY2_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_NAT_MODULE: u32 = 1;
pub const CONFIG_AD7793_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_H4: u32 = 1;
pub const CONFIG_LEDS_NIC78BX_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_MIDI: u32 = 1;
pub const CONFIG_RTC_DRV_DS3232_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM3168A_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MC13783_MODULE: u32 = 1;
pub const CONFIG_GPIO_ELKHARTLAKE_MODULE: u32 = 1;
pub const CONFIG_PACKING: u32 = 1;
pub const CONFIG_CROS_KBD_LED_BACKLIGHT_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_DMIC_MODULE: u32 = 1;
pub const CONFIG_SND_PCM_ELD: u32 = 1;
pub const CONFIG_XEN_WDT_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_M920X_MODULE: u32 = 1;
pub const CONFIG_MLX5_SW_STEERING: u32 = 1;
pub const CONFIG_UIO_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_TLS_DEVICE_MODULE: u32 = 1;
pub const CONFIG_NVMEM_RMEM_MODULE: u32 = 1;
pub const CONFIG_HID_WALTOP_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_LM3630A_MODULE: u32 = 1;
pub const CONFIG_ADIS16136_MODULE: u32 = 1;
pub const CONFIG_GPIO_RC5T583: u32 = 1;
pub const CONFIG_VIDEO_ADV7170_MODULE: u32 = 1;
pub const CONFIG_RTW89_8852CE_MODULE: u32 = 1;
pub const CONFIG_UIO_DMEM_GENIRQ_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TAS5086_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_AQUANTIA: u32 = 1;
pub const CONFIG_SCSI_VIRTIO: u32 = 1;
pub const CONFIG_NF_CONNTRACK_MARK: u32 = 1;
pub const CONFIG_IDLE_PAGE_TRACKING: u32 = 1;
pub const CONFIG_MAX5522_MODULE: u32 = 1;
pub const CONFIG_INTERVAL_TREE_SPAN_ITER: u32 = 1;
pub const CONFIG_HVC_DRIVER: u32 = 1;
pub const CONFIG_BLK_DEV_PCIESSD_MTIP32XX_MODULE: u32 = 1;
pub const CONFIG_NETFILTER: u32 = 1;
pub const CONFIG_NFT_REJECT_IPV4_MODULE: u32 = 1;
pub const CONFIG_RC_LOOPBACK_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_INTEL_SOUNDWIRE_LINK_BASELINE_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_HASHLIMIT_MODULE: u32 = 1;
pub const CONFIG_MODULE_SIG: u32 = 1;
pub const CONFIG_BRIDGE_EBT_AMONG_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DT2814_MODULE: u32 = 1;
pub const CONFIG_B53_MODULE: u32 = 1;
pub const CONFIG_ATH9K_WOW: u32 = 1;
pub const CONFIG_B43_PIO: u32 = 1;
pub const CONFIG_BACKLIGHT_88PM860X_MODULE: u32 = 1;
pub const CONFIG_B43_BUSES_BCMA_AND_SSB: u32 = 1;
pub const CONFIG_ADIS16201_MODULE: u32 = 1;
pub const CONFIG_USB_R8A66597_HCD_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TWL4030_MODULE: u32 = 1;
pub const CONFIG_X86_MSR_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_KASAN: u32 = 1;
pub const CONFIG_LOCK_DOWN_IN_SECURE_BOOT: u32 = 1;
pub const CONFIG_MLX90635_MODULE: u32 = 1;
pub const CONFIG_BME680_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_SMSC: u32 = 1;
pub const CONFIG_UACCE_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_NETLINK_ACCT_MODULE: u32 = 1;
pub const CONFIG_LEDS_CHT_WCOVE_MODULE: u32 = 1;
pub const CONFIG_COMEDI_8254_MODULE: u32 = 1;
pub const CONFIG_BOSCH_BNO055_I2C_MODULE: u32 = 1;
pub const CONFIG_NFS_DISABLE_UDP_SUPPORT: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CLUSTER_MODULE: u32 = 1;
pub const CONFIG_USB_KC2190: u32 = 1;
pub const CONFIG_R6040_MODULE: u32 = 1;
pub const CONFIG_PATA_PARPORT_EPATC8: u32 = 1;
pub const CONFIG_TOOLS_SUPPORT_RELR: u32 = 1;
pub const CONFIG_SND_SOC_CS35L56_I2C_MODULE: u32 = 1;
pub const CONFIG_F2FS_FS_COMPRESSION: u32 = 1;
pub const CONFIG_NET_DSA_TAG_NONE_MODULE: u32 = 1;
pub const CONFIG_NSM_MODULE: u32 = 1;
pub const CONFIG_USB_MDC800_MODULE: u32 = 1;
pub const CONFIG_GPIO_AMD_FCH_MODULE: u32 = 1;
pub const CONFIG_6LOWPAN_MODULE: u32 = 1;
pub const CONFIG_VIPERBOARD_ADC_MODULE: u32 = 1;
pub const CONFIG_HWMON_VID_MODULE: u32 = 1;
pub const CONFIG_SERIO_SERPORT_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ME4000_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_950_MODULE: u32 = 1;
pub const CONFIG_DVB_STV0297_MODULE: u32 = 1;
pub const CONFIG_DVB_TTUSB_DEC_MODULE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_ONESHOT_MODULE: u32 = 1;
pub const CONFIG_HAVE_NMI: u32 = 1;
pub const CONFIG_DRM_SSD130X_MODULE: u32 = 1;
pub const CONFIG_LIRC: u32 = 1;
pub const CONFIG_INPUT_PWM_BEEPER_MODULE: u32 = 1;
pub const CONFIG_SCSI_AIC94XX_MODULE: u32 = 1;
pub const CONFIG_BT_BNEP_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_QFQ_MODULE: u32 = 1;
pub const CONFIG_DVB_TDA826X_MODULE: u32 = 1;
pub const CONFIG_COMEDI_MPC624_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_RAM_COUNT: u32 = 16;
pub const CONFIG_NFT_REJECT_NETDEV_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_RZN1_A5PSW_MODULE: u32 = 1;
pub const CONFIG_IXGBEVF_MODULE: u32 = 1;
pub const CONFIG_SND_AC97_POWER_SAVE_DEFAULT: u32 = 0;
pub const CONFIG_TABLET_SERIAL_WACOM4_MODULE: u32 = 1;
pub const CONFIG_THINKPAD_ACPI_DEBUGFACILITIES: u32 = 1;
pub const CONFIG_DVB_NGENE_MODULE: u32 = 1;
pub const CONFIG_RD_XZ: u32 = 1;
pub const CONFIG_AUXILIARY_BUS: u32 = 1;
pub const CONFIG_IP_MROUTE: u32 = 1;
pub const CONFIG_VIDEO_MXB_MODULE: u32 = 1;
pub const CONFIG_PREEMPT_RCU: u32 = 1;
pub const CONFIG_SYSTEM_EXTRA_CERTIFICATE: u32 = 1;
pub const CONFIG_SND_SOC_TLV320AIC23_MODULE: u32 = 1;
pub const CONFIG_VGA_CONSOLE: u32 = 1;
pub const CONFIG_DEVFREQ_THERMAL: u32 = 1;
pub const CONFIG_CRYPTO_ECDH_MODULE: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS: u32 = 1;
pub const CONFIG_NET_ACT_TUNNEL_KEY_MODULE: u32 = 1;
pub const CONFIG_RPMSG_WWAN_CTRL_MODULE: u32 = 1;
pub const CONFIG_HID_RMI_MODULE: u32 = 1;
pub const CONFIG_USB_F_UAC1_LEGACY_MODULE: u32 = 1;
pub const CONFIG_ATA_VERBOSE_ERROR: u32 = 1;
pub const CONFIG_SENSORS_PECI_CPUTEMP_MODULE: u32 = 1;
pub const CONFIG_MT76_USB_MODULE: u32 = 1;
pub const CONFIG_XEN_BLKDEV_FRONTEND: u32 = 1;
pub const CONFIG_NF_CONNTRACK_SNMP_MODULE: u32 = 1;
pub const CONFIG_FPGA_DFL_NIOS_INTEL_PAC_N3000_MODULE: u32 = 1;
pub const CONFIG_UEFI_CPER_X86: u32 = 1;
pub const CONFIG_CM3232_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_AUDIO_MODULE: u32 = 1;
pub const CONFIG_SND_DRIVERS: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_KEXEC_SIG_FORCE: u32 = 1;
pub const CONFIG_USB_SERIAL_BELKIN_MODULE: u32 = 1;
pub const CONFIG_X86_PLATFORM_DRIVERS_HP: u32 = 1;
pub const CONFIG_W1_MASTER_DS2490_MODULE: u32 = 1;
pub const CONFIG_SPI_INTEL_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MT2266_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_GREEK_MODULE: u32 = 1;
pub const CONFIG_NET_FLOW_LIMIT: u32 = 1;
pub const CONFIG_XFS_FS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_DME1737_MODULE: u32 = 1;
pub const CONFIG_INPUT_KEYSPAN_REMOTE_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_PAC7302_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_CS47L92: u32 = 1;
pub const CONFIG_LOCKDEP_SUPPORT: u32 = 1;
pub const CONFIG_X86_MCE_INJECT_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ELO_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_869_MODULE: u32 = 1;
pub const CONFIG_SENSORS_NCT7904_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_MPLS_MODULE: u32 = 1;
pub const CONFIG_SND_AZT3328_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ML86V7667_MODULE: u32 = 1;
pub const CONFIG_SND_AC97_POWER_SAVE: u32 = 1;
pub const CONFIG_NET_SCH_CAKE_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_TARGET_MASQUERADE_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_PALMAS_MODULE: u32 = 1;
pub const CONFIG_NFT_REDIR_MODULE: u32 = 1;
pub const CONFIG_SATA_VIA_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCMMIO_MODULE: u32 = 1;
pub const CONFIG_DM_VERITY_VERIFY_ROOTHASH_SIG_SECONDARY_KEYRING: u32 = 1;
pub const CONFIG_CRYPTO_LIB_CURVE25519_GENERIC_MODULE: u32 = 1;
pub const CONFIG_ACPI_PROCESSOR_IDLE: u32 = 1;
pub const CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION: u32 = 1;
pub const CONFIG_NO_HZ: u32 = 1;
pub const CONFIG_INTEL_SOC_PMIC: u32 = 1;
pub const CONFIG_SND_SOC_RT1308_SDW_MODULE: u32 = 1;
pub const CONFIG_ARCH_WANT_HUGE_PMD_SHARE: u32 = 1;
pub const CONFIG_BMI160_MODULE: u32 = 1;
pub const CONFIG_RTW88_8723DS_MODULE: u32 = 1;
pub const CONFIG_NFT_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TLV320ADC3XXX_MODULE: u32 = 1;
pub const CONFIG_POSIX_MQUEUE: u32 = 1;
pub const CONFIG_CC_HAS_WORKING_NOSANITIZE_ADDRESS: u32 = 1;
pub const CONFIG_TI_LMP92064_MODULE: u32 = 1;
pub const CONFIG_NOUVEAU_DEBUG: u32 = 5;
pub const CONFIG_MLX5_FPGA: u32 = 1;
pub const CONFIG_NETFILTER_INGRESS: u32 = 1;
pub const CONFIG_CRYPTO_LIB_GF128MUL: u32 = 1;
pub const CONFIG_SND_SOC_TOPOLOGY: u32 = 1;
pub const CONFIG_REGULATOR_MAX20086_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TOUCHIT213_MODULE: u32 = 1;
pub const CONFIG_KVM_GENERIC_PRIVATE_MEM: u32 = 1;
pub const CONFIG_GPIO_MADERA_MODULE: u32 = 1;
pub const CONFIG_GPIO_DWAPB_MODULE: u32 = 1;
pub const CONFIG_LTC2632_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_RT6190_MODULE: u32 = 1;
pub const CONFIG_TRUSTED_KEYS_TPM: u32 = 1;
pub const CONFIG_VIDEO_THP7312_MODULE: u32 = 1;
pub const CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT: u32 = 1;
pub const CONFIG_FB_PM2_FIFO_DISCONNECT: u32 = 1;
pub const CONFIG_TOUCHSCREEN_STMFTS_MODULE: u32 = 1;
pub const CONFIG_GNSS_USB_MODULE: u32 = 1;
pub const CONFIG_SND_UMP_LEGACY_RAWMIDI: u32 = 1;
pub const CONFIG_SENSORS_LM83_MODULE: u32 = 1;
pub const CONFIG_USB_NET_CDC_MBIM_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TMP108_MODULE: u32 = 1;
pub const CONFIG_MT76x0E_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE: u32 = 256;
pub const CONFIG_VIDEO_MT9M114_MODULE: u32 = 1;
pub const CONFIG_ACENIC_MODULE: u32 = 1;
pub const CONFIG_ARCH_MIGHT_HAVE_PC_SERIO: u32 = 1;
pub const CONFIG_PSTORE_RAM_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCM3724_MODULE: u32 = 1;
pub const CONFIG_LEDS_BLINKM_MODULE: u32 = 1;
pub const CONFIG_INPUT_PWM_VIBRA_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_STAT: u32 = 1;
pub const CONFIG_JFS_STATISTICS: u32 = 1;
pub const CONFIG_COMEDI_NI_DAQ_700_CS_MODULE: u32 = 1;
pub const CONFIG_ISCSI_IBFT_MODULE: u32 = 1;
pub const CONFIG_NET_XGRESS: u32 = 1;
pub const CONFIG_DRM_AMD_DC_SI: u32 = 1;
pub const CONFIG_SPI_PXA2XX_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_SMC91C92_MODULE: u32 = 1;
pub const CONFIG_WILC1000_HW_OOB_INTR: u32 = 1;
pub const CONFIG_BT_HCIDTL1_MODULE: u32 = 1;
pub const CONFIG_TIFM_CORE_MODULE: u32 = 1;
pub const CONFIG_XEN_PRIVCMD_MODULE: u32 = 1;
pub const CONFIG_FXAS21002C_SPI_MODULE: u32 = 1;
pub const CONFIG_TI_ADS7924_MODULE: u32 = 1;
pub const CONFIG_GENERIC_STRNCPY_FROM_USER: u32 = 1;
pub const CONFIG_VIDEO_IMX296_MODULE: u32 = 1;
pub const CONFIG_FUSION_SAS_MODULE: u32 = 1;
pub const CONFIG_ADMV8818_MODULE: u32 = 1;
pub const CONFIG_MEDIA_PLATFORM_SUPPORT: u32 = 1;
pub const CONFIG_FB_TFT_SSD1331_MODULE: u32 = 1;
pub const CONFIG_MTD_BLKDEVS_MODULE: u32 = 1;
pub const CONFIG_GPIO_KEMPLD_MODULE: u32 = 1;
pub const CONFIG_DVB_TDA10086_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_3W_XXXX_RAID_MODULE: u32 = 1;
pub const CONFIG_HAVE_RSEQ: u32 = 1;
pub const CONFIG_MEMSTICK_R592_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_MQPRIO_MODULE: u32 = 1;
pub const CONFIG_REGMAP_SOUNDWIRE_MBQ_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_NETMAP_MODULE: u32 = 1;
pub const CONFIG_MLX5_CORE_EN_DCB: u32 = 1;
pub const CONFIG_DEV_DAX_CXL_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MAX98088_MODULE: u32 = 1;
pub const CONFIG_CONTEXT_TRACKING_IDLE: u32 = 1;
pub const CONFIG_SENSORS_EMC2305_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ILITEK_MODULE: u32 = 1;
pub const CONFIG_HID_ELAN_MODULE: u32 = 1;
pub const CONFIG_VIDEO_VPX3220_MODULE: u32 = 1;
pub const CONFIG_APDS9802ALS_MODULE: u32 = 1;
pub const CONFIG_DVB_NXT6000_MODULE: u32 = 1;
pub const CONFIG_SPMI_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_NITROX_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LTC4286: u32 = 1;
pub const CONFIG_MANTIS_CORE_MODULE: u32 = 1;
pub const CONFIG_PATA_MARVELL_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_SCTP_MODULE: u32 = 1;
pub const CONFIG_GPIO_SIOX_MODULE: u32 = 1;
pub const CONFIG_SERIO_GPIO_PS2_MODULE: u32 = 1;
pub const CONFIG_SATA_SIL24_MODULE: u32 = 1;
pub const CONFIG_RTL8723BS_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT1318_SDW_MODULE: u32 = 1;
pub const CONFIG_SMS_SIANO_RC: u32 = 1;
pub const CONFIG_SND_SOC_CS42L52_MODULE: u32 = 1;
pub const CONFIG_CRASH_CORE: u32 = 1;
pub const CONFIG_ISL29125_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_RT298_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_DEC: u32 = 1;
pub const CONFIG_MDIO_CAVIUM_MODULE: u32 = 1;
pub const CONFIG_NLS_ISO8859_15_MODULE: u32 = 1;
pub const CONFIG_HID_SENSOR_MAGNETOMETER_3D_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_EETI_MODULE: u32 = 1;
pub const CONFIG_TIPC_CRYPTO: u32 = 1;
pub const CONFIG_USB_ROLES_INTEL_XHCI_MODULE: u32 = 1;
pub const CONFIG_SENSORS_VIA686A_MODULE: u32 = 1;
pub const CONFIG_QRTR_MHI_MODULE: u32 = 1;
pub const CONFIG_INET6_ESP_MODULE: u32 = 1;
pub const CONFIG_EARLY_PRINTK_USB_XDBC: u32 = 1;
pub const CONFIG_QRTR_MODULE: u32 = 1;
pub const CONFIG_RV_REACT_PANIC: u32 = 1;
pub const CONFIG_IP_VS_WRR_MODULE: u32 = 1;
pub const CONFIG_PCI_DOE: u32 = 1;
pub const CONFIG_INTEL_IOMMU_SVM: u32 = 1;
pub const CONFIG_NET_NSH_MODULE: u32 = 1;
pub const CONFIG_UCSI_CCG_MODULE: u32 = 1;
pub const CONFIG_ATH5K_MODULE: u32 = 1;
pub const CONFIG_VIDEO_FB_IVTV_MODULE: u32 = 1;
pub const CONFIG_SURFACE_AGGREGATOR_HUB_MODULE: u32 = 1;
pub const CONFIG_ACPI_BUTTON: u32 = 1;
pub const CONFIG_LEDS_LM355x_MODULE: u32 = 1;
pub const CONFIG_ILLEGAL_POINTER_VALUE: i64 = -2401263026318606336;
pub const CONFIG_CRYPTO_DEV_CCP_CRYPTO_MODULE: u32 = 1;
pub const CONFIG_GENERIC_GETTIMEOFDAY: u32 = 1;
pub const CONFIG_UIO_NETX_MODULE: u32 = 1;
pub const CONFIG_CAN_MCP251XFD_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_SET_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_CROATIAN_MODULE: u32 = 1;
pub const CONFIG_SFC_MTD: u32 = 1;
pub const CONFIG_PCS_XPCS_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MAX98090_MODULE: u32 = 1;
pub const CONFIG_USB_XHCI_PCI_RENESAS_MODULE: u32 = 1;
pub const CONFIG_ARCH_USE_MEMTEST: u32 = 1;
pub const CONFIG_TASKSTATS: u32 = 1;
pub const CONFIG_EXTCON_GPIO_MODULE: u32 = 1;
pub const CONFIG_VIDEO_LM3560_MODULE: u32 = 1;
pub const CONFIG_ARCNET_1201_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_932_MODULE: u32 = 1;
pub const CONFIG_MCB_MODULE: u32 = 1;
pub const CONFIG_RT2X00_LIB_MMIO_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CRC32C_INTEL: u32 = 1;
pub const CONFIG_WILC1000_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_ICELAND_MODULE: u32 = 1;
pub const CONFIG_SND_ATMEL_SOC_MODULE: u32 = 1;
pub const CONFIG_MEDIA_SUBDRV_AUTOSELECT: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TSC200X_CORE_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_ECC_SW_HAMMING: u32 = 1;
pub const CONFIG_CAN_PLX_PCI_MODULE: u32 = 1;
pub const CONFIG_VIDEO_GS1662_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8940_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5677_SPI_MODULE: u32 = 1;
pub const CONFIG_USB_FUNCTIONFS_GENERIC: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BYTCR_RT5651_MACH_MODULE: u32 = 1;
pub const CONFIG_JFS_POSIX_ACL: u32 = 1;
pub const CONFIG_PPPOE_HASH_BITS: u32 = 4;
pub const CONFIG_I2C_ALI1563_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_PENSANDO: u32 = 1;
pub const CONFIG_IP6_NF_FILTER_MODULE: u32 = 1;
pub const CONFIG_DELL_WMI_DESCRIPTOR_MODULE: u32 = 1;
pub const CONFIG_SYSTEM_DATA_VERIFICATION: u32 = 1;
pub const CONFIG_CRAMFS_MTD: u32 = 1;
pub const CONFIG_INPUT_MOUSEDEV_SCREEN_X: u32 = 1024;
pub const CONFIG_MDIO_REGMAP_MODULE: u32 = 1;
pub const CONFIG_EFI_ESRT: u32 = 1;
pub const CONFIG_SND_SOC_AMD_ACP_LEGACY_COMMON_MODULE: u32 = 1;
pub const CONFIG_NEED_DMA_MAP_STATE: u32 = 1;
pub const CONFIG_FB_TFT_ILI9340_MODULE: u32 = 1;
pub const CONFIG_IIO_TRIGGERED_EVENT_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_MODULE: u32 = 1;
pub const CONFIG_SENSORS_G762_MODULE: u32 = 1;
pub const CONFIG_IIO_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_PREALLOC_SIZE: u32 = 0;
pub const CONFIG_GARP_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_AHA152X_MODULE: u32 = 1;
pub const CONFIG_INPUT_TWL6040_VIBRA_MODULE: u32 = 1;
pub const CONFIG_RT2500USB_MODULE: u32 = 1;
pub const CONFIG_YENTA_ENE_TUNE: u32 = 1;
pub const CONFIG_RCU_LAZY: u32 = 1;
pub const CONFIG_MOUSE_PS2_LIFEBOOK: u32 = 1;
pub const CONFIG_SERIO_LIBPS2: u32 = 1;
pub const CONFIG_MFD_SMPRO_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_DRBD_MODULE: u32 = 1;
pub const CONFIG_IP_VS_PROTO_TCP: u32 = 1;
pub const CONFIG_QED_OOO: u32 = 1;
pub const CONFIG_SND_SOC_SOF_ACPI_MODULE: u32 = 1;
pub const CONFIG_ISCSI_BOOT_SYSFS_MODULE: u32 = 1;
pub const CONFIG_X86_CPUID_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_QAT_C3XXXVF_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_RED_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AW8738_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_NFACCT_MODULE: u32 = 1;
pub const CONFIG_SERIAL_SPRD_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNBYTES_MODULE: u32 = 1;
pub const CONFIG_KDB_CONTINUE_CATASTROPHIC: u32 = 0;
pub const CONFIG_F2FS_FS_LZ4HC: u32 = 1;
pub const CONFIG_REGULATOR_RT5739_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_METRO_MODULE: u32 = 1;
pub const CONFIG_USB_PRINTER_MODULE: u32 = 1;
pub const CONFIG_FONT_8x8: u32 = 1;
pub const CONFIG_SSB_SPROM: u32 = 1;
pub const CONFIG_ACPI_PCC: u32 = 1;
pub const CONFIG_UBUNTU_HOST_MODULE: u32 = 1;
pub const CONFIG_SOUNDWIRE_AMD_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WCD938X_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_PAC207_MODULE: u32 = 1;
pub const CONFIG_RAPIDIO_RXS_GEN3_MODULE: u32 = 1;
pub const CONFIG_MITIGATION_SPECTRE_BHI: u32 = 1;
pub const CONFIG_VIDEO_RDACM20_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_ATHEROS: u32 = 1;
pub const CONFIG_USB_SERIAL_IR_MODULE: u32 = 1;
pub const CONFIG_SENSORS_PECI_MODULE: u32 = 1;
pub const CONFIG_IIO_CROS_EC_BARO_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_RTQ2208_MODULE: u32 = 1;
pub const CONFIG_PATA_PARPORT_EPIA_MODULE: u32 = 1;
pub const CONFIG_SKGE_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DT9812_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_ACT8865_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AK4104_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT712_SDCA_DMIC_SDW_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_HDA_DSP_COMMON_MODULE: u32 = 1;
pub const CONFIG_INPUT_DA9055_ONKEY_MODULE: u32 = 1;
pub const CONFIG_TCM_PSCSI_MODULE: u32 = 1;
pub const CONFIG_RELOCATABLE: u32 = 1;
pub const CONFIG_DMARD10_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_POLY1305_MODULE: u32 = 1;
pub const CONFIG_QUEUED_SPINLOCKS: u32 = 1;
pub const CONFIG_XOR_BLOCKS_MODULE: u32 = 1;
pub const CONFIG_ADMV1013_MODULE: u32 = 1;
pub const CONFIG_AD8801_MODULE: u32 = 1;
pub const CONFIG_HID_TWINHAN_MODULE: u32 = 1;
pub const CONFIG_NFS_V4_1_MIGRATION: u32 = 1;
pub const CONFIG_SENSORS_NTC_THERMISTOR_MODULE: u32 = 1;
pub const CONFIG_TIME_NS: u32 = 1;
pub const CONFIG_ADF4371_MODULE: u32 = 1;
pub const CONFIG_SPI_OC_TINY_MODULE: u32 = 1;
pub const CONFIG_AS3935_MODULE: u32 = 1;
pub const CONFIG_MISDN_L1OIP_MODULE: u32 = 1;
pub const CONFIG_DVB_PT1_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_SUN: u32 = 1;
pub const CONFIG_DMIID: u32 = 1;
pub const CONFIG_AS_HAS_NON_CONST_ULEB128: u32 = 1;
pub const CONFIG_ARCH_HAS_MEM_ENCRYPT: u32 = 1;
pub const CONFIG_PANIC_TIMEOUT: u32 = 0;
pub const CONFIG_AMT_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MAX20411_MODULE: u32 = 1;
pub const CONFIG_SENSORS_DS1621_MODULE: u32 = 1;
pub const CONFIG_ASUS_WMI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_IMG_PARALLEL_OUT_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_OVS: u32 = 1;
pub const CONFIG_PC104: u32 = 1;
pub const CONFIG_USB_LGM_PHY_MODULE: u32 = 1;
pub const CONFIG_MMC_TOSHIBA_PCI_MODULE: u32 = 1;
pub const CONFIG_QUOTA_NETLINK_INTERFACE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BDW_RT5677_MACH_MODULE: u32 = 1;
pub const CONFIG_INPUT_JOYSTICK: u32 = 1;
pub const CONFIG_QNX4FS_FS_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_SIMP_MODULE: u32 = 1;
pub const CONFIG_SENSORS_RM3100_I2C_MODULE: u32 = 1;
pub const CONFIG_PSE_REGULATOR_MODULE: u32 = 1;
pub const CONFIG_USB_OXU210HP_HCD_MODULE: u32 = 1;
pub const CONFIG_RT2X00_LIB_MODULE: u32 = 1;
pub const CONFIG_USB_DWC2: u32 = 1;
pub const CONFIG_HID_BATTERY_STRENGTH: u32 = 1;
pub const CONFIG_PM_GENERIC_DOMAINS_SLEEP: u32 = 1;
pub const CONFIG_YAM_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS28E17_MODULE: u32 = 1;
pub const CONFIG_MACB_PCI_MODULE: u32 = 1;
pub const CONFIG_DM_VERITY_MODULE: u32 = 1;
pub const CONFIG_BT_MTKUART_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_ECN_MODULE: u32 = 1;
pub const CONFIG_PRESTERA_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_STV0680_MODULE: u32 = 1;
pub const CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT: u32 = 1;
pub const CONFIG_SYSTEM_BLACKLIST_HASH_LIST: &[u8; 1usize] = b"\0";
pub const CONFIG_RESET_TI_TPS380X_MODULE: u32 = 1;
pub const CONFIG_TYPEC_TCPM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT1308_MODULE: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK_IDTCM_MODULE: u32 = 1;
pub const CONFIG_ATH9K_PCOEM: u32 = 1;
pub const CONFIG_SND_FM801_TEA575X_BOOL: u32 = 1;
pub const CONFIG_USB_STORAGE_SDDR55_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_SECCOMP: u32 = 1;
pub const CONFIG_PPDEV_MODULE: u32 = 1;
pub const CONFIG_KVM_AMD_SEV: u32 = 1;
pub const CONFIG_USB4_NET_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS4271_SPI_MODULE: u32 = 1;
pub const CONFIG_SILICOM_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_BXT_WC_PMIC_OPREGION: u32 = 1;
pub const CONFIG_SENSORS_TPS53679_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_S6D02A1_MODULE: u32 = 1;
pub const CONFIG_BCM_VK_MODULE: u32 = 1;
pub const CONFIG_IP_NF_TARGET_TTL_MODULE: u32 = 1;
pub const CONFIG_AMILO_RFKILL_MODULE: u32 = 1;
pub const CONFIG_STACKDEPOT: u32 = 1;
pub const CONFIG_LWTUNNEL_BPF: u32 = 1;
pub const CONFIG_CFG80211_DEFAULT_PS: u32 = 1;
pub const CONFIG_SND_SOC_WM8974_MODULE: u32 = 1;
pub const CONFIG_GENERIC_IOMAP: u32 = 1;
pub const CONFIG_IEEE802154_FAKELB_MODULE: u32 = 1;
pub const CONFIG_USBIP_HOST_MODULE: u32 = 1;
pub const CONFIG_CHARGER_BQ24190_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_WACOM_W8001_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_PRESS_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADL_PCI7X3X_MODULE: u32 = 1;
pub const CONFIG_DVB_PLUTO2_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_XILINX: u32 = 1;
pub const CONFIG_SQUASHFS_MOUNT_DECOMP_THREADS: u32 = 1;
pub const CONFIG_COMEDI_NI_ROUTING_MODULE: u32 = 1;
pub const CONFIG_RTL8723AE_MODULE: u32 = 1;
pub const CONFIG_DECOMPRESS_LZ4: u32 = 1;
pub const CONFIG_SND_SOC_ADAU7002_MODULE: u32 = 1;
pub const CONFIG_THUNDER_NIC_RGX_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_NETLINK_OSF_MODULE: u32 = 1;
pub const CONFIG_XEN_FBDEV_FRONTEND_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV02A10_MODULE: u32 = 1;
pub const CONFIG_GPIO_DLN2_MODULE: u32 = 1;
pub const CONFIG_DVB_AV7110_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_SRH_MODULE: u32 = 1;
pub const CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK: u32 = 1;
pub const CONFIG_DVB_OR51132_MODULE: u32 = 1;
pub const CONFIG_RT2X00_LIB_FIRMWARE: u32 = 1;
pub const CONFIG_DL2K_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_MMS114_MODULE: u32 = 1;
pub const CONFIG_VIDEO_V4L2_I2C: u32 = 1;
pub const CONFIG_SXGBE_ETH_MODULE: u32 = 1;
pub const CONFIG_MUX_ADG792A_MODULE: u32 = 1;
pub const CONFIG_UBSAN_SHIFT: u32 = 1;
pub const CONFIG_BPF_SYSCALL: u32 = 1;
pub const CONFIG_SND_SOC_CS35L45_MODULE: u32 = 1;
pub const CONFIG_SMP: u32 = 1;
pub const CONFIG_NET_VENDOR_CADENCE: u32 = 1;
pub const CONFIG_FB_KYRO_MODULE: u32 = 1;
pub const CONFIG_DVB_ZL10353_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_MICROSOFT: u32 = 1;
pub const CONFIG_MFD_INTEL_LPSS_ACPI_MODULE: u32 = 1;
pub const CONFIG_TTY: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_TIME_MODULE: u32 = 1;
pub const CONFIG_CXL_ACPI_MODULE: u32 = 1;
pub const CONFIG_IP_VS_MODULE: u32 = 1;
pub const CONFIG_HAVE_KERNEL_GZIP: u32 = 1;
pub const CONFIG_VCNL4035_MODULE: u32 = 1;
pub const CONFIG_TYPEC_TCPCI_MODULE: u32 = 1;
pub const CONFIG_MT76x02_USB_MODULE: u32 = 1;
pub const CONFIG_ZSMALLOC: u32 = 1;
pub const CONFIG_I2C_MLXCPLD_MODULE: u32 = 1;
pub const CONFIG_DM_UEVENT: u32 = 1;
pub const CONFIG_CAIF_VIRTIO_MODULE: u32 = 1;
pub const CONFIG_USB_MV_UDC_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_I825XX: u32 = 1;
pub const CONFIG_MMA7660_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_SEESAW_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_RT286_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_ACP_PCI_MODULE: u32 = 1;
pub const CONFIG_USB_XUSBATM_MODULE: u32 = 1;
pub const CONFIG_AD7091R8_MODULE: u32 = 1;
pub const CONFIG_PNP: u32 = 1;
pub const CONFIG_INTEGRITY_MACHINE_KEYRING: u32 = 1;
pub const CONFIG_RTC_DRV_RP5C01_MODULE: u32 = 1;
pub const CONFIG_EROFS_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_MAC_MODULE: u32 = 1;
pub const CONFIG_I2C_NFORCE2_S4985_MODULE: u32 = 1;
pub const CONFIG_MLX5_BRIDGE: u32 = 1;
pub const CONFIG_IOMMU_DMA: u32 = 1;
pub const CONFIG_LTRF216A_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_RT5682_MODULE: u32 = 1;
pub const CONFIG_THUNDER_NIC_BGX_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_PCI_ADMIN_LEGACY: u32 = 1;
pub const CONFIG_SENSORS_NCT6775_MODULE: u32 = 1;
pub const CONFIG_YELLOWFIN_MODULE: u32 = 1;
pub const CONFIG_RCU_EXP_CPU_STALL_TIMEOUT: u32 = 0;
pub const CONFIG_TOUCHSCREEN_TPS6507X_MODULE: u32 = 1;
pub const CONFIG_DW_DMAC_CORE_MODULE: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_DIO200_ISA_MODULE: u32 = 1;
pub const CONFIG_QED_ISCSI: u32 = 1;
pub const CONFIG_NET_ACT_PEDIT_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_QCOM_WLED_MODULE: u32 = 1;
pub const CONFIG_GPIO_TANGIER_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_NFLOG_MODULE: u32 = 1;
pub const CONFIG_VIDEO_BT819_MODULE: u32 = 1;
pub const CONFIG_DVB_ZD1301_DEMOD_MODULE: u32 = 1;
pub const CONFIG_DA9150_GPADC_MODULE: u32 = 1;
pub const CONFIG_XFRM_OFFLOAD: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_JASTEC: u32 = 1;
pub const CONFIG_GENERIC_ALLOCATOR: u32 = 1;
pub const CONFIG_OPENVSWITCH_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1390_MODULE: u32 = 1;
pub const CONFIG_L2TP_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_DA9052_MODULE: u32 = 1;
pub const CONFIG_DVB_B2C2_FLEXCOP_USB_MODULE: u32 = 1;
pub const CONFIG_IIO_GTS_HELPER_MODULE: u32 = 1;
pub const CONFIG_MMC_SDHCI_IO_ACCESSORS: u32 = 1;
pub const CONFIG_CRASH_MAX_MEMORY_RANGES: u32 = 8192;
pub const CONFIG_HAVE_DYNAMIC_FTRACE_WITH_DIRECT_CALLS: u32 = 1;
pub const CONFIG_FB_SYSMEM_HELPERS_DEFERRED: u32 = 1;
pub const CONFIG_TCP_CONG_WESTWOOD_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_M41T93_MODULE: u32 = 1;
pub const CONFIG_KALLSYMS_ALL: u32 = 1;
pub const CONFIG_ATM_FORE200E_TX_RETRY: u32 = 16;
pub const CONFIG_HID_AUREAL_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SPCA561_MODULE: u32 = 1;
pub const CONFIG_IPMI_SSIF_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_AMD_RENOIR_MODULE: u32 = 1;
pub const CONFIG_DRM_GM12U320_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_SDIO_MODULE: u32 = 1;
pub const CONFIG_SQUASHFS_LZ4: u32 = 1;
pub const CONFIG_DEBUG_INFO_BTF_MODULES: u32 = 1;
pub const CONFIG_DLN2_ADC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM3168A_I2C_MODULE: u32 = 1;
pub const CONFIG_LIBCRC32C_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_MATRIX_MODULE: u32 = 1;
pub const CONFIG_RSI_USB_MODULE: u32 = 1;
pub const CONFIG_HAVE_BOOTMEM_INFO_NODE: u32 = 1;
pub const CONFIG_MFD_PCF50633_MODULE: u32 = 1;
pub const CONFIG_GENERIC_BUG: u32 = 1;
pub const CONFIG_CRYPTO_SHA256: u32 = 1;
pub const CONFIG_SND_SOC_AMD_ACP_PDM_MODULE: u32 = 1;
pub const CONFIG_HAVE_FTRACE_MCOUNT_RECORD: u32 = 1;
pub const CONFIG_NET_DSA_MT7530_MDIO_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_GUILLEMOT_MODULE: u32 = 1;
pub const CONFIG_MLXSW_MINIMAL_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_VLAN_FILTERING: u32 = 1;
pub const CONFIG_VIDEO_AU0828_MODULE: u32 = 1;
pub const CONFIG_WL18XX_MODULE: u32 = 1;
pub const CONFIG_POSIX_TIMERS: u32 = 1;
pub const CONFIG_SND_SOC_SOF_HDA_MODULE: u32 = 1;
pub const CONFIG_INET_TCP_DIAG_MODULE: u32 = 1;
pub const CONFIG_HID_SONY_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_CORE_SYNC_DEAD: u32 = 1;
pub const CONFIG_VIDEO_PVRUSB2_DVB: u32 = 1;
pub const CONFIG_USB_CDNSP_GADGET: u32 = 1;
pub const CONFIG_USB_F_PRINTER_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AW88399_MODULE: u32 = 1;
pub const CONFIG_MEMSTICK_REALTEK_PCI_MODULE: u32 = 1;
pub const CONFIG_PCI_PASID: u32 = 1;
pub const CONFIG_CRYPTO_BLOWFISH_X86_64_MODULE: u32 = 1;
pub const CONFIG_HW_CONSOLE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_NITROX_CNN55XX_MODULE: u32 = 1;
pub const CONFIG_MDIO_BITBANG_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_IPT_MODULE: u32 = 1;
pub const CONFIG_ZSMALLOC_CHAIN_SIZE: u32 = 8;
pub const CONFIG_DVB_AS102_MODULE: u32 = 1;
pub const CONFIG_BPF_STREAM_PARSER: u32 = 1;
pub const CONFIG_HAVE_KVM_IRQ_ROUTING: u32 = 1;
pub const CONFIG_LEDS_MLXCPLD_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MAX98390_MODULE: u32 = 1;
pub const CONFIG_SCSI_BNX2X_FCOE_MODULE: u32 = 1;
pub const CONFIG_MTD_UBI_GLUEBI_MODULE: u32 = 1;
pub const CONFIG_RAS: u32 = 1;
pub const CONFIG_COMMON_CLK_CDCE706_MODULE: u32 = 1;
pub const CONFIG_AD5761_MODULE: u32 = 1;
pub const CONFIG_VIDEO_GO7007_LOADER_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DA9052_MODULE: u32 = 1;
pub const CONFIG_USB_ETH_EEM: u32 = 1;
pub const CONFIG_KEYBOARD_TWL4030_MODULE: u32 = 1;
pub const CONFIG_HYPERV_NET_MODULE: u32 = 1;
pub const CONFIG_REGMAP_SPMI_MODULE: u32 = 1;
pub const CONFIG_SMSC_PHY_MODULE: u32 = 1;
pub const CONFIG_DEVMEM: u32 = 1;
pub const CONFIG_BATTERY_MAX1721X_MODULE: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_INTROSPECT_POLICY: u32 = 1;
pub const CONFIG_HP_ACCEL_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_FOCALTECH: u32 = 1;
pub const CONFIG_CAN_EMS_PCI_MODULE: u32 = 1;
pub const CONFIG_X86_CET: u32 = 1;
pub const CONFIG_SCSI_BNX2_ISCSI_MODULE: u32 = 1;
pub const CONFIG_OMFS_FS_MODULE: u32 = 1;
pub const CONFIG_DRM_DP_CEC: u32 = 1;
pub const CONFIG_TCG_TIS_I2C_NUVOTON_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_ZC3XX_MODULE: u32 = 1;
pub const CONFIG_SND_ES1968_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LIB_SHA1: u32 = 1;
pub const CONFIG_REGULATOR_DA9062_MODULE: u32 = 1;
pub const CONFIG_SND_SPI: u32 = 1;
pub const CONFIG_EUROTECH_WDT_MODULE: u32 = 1;
pub const CONFIG_I2C_DLN2_MODULE: u32 = 1;
pub const CONFIG_MLX5_CORE_MODULE: u32 = 1;
pub const CONFIG_NFT_LOG_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_ADP8870_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_MTOUCH_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_IP_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_RT6160_MODULE: u32 = 1;
pub const CONFIG_HID_MONTEREY_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT1011_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_MICROCHIP_KSZ9477_I2C_MODULE: u32 = 1;
pub const CONFIG_CGROUP_RDMA: u32 = 1;
pub const CONFIG_FB_UDL_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_CYPRESS_M8_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ES8328_SPI_MODULE: u32 = 1;
pub const CONFIG_FB_NEOMAGIC_MODULE: u32 = 1;
pub const CONFIG_I2C_NVIDIA_GPU_MODULE: u32 = 1;
pub const CONFIG_HID_EZKEY_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SKYLAKE_FAMILY_MODULE: u32 = 1;
pub const CONFIG_KVM_SMM: u32 = 1;
pub const CONFIG_PADATA: u32 = 1;
pub const CONFIG_USB_PULSE8_CEC_MODULE: u32 = 1;
pub const CONFIG_THERMAL_GOV_USER_SPACE: u32 = 1;
pub const CONFIG_SIEMENS_SIMATIC_IPC_BATT_ELKHARTLAKE_MODULE: u32 = 1;
pub const CONFIG_DVB_S5H1409_MODULE: u32 = 1;
pub const CONFIG_IPW2200_QOS: u32 = 1;
pub const CONFIG_MDIO_BCM_UNIMAC_MODULE: u32 = 1;
pub const CONFIG_SCSI_LOWLEVEL_PCMCIA: u32 = 1;
pub const CONFIG_VDPA_SIM_NET_MODULE: u32 = 1;
pub const CONFIG_ATH9K_COMMON_DEBUG: u32 = 1;
pub const CONFIG_EFI_CAPSULE_LOADER_MODULE: u32 = 1;
pub const CONFIG_JFFS2_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_INPUT_DA9052_ONKEY_MODULE: u32 = 1;
pub const CONFIG_DM_THIN_PROVISIONING_MODULE: u32 = 1;
pub const CONFIG_SURFACE_HID_CORE_MODULE: u32 = 1;
pub const CONFIG_MFD_MT6370_MODULE: u32 = 1;
pub const CONFIG_IPMI_DMI_DECODE: u32 = 1;
pub const CONFIG_HAVE_UID16: u32 = 1;
pub const CONFIG_SERIAL_NONSTANDARD: u32 = 1;
pub const CONFIG_RT61PCI_MODULE: u32 = 1;
pub const CONFIG_COMPAT_OLD_SIGACTION: u32 = 1;
pub const CONFIG_SENSORS_TPS23861_MODULE: u32 = 1;
pub const CONFIG_PATA_JMICRON_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MAX98388_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2438_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TSC_SERIO_MODULE: u32 = 1;
pub const CONFIG_IRQ_MSI_IOMMU: u32 = 1;
pub const CONFIG_BMA400_SPI_MODULE: u32 = 1;
pub const CONFIG_RTC_NVMEM: u32 = 1;
pub const CONFIG_JOYSTICK_XPAD_LEDS: u32 = 1;
pub const CONFIG_PSE_CONTROLLER: u32 = 1;
pub const CONFIG_SENSORS_TC74_MODULE: u32 = 1;
pub const CONFIG_MMC_CRYPTO: u32 = 1;
pub const CONFIG_TINYDRM_ILI9486_MODULE: u32 = 1;
pub const CONFIG_IPW2100_MODULE: u32 = 1;
pub const CONFIG_SCSI_PPA_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_PWM_MODULE: u32 = 1;
pub const CONFIG_BT_MRVL_MODULE: u32 = 1;
pub const CONFIG_QUOTACTL: u32 = 1;
pub const CONFIG_RTC_DRV_RX8581_MODULE: u32 = 1;
pub const CONFIG_V4L2_MEM2MEM_DEV_MODULE: u32 = 1;
pub const CONFIG_SENSORS_XDPE122_REGULATOR: u32 = 1;
pub const CONFIG_FB_SAVAGE_I2C: u32 = 1;
pub const CONFIG_PARAVIRT: u32 = 1;
pub const CONFIG_TWL4030_MADC_MODULE: u32 = 1;
pub const CONFIG_WQ_POWER_EFFICIENT_DEFAULT: u32 = 1;
pub const CONFIG_NLS_UCS2_UTILS_MODULE: u32 = 1;
pub const CONFIG_HP03_MODULE: u32 = 1;
pub const CONFIG_SFC_FALCON_MTD: u32 = 1;
pub const CONFIG_VCAP: u32 = 1;
pub const CONFIG_CRYPTO_CRYPTD_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_JASPERLAKE_MODULE: u32 = 1;
pub const CONFIG_LEGACY_VSYSCALL_XONLY: u32 = 1;
pub const CONFIG_ZSTD_COMMON: u32 = 1;
pub const CONFIG_NF_SOCKET_IPV4_MODULE: u32 = 1;
pub const CONFIG_BCACHEFS_FS_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_VITESSE_VSC73XX_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_FSIA6B_MODULE: u32 = 1;
pub const CONFIG_HAVE_IOREMAP_PROT: u32 = 1;
pub const CONFIG_CRYPTO_CHACHA20_X86_64_MODULE: u32 = 1;
pub const CONFIG_SND_PCMTEST_MODULE: u32 = 1;
pub const CONFIG_PHY_CPCAP_USB_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_NAU8821_MODULE: u32 = 1;
pub const CONFIG_CC_HAS_KASAN_GENERIC: u32 = 1;
pub const CONFIG_SENSORS_MAX15301_MODULE: u32 = 1;
pub const CONFIG_CM32181_MODULE: u32 = 1;
pub const CONFIG_DVB_STV6111_MODULE: u32 = 1;
pub const CONFIG_USBIP_VHCI_HCD_MODULE: u32 = 1;
pub const CONFIG_PATA_RZ1000_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_ADP8860_MODULE: u32 = 1;
pub const CONFIG_MAX8925_POWER_MODULE: u32 = 1;
pub const CONFIG_CAPI_TRACE: u32 = 1;
pub const CONFIG_DEBUG_KERNEL: u32 = 1;
pub const CONFIG_MTD_RAM_MODULE: u32 = 1;
pub const CONFIG_RTL8192DE_MODULE: u32 = 1;
pub const CONFIG_ACPI_TOSHIBA_MODULE: u32 = 1;
pub const CONFIG_INV_MPU6050_IIO_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_F8153X_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MT6311_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LTC2978_REGULATOR: u32 = 1;
pub const CONFIG_HID_GOOGLE_HAMMER_MODULE: u32 = 1;
pub const CONFIG_DM_ZONED_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TC654_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX2341X_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MP2975_MODULE: u32 = 1;
pub const CONFIG_CROS_EC_MODULE: u32 = 1;
pub const CONFIG_I2C_VIPERBOARD_MODULE: u32 = 1;
pub const CONFIG_CHARLCD_MODULE: u32 = 1;
pub const CONFIG_LOCALVERSION: &[u8; 1usize] = b"\0";
pub const CONFIG_FS_STACK: u32 = 1;
pub const CONFIG_REISERFS_FS_SECURITY: u32 = 1;
pub const CONFIG_DVB_STV6110x_MODULE: u32 = 1;
pub const CONFIG_PATA_IT821X_MODULE: u32 = 1;
pub const CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK: u32 = 1;
pub const CONFIG_ACERHDF_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_PAGE_TABLE_CHECK: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BROADWELL_MACH_MODULE: u32 = 1;
pub const CONFIG_RADIO_ADAPTERS_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_QCOM_SPMI_MODULE: u32 = 1;
pub const CONFIG_MEMTEST: u32 = 1;
pub const CONFIG_KEYBOARD_XTKBD_MODULE: u32 = 1;
pub const CONFIG_HAVE_PCSPKR_PLATFORM: u32 = 1;
pub const CONFIG_NFS_FSCACHE: u32 = 1;
pub const CONFIG_PINCTRL_EMMITSBURG_MODULE: u32 = 1;
pub const CONFIG_MAC80211_MESH: u32 = 1;
pub const CONFIG_MMC_WBSD_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_TOPRO_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_MARS_MODULE: u32 = 1;
pub const CONFIG_CAN_RAW_MODULE: u32 = 1;
pub const CONFIG_SYMBOLIC_ERRNAME: u32 = 1;
pub const CONFIG_DRM_XE_PREEMPT_TIMEOUT_MAX: u32 = 10000000;
pub const CONFIG_AD5686_SPI_MODULE: u32 = 1;
pub const CONFIG_DVB_SI2165_MODULE: u32 = 1;
pub const CONFIG_SURFACE_AGGREGATOR_CDEV_MODULE: u32 = 1;
pub const CONFIG_CRYPTO: u32 = 1;
pub const CONFIG_SURFACE_HOTPLUG_MODULE: u32 = 1;
pub const CONFIG_I2C_MUX_PCA954x_MODULE: u32 = 1;
pub const CONFIG_FB_MATROX_MILLENIUM: u32 = 1;
pub const CONFIG_SENSORS_EMC6W201_MODULE: u32 = 1;
pub const CONFIG_FUNCTION_TRACER: u32 = 1;
pub const CONFIG_NET_DSA_TAG_AR9331_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CPU_DEVICES: u32 = 1;
pub const CONFIG_CRYPTO_NHPOLY1305_AVX2_MODULE: u32 = 1;
pub const CONFIG_USB_TRANCEVIBRATOR_MODULE: u32 = 1;
pub const CONFIG_SCHED_DEBUG: u32 = 1;
pub const CONFIG_GPIO_REGMAP_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SMACK_APPEND_SIGNALS: u32 = 1;
pub const CONFIG_NET_VENDOR_BROCADE: u32 = 1;
pub const CONFIG_BTRFS_FS_MODULE: u32 = 1;
pub const CONFIG_OPT4001_MODULE: u32 = 1;
pub const CONFIG_BLK_WBT_MQ: u32 = 1;
pub const CONFIG_DEFAULT_MMAP_MIN_ADDR: u32 = 65536;
pub const CONFIG_SYSTEM_TRUSTED_KEYS: &[u8; 1usize] = b"\0";
pub const CONFIG_MAX11205_MODULE: u32 = 1;
pub const CONFIG_SND_USB_6FIRE_MODULE: u32 = 1;
pub const CONFIG_PERF_EVENTS_INTEL_UNCORE: u32 = 1;
pub const CONFIG_SND_HDA_HWDEP: u32 = 1;
pub const CONFIG_INPUT_AD714X_I2C_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_BU21029_MODULE: u32 = 1;
pub const CONFIG_I2C_SIS96X_MODULE: u32 = 1;
pub const CONFIG_INET_RAW_DIAG_MODULE: u32 = 1;
pub const CONFIG_MMC_TIFM_SD_MODULE: u32 = 1;
pub const CONFIG_GFS2_FS_LOCKING_DLM: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TDA18218_MODULE: u32 = 1;
pub const CONFIG_PRESTERA_PCI_MODULE: u32 = 1;
pub const CONFIG_IP_NF_IPTABLES_MODULE: u32 = 1;
pub const CONFIG_ZPA2326_SPI_MODULE: u32 = 1;
pub const CONFIG_MISC_RTSX_USB_MODULE: u32 = 1;
pub const CONFIG_LEDS_LP50XX_MODULE: u32 = 1;
pub const CONFIG_VSOCKETS_MODULE: u32 = 1;
pub const CONFIG_GPIO_F7188X_MODULE: u32 = 1;
pub const CONFIG_BT_BNEP_PROTO_FILTER: u32 = 1;
pub const CONFIG_SENSORS_DRIVETEMP_MODULE: u32 = 1;
pub const CONFIG_DYNAMIC_FTRACE_WITH_REGS: u32 = 1;
pub const CONFIG_NTB_SWITCHTEC_MODULE: u32 = 1;
pub const CONFIG_PCIE_PTM: u32 = 1;
pub const CONFIG_IWLWIFI_LEDS: u32 = 1;
pub const CONFIG_USB_CHIPIDEA_HOST: u32 = 1;
pub const CONFIG_MFD_RETU_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_QLOGIC: u32 = 1;
pub const CONFIG_SPI_GPIO_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_CPIA1_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS42L42_MODULE: u32 = 1;
pub const CONFIG_HSI_CHAR_MODULE: u32 = 1;
pub const CONFIG_HID_LETSKETCH_MODULE: u32 = 1;
pub const CONFIG_GCC10_NO_ARRAY_BOUNDS: u32 = 1;
pub const CONFIG_RUNTIME_TESTING_MENU: u32 = 1;
pub const CONFIG_MPLS_IPTUNNEL_MODULE: u32 = 1;
pub const CONFIG_VIDEOBUF2_DMA_CONTIG_MODULE: u32 = 1;
pub const CONFIG_TSNEP_MODULE: u32 = 1;
pub const CONFIG_USB_XHCI_HCD: u32 = 1;
pub const CONFIG_VIRTIO: u32 = 1;
pub const CONFIG_REGULATOR_TPS65910_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_RTL8_4_MODULE: u32 = 1;
pub const CONFIG_DEFAULT_CUBIC: u32 = 1;
pub const CONFIG_CAN_KVASER_PCI_MODULE: u32 = 1;
pub const CONFIG_YENTA_TI: u32 = 1;
pub const CONFIG_COMEDI_NI_660X_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS35L32_MODULE: u32 = 1;
pub const CONFIG_MFD_SM501_MODULE: u32 = 1;
pub const CONFIG_AD7606_MODULE: u32 = 1;
pub const CONFIG_HID_SAMSUNG_MODULE: u32 = 1;
pub const CONFIG_SPI_XCOMM_MODULE: u32 = 1;
pub const CONFIG_SFC_MCDI_LOGGING: u32 = 1;
pub const CONFIG_PARMAN_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ZINITIX_MODULE: u32 = 1;
pub const CONFIG_IP_SET_LIST_SET_MODULE: u32 = 1;
pub const CONFIG_TCM_IBLOCK_MODULE: u32 = 1;
pub const CONFIG_IP_PIMSM_V2: u32 = 1;
pub const CONFIG_BACKLIGHT_ARCXCNN_MODULE: u32 = 1;
pub const CONFIG_CFS_BANDWIDTH: u32 = 1;
pub const CONFIG_MCP3911_MODULE: u32 = 1;
pub const CONFIG_WM831X_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_RTW88_MODULE: u32 = 1;
pub const CONFIG_NET_SELFTESTS: u32 = 1;
pub const CONFIG_MUX_GPIO_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_TRAILER_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_CA0132_DSP: u32 = 1;
pub const CONFIG_XFRM_STATISTICS: u32 = 1;
pub const CONFIG_GPIO_GENERIC_PLATFORM: u32 = 1;
pub const CONFIG_X86_MCE_THRESHOLD: u32 = 1;
pub const CONFIG_TOUCHSCREEN_HIMAX_HX83112B_MODULE: u32 = 1;
pub const CONFIG_MTD_SCB2_FLASH_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TW2804_MODULE: u32 = 1;
pub const CONFIG_VIA_RHINE_MMIO: u32 = 1;
pub const CONFIG_SMB_SERVER_SMBDIRECT: u32 = 1;
pub const CONFIG_USB_ISIGHTFW_MODULE: u32 = 1;
pub const CONFIG_JME_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_CPU_CACHE_INVALIDATE_MEMREGION: u32 = 1;
pub const CONFIG_RTW88_SDIO_MODULE: u32 = 1;
pub const CONFIG_GP2AP002_MODULE: u32 = 1;
pub const CONFIG_USB_LINK_LAYER_TEST_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_CMEDIA_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_SAMPLE_MODULE: u32 = 1;
pub const CONFIG_NFC_TRF7970A_MODULE: u32 = 1;
pub const CONFIG_DMA_VIRTUAL_CHANNELS: u32 = 1;
pub const CONFIG_SCSI_WD719X_MODULE: u32 = 1;
pub const CONFIG_ZSWAP_COMPRESSOR_DEFAULT: &[u8; 4usize] = b"lzo\0";
pub const CONFIG_DVB_PLATFORM_DRIVERS: u32 = 1;
pub const CONFIG_YENTA_O2: u32 = 1;
pub const CONFIG_SPS30_SERIAL_MODULE: u32 = 1;
pub const CONFIG_SND_SEQ_HRTIMER_DEFAULT: u32 = 1;
pub const CONFIG_USB_ARCH_HAS_HCD: u32 = 1;
pub const CONFIG_DVB_DIB3000MC_MODULE: u32 = 1;
pub const CONFIG_CACHEFILES_MODULE: u32 = 1;
pub const CONFIG_DVB_MXL5XX_MODULE: u32 = 1;
pub const CONFIG_STRICT_DEVMEM: u32 = 1;
pub const CONFIG_PATA_OLDPIIX_MODULE: u32 = 1;
pub const CONFIG_I2C_KEMPLD_MODULE: u32 = 1;
pub const CONFIG_NET_REDIRECT: u32 = 1;
pub const CONFIG_GENERIC_IRQ_SHOW: u32 = 1;
pub const CONFIG_CRYPTO_POLYVAL_CLMUL_NI_MODULE: u32 = 1;
pub const CONFIG_CXL_PMU_MODULE: u32 = 1;
pub const CONFIG_TINYDRM_REPAPER_MODULE: u32 = 1;
pub const CONFIG_SENSORS_PLI1209BC_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_SI3054_MODULE: u32 = 1;
pub const CONFIG_FXOS8700_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_PCF50633_MODULE: u32 = 1;
pub const CONFIG_LCD_ILI9320_MODULE: u32 = 1;
pub const CONFIG_CHARGER_BQ25980_MODULE: u32 = 1;
pub const CONFIG_MFD_MAX8925: u32 = 1;
pub const CONFIG_NVMEM_SYSFS: u32 = 1;
pub const CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE: u32 = 1;
pub const CONFIG_NFC_MICROREAD_I2C_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_ELF_RANDOMIZE: u32 = 1;
pub const CONFIG_9P_FS_MODULE: u32 = 1;
pub const CONFIG_NETFS_SUPPORT_MODULE: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_ARG_ACCESS_API: u32 = 1;
pub const CONFIG_MD_AUTODETECT: u32 = 1;
pub const CONFIG_ASUS_WIRELESS_MODULE: u32 = 1;
pub const CONFIG_AD7766_MODULE: u32 = 1;
pub const CONFIG_PANIC_ON_OOPS_VALUE: u32 = 0;
pub const CONFIG_JOYSTICK_A3D_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_SAMSUNG: u32 = 1;
pub const CONFIG_SND_SOC_CS4270_MODULE: u32 = 1;
pub const CONFIG_PLDMFW: u32 = 1;
pub const CONFIG_SENSORS_ATK0110_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_ADI: u32 = 1;
pub const CONFIG_IIO_MS_SENSORS_I2C_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_INTEL_SOUNDWIRE_MODULE: u32 = 1;
pub const CONFIG_FB_VIA_X_COMPATIBILITY: u32 = 1;
pub const CONFIG_ZRAM_DEF_COMP: &[u8; 8usize] = b"lzo-rle\0";
pub const CONFIG_REMOTEPROC_CDEV: u32 = 1;
pub const CONFIG_SFC_SRIOV: u32 = 1;
pub const CONFIG_RTW89_PCI_MODULE: u32 = 1;
pub const CONFIG_SERIAL_SCCNXP: u32 = 1;
pub const CONFIG_TCP_CONG_HSTCP_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_MSG2638_MODULE: u32 = 1;
pub const CONFIG_INITRAMFS_PRESERVE_MTIME: u32 = 1;
pub const CONFIG_BATTERY_BQ27XXX_I2C_MODULE: u32 = 1;
pub const CONFIG_SCSI_MOD: u32 = 1;
pub const CONFIG_SCSI_SMARTPQI_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ATMEL_MXT_T37: u32 = 1;
pub const CONFIG_SND_SOC_SSM2602_MODULE: u32 = 1;
pub const CONFIG_INPUT_88PM860X_ONKEY_MODULE: u32 = 1;
pub const CONFIG_SIEMENS_SIMATIC_IPC_BATT_F7188X_MODULE: u32 = 1;
pub const CONFIG_I2C_CROS_EC_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_MICREL: u32 = 1;
pub const CONFIG_CRYPTO_ESSIV_MODULE: u32 = 1;
pub const CONFIG_FB_PM2_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_UPD161704_MODULE: u32 = 1;
pub const CONFIG_MFD_CS47L15: u32 = 1;
pub const CONFIG_MPLS_ROUTING_MODULE: u32 = 1;
pub const CONFIG_SFC_SIENA_MODULE: u32 = 1;
pub const CONFIG_F2FS_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_VIDEOBUF2_DMA_SG_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_ADD_PAGES: u32 = 1;
pub const CONFIG_JOYSTICK_ZHENHUA_MODULE: u32 = 1;
pub const CONFIG_SENSORS_STPDDC60_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_NETLINK_HOOK_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_IPSEC_INLINE_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_SPCP8X5_MODULE: u32 = 1;
pub const CONFIG_BT_HCIRSI_MODULE: u32 = 1;
pub const CONFIG_KEYS_REQUEST_CACHE: u32 = 1;
pub const CONFIG_WILC1000_SDIO_MODULE: u32 = 1;
pub const CONFIG_MAX5481_MODULE: u32 = 1;
pub const CONFIG_HID_ITE_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AK5386_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP4_I2C_MODULE: u32 = 1;
pub const CONFIG_INTEL_QEP_MODULE: u32 = 1;
pub const CONFIG_HID_SENSOR_PROX_MODULE: u32 = 1;
pub const CONFIG_IOMMU_DEFAULT_DMA_LAZY: u32 = 1;
pub const CONFIG_RC_DECODERS: u32 = 1;
pub const CONFIG_B43_LEDS: u32 = 1;
pub const CONFIG_UBIFS_FS_XATTR: u32 = 1;
pub const CONFIG_P54_USB_MODULE: u32 = 1;
pub const CONFIG_GPIO_AGGREGATOR_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ECRDSA_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV01A10_MODULE: u32 = 1;
pub const CONFIG_FB_ATY_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP4_CORE_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_KINECT_MODULE: u32 = 1;
pub const CONFIG_NET_9P_XEN_MODULE: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_DECEXT_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_WISHBONE_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DAQBOARD2000_MODULE: u32 = 1;
pub const CONFIG_TPS68470_PMIC_OPREGION: u32 = 1;
pub const CONFIG_IOMMUFD_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_PINEPHONE_MODULE: u32 = 1;
pub const CONFIG_LEDS_CLASS_FLASH_MODULE: u32 = 1;
pub const CONFIG_USB_NET_HUAWEI_CDC_NCM_MODULE: u32 = 1;
pub const CONFIG_SCSI_ESAS2R_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_BEAGLEPLAY_MODULE: u32 = 1;
pub const CONFIG_VIDEO_MT9V111_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_CML_LP_DA7219_MAX98357A_MACH_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX25821_ALSA_MODULE: u32 = 1;
pub const CONFIG_GPIO_PISOSR_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CRC32C: u32 = 1;
pub const CONFIG_SERIAL_CORE: u32 = 1;
pub const CONFIG_IIO_ST_SENSORS_I2C_MODULE: u32 = 1;
pub const CONFIG_FUSE_FS: u32 = 1;
pub const CONFIG_HID_SENSOR_HUMIDITY_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_IQS62X_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_SERIAL: u32 = 1;
pub const CONFIG_UID16: u32 = 1;
pub const CONFIG_DW_DMAC_MODULE: u32 = 1;
pub const CONFIG_ETHOC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_ACPI_DEV_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM512x_MODULE: u32 = 1;
pub const CONFIG_ACPI_HED: u32 = 1;
pub const CONFIG_HID_MICROSOFT_MODULE: u32 = 1;
pub const CONFIG_EXFAT_DEFAULT_IOCHARSET: &[u8; 5usize] = b"utf8\0";
pub const CONFIG_RTLLIB_MODULE: u32 = 1;
pub const CONFIG_LIVEPATCH: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BYT_CHT_ES8316_MACH_MODULE: u32 = 1;
pub const CONFIG_HAVE_KVM_DIRTY_RING: u32 = 1;
pub const CONFIG_PCC: u32 = 1;
pub const CONFIG_RTC_DRV_S35390A_MODULE: u32 = 1;
pub const CONFIG_HAVE_KRETPROBES: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_KEXEC_JUMP: u32 = 1;
pub const CONFIG_SYSTEM_EXTRA_CERTIFICATE_SIZE: u32 = 4096;
pub const CONFIG_HYPERV_BALLOON_MODULE: u32 = 1;
pub const CONFIG_SCSI_IMM_MODULE: u32 = 1;
pub const CONFIG_OBJTOOL: u32 = 1;
pub const CONFIG_SENSORS_LM25066_MODULE: u32 = 1;
pub const CONFIG_ASSOCIATIVE_ARRAY: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_UVC: u32 = 1;
pub const CONFIG_HSA_AMD: u32 = 1;
pub const CONFIG_AGP_VIA: u32 = 1;
pub const CONFIG_SND_SOC_RT5659_MODULE: u32 = 1;
pub const CONFIG_NF_DEFRAG_IPV6_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_CONEX_MODULE: u32 = 1;
pub const CONFIG_MICREL_PHY_MODULE: u32 = 1;
pub const CONFIG_DRM_LOAD_EDID_FIRMWARE: u32 = 1;
pub const CONFIG_VIDEO_DEV_MODULE: u32 = 1;
pub const CONFIG_SIEMENS_SIMATIC_IPC_WDT_MODULE: u32 = 1;
pub const CONFIG_KS0108_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_FSL_AUDMIX_MODULE: u32 = 1;
pub const CONFIG_CC_HAS_ZERO_CALL_USED_REGS: u32 = 1;
pub const CONFIG_CXL_MEM_MODULE: u32 = 1;
pub const CONFIG_NFS_V4_MODULE: u32 = 1;
pub const CONFIG_IONIC_MODULE: u32 = 1;
pub const CONFIG_RCU_CPU_STALL_CPUTIME: u32 = 1;
pub const CONFIG_MFD_WM831X: u32 = 1;
pub const CONFIG_PMIC_ADP5520: u32 = 1;
pub const CONFIG_RPMSG_QCOM_GLINK_RPM_MODULE: u32 = 1;
pub const CONFIG_PPP_FILTER: u32 = 1;
pub const CONFIG_DYNAMIC_FTRACE: u32 = 1;
pub const CONFIG_MSI_EC_MODULE: u32 = 1;
pub const CONFIG_MAILBOX: u32 = 1;
pub const CONFIG_VIDEO_MT9M111_MODULE: u32 = 1;
pub const CONFIG_INPUT_LEDS_MODULE: u32 = 1;
pub const CONFIG_RCU_NEED_SEGCBLIST: u32 = 1;
pub const CONFIG_RV_REACT_PRINTK: u32 = 1;
pub const CONFIG_MTD_SLRAM_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TW9900_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_CS47L85: u32 = 1;
pub const CONFIG_DEBUG_WX: u32 = 1;
pub const CONFIG_MTD_ROM_MODULE: u32 = 1;
pub const CONFIG_EXTCON_USBC_TUSB320_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_HCTR2_MODULE: u32 = 1;
pub const CONFIG_XFS_SUPPORT_V4: u32 = 1;
pub const CONFIG_PATA_PDC2027X_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LTC2978_MODULE: u32 = 1;
pub const CONFIG_HAS_DMA: u32 = 1;
pub const CONFIG_INTEL_IPS_MODULE: u32 = 1;
pub const CONFIG_I2C_HID_OF_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS43130_MODULE: u32 = 1;
pub const CONFIG_NF_CT_PROTO_SCTP: u32 = 1;
pub const CONFIG_EDAC: u32 = 1;
pub const CONFIG_USB_SERIAL_VISOR_MODULE: u32 = 1;
pub const CONFIG_INTEL_TPMI_MODULE: u32 = 1;
pub const CONFIG_VIDEO_IMX208_MODULE: u32 = 1;
pub const CONFIG_MTD_PMC551_MODULE: u32 = 1;
pub const CONFIG_BROADCOM_PHY_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCMUIO_MODULE: u32 = 1;
pub const CONFIG_KFENCE: u32 = 1;
pub const CONFIG_DVB_AS102_FE_MODULE: u32 = 1;
pub const CONFIG_PCS_MTK_LYNXI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS42XX8_I2C_MODULE: u32 = 1;
pub const CONFIG_SCSI: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_PANIC: u32 = 1;
pub const CONFIG_SMPRO_ERRMON_MODULE: u32 = 1;
pub const CONFIG_DVB_CXD2841ER_MODULE: u32 = 1;
pub const CONFIG_GENWQE_PLATFORM_ERROR_RECOVERY: u32 = 0;
pub const CONFIG_FB_CFB_FILLRECT: u32 = 1;
pub const CONFIG_RT2800_LIB_MMIO_MODULE: u32 = 1;
pub const CONFIG_VIRT_WIFI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_RT274_MODULE: u32 = 1;
pub const CONFIG_HYPERV_MODULE: u32 = 1;
pub const CONFIG_AT76C50X_USB_MODULE: u32 = 1;
pub const CONFIG_QCOM_SPMI_IADC_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_WM8994_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_PPTP_MODULE: u32 = 1;
pub const CONFIG_FUNCTION_GRAPH_TRACER: u32 = 1;
pub const CONFIG_HID_VIEWSONIC_MODULE: u32 = 1;
pub const CONFIG_SPI_CS42L43_MODULE: u32 = 1;
pub const CONFIG_HID_CHICONY_MODULE: u32 = 1;
pub const CONFIG_SENSORS_AS370_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_ROMAN_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST: u32 = 1;
pub const CONFIG_HID_MODULE: u32 = 1;
pub const CONFIG_HW_RANDOM_AMD_MODULE: u32 = 1;
pub const CONFIG_LEDS_TI_LMU_COMMON_MODULE: u32 = 1;
pub const CONFIG_VIDEO_VIVID_MODULE: u32 = 1;
pub const CONFIG_RMI4_SMB_MODULE: u32 = 1;
pub const CONFIG_LIBERTAS_THINFIRM_USB_MODULE: u32 = 1;
pub const CONFIG_AMD_XGBE_MODULE: u32 = 1;
pub const CONFIG_CGROUP_NET_PRIO: u32 = 1;
pub const CONFIG_RANDOMIZE_BASE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_UAC1: u32 = 1;
pub const CONFIG_RTC_DRV_MAX31335_MODULE: u32 = 1;
pub const CONFIG_USB_DWC3_DUAL_ROLE: u32 = 1;
pub const CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BXT_DA7219_MAX98357A_MACH_MODULE: u32 = 1;
pub const CONFIG_VIDEO_VICODEC_MODULE: u32 = 1;
pub const CONFIG_ANDROID_BINDERFS_MODULE: u32 = 1;
pub const CONFIG_TLS_DEVICE: u32 = 1;
pub const CONFIG_PWM_TWL_LED_MODULE: u32 = 1;
pub const CONFIG_SLIP_SMART: u32 = 1;
pub const CONFIG_NLS_ISO8859_9_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ZFORCE_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_BPF_MODULE: u32 = 1;
pub const CONFIG_HYPERV_IOMMU: u32 = 1;
pub const CONFIG_FIRMWARE_EDID: u32 = 1;
pub const CONFIG_SND_SERIAL_U16550_MODULE: u32 = 1;
pub const CONFIG_USB_ARMLINUX: u32 = 1;
pub const CONFIG_I2C_SMBUS_MODULE: u32 = 1;
pub const CONFIG_IP_VS_PE_SIP_MODULE: u32 = 1;
pub const CONFIG_MEMSTICK_REALTEK_USB_MODULE: u32 = 1;
pub const CONFIG_PLATFORM_SI4713_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_GF2K_MODULE: u32 = 1;
pub const CONFIG_RTLWIFI_MODULE: u32 = 1;
pub const CONFIG_MT76_CORE_MODULE: u32 = 1;
pub const CONFIG_TCG_TIS_ST33ZP24_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BXT_RT298_MACH_MODULE: u32 = 1;
pub const CONFIG_LP8788_ADC_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_MEN_MCB_MODULE: u32 = 1;
pub const CONFIG_EDAC_GHES: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_DEFAULT_ON_MODULE: u32 = 1;
pub const CONFIG_MXM_WMI_MODULE: u32 = 1;
pub const CONFIG_FONT_8x16: u32 = 1;
pub const CONFIG_RTW89_8852AE_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_MELLANOX: u32 = 1;
pub const CONFIG_MAC80211_HWSIM_MODULE: u32 = 1;
pub const CONFIG_DVB_LGDT330X_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_MANY_PORTS: u32 = 1;
pub const CONFIG_VT_CONSOLE_SLEEP: u32 = 1;
pub const CONFIG_LIBFC_MODULE: u32 = 1;
pub const CONFIG_X86_MCE_INTEL: u32 = 1;
pub const CONFIG_X86_64: u32 = 1;
pub const CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG: u32 = 1;
pub const CONFIG_MEDIATEK_MT6360_ADC_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_CMOS: u32 = 1;
pub const CONFIG_SENSORS_MAX16601_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_USER_API_AEAD_MODULE: u32 = 1;
pub const CONFIG_CHARGER_MT6370_MODULE: u32 = 1;
pub const CONFIG_PCI_LOCKLESS_CONFIG: u32 = 1;
pub const CONFIG_ARCH_HAS_CURRENT_STACK_POINTER: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK: u32 = 1;
pub const CONFIG_PROBE_EVENTS_BTF_ARGS: u32 = 1;
pub const CONFIG_NF_DUP_NETDEV_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MAX98927_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SM3_AVX_X86_64_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_DRIVERS_MODULE: u32 = 1;
pub const CONFIG_ADFS_FS_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_RV3029_HWMON: u32 = 1;
pub const CONFIG_TCP_CONG_BBR_MODULE: u32 = 1;
pub const CONFIG_VL53L0X_I2C_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_IRTOUCH: u32 = 1;
pub const CONFIG_PATA_AMD_MODULE: u32 = 1;
pub const CONFIG_USB_PWC_MODULE: u32 = 1;
pub const CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE: u32 = 3;
pub const CONFIG_SENSORS_AD7414_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TDA8290_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADV_PCI_DIO_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_PANJIT: u32 = 1;
pub const CONFIG_RT2800PCI_RT53XX: u32 = 1;
pub const CONFIG_BONDING_MODULE: u32 = 1;
pub const CONFIG_PROC_THERMAL_MMIO_RAPL_MODULE: u32 = 1;
pub const CONFIG_SECURITY_TOMOYO_ACTIVATION_TRIGGER: &[u8; 11usize] = b"/sbin/init\0";
pub const CONFIG_HTS221_I2C_MODULE: u32 = 1;
pub const CONFIG_MLXSW_SPECTRUM_DCB: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TDA18212_MODULE: u32 = 1;
pub const CONFIG_MCP3422_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_EM3027_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_CACHE_LINE_SIZE: u32 = 1;
pub const CONFIG_UIO_DFL_MODULE: u32 = 1;
pub const CONFIG_6LOWPAN_NHC_DEST_MODULE: u32 = 1;
pub const CONFIG_X86_SGX: u32 = 1;
pub const CONFIG_TSL2591_MODULE: u32 = 1;
pub const CONFIG_VHOST_VDPA_MODULE: u32 = 1;
pub const CONFIG_VEML6070_MODULE: u32 = 1;
pub const CONFIG_VIDEO_SAA7134_RC: u32 = 1;
pub const CONFIG_JBD2: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_PC236_PCI_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ASB100_MODULE: u32 = 1;
pub const CONFIG_PWM_DWC_MODULE: u32 = 1;
pub const CONFIG_SND_INTEL8X0_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_ATMIO_MODULE: u32 = 1;
pub const CONFIG_PATA_NS87415_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ADAU1761_MODULE: u32 = 1;
pub const CONFIG_USBIP_CORE_MODULE: u32 = 1;
pub const CONFIG_CAN_M_CAN_TCAN4X5X_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DAC02_MODULE: u32 = 1;
pub const CONFIG_ATH10K_TRACING: u32 = 1;
pub const CONFIG_ATM_BR2684_MODULE: u32 = 1;
pub const CONFIG_SPARSEMEM_VMEMMAP: u32 = 1;
pub const CONFIG_CRYPTO_CAMELLIA_X86_64_MODULE: u32 = 1;
pub const CONFIG_INTEL_ATOMISP2_PDX86: u32 = 1;
pub const CONFIG_PINCTRL_CY8C95X0_MODULE: u32 = 1;
pub const CONFIG_IB700_WDT_MODULE: u32 = 1;
pub const CONFIG_X86_5LEVEL: u32 = 1;
pub const CONFIG_MMC_USHC_MODULE: u32 = 1;
pub const CONFIG_COMEDI_CB_PCIDAS64_MODULE: u32 = 1;
pub const CONFIG_SPI_TLE62X0_MODULE: u32 = 1;
pub const CONFIG_INET6_IPCOMP_MODULE: u32 = 1;
pub const CONFIG_SONY_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_QLCNIC_MODULE: u32 = 1;
pub const CONFIG_MEMCG_KMEM: u32 = 1;
pub const CONFIG_FB_SIS_315: u32 = 1;
pub const CONFIG_TPS6507X_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_MARVELL: u32 = 1;
pub const CONFIG_PHYLIB: u32 = 1;
pub const CONFIG_SND_SOC_XILINX_SPDIF_MODULE: u32 = 1;
pub const CONFIG_IGB_DCA: u32 = 1;
pub const CONFIG_NFP_APP_FLOWER: u32 = 1;
pub const CONFIG_SENSORS_IBM_CFFPS_MODULE: u32 = 1;
pub const CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU: u32 = 1;
pub const CONFIG_CRYPTO_SHA1_SSSE3_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_GPIO_MODULE: u32 = 1;
pub const CONFIG_FB_IOMEM_HELPERS_DEFERRED: u32 = 1;
pub const CONFIG_IPV6_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_IOSM_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM77_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_NVIDIA: u32 = 1;
pub const CONFIG_ARCH_MEMORY_PROBE: u32 = 1;
pub const CONFIG_X86_AMD_FREQ_SENSITIVITY_MODULE: u32 = 1;
pub const CONFIG_DVB_TDA665x_MODULE: u32 = 1;
pub const CONFIG_PATA_PARPORT_FRPW_MODULE: u32 = 1;
pub const CONFIG_PAHOLE_HAS_LANG_EXCLUDE: u32 = 1;
pub const CONFIG_VIDEO_SAA7164_MODULE: u32 = 1;
pub const CONFIG_NFC_MRVL_USB_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_874_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MT6351_MODULE: u32 = 1;
pub const CONFIG_LINEDISP_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_DSA_COMMON_MODULE: u32 = 1;
pub const CONFIG_ULTRIX_PARTITION: u32 = 1;
pub const CONFIG_IRQ_DOMAIN: u32 = 1;
pub const CONFIG_NET_DSA_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_BALLOON: u32 = 1;
pub const CONFIG_HOTPLUG_PCI_CPCI_GENERIC_MODULE: u32 = 1;
pub const CONFIG_IMA: u32 = 1;
pub const CONFIG_LSM_MMAP_MIN_ADDR: u32 = 0;
pub const CONFIG_SCSI_ARCMSR_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_BD28623_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS35L45_SPI_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_AMD: u32 = 1;
pub const CONFIG_INTEGRITY_AUDIT: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_DIO200_MODULE: u32 = 1;
pub const CONFIG_PVPANIC: u32 = 1;
pub const CONFIG_CAN_PEAK_PCI_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS: u32 = 0;
pub const CONFIG_PPS_CLIENT_LDISC_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_DEBUG_VIRTUAL: u32 = 1;
pub const CONFIG_KEYBOARD_QT1050_MODULE: u32 = 1;
pub const CONFIG_TYPEC_RT1719_MODULE: u32 = 1;
pub const CONFIG_MTD_ONENAND_2X_PROGRAM: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MT20XX_MODULE: u32 = 1;
pub const CONFIG_NET_TULIP: u32 = 1;
pub const CONFIG_IIO_HRTIMER_TRIGGER_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_SP_CCP: u32 = 1;
pub const CONFIG_JFFS2_RTIME: u32 = 1;
pub const CONFIG_HAVE_ASM_MODVERSIONS: u32 = 1;
pub const CONFIG_BNXT_HWMON: u32 = 1;
pub const CONFIG_IPC_NS: u32 = 1;
pub const CONFIG_CRYPTO_LIB_CHACHA20POLY1305_MODULE: u32 = 1;
pub const CONFIG_DEVFREQ_GOV_PASSIVE: u32 = 1;
pub const CONFIG_DVB_HORUS3A_MODULE: u32 = 1;
pub const CONFIG_RMI4_F34: u32 = 1;
pub const CONFIG_MISC_FILESYSTEMS: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS_MIN: u32 = 28;
pub const CONFIG_FTRACE: u32 = 1;
pub const CONFIG_IOMMUFD_DRIVER: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_KEXEC_PURGATORY: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNLIMIT_MODULE: u32 = 1;
pub const CONFIG_ATP_MODULE: u32 = 1;
pub const CONFIG_X86_THERMAL_VECTOR: u32 = 1;
pub const CONFIG_FW_LOADER_DEBUG: u32 = 1;
pub const CONFIG_PERF_EVENTS_AMD_UNCORE_MODULE: u32 = 1;
pub const CONFIG_IP_NF_SECURITY_MODULE: u32 = 1;
pub const CONFIG_IP_NF_RAW_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_LTO_CLANG: u32 = 1;
pub const CONFIG_IP_NF_ARPFILTER_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_LP8788_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_ETT_TC45USB: u32 = 1;
pub const CONFIG_INTEL_MEI_VSC_HW_MODULE: u32 = 1;
pub const CONFIG_USER_DECRYPTED_DATA: u32 = 1;
pub const CONFIG_COMPAT_32: u32 = 1;
pub const CONFIG_SND_SOC_AMD_RPL_ACP6x_MODULE: u32 = 1;
pub const CONFIG_W1_CON: u32 = 1;
pub const CONFIG_HID_GOOGLE_STADIA_FF_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_SOCKET_MODULE: u32 = 1;
pub const CONFIG_FB_ASILIANT: u32 = 1;
pub const CONFIG_PPPOL2TP_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_TLS8204_MODULE: u32 = 1;
pub const CONFIG_REGMAP_SOUNDWIRE_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_ADP5588_MODULE: u32 = 1;
pub const CONFIG_CLOCKSOURCE_WATCHDOG: u32 = 1;
pub const CONFIG_R8712U_MODULE: u32 = 1;
pub const CONFIG_HID_TOPSEED_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_RC5T583_MODULE: u32 = 1;
pub const CONFIG_B43_PHY_HT: u32 = 1;
pub const CONFIG_PINCTRL_MADERA_MODULE: u32 = 1;
pub const CONFIG_INPUT_RAVE_SP_PWRBUTTON_MODULE: u32 = 1;
pub const CONFIG_FB_VT8623_MODULE: u32 = 1;
pub const CONFIG_AD7606_IFACE_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_KBL_RT5663_RT5514_MAX98927_MACH_MODULE: u32 = 1;
pub const CONFIG_LEDS_DA9052_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SOF_CIRRUS_COMMON_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ARIA_AESNI_AVX2_X86_64_MODULE: u32 = 1;
pub const CONFIG_LEDS_BRIGHTNESS_HW_CHANGED: u32 = 1;
pub const CONFIG_DECOMPRESS_BZIP2: u32 = 1;
pub const CONFIG_RTW89_8852B_MODULE: u32 = 1;
pub const CONFIG_RT2800PCI_RT33XX: u32 = 1;
pub const CONFIG_CORDIC_MODULE: u32 = 1;
pub const CONFIG_ATH9K_RFKILL: u32 = 1;
pub const CONFIG_COMEDI_CB_PCIDAS_MODULE: u32 = 1;
pub const CONFIG_FB_TRIDENT_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_AXP20X_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADM1029_MODULE: u32 = 1;
pub const CONFIG_PER_VMA_LOCK: u32 = 1;
pub const CONFIG_MHP_MEMMAP_ON_MEMORY: u32 = 1;
pub const CONFIG_IIO_ST_SENSORS_CORE_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS42L43_SDW_MODULE: u32 = 1;
pub const CONFIG_KSM: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_UPROBES: u32 = 1;
pub const CONFIG_EXPORTFS_BLOCK_OPS: u32 = 1;
pub const CONFIG_DRM_DP_AUX_CHARDEV: u32 = 1;
pub const CONFIG_NET_VENDOR_STMICRO: u32 = 1;
pub const CONFIG_EDAC_I3000_MODULE: u32 = 1;
pub const CONFIG_PARPORT_PC_FIFO: u32 = 1;
pub const CONFIG_SHUFFLE_PAGE_ALLOCATOR: u32 = 1;
pub const CONFIG_TOPSTAR_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_AGP_SIS_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_H323_MODULE: u32 = 1;
pub const CONFIG_XZ_DEC_SPARC: u32 = 1;
pub const CONFIG_V4L2_CCI_MODULE: u32 = 1;
pub const CONFIG_IMA_LSM_RULES: u32 = 1;
pub const CONFIG_JOYSTICK_TURBOGRAFX_MODULE: u32 = 1;
pub const CONFIG_ARCH_SPARSEMEM_DEFAULT: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_EXPORT_BINARY: u32 = 1;
pub const CONFIG_SND_SOC_SOF_XTENSA_MODULE: u32 = 1;
pub const CONFIG_MLXSW_PCI_MODULE: u32 = 1;
pub const CONFIG_INPUT_IQS269A_MODULE: u32 = 1;
pub const CONFIG_INPUT_DA7280_HAPTICS_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DMM32AT_MODULE: u32 = 1;
pub const CONFIG_MOST_MODULE: u32 = 1;
pub const CONFIG_USB_NET_QMI_WWAN_MODULE: u32 = 1;
pub const CONFIG_NET_TEAM_MODE_ROUNDROBIN_MODULE: u32 = 1;
pub const CONFIG_BOARD_TPCI200_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_RT5033_MODULE: u32 = 1;
pub const CONFIG_INPUT_CMA3000_MODULE: u32 = 1;
pub const CONFIG_CEC_NOTIFIER: u32 = 1;
pub const CONFIG_EDAC_IE31200_MODULE: u32 = 1;
pub const CONFIG_IR_ENE_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_S6D1121_MODULE: u32 = 1;
pub const CONFIG_ALIM1535_WDT_MODULE: u32 = 1;
pub const CONFIG_RICHTEK_RTQ6056_MODULE: u32 = 1;
pub const CONFIG_HID_HYPERV_MOUSE_MODULE: u32 = 1;
pub const CONFIG_GACT_PROB: u32 = 1;
pub const CONFIG_SERIAL_MCTRL_GPIO: u32 = 1;
pub const CONFIG_MISDN_ISAR_MODULE: u32 = 1;
pub const CONFIG_REALTEK_PHY_MODULE: u32 = 1;
pub const CONFIG_PROC_VMCORE: u32 = 1;
pub const CONFIG_HID_A4TECH_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MC44S803_MODULE: u32 = 1;
pub const CONFIG_RTC_MC146818_LIB: u32 = 1;
pub const CONFIG_KMX61_MODULE: u32 = 1;
pub const CONFIG_NFC_PN544_MEI_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_QCA: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_860_MODULE: u32 = 1;
pub const CONFIG_INTEL_MEI_WDT_MODULE: u32 = 1;
pub const CONFIG_GPIO_TPIC2810_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_GSWIP_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_LSM6DSX_I3C_MODULE: u32 = 1;
pub const CONFIG_AD799X_MODULE: u32 = 1;
pub const CONFIG_DPLL: u32 = 1;
pub const CONFIG_SND_MONA_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_ESP_MODULE: u32 = 1;
pub const CONFIG_NIU_MODULE: u32 = 1;
pub const CONFIG_AD8366_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_VMMOUSE: u32 = 1;
pub const CONFIG_IP_NF_TARGET_NETMAP_MODULE: u32 = 1;
pub const CONFIG_DST_CACHE: u32 = 1;
pub const CONFIG_USB_GSPCA_SPCA505_MODULE: u32 = 1;
pub const CONFIG_KVM_GENERIC_HARDWARE_ENABLING: u32 = 1;
pub const CONFIG_INFINIBAND_RTRS_MODULE: u32 = 1;
pub const CONFIG_NF_REJECT_IPV6_MODULE: u32 = 1;
pub const CONFIG_RCU_CPU_STALL_TIMEOUT: u32 = 60;
pub const CONFIG_FPGA_MGR_MACHXO2_SPI_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_ADP5520_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SQ905C_MODULE: u32 = 1;
pub const CONFIG_842_COMPRESS_MODULE: u32 = 1;
pub const CONFIG_SATA_VITESSE_MODULE: u32 = 1;
pub const CONFIG_POSIX_CPU_TIMERS_TASK_WORK: u32 = 1;
pub const CONFIG_SND_SOC_WCD_MBHC_MODULE: u32 = 1;
pub const CONFIG_BCACHEFS_QUOTA: u32 = 1;
pub const CONFIG_NET_DSA_MV88E6XXX_MODULE: u32 = 1;
pub const CONFIG_CHECKPOINT_RESTORE: u32 = 1;
pub const CONFIG_PRINTER_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_ISL1208_MODULE: u32 = 1;
pub const CONFIG_INTEL_TDX_GUEST: u32 = 1;
pub const CONFIG_MFD_MENF21BMC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS4265_MODULE: u32 = 1;
pub const CONFIG_SND_VERBOSE_PROCFS: u32 = 1;
pub const CONFIG_SENSORS_HMC5843_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_FIREWIRE_LIB_MODULE: u32 = 1;
pub const CONFIG_INT340X_THERMAL_MODULE: u32 = 1;
pub const CONFIG_DA9052_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV2740_MODULE: u32 = 1;
pub const CONFIG_CFG80211_DEBUGFS: u32 = 1;
pub const CONFIG_TYPEC_TPS6598X_MODULE: u32 = 1;
pub const CONFIG_GNSS_MTK_SERIAL_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_BCM: u32 = 1;
pub const CONFIG_HAVE_ARCH_COMPAT_MMAP_BASES: u32 = 1;
pub const CONFIG_MAX9611_MODULE: u32 = 1;
pub const CONFIG_LAPB_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM25066_REGULATOR: u32 = 1;
pub const CONFIG_IIO_ST_GYRO_3AXIS_MODULE: u32 = 1;
pub const CONFIG_SCD30_CORE_MODULE: u32 = 1;
pub const CONFIG_SECURITY_TOMOYO_MAX_ACCEPT_ENTRY: u32 = 2048;
pub const CONFIG_IP_ROUTE_MULTIPATH: u32 = 1;
pub const CONFIG_FPGA_DFL_FME_REGION_MODULE: u32 = 1;
pub const CONFIG_AM2315_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_PCF2123_MODULE: u32 = 1;
pub const CONFIG_DVB_LNBP21_MODULE: u32 = 1;
pub const CONFIG_XEN_NETDEV_FRONTEND: u32 = 1;
pub const CONFIG_DVB_TDA10048_MODULE: u32 = 1;
pub const CONFIG_INPUT_FF_MEMLESS_MODULE: u32 = 1;
pub const CONFIG_PARAVIRT_CLOCK: u32 = 1;
pub const CONFIG_TYPEC_MT6360_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_FSL_SAI_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_PRINTER: u32 = 1;
pub const CONFIG_SENSORS_W83627HF_MODULE: u32 = 1;
pub const CONFIG_CHR_DEV_SG: u32 = 1;
pub const CONFIG_USB_CDC_PHONET_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_NET_MODULE: u32 = 1;
pub const CONFIG_LLD_VERSION: u32 = 0;
pub const CONFIG_SECTION_MISMATCH_WARN_ONLY: u32 = 1;
pub const CONFIG_ROHM_BU27008_MODULE: u32 = 1;
pub const CONFIG_SND_AD1889_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_SMSC_LAN9303_MDIO_MODULE: u32 = 1;
pub const CONFIG_MISC_RTSX_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_LAKEFIELD_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SSM2305_MODULE: u32 = 1;
pub const CONFIG_SSB_DRIVER_PCICORE_POSSIBLE: u32 = 1;
pub const CONFIG_MISDN_AVMFRITZ_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_EGRESS: u32 = 1;
pub const CONFIG_NET_DSA_QCA8K_LEDS_SUPPORT: u32 = 1;
pub const CONFIG_SENSORS_CORSAIR_PSU_MODULE: u32 = 1;
pub const CONFIG_MDIO_DEVICE: u32 = 1;
pub const CONFIG_SMS_SDIO_DRV_MODULE: u32 = 1;
pub const CONFIG_NFSD_PNFS: u32 = 1;
pub const CONFIG_INTEL_SOC_PMIC_MRFLD_MODULE: u32 = 1;
pub const CONFIG_NEED_SG_DMA_LENGTH: u32 = 1;
pub const CONFIG_INPUT_AXP20X_PEK_MODULE: u32 = 1;
pub const CONFIG_MODPROBE_PATH: &[u8; 15usize] = b"/sbin/modprobe\0";
pub const CONFIG_SND_MPU401_MODULE: u32 = 1;
pub const CONFIG_DVB_CX24116_MODULE: u32 = 1;
pub const CONFIG_POWER_RESET: u32 = 1;
pub const CONFIG_CRYPTO_XCBC_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_ATMEL_SHA204A_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_AMANDA_MODULE: u32 = 1;
pub const CONFIG_IPW2200_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_MARK_MODULE: u32 = 1;
pub const CONFIG_DRM_DISPLAY_HELPER_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_VFIO_PCI_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_QT2160_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADT7411_MODULE: u32 = 1;
pub const CONFIG_IXGBE_DCA: u32 = 1;
pub const CONFIG_VP_VDPA_MODULE: u32 = 1;
pub const CONFIG_EFI_SECRET_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_IPV6HEADER_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV5647_MODULE: u32 = 1;
pub const CONFIG_MACVLAN_MODULE: u32 = 1;
pub const CONFIG_TPS6105X_MODULE: u32 = 1;
pub const CONFIG_TI_ADC084S021_MODULE: u32 = 1;
pub const CONFIG_PATA_PDC_OLD_MODULE: u32 = 1;
pub const CONFIG_L2TP_V3: u32 = 1;
pub const CONFIG_INTEL_MRFLD_PWRBTN_MODULE: u32 = 1;
pub const CONFIG_I2C_MUX_REG_MODULE: u32 = 1;
pub const CONFIG_RTL8723_COMMON_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_T1_1G: u32 = 1;
pub const CONFIG_BPF_JIT: u32 = 1;
pub const CONFIG_INV_MPU6050_I2C_MODULE: u32 = 1;
pub const CONFIG_NINTENDO_FF: u32 = 1;
pub const CONFIG_IIO_INTERRUPT_TRIGGER_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_AW37503_MODULE: u32 = 1;
pub const CONFIG_I2C_HID_CORE_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV13B10_MODULE: u32 = 1;
pub const CONFIG_MMCONF_FAM10H: u32 = 1;
pub const CONFIG_SENSORS_INA2XX_MODULE: u32 = 1;
pub const CONFIG_WLCORE_SDIO_MODULE: u32 = 1;
pub const CONFIG_FB_ARK_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_IFORCE_MODULE: u32 = 1;
pub const CONFIG_PCIEASPM_DEFAULT: u32 = 1;
pub const CONFIG_SND_SOC_WM8524_MODULE: u32 = 1;
pub const CONFIG_PROFILING: u32 = 1;
pub const CONFIG_PCF50633_ADC_MODULE: u32 = 1;
pub const CONFIG_INTERVAL_TREE: u32 = 1;
pub const CONFIG_FB_TFT_ST7735R_MODULE: u32 = 1;
pub const CONFIG_ARCNET_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8731_MODULE: u32 = 1;
pub const CONFIG_IOSF_MBI: u32 = 1;
pub const CONFIG_I2C_ALI15X3_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX31785_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_AMAZON: u32 = 1;
pub const CONFIG_SPARSEMEM: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2805_MODULE: u32 = 1;
pub const CONFIG_BLK_MQ_STACKING: u32 = 1;
pub const CONFIG_REGULATOR_FAN53555_MODULE: u32 = 1;
pub const CONFIG_SPI_MICROCHIP_CORE_QSPI_MODULE: u32 = 1;
pub const CONFIG_NVME_FC_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_2032_MODULE: u32 = 1;
pub const CONFIG_DRM_GEM_SHMEM_HELPER: u32 = 1;
pub const CONFIG_REGULATOR_DA9210_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_FORCE_DMA_UNENCRYPTED: u32 = 1;
pub const CONFIG_HID_GLORIOUS_MODULE: u32 = 1;
pub const CONFIG_HD44780_MODULE: u32 = 1;
pub const CONFIG_INPUT_REGULATOR_HAPTIC_MODULE: u32 = 1;
pub const CONFIG_CAN_MCBA_USB_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_6LOWPAN_MODULE: u32 = 1;
pub const CONFIG_VHOST_NET_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TEA6415C_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ATMEL: u32 = 1;
pub const CONFIG_CHROMEOS_ACPI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BYTCR_WM5102_MACH_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_CZ_RT5645_MACH_MODULE: u32 = 1;
pub const CONFIG_DWMAC_INTEL_MODULE: u32 = 1;
pub const CONFIG_DVB_STV0900_MODULE: u32 = 1;
pub const CONFIG_SERIAL_MULTI_INSTANTIATE_MODULE: u32 = 1;
pub const CONFIG_I2C_NFORCE2_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_DIGI_ACCELEPORT_MODULE: u32 = 1;
pub const CONFIG_USB_GL860_MODULE: u32 = 1;
pub const CONFIG_GRACE_PERIOD_MODULE: u32 = 1;
pub const CONFIG_SLHC: u32 = 1;
pub const CONFIG_NET_VENDOR_TEHUTI: u32 = 1;
pub const CONFIG_QED_RDMA: u32 = 1;
pub const CONFIG_SCSI_UFSHCD_PCI_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_LTC3589_MODULE: u32 = 1;
pub const CONFIG_SND_ALS300_MODULE: u32 = 1;
pub const CONFIG_MCTP: u32 = 1;
pub const CONFIG_ADT7316_I2C_MODULE: u32 = 1;
pub const CONFIG_ALTERA_TSE_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_GPIO_POLLED_MODULE: u32 = 1;
pub const CONFIG_HP_BIOSCFG_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SOF_DA7219_MACH_MODULE: u32 = 1;
pub const CONFIG_E1000E_HWTS: u32 = 1;
pub const CONFIG_CRYPTO_MANAGER: u32 = 1;
pub const CONFIG_PHY_SAMSUNG_USB2_MODULE: u32 = 1;
pub const CONFIG_INTEL_MEI_TXE_MODULE: u32 = 1;
pub const CONFIG_SCSI_IPR_TRACE: u32 = 1;
pub const CONFIG_NET_SCH_HTB_MODULE: u32 = 1;
pub const CONFIG_EEPROM_AT24_MODULE: u32 = 1;
pub const CONFIG_UIO_SERCOS3_MODULE: u32 = 1;
pub const CONFIG_HID_CP2112_MODULE: u32 = 1;
pub const CONFIG_PPP_BSDCOMP_MODULE: u32 = 1;
pub const CONFIG_SCHED_SMT: u32 = 1;
pub const CONFIG_DVB_USB_TTUSB2_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_RENOIR_MODULE: u32 = 1;
pub const CONFIG_EDAC_SUPPORT: u32 = 1;
pub const CONFIG_RT_MUTEXES: u32 = 1;
pub const CONFIG_MFD_MADERA_SPI_MODULE: u32 = 1;
pub const CONFIG_LOCK_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_KRETPROBE_ON_RETHOOK: u32 = 1;
pub const CONFIG_REGULATOR_LTC3676_MODULE: u32 = 1;
pub const CONFIG_WLCORE_MODULE: u32 = 1;
pub const CONFIG_HID_ORTEK_MODULE: u32 = 1;
pub const CONFIG_VIDEO_V4L2_TPG_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_MARK_MODULE: u32 = 1;
pub const CONFIG_NFT_SYNPROXY_MODULE: u32 = 1;
pub const CONFIG_HID_ASUS_MODULE: u32 = 1;
pub const CONFIG_RTW88_8822CU_MODULE: u32 = 1;
pub const CONFIG_X86_AMD_PSTATE_DEFAULT_MODE: u32 = 3;
pub const CONFIG_SND_SOC_INTEL_BXT_DA7219_MAX98357A_COMMON_MODULE: u32 = 1;
pub const CONFIG_AR5523_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_RNBD_CLIENT_MODULE: u32 = 1;
pub const CONFIG_PERF_EVENTS_AMD_BRS: u32 = 1;
pub const CONFIG_SENSORS_TMP464_MODULE: u32 = 1;
pub const CONFIG_DEVICE_PRIVATE: u32 = 1;
pub const CONFIG_INPUT_IQS7222_MODULE: u32 = 1;
pub const CONFIG_CC_NO_ARRAY_BOUNDS: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MXL5007T_MODULE: u32 = 1;
pub const CONFIG_ATH10K_CE: u32 = 1;
pub const CONFIG_CX_ECAT_MODULE: u32 = 1;
pub const CONFIG_DRM_I2C_SIL164_MODULE: u32 = 1;
pub const CONFIG_SATA_INIC162X_MODULE: u32 = 1;
pub const CONFIG_HUGETLBFS: u32 = 1;
pub const CONFIG_CHECK_SIGNATURE: u32 = 1;
pub const CONFIG_DVB_TDA10021_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX231XX_DVB_MODULE: u32 = 1;
pub const CONFIG_SLAB_MERGE_DEFAULT: u32 = 1;
pub const CONFIG_OSNOISE_TRACER: u32 = 1;
pub const CONFIG_KERNFS: u32 = 1;
pub const CONFIG_CXD2880_SPI_DRV_MODULE: u32 = 1;
pub const CONFIG_INTEL_UNCORE_FREQ_CONTROL_TPMI_MODULE: u32 = 1;
pub const CONFIG_WL1251_MODULE: u32 = 1;
pub const CONFIG_I2C_ALGOBIT_MODULE: u32 = 1;
pub const CONFIG_IPV6_SUBTREES: u32 = 1;
pub const CONFIG_MMC_BLOCK_MODULE: u32 = 1;
pub const CONFIG_BATTERY_AXP20X_MODULE: u32 = 1;
pub const CONFIG_NET_CLS_FW_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_CCP: u32 = 1;
pub const CONFIG_KVM_MODULE: u32 = 1;
pub const CONFIG_PAGE_COUNTER: u32 = 1;
pub const CONFIG_KEYBOARD_DLINK_DIR685_MODULE: u32 = 1;
pub const CONFIG_SND_SIMPLE_CARD_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2781_MODULE: u32 = 1;
pub const CONFIG_HAVE_STATIC_CALL_INLINE: u32 = 1;
pub const CONFIG_INTEL_WMI: u32 = 1;
pub const CONFIG_VIDEO_SAA7185_MODULE: u32 = 1;
pub const CONFIG_SND_PCI: u32 = 1;
pub const CONFIG_VIDEO_SAA7134_DVB_MODULE: u32 = 1;
pub const CONFIG_ATM_FORE200E_DEBUG: u32 = 0;
pub const CONFIG_EXPERT: u32 = 1;
pub const CONFIG_TOUCHSCREEN_PCAP_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT715_MODULE: u32 = 1;
pub const CONFIG_PSTORE_BLK_MAX_REASON: u32 = 2;
pub const CONFIG_NVME_TARGET_TCP_MODULE: u32 = 1;
pub const CONFIG_DVB_NETUP_UNIDVB_MODULE: u32 = 1;
pub const CONFIG_LEDS_RT8515_MODULE: u32 = 1;
pub const CONFIG_ATL1C_MODULE: u32 = 1;
pub const CONFIG_HAVE_KVM_DIRTY_RING_TSO: u32 = 1;
pub const CONFIG_IR_SANYO_DECODER_MODULE: u32 = 1;
pub const CONFIG_SENSORS_POWERZ_MODULE: u32 = 1;
pub const CONFIG_DMAR_TABLE: u32 = 1;
pub const CONFIG_MFD_INTEL_LPSS_PCI_MODULE: u32 = 1;
pub const CONFIG_HW_RANDOM_INTEL_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_RTRS_SERVER_MODULE: u32 = 1;
pub const CONFIG_SLS: u32 = 1;
pub const CONFIG_LCD_LTV350QV_MODULE: u32 = 1;
pub const CONFIG_LXT_PHY_MODULE: u32 = 1;
pub const CONFIG_CFG80211_CRDA_SUPPORT: u32 = 1;
pub const CONFIG_RTW88_8723D_MODULE: u32 = 1;
pub const CONFIG_FB_MB862XX_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV9650_MODULE: u32 = 1;
pub const CONFIG_VIDEO_MT9V011_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ALC5623_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_IMG: u32 = 1;
pub const CONFIG_CAN_M_CAN_MODULE: u32 = 1;
pub const CONFIG_WIRELESS: u32 = 1;
pub const CONFIG_WEXT_PROC: u32 = 1;
pub const CONFIG_RPMSG_CTRL_MODULE: u32 = 1;
pub const CONFIG_PATA_PARPORT_MODULE: u32 = 1;
pub const CONFIG_CGROUP_MISC: u32 = 1;
pub const CONFIG_BCMA_DRIVER_PCI: u32 = 1;
pub const CONFIG_SQUASHFS: u32 = 1;
pub const CONFIG_6LOWPAN_NHC_MODULE: u32 = 1;
pub const CONFIG_EDAC_I7CORE_MODULE: u32 = 1;
pub const CONFIG_HID_VIVALDI_MODULE: u32 = 1;
pub const CONFIG_RMNET_MODULE: u32 = 1;
pub const CONFIG_FB_N411_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_JITTERENTROPY_MEMORY_BLOCKS: u32 = 64;
pub const CONFIG_X86_IO_APIC: u32 = 1;
pub const CONFIG_ARCH_HAS_STRICT_KERNEL_RWX: u32 = 1;
pub const CONFIG_NFT_DUP_IPV6_MODULE: u32 = 1;
pub const CONFIG_DELL_WMI_AIO_MODULE: u32 = 1;
pub const CONFIG_PCIE_DW_PLAT_HOST: u32 = 1;
pub const CONFIG_SND_ALS4000_MODULE: u32 = 1;
pub const CONFIG_INTEL_PMT_CRASHLOG_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_KONICA_MODULE: u32 = 1;
pub const CONFIG_TCG_TIS_I2C_ATMEL_MODULE: u32 = 1;
pub const CONFIG_PATA_PARPORT_DSTR_MODULE: u32 = 1;
pub const CONFIG_LOCK_DEBUGGING_SUPPORT: u32 = 1;
pub const CONFIG_SND_SOC_WM8770_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ICS43432_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_TBF_MODULE: u32 = 1;
pub const CONFIG_PATA_PARPORT_BPCK6_MODULE: u32 = 1;
pub const CONFIG_I2C_PCI1XXXX_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBTUSB_MODULE: u32 = 1;
pub const CONFIG_PKCS7_MESSAGE_PARSER: u32 = 1;
pub const CONFIG_XILINX_PR_DECOUPLER_MODULE: u32 = 1;
pub const CONFIG_PING_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_RAVE_SP_MODULE: u32 = 1;
pub const CONFIG_USB_NET_CH9200_MODULE: u32 = 1;
pub const CONFIG_CC_HAS_SANE_STACKPROTECTOR: u32 = 1;
pub const CONFIG_USB_LED_TRIG: u32 = 1;
pub const CONFIG_FB_TFT_ILI9481_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TVP7002_MODULE: u32 = 1;
pub const CONFIG_IRQ_SIM: u32 = 1;
pub const CONFIG_DVB_CX22702_MODULE: u32 = 1;
pub const CONFIG_KGDB: u32 = 1;
pub const CONFIG_LTR501_MODULE: u32 = 1;
pub const CONFIG_CROS_EC_LIGHTBAR_MODULE: u32 = 1;
pub const CONFIG_SERIO_RAW_MODULE: u32 = 1;
pub const CONFIG_TASK_IO_ACCOUNTING: u32 = 1;
pub const CONFIG_MISC_RTSX_PCI_MODULE: u32 = 1;
pub const CONFIG_NF_LOG_SYSLOG_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_KTD253_MODULE: u32 = 1;
pub const CONFIG_FAT_DEFAULT_IOCHARSET: &[u8; 10usize] = b"iso8859-1\0";
pub const CONFIG_USBIP_VHCI_NR_HCS: u32 = 1;
pub const CONFIG_VIDEO_IMX258_MODULE: u32 = 1;
pub const CONFIG_ASYNC_XOR_MODULE: u32 = 1;
pub const CONFIG_HAVE_RUST: u32 = 1;
pub const CONFIG_USB_CONFIGFS_MASS_STORAGE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SST_TOPLEVEL: u32 = 1;
pub const CONFIG_ISDN_CAPI_MIDDLEWARE: u32 = 1;
pub const CONFIG_TIPC_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_ILI9163_MODULE: u32 = 1;
pub const CONFIG_DVB_STB6100_MODULE: u32 = 1;
pub const CONFIG_W83977F_WDT_MODULE: u32 = 1;
pub const CONFIG_NXP_CBTX_PHY_MODULE: u32 = 1;
pub const CONFIG_MD_RAID0_MODULE: u32 = 1;
pub const CONFIG_FRAME_WARN: u32 = 1024;
pub const CONFIG_VIDEO_MT9P031_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_AGERE: u32 = 1;
pub const CONFIG_SND_FIREFACE_MODULE: u32 = 1;
pub const CONFIG_USB_NET_CDC_NCM_MODULE: u32 = 1;
pub const CONFIG_UVC_COMMON_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_BAYTRAIL_MODULE: u32 = 1;
pub const CONFIG_HID_GENERIC_MODULE: u32 = 1;
pub const CONFIG_HID_MEGAWORLD_FF_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_INTEL_COMMON_MODULE: u32 = 1;
pub const CONFIG_FB_SIS_300: u32 = 1;
pub const CONFIG_VIRTIO_MEM_MODULE: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS: u32 = 32;
pub const CONFIG_X86_VSYSCALL_EMULATION: u32 = 1;
pub const CONFIG_DUMMY_IRQ_MODULE: u32 = 1;
pub const CONFIG_USB_DWC2_HOST: u32 = 1;
pub const CONFIG_USB_HACKRF_MODULE: u32 = 1;
pub const CONFIG_AD7303_MODULE: u32 = 1;
pub const CONFIG_HP_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DAS08_ISA_MODULE: u32 = 1;
pub const CONFIG_MTD_DATAFLASH_OTP: u32 = 1;
pub const CONFIG_HID_RETRODE_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SM2_MODULE: u32 = 1;
pub const CONFIG_COMEDI_USB_DRIVERS_MODULE: u32 = 1;
pub const CONFIG_BCM87XX_PHY_MODULE: u32 = 1;
pub const CONFIG_I2C_DESIGNWARE_PCI_MODULE: u32 = 1;
pub const CONFIG_USB_ETH_MODULE: u32 = 1;
pub const CONFIG_PATA_SCH_MODULE: u32 = 1;
pub const CONFIG_VIDEO_VIM2M_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_ILI9320_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ADAU1701_MODULE: u32 = 1;
pub const CONFIG_BATTERY_TWL4030_MADC_MODULE: u32 = 1;
pub const CONFIG_ZRAM_MEMORY_TRACKING: u32 = 1;
pub const CONFIG_CRYPTO_DEV_SP_PSP: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_HDAUDIO_MODULE: u32 = 1;
pub const CONFIG_INITRAMFS_SOURCE: &[u8; 1usize] = b"\0";
pub const CONFIG_VIDEO_THS7303_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TW5864_MODULE: u32 = 1;
pub const CONFIG_RTL_CARDS_MODULE: u32 = 1;
pub const CONFIG_PATA_NETCELL_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_PCA9450_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SKL_HDA_DSP_GENERIC_MACH_MODULE: u32 = 1;
pub const CONFIG_X86_MCELOG_LEGACY: u32 = 1;
pub const CONFIG_INPUT_IMS_PCU_MODULE: u32 = 1;
pub const CONFIG_PAGE_POOL_STATS: u32 = 1;
pub const CONFIG_ARCH_MHP_MEMMAP_ON_MEMORY_ENABLE: u32 = 1;
pub const CONFIG_VIDEO_IMX319_MODULE: u32 = 1;
pub const CONFIG_DHT11_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1374_WDT: u32 = 1;
pub const CONFIG_MT7663U_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_SCODEC_TAS2781_I2C_MODULE: u32 = 1;
pub const CONFIG_ATM_CLIP_MODULE: u32 = 1;
pub const CONFIG_X86_CPU_RESCTRL: u32 = 1;
pub const CONFIG_TASKS_TRACE_RCU: u32 = 1;
pub const CONFIG_COMEDI_RTD520_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_SIGMATEL_MODULE: u32 = 1;
pub const CONFIG_CGROUPS: u32 = 1;
pub const CONFIG_MFD_AXP20X_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5670_MODULE: u32 = 1;
pub const CONFIG_SND_USB_CAIAQ_INPUT: u32 = 1;
pub const CONFIG_MMC: u32 = 1;
pub const CONFIG_LZO_COMPRESS: u32 = 1;
pub const CONFIG_DAX: u32 = 1;
pub const CONFIG_USB_F_PHONET_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_MAX98927_MODULE: u32 = 1;
pub const CONFIG_DRM_SSD130X_I2C_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_SJA1105_MODULE: u32 = 1;
pub const CONFIG_GUEST_PERF_EVENTS: u32 = 1;
pub const CONFIG_VIRTIO_INPUT_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS: u32 = 1;
pub const CONFIG_DELL_RBTN_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_GUNZE: u32 = 1;
pub const CONFIG_PROC_CPU_RESCTRL: u32 = 1;
pub const CONFIG_CRYPTO_SEQIV: u32 = 1;
pub const CONFIG_ACPI_SPCR_TABLE: u32 = 1;
pub const CONFIG_VF610_ADC_MODULE: u32 = 1;
pub const CONFIG_NI903X_WDT_MODULE: u32 = 1;
pub const CONFIG_SFC_SIENA_SRIOV: u32 = 1;
pub const CONFIG_GPIO_XRA1403_MODULE: u32 = 1;
pub const CONFIG_BRCMFMAC_MODULE: u32 = 1;
pub const CONFIG_COMEDI_QUATECH_DAQP_CS_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_AD7877_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_POWER_SAVE_DEFAULT: u32 = 1;
pub const CONFIG_TTY_PRINTK: u32 = 1;
pub const CONFIG_9P_FSCACHE: u32 = 1;
pub const CONFIG_HID_LOGITECH_MODULE: u32 = 1;
pub const CONFIG_SND_INDIGODJX_MODULE: u32 = 1;
pub const CONFIG_ARCNET_COM90xx_MODULE: u32 = 1;
pub const CONFIG_VME_BUS: u32 = 1;
pub const CONFIG_DM_LOG_USERSPACE_MODULE: u32 = 1;
pub const CONFIG_DM_AUDIT: u32 = 1;
pub const CONFIG_JOYSTICK_GAMECON_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_USER_API_RNG_MODULE: u32 = 1;
pub const CONFIG_DRM_VIRTIO_GPU_KMS: u32 = 1;
pub const CONFIG_SCSI_ENCLOSURE_MODULE: u32 = 1;
pub const CONFIG_HAVE_GCC_PLUGINS: u32 = 1;
pub const CONFIG_AMD_PMC_MODULE: u32 = 1;
pub const CONFIG_DYNAMIC_EVENTS: u32 = 1;
pub const CONFIG_REGULATOR_RT4803_MODULE: u32 = 1;
pub const CONFIG_DVB_SP887X_MODULE: u32 = 1;
pub const CONFIG_STACKTRACE: u32 = 1;
pub const CONFIG_NET_EMATCH_CANID_MODULE: u32 = 1;
pub const CONFIG_TAHVO_USB_HOST_BY_DEFAULT: u32 = 1;
pub const CONFIG_HAVE_PCI: u32 = 1;
pub const CONFIG_SENSORS_LM92_MODULE: u32 = 1;
pub const CONFIG_EXTCON: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_3120_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_LIB_MODULE: u32 = 1;
pub const CONFIG_RTW88_8821CE_MODULE: u32 = 1;
pub const CONFIG_SCSI_SAS_LIBSAS_MODULE: u32 = 1;
pub const CONFIG_ISCSI_TARGET_MODULE: u32 = 1;
pub const CONFIG_MFD_INTEL_M10_BMC_SPI_MODULE: u32 = 1;
pub const CONFIG_IMA_MEASURE_PCR_IDX: u32 = 10;
pub const CONFIG_MERAKI_MX100_MODULE: u32 = 1;
pub const CONFIG_HAVE_ACPI_APEI: u32 = 1;
pub const CONFIG_RTW88_8723DU_MODULE: u32 = 1;
pub const CONFIG_ARCNET_RIM_I_MODULE: u32 = 1;
pub const CONFIG_AK8974_MODULE: u32 = 1;
pub const CONFIG_MHI_BUS_MODULE: u32 = 1;
pub const CONFIG_PATA_RADISYS_MODULE: u32 = 1;
pub const CONFIG_TOSHIBA_HAPS_MODULE: u32 = 1;
pub const CONFIG_IPV6_GRE_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_IDLETIMER_MODULE: u32 = 1;
pub const CONFIG_FB_ATY128_MODULE: u32 = 1;
pub const CONFIG_NETKIT: u32 = 1;
pub const CONFIG_GPIO_TPS65086_MODULE: u32 = 1;
pub const CONFIG_VDPA_SIM_MODULE: u32 = 1;
pub const CONFIG_VFIO_PCI_INTX: u32 = 1;
pub const CONFIG_BMG160_MODULE: u32 = 1;
pub const CONFIG_UIO_AEC_MODULE: u32 = 1;
pub const CONFIG_SCSI_PM8001_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC: u32 = 1;
pub const CONFIG_VIDEO_TUNER_MODULE: u32 = 1;
pub const CONFIG_IFB_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_ACCEL_3AXIS_MODULE: u32 = 1;
pub const CONFIG_USB_FUNCTIONFS_ETH: u32 = 1;
pub const CONFIG_TCS3472_MODULE: u32 = 1;
pub const CONFIG_HAS_IOPORT: u32 = 1;
pub const CONFIG_DM_MULTIPATH_HST_MODULE: u32 = 1;
pub const CONFIG_RDMA_SIW_MODULE: u32 = 1;
pub const CONFIG_LEDS_LP3944_MODULE: u32 = 1;
pub const CONFIG_SX9360_MODULE: u32 = 1;
pub const CONFIG_USB_SEVSEG_MODULE: u32 = 1;
pub const CONFIG_SND_MPU401_UART_MODULE: u32 = 1;
pub const CONFIG_IPV6_VTI_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DRBG: u32 = 1;
pub const CONFIG_RTC_DRV_PCF8563_MODULE: u32 = 1;
pub const CONFIG_SND_MAX_CARDS: u32 = 32;
pub const CONFIG_PPTP_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MSI001_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_V2_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SMSC47M1_MODULE: u32 = 1;
pub const CONFIG_SND_USB_US122L_MODULE: u32 = 1;
pub const CONFIG_TEST_BLACKHOLE_DEV_MODULE: u32 = 1;
pub const CONFIG_RTW89_CORE_MODULE: u32 = 1;
pub const CONFIG_USB_CDC_COMPOSITE_MODULE: u32 = 1;
pub const CONFIG_USB_DSBR_MODULE: u32 = 1;
pub const CONFIG_MSE102X_MODULE: u32 = 1;
pub const CONFIG_ISCSI_IBFT_FIND: u32 = 1;
pub const CONFIG_KGDB_KDB: u32 = 1;
pub const CONFIG_DCB: u32 = 1;
pub const CONFIG_PCIPCWATCHDOG_MODULE: u32 = 1;
pub const CONFIG_XILLYBUS_CLASS_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ADMTEK: u32 = 1;
pub const CONFIG_SENSORS_NZXT_KRAKEN2_MODULE: u32 = 1;
pub const CONFIG_MLX5_MPFS: u32 = 1;
pub const CONFIG_CGROUP_CPUACCT: u32 = 1;
pub const CONFIG_FS_VERITY: u32 = 1;
pub const CONFIG_USB_SERIAL_OTI6858_MODULE: u32 = 1;
pub const CONFIG_GCC_NO_STRINGOP_OVERFLOW: u32 = 1;
pub const CONFIG_ADXL367_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_COMPONENT: u32 = 1;
pub const CONFIG_SERIAL_SC16IS7XX_CORE_MODULE: u32 = 1;
pub const CONFIG_MCP4531_MODULE: u32 = 1;
pub const CONFIG_VIDEO_GO7007_USB_MODULE: u32 = 1;
pub const CONFIG_CAN_BCM_MODULE: u32 = 1;
pub const CONFIG_HAS_IOPORT_MAP: u32 = 1;
pub const CONFIG_BRCMSMAC_LEDS: u32 = 1;
pub const CONFIG_SND_SOC_ES8328_I2C_MODULE: u32 = 1;
pub const CONFIG_X86_CMPXCHG64: u32 = 1;
pub const CONFIG_VIDEO_SAA7146_VV_MODULE: u32 = 1;
pub const CONFIG_DA9062_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AK4375_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_RT5663_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_CS47L35: u32 = 1;
pub const CONFIG_CARL9170_HWRNG: u32 = 1;
pub const CONFIG_NLMON_MODULE: u32 = 1;
pub const CONFIG_ATH10K_PCI_MODULE: u32 = 1;
pub const CONFIG_CAN_PEAK_PCMCIA_MODULE: u32 = 1;
pub const CONFIG_HAVE_FAST_GUP: u32 = 1;
pub const CONFIG_VIRTIO_PCI_LIB: u32 = 1;
pub const CONFIG_NET_VENDOR_VIA: u32 = 1;
pub const CONFIG_UBIFS_FS_SECURITY: u32 = 1;
pub const CONFIG_USB_ATM_MODULE: u32 = 1;
pub const CONFIG_USB_CDNS_HOST: u32 = 1;
pub const CONFIG_NFC_S3FWRN82_UART_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SDW_MOCKUP_MODULE: u32 = 1;
pub const CONFIG_ISA_DMA_API: u32 = 1;
pub const CONFIG_XEN_PCI_STUB: u32 = 1;
pub const CONFIG_PCMCIA_FDOMAIN_MODULE: u32 = 1;
pub const CONFIG_HZ: u32 = 1000;
pub const CONFIG_MSA311_MODULE: u32 = 1;
pub const CONFIG_INET6_ESPINTCP: u32 = 1;
pub const CONFIG_IIO_SIMPLE_DUMMY_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_SHARE_IRQ: u32 = 1;
pub const CONFIG_MT76x2U_MODULE: u32 = 1;
pub const CONFIG_DPS310_MODULE: u32 = 1;
pub const CONFIG_RUST: u32 = 1;
pub const CONFIG_HID_TOPRE_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV5648_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_VLAN_MODULE: u32 = 1;
pub const CONFIG_INTEL_IDXD_PERFMON: u32 = 1;
pub const CONFIG_IXGBE_HWMON: u32 = 1;
pub const CONFIG_HOTPLUG_CORE_SYNC_FULL: u32 = 1;
pub const CONFIG_USB_RTL8152_MODULE: u32 = 1;
pub const CONFIG_ECHO_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_UAC2: u32 = 1;
pub const CONFIG_I2C_HELPER_AUTO: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_U32_MODULE: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_DIO200_PCI_MODULE: u32 = 1;
pub const CONFIG_KVM_XFER_TO_GUEST_WORK: u32 = 1;
pub const CONFIG_VIDEO_SONY_BTF_MPX_MODULE: u32 = 1;
pub const CONFIG_INTEGRITY_TRUSTED_KEYRING: u32 = 1;
pub const CONFIG_SQUASHFS_ZLIB: u32 = 1;
pub const CONFIG_FPGA_MGR_LATTICE_SYSCONFIG_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX23885_MODULE: u32 = 1;
pub const CONFIG_AGP_INTEL: u32 = 1;
pub const CONFIG_NLS_ISO8859_4_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_AD7879_I2C_MODULE: u32 = 1;
pub const CONFIG_INTEL_OAKTRAIL_MODULE: u32 = 1;
pub const CONFIG_SND_MTS64_MODULE: u32 = 1;
pub const CONFIG_EXAR_WDT_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_PERICOM_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX31760_MODULE: u32 = 1;
pub const CONFIG_SPI_ALTERA_DFL_MODULE: u32 = 1;
pub const CONFIG_FB_BACKLIGHT_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_RX8025_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_NR_UARTS: u32 = 48;
pub const CONFIG_WILCO_EC_TELEMETRY_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_STRICT_MODULE_RWX: u32 = 1;
pub const CONFIG_TCP_CONG_DCTCP_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MAX8997_MODULE: u32 = 1;
pub const CONFIG_NET_EMATCH_IPSET_MODULE: u32 = 1;
pub const CONFIG_TSL2772_MODULE: u32 = 1;
pub const CONFIG_AD7291_MODULE: u32 = 1;
pub const CONFIG_CC_IS_GCC: u32 = 1;
pub const CONFIG_GPIO_I8255_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_SRPT_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_RMD160_MODULE: u32 = 1;
pub const CONFIG_IR_IMON_MODULE: u32 = 1;
pub const CONFIG_CPU_SUP_HYGON: u32 = 1;
pub const CONFIG_BCM7XXX_PHY_MODULE: u32 = 1;
pub const CONFIG_SCD30_I2C_MODULE: u32 = 1;
pub const CONFIG_PATA_HPT366_MODULE: u32 = 1;
pub const CONFIG_DMA_OPS: u32 = 1;
pub const CONFIG_KVM_COMMON: u32 = 1;
pub const CONFIG_HID_MCP2200_MODULE: u32 = 1;
pub const CONFIG_NET_EGRESS: u32 = 1;
pub const CONFIG_SND_SOC_FSL_UTILS_MODULE: u32 = 1;
pub const CONFIG_XEN_AUTO_XLATE: u32 = 1;
pub const CONFIG_RMI4_CORE_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_ARC: u32 = 1;
pub const CONFIG_SCHED_MC_PRIO: u32 = 1;
pub const CONFIG_IP_SET_HASH_MAC_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_BD663474_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ENGINE_MODULE: u32 = 1;
pub const CONFIG_GP_PCI1XXXX_MODULE: u32 = 1;
pub const CONFIG_INET_AH_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ATXP1_MODULE: u32 = 1;
pub const CONFIG_RANDOMIZE_KSTACK_OFFSET: u32 = 1;
pub const CONFIG_HID_LENOVO_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MAX98373_MODULE: u32 = 1;
pub const CONFIG_HAVE_USER_RETURN_NOTIFIER: u32 = 1;
pub const CONFIG_SND_SOC_ADAU17X1_MODULE: u32 = 1;
pub const CONFIG_MTD_UBI_BEB_LIMIT: u32 = 20;
pub const CONFIG_DRM_I2C_CH7006_MODULE: u32 = 1;
pub const CONFIG_TABLET_USB_KBTAB_MODULE: u32 = 1;
pub const CONFIG_AMD_PMF_DEBUG: u32 = 1;
pub const CONFIG_PATA_PARPORT_COMM_MODULE: u32 = 1;
pub const CONFIG_UDF_FS_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1343_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BYTCR_RT5640_MACH_MODULE: u32 = 1;
pub const CONFIG_IPV6_MIP6_MODULE: u32 = 1;
pub const CONFIG_MARVELL_PHY_MODULE: u32 = 1;
pub const CONFIG_NFT_SOCKET_MODULE: u32 = 1;
pub const CONFIG_HAVE_PERF_USER_STACK_DUMP: u32 = 1;
pub const CONFIG_ACPI_EC_DEBUGFS_MODULE: u32 = 1;
pub const CONFIG_EROFS_FS_SECURITY: u32 = 1;
pub const CONFIG_SENSORS_ADM1266_MODULE: u32 = 1;
pub const CONFIG_APPLE_PROPERTIES: u32 = 1;
pub const CONFIG_VXFS_FS_MODULE: u32 = 1;
pub const CONFIG_USB_CONN_GPIO_MODULE: u32 = 1;
pub const CONFIG_RMI4_F3A: u32 = 1;
pub const CONFIG_GPIO_SCH_MODULE: u32 = 1;
pub const CONFIG_CGROUP_PERF: u32 = 1;
pub const CONFIG_NLATTR: u32 = 1;
pub const CONFIG_SND_LOLA_MODULE: u32 = 1;
pub const CONFIG_ISDN_CAPI: u32 = 1;
pub const CONFIG_HOTPLUG_PCI: u32 = 1;
pub const CONFIG_IIO_ADIS_LIB_MODULE: u32 = 1;
pub const CONFIG_LOCK_DOWN_KERNEL_FORCE_NONE: u32 = 1;
pub const CONFIG_ZD1211RW_MODULE: u32 = 1;
pub const CONFIG_SRF08_MODULE: u32 = 1;
pub const CONFIG_VEML6075_MODULE: u32 = 1;
pub const CONFIG_PCI_PF_STUB_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_CUBIC: u32 = 1;
pub const CONFIG_CEPH_FS_MODULE: u32 = 1;
pub const CONFIG_MPL115_SPI_MODULE: u32 = 1;
pub const CONFIG_SGI_XP_MODULE: u32 = 1;
pub const CONFIG_SCSI_NETLINK: u32 = 1;
pub const CONFIG_BACKLIGHT_BD6107_MODULE: u32 = 1;
pub const CONFIG_TCG_TIS_ST33ZP24_I2C_MODULE: u32 = 1;
pub const CONFIG_NR_CPUS: u32 = 8192;
pub const CONFIG_IXGBE_MODULE: u32 = 1;
pub const CONFIG_SUSPEND_FREEZER: u32 = 1;
pub const CONFIG_HAVE_EXIT_THREAD: u32 = 1;
pub const CONFIG_IIO_BUFFER_CB_MODULE: u32 = 1;
pub const CONFIG_MMC_SDHCI_MODULE: u32 = 1;
pub const CONFIG_VIDEO_AR0521_MODULE: u32 = 1;
pub const CONFIG_GPIO_CRYSTAL_COVE: u32 = 1;
pub const CONFIG_USB_MOUSE_MODULE: u32 = 1;
pub const CONFIG_B43_SSB: u32 = 1;
pub const CONFIG_SND_SUPPORT_OLD_API: u32 = 1;
pub const CONFIG_DVB_DIB7000M_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_CONNMARK_MODULE: u32 = 1;
pub const CONFIG_ENA_ETHERNET_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS35L35_MODULE: u32 = 1;
pub const CONFIG_NR_CPUS_RANGE_BEGIN: u32 = 8192;
pub const CONFIG_IIO_ST_ACCEL_SPI_3AXIS_MODULE: u32 = 1;
pub const CONFIG_LEDS_LT3593_MODULE: u32 = 1;
pub const CONFIG_NO_HZ_FULL: u32 = 1;
pub const CONFIG_LOGITECH_FF: u32 = 1;
pub const CONFIG_BOOTTIME_TRACING: u32 = 1;
pub const CONFIG_DVB_AF9033_MODULE: u32 = 1;
pub const CONFIG_IPV6_FOU_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_INTEL_ISHTP_ECLITE_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_RAW_MODULE: u32 = 1;
pub const CONFIG_EDAC_PND2_MODULE: u32 = 1;
pub const CONFIG_HID_KYE_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MT6360_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_TRACKPOINT: u32 = 1;
pub const CONFIG_CRYPTO_CHACHA20_MODULE: u32 = 1;
pub const CONFIG_HID_GEMBIRD_MODULE: u32 = 1;
pub const CONFIG_MOUSE_VSXXXAA_MODULE: u32 = 1;
pub const CONFIG_IP_MROUTE_MULTIPLE_TABLES: u32 = 1;
pub const CONFIG_VEML6030_MODULE: u32 = 1;
pub const CONFIG_NFT_COMPAT_MODULE: u32 = 1;
pub const CONFIG_LEDS_PCA963X_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_SY7636A_MODULE: u32 = 1;
pub const CONFIG_DRM_NOUVEAU_BACKLIGHT: u32 = 1;
pub const CONFIG_SOFT_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_SYSFS: u32 = 1;
pub const CONFIG_CRYPTO_ARIA_GFNI_AVX512_X86_64_MODULE: u32 = 1;
pub const CONFIG_TYPEC_TCPCI_MT6370_MODULE: u32 = 1;
pub const CONFIG_IPWIRELESS_MODULE: u32 = 1;
pub const CONFIG_IP_SET_BITMAP_IPMAC_MODULE: u32 = 1;
pub const CONFIG_ISCSI_TARGET_CXGB4_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_RICOH_MODULE: u32 = 1;
pub const CONFIG_NETFS_STATS: u32 = 1;
pub const CONFIG_USB_DEFAULT_PERSIST: u32 = 1;
pub const CONFIG_ARCH_HAS_PARANOID_L1D_FLUSH: u32 = 1;
pub const CONFIG_PANEL_PARPORT: u32 = 0;
pub const CONFIG_DVB_MN88473_MODULE: u32 = 1;
pub const CONFIG_LIB80211_CRYPT_WEP_MODULE: u32 = 1;
pub const CONFIG_DELL_WMI_MODULE: u32 = 1;
pub const CONFIG_SBP_TARGET_MODULE: u32 = 1;
pub const CONFIG_DEVICE_MIGRATION: u32 = 1;
pub const CONFIG_SENSORS_W83791D_MODULE: u32 = 1;
pub const CONFIG_HID_SENSOR_CUSTOM_INTEL_HINGE_MODULE: u32 = 1;
pub const CONFIG_INPUT_TOUCHSCREEN: u32 = 1;
pub const CONFIG_RT2800USB_UNKNOWN: u32 = 1;
pub const CONFIG_RADIO_SI4713_MODULE: u32 = 1;
pub const CONFIG_DRM_PANEL_BRIDGE: u32 = 1;
pub const CONFIG_RIONET_RX_SIZE: u32 = 128;
pub const CONFIG_JAILHOUSE_GUEST: u32 = 1;
pub const CONFIG_SND_SOC_CS42L51_I2C_MODULE: u32 = 1;
pub const CONFIG_ROCKCHIP_PHY_MODULE: u32 = 1;
pub const CONFIG_USB_HUB_USB251XB_MODULE: u32 = 1;
pub const CONFIG_I2C_VIAPRO_MODULE: u32 = 1;
pub const CONFIG_FB_HYPERV_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_NW80X_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_LABELS: u32 = 1;
pub const CONFIG_INFINIBAND_ERDMA_MODULE: u32 = 1;
pub const CONFIG_GPIO_ADP5520_MODULE: u32 = 1;
pub const CONFIG_ASN1_ENCODER: u32 = 1;
pub const CONFIG_RTC_DRV_RC5T583_MODULE: u32 = 1;
pub const CONFIG_IP_NF_MATCH_AH_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_SRP_MODULE: u32 = 1;
pub const CONFIG_CARL9170_WPC: u32 = 1;
pub const CONFIG_GPIO_BD9571MWV_MODULE: u32 = 1;
pub const CONFIG_XDP_SOCKETS: u32 = 1;
pub const CONFIG_VIDEO_SAA7134_GO7007_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_VENO_MODULE: u32 = 1;
pub const CONFIG_DVB_S5H1420_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_MODULE: u32 = 1;
pub const CONFIG_AFS_FS_MODULE: u32 = 1;
pub const CONFIG_MFD_88PM800_MODULE: u32 = 1;
pub const CONFIG_SLIMBUS_MODULE: u32 = 1;
pub const CONFIG_SMC_MODULE: u32 = 1;
pub const CONFIG_COMEDI_S526_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DAS1800_MODULE: u32 = 1;
pub const CONFIG_USB_EHCI_HCD_PLATFORM: u32 = 1;
pub const CONFIG_DVB_NET: u32 = 1;
pub const CONFIG_MEDIA_CEC_RC: u32 = 1;
pub const CONFIG_BLK_DEV_BSG_COMMON: u32 = 1;
pub const CONFIG_ASN1: u32 = 1;
pub const CONFIG_BT_MTK_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_LIMIT_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_AES_NI_INTEL_MODULE: u32 = 1;
pub const CONFIG_NFC_SHDLC: u32 = 1;
pub const CONFIG_CRYPTO_DEV_VIRTIO_MODULE: u32 = 1;
pub const CONFIG_MFD_WM8998: u32 = 1;
pub const CONFIG_ULI526X_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_BU21013_MODULE: u32 = 1;
pub const CONFIG_I2C_SIMTEC_MODULE: u32 = 1;
pub const CONFIG_ROHM_BU27034_MODULE: u32 = 1;
pub const CONFIG_FB_SMSCUFX_MODULE: u32 = 1;
pub const CONFIG_FPGA_DFL_FME_BRIDGE_MODULE: u32 = 1;
pub const CONFIG_NTB_TRANSPORT_MODULE: u32 = 1;
pub const CONFIG_XZ_DEC_ARM: u32 = 1;
pub const CONFIG_MAX44000_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_775_MODULE: u32 = 1;
pub const CONFIG_MFD_TI_LMU_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_EEM: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK_OPTIONAL: u32 = 1;
pub const CONFIG_RTLLIB_CRYPTO_TKIP_MODULE: u32 = 1;
pub const CONFIG_QCOM_QMI_HELPERS_MODULE: u32 = 1;
pub const CONFIG_MOUSE_SERIAL_MODULE: u32 = 1;
pub const CONFIG_FB_DMAMEM_HELPERS: u32 = 1;
pub const CONFIG_CRYPTO_HASH_INFO: u32 = 1;
pub const CONFIG_INTEL_ATOMISP2_LED_MODULE: u32 = 1;
pub const CONFIG_IMA_KEXEC: u32 = 1;
pub const CONFIG_JOYSTICK_ANALOG_MODULE: u32 = 1;
pub const CONFIG_MISDN_HFCPCI_MODULE: u32 = 1;
pub const CONFIG_QED_FCOE: u32 = 1;
pub const CONFIG_HAVE_SYSCALL_TRACEPOINTS: u32 = 1;
pub const CONFIG_HAVE_ARCH_HUGE_VMALLOC: u32 = 1;
pub const CONFIG_NFC_ST_NCI_I2C_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_BRCM_COMMON_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_XC4000_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_DEVGROUP_MODULE: u32 = 1;
pub const CONFIG_ACPI_BATTERY: u32 = 1;
pub const CONFIG_IO_WQ: u32 = 1;
pub const CONFIG_DECOMPRESS_ZSTD: u32 = 1;
pub const CONFIG_XEN_PV_DOM0: u32 = 1;
pub const CONFIG_SND_SOC_TAS571X_MODULE: u32 = 1;
pub const CONFIG_DVB_LGDT3305_MODULE: u32 = 1;
pub const CONFIG_CAN_HI311X_MODULE: u32 = 1;
pub const CONFIG_MEMSTICK_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_RX6110_MODULE: u32 = 1;
pub const CONFIG_FUJITSU_TABLET_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_PRESS_SPI_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_MPR121_MODULE: u32 = 1;
pub const CONFIG_FPGA_DFL_AFU_MODULE: u32 = 1;
pub const CONFIG_VIDEO_USBTV_MODULE: u32 = 1;
pub const CONFIG_EEPROM_IDT_89HPESX_MODULE: u32 = 1;
pub const CONFIG_PM_DEVFREQ: u32 = 1;
pub const CONFIG_MFD_JANZ_CMODIO_MODULE: u32 = 1;
pub const CONFIG_VIDEO_SAA7146_MODULE: u32 = 1;
pub const CONFIG_XILINX_EMACLITE_MODULE: u32 = 1;
pub const CONFIG_MTD_COMPLEX_MAPPINGS: u32 = 1;
pub const CONFIG_MARVELL_10G_PHY_MODULE: u32 = 1;
pub const CONFIG_FB: u32 = 1;
pub const CONFIG_NET_DSA_REALTEK_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_LOG_MODULE: u32 = 1;
pub const CONFIG_X86_HAVE_PAE: u32 = 1;
pub const CONFIG_BATTERY_DA9030_MODULE: u32 = 1;
pub const CONFIG_IMA_NG_TEMPLATE: u32 = 1;
pub const CONFIG_TRACING: u32 = 1;
pub const CONFIG_IIO_SYSFS_TRIGGER_MODULE: u32 = 1;
pub const CONFIG_THINKPAD_LMI_MODULE: u32 = 1;
pub const CONFIG_BLK_MQ_VIRTIO: u32 = 1;
pub const CONFIG_TOUCHSCREEN_S6SY761_MODULE: u32 = 1;
pub const CONFIG_IP_NF_MATCH_RPFILTER_MODULE: u32 = 1;
pub const CONFIG_IR_IMON_RAW_MODULE: u32 = 1;
pub const CONFIG_REGMAP_W1_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_865_MODULE: u32 = 1;
pub const CONFIG_TASKS_RUDE_RCU: u32 = 1;
pub const CONFIG_I2C_COMPAT: u32 = 1;
pub const CONFIG_KEYBOARD_OPENCORES_MODULE: u32 = 1;
pub const CONFIG_DRM_SCHED_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ZYDAS: u32 = 1;
pub const CONFIG_SECURITY_LOCKDOWN_LSM_EARLY: u32 = 1;
pub const CONFIG_EFI_DEV_PATH_PARSER: u32 = 1;
pub const CONFIG_REGULATOR_MT6332_MODULE: u32 = 1;
pub const CONFIG_INET_SCTP_DIAG_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BYT_CHT_DA7213_MACH_MODULE: u32 = 1;
pub const CONFIG_NFSD_V3_ACL: u32 = 1;
pub const CONFIG_SND_SOC_SSM4567_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_XRS700X_I2C_MODULE: u32 = 1;
pub const CONFIG_SDR_MAX2175_MODULE: u32 = 1;
pub const CONFIG_CALL_THUNKS: u32 = 1;
pub const CONFIG_USB_GSPCA_SPCA500_MODULE: u32 = 1;
pub const CONFIG_SPARSEMEM_VMEMMAP_ENABLE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_CPU: u32 = 1;
pub const CONFIG_PC300TOO_MODULE: u32 = 1;
pub const CONFIG_HID_ELO_MODULE: u32 = 1;
pub const CONFIG_CAN_CTUCANFD_PCI_MODULE: u32 = 1;
pub const CONFIG_ENCX24J600_MODULE: u32 = 1;
pub const CONFIG_IPVLAN_MODULE: u32 = 1;
pub const CONFIG_HALTPOLL_CPUIDLE_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_KEXEC_SIG: u32 = 1;
pub const CONFIG_COMEDI_NI_LABPC_ISADMA_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_RV3028_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_DA7213_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_NAT_MODULE: u32 = 1;
pub const CONFIG_BATTERY_DS2780_MODULE: u32 = 1;
pub const CONFIG_GPIO_104_IDI_48_MODULE: u32 = 1;
pub const CONFIG_NFC_PORT100_MODULE: u32 = 1;
pub const CONFIG_FTRACE_MCOUNT_RECORD: u32 = 1;
pub const CONFIG_OCFS2_FS_STATS: u32 = 1;
pub const CONFIG_DRM_SSD130X_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_PCI_MODULE: u32 = 1;
pub const CONFIG_MFD_SKY81452_MODULE: u32 = 1;
pub const CONFIG_VIRTUALIZATION: u32 = 1;
pub const CONFIG_ND_CLAIM: u32 = 1;
pub const CONFIG_MSDOS_PARTITION: u32 = 1;
pub const CONFIG_USB_CHIPIDEA_PCI_MODULE: u32 = 1;
pub const CONFIG_COMEDI_RTI800_MODULE: u32 = 1;
pub const CONFIG_MXC4005_MODULE: u32 = 1;
pub const CONFIG_RTC_I2C_AND_SPI: u32 = 1;
pub const CONFIG_VIRT_CPU_ACCOUNTING_GEN: u32 = 1;
pub const CONFIG_MYRI10GE_DCA: u32 = 1;
pub const CONFIG_VIDEO_OV08X40_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_MODULE: u32 = 1;
pub const CONFIG_RESET_ATTACK_MITIGATION: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_NEXIO: u32 = 1;
pub const CONFIG_RT2800USB_RT33XX: u32 = 1;
pub const CONFIG_SND_SOC_SOF_INTEL_TOPLEVEL: u32 = 1;
pub const CONFIG_SND_SOC_WM8903_MODULE: u32 = 1;
pub const CONFIG_DVB_LNBP22_MODULE: u32 = 1;
pub const CONFIG_SENSORS_WM831X_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_INTEL: u32 = 1;
pub const CONFIG_RTC_DRV_TPS6586X_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV2659_MODULE: u32 = 1;
pub const CONFIG_HAVE_CONTEXT_TRACKING_USER_OFFSTACK: u32 = 1;
pub const CONFIG_LEDS_SIEMENS_SIMATIC_IPC_APOLLOLAKE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TMP421_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8804_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM186X_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT711_SDCA_SDW_MODULE: u32 = 1;
pub const CONFIG_FB_RADEON_I2C: u32 = 1;
pub const CONFIG_HMEM_REPORTING: u32 = 1;
pub const CONFIG_DVB_RTL2832_SDR_MODULE: u32 = 1;
pub const CONFIG_CAN_PEAK_PCIEFD_MODULE: u32 = 1;
pub const CONFIG_HAVE_POSIX_CPU_TIMERS_TASK_WORK: u32 = 1;
pub const CONFIG_USB_GSPCA_SN9C2028_MODULE: u32 = 1;
pub const CONFIG_SUNGEM_MODULE: u32 = 1;
pub const CONFIG_BLK_INLINE_ENCRYPTION_FALLBACK: u32 = 1;
pub const CONFIG_BMP280_I2C_MODULE: u32 = 1;
pub const CONFIG_IR_STREAMZAP_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_CS8409_MODULE: u32 = 1;
pub const CONFIG_SAMPLE_FTRACE_DIRECT_MODULE: u32 = 1;
pub const CONFIG_SND_HDSPM_MODULE: u32 = 1;
pub const CONFIG_CAN_PEAK_PCIEC: u32 = 1;
pub const CONFIG_EFI_VARS_PSTORE_MODULE: u32 = 1;
pub const CONFIG_X86_INTEL_LPSS: u32 = 1;
pub const CONFIG_USB_SERIAL_XR_MODULE: u32 = 1;
pub const CONFIG_CPU_IDLE_GOV_LADDER: u32 = 1;
pub const CONFIG_CPU_SUP_ZHAOXIN: u32 = 1;
pub const CONFIG_ACPI_PLATFORM_PROFILE_MODULE: u32 = 1;
pub const CONFIG_LEGACY_DIRECT_IO: u32 = 1;
pub const CONFIG_IP_SET_MODULE: u32 = 1;
pub const CONFIG_FUNCTION_PADDING_BYTES: u32 = 16;
pub const CONFIG_I2C_CCGX_UCSI_MODULE: u32 = 1;
pub const CONFIG_HW_RANDOM_XIPHERA_MODULE: u32 = 1;
pub const CONFIG_THERMAL: u32 = 1;
pub const CONFIG_DVB_BUDGET_PATCH_MODULE: u32 = 1;
pub const CONFIG_SYNC_FILE: u32 = 1;
pub const CONFIG_USB_XHCI_PCI_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TOUCHRIGHT_MODULE: u32 = 1;
pub const CONFIG_AMD8111_ETH_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADL_PCI8164_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ACPI_INTEL_MATCH_MODULE: u32 = 1;
pub const CONFIG_XEN_ACPI: u32 = 1;
pub const CONFIG_AMD_IOMMU: u32 = 1;
pub const CONFIG_I2C_AMD8111_MODULE: u32 = 1;
pub const CONFIG_INPUT_POWERMATE_MODULE: u32 = 1;
pub const CONFIG_OVERLAY_FS_XINO_AUTO: u32 = 1;
pub const CONFIG_NET_FC: u32 = 1;
pub const CONFIG_ACPI_WATCHDOG: u32 = 1;
pub const CONFIG_FB_S3_MODULE: u32 = 1;
pub const CONFIG_PSTORE_BLK_MODULE: u32 = 1;
pub const CONFIG_ADA4250_MODULE: u32 = 1;
pub const CONFIG_BRCMUTIL_MODULE: u32 = 1;
pub const CONFIG_USB4_MODULE: u32 = 1;
pub const CONFIG_SI1133_MODULE: u32 = 1;
pub const CONFIG_DVB_TTUSB_BUDGET_MODULE: u32 = 1;
pub const CONFIG_VETH_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_PCF8583_MODULE: u32 = 1;
pub const CONFIG_DVB_MT312_MODULE: u32 = 1;
pub const CONFIG_SND_AMD_ASOC_ACP63_MODULE: u32 = 1;
pub const CONFIG_MLX5_CORE_EN: u32 = 1;
pub const CONFIG_LEDS_PCA955X_GPIO: u32 = 1;
pub const CONFIG_MFD_TPS65912_I2C: u32 = 1;
pub const CONFIG_NET_VENDOR_3COM: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ROHM_BU21023_MODULE: u32 = 1;
pub const CONFIG_ATM_DUMMY_MODULE: u32 = 1;
pub const CONFIG_MAX517_MODULE: u32 = 1;
pub const CONFIG_HID_PETALYNX_MODULE: u32 = 1;
pub const CONFIG_AMD_NUMA: u32 = 1;
pub const CONFIG_MTD_PCMCIA_MODULE: u32 = 1;
pub const CONFIG_XPOWER_PMIC_OPREGION: u32 = 1;
pub const CONFIG_FB_ATY_CT: u32 = 1;
pub const CONFIG_STACKPROTECTOR: u32 = 1;
pub const CONFIG_IRQ_BYPASS_MANAGER_MODULE: u32 = 1;
pub const CONFIG_ADXRS450_MODULE: u32 = 1;
pub const CONFIG_TLAN_MODULE: u32 = 1;
pub const CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_PCI230_MODULE: u32 = 1;
pub const CONFIG_SEV_GUEST_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM3060_SPI_MODULE: u32 = 1;
pub const CONFIG_SFC_SIENA_MTD: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_VIA_MODULE: u32 = 1;
pub const CONFIG_CMDLINE_PARTITION: u32 = 1;
pub const CONFIG_MEMSTICK_TIFM_MS_MODULE: u32 = 1;
pub const CONFIG_ATM_LANE_MODULE: u32 = 1;
pub const CONFIG_MLXSW_CORE_THERMAL: u32 = 1;
pub const CONFIG_COMMON_CLK_PWM_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_BRCM_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LIB_CHACHA_MODULE: u32 = 1;
pub const CONFIG_SENSORS_W83L786NG_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM1681_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_MIRRED_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_KGDB: u32 = 1;
pub const CONFIG_ARCH_USE_QUEUED_SPINLOCKS: u32 = 1;
pub const CONFIG_IMA_DEFAULT_HASH: &[u8; 7usize] = b"sha256\0";
pub const CONFIG_SOUNDWIRE_CADENCE_MODULE: u32 = 1;
pub const CONFIG_INPUT_APANEL_MODULE: u32 = 1;
pub const CONFIG_NF_TPROXY_IPV4_MODULE: u32 = 1;
pub const CONFIG_B43_PCICORE_AUTOSELECT: u32 = 1;
pub const CONFIG_BLK_DEBUG_FS: u32 = 1;
pub const CONFIG_KEYBOARD_CYPRESS_SF_MODULE: u32 = 1;
pub const CONFIG_QLCNIC_SRIOV: u32 = 1;
pub const CONFIG_MYRI10GE_MODULE: u32 = 1;
pub const CONFIG_X86_PM_TIMER: u32 = 1;
pub const CONFIG_TI_ADC161S626_MODULE: u32 = 1;
pub const CONFIG_USB_VL600_MODULE: u32 = 1;
pub const CONFIG_VIDEO_IMX355_MODULE: u32 = 1;
pub const CONFIG_ISL29501_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_HID_SENSOR_TIME_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_ZONE_DMA_SET: u32 = 1;
pub const CONFIG_ZPA2326_I2C_MODULE: u32 = 1;
pub const CONFIG_B43LEGACY_HWRNG: u32 = 1;
pub const CONFIG_NET_DSA_TAG_LAN9303_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_CHT_BSW_RT5672_MACH_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_AMD_REMBRANDT_MODULE: u32 = 1;
pub const CONFIG_ATH9K_BTCOEX_SUPPORT: u32 = 1;
pub const CONFIG_CAN_SOFTING_MODULE: u32 = 1;
pub const CONFIG_STM_DUMMY_MODULE: u32 = 1;
pub const CONFIG_WIRELESS_HOTKEY_MODULE: u32 = 1;
pub const CONFIG_AMDTEE_MODULE: u32 = 1;
pub const CONFIG_RT2X00_LIB_PCI_MODULE: u32 = 1;
pub const CONFIG_SND_DUMMY_MODULE: u32 = 1;
pub const CONFIG_VIDEOBUF2_V4L2_MODULE: u32 = 1;
pub const CONFIG_SPI_LJCA_MODULE: u32 = 1;
pub const CONFIG_X86_DEBUG_FPU: u32 = 1;
pub const CONFIG_SCSI_MVSAS_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_SCHEDUTIL: u32 = 1;
pub const CONFIG_ADIS16260_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_INTEL: u32 = 1;
pub const CONFIG_HAVE_SOFTIRQ_ON_OWN_STACK: u32 = 1;
pub const CONFIG_NFC_PN544_I2C_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TAS2552_MODULE: u32 = 1;
pub const CONFIG_RPS: u32 = 1;
pub const CONFIG_PACKET_DIAG_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_IMG_I2S_OUT_MODULE: u32 = 1;
pub const CONFIG_DVB_AU8522_DTV_MODULE: u32 = 1;
pub const CONFIG_USB_NET_ZAURUS_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_EXAR_MODULE: u32 = 1;
pub const CONFIG_DEVFREQ_GOV_PERFORMANCE: u32 = 1;
pub const CONFIG_INET6_XFRM_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_DRM_AST_MODULE: u32 = 1;
pub const CONFIG_DM_MULTIPATH_ST_MODULE: u32 = 1;
pub const CONFIG_NET_TEAM_MODE_RANDOM_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM95241_MODULE: u32 = 1;
pub const CONFIG_CXL_PCI_MODULE: u32 = 1;
pub const CONFIG_PROC_PID_CPUSET: u32 = 1;
pub const CONFIG_CPU_IDLE_GOV_TEO: u32 = 1;
pub const CONFIG_REALTEK_AUTOPM: u32 = 1;
pub const CONFIG_IEEE802154_ADF7242_MODULE: u32 = 1;
pub const CONFIG_USB_NET_AX88179_178A_MODULE: u32 = 1;
pub const CONFIG_FB_METRONOME_MODULE: u32 = 1;
pub const CONFIG_CHARGER_LTC4162L_MODULE: u32 = 1;
pub const CONFIG_NF_TABLES_BRIDGE_MODULE: u32 = 1;
pub const CONFIG_USB_MV_U3D_MODULE: u32 = 1;
pub const CONFIG_AD525X_DPOT_SPI_MODULE: u32 = 1;
pub const CONFIG_BATTERY_GAUGE_LTC2941_MODULE: u32 = 1;
pub const CONFIG_INET_ESP_OFFLOAD_MODULE: u32 = 1;
pub const CONFIG_PM_GENERIC_DOMAINS: u32 = 1;
pub const CONFIG_MICROSOFT_MANA_MODULE: u32 = 1;
pub const CONFIG_BINDGEN_VERSION_TEXT: &[u8; 15usize] = b"bindgen 0.65.1\0";
pub const CONFIG_LEGACY_PTY_COUNT: u32 = 0;
pub const CONFIG_IIO_BACKEND_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_E4000_MODULE: u32 = 1;
pub const CONFIG_PMS7003_MODULE: u32 = 1;
pub const CONFIG_INPUT_ATLAS_BTNS_MODULE: u32 = 1;
pub const CONFIG_LOAD_UEFI_KEYS: u32 = 1;
pub const CONFIG_ACQUIRE_WDT_MODULE: u32 = 1;
pub const CONFIG_PM_WAKELOCKS_LIMIT: u32 = 100;
pub const CONFIG_VIDEO_SAA6588_MODULE: u32 = 1;
pub const CONFIG_IPV6_FOU_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_DMC_TSC10: u32 = 1;
pub const CONFIG_DVB_ZL10039_MODULE: u32 = 1;
pub const CONFIG_INTEL_ATOMISP2_PM_MODULE: u32 = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_2: u32 = 1;
pub const CONFIG_USB_AUDIO_MODULE: u32 = 1;
pub const CONFIG_NFT_REJECT_MODULE: u32 = 1;
pub const CONFIG_NVME_TARGET_RDMA_MODULE: u32 = 1;
pub const CONFIG_WDTPCI_MODULE: u32 = 1;
pub const CONFIG_STX104_MODULE: u32 = 1;
pub const CONFIG_LG_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_DEBUG_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX16064_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_IPPORTIP_MODULE: u32 = 1;
pub const CONFIG_MLX4_EN_MODULE: u32 = 1;
pub const CONFIG_TABLET_USB_ACECAD_MODULE: u32 = 1;
pub const CONFIG_HYPERVISOR_GUEST: u32 = 1;
pub const CONFIG_SENSORS_LM70_MODULE: u32 = 1;
pub const CONFIG_SERIAL_MAX310X: u32 = 1;
pub const CONFIG_SECURITY_SMACK_NETFILTER: u32 = 1;
pub const CONFIG_NET_EMATCH_NBYTE_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_XRS700X_MODULE: u32 = 1;
pub const CONFIG_RESET_SIMPLE: u32 = 1;
pub const CONFIG_SENSORS_BH1770_MODULE: u32 = 1;
pub const CONFIG_SIS190_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_UC1611_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MT6358_MODULE: u32 = 1;
pub const CONFIG_HID_RAZER_MODULE: u32 = 1;
pub const CONFIG_INTEL_INT0002_VGPIO_MODULE: u32 = 1;
pub const CONFIG_RAPIDIO_DMA_ENGINE: u32 = 1;
pub const CONFIG_CALL_PADDING: u32 = 1;
pub const CONFIG_FONT_TER16x32: u32 = 1;
pub const CONFIG_USB_BDC_UDC_MODULE: u32 = 1;
pub const CONFIG_TCG_NSC_MODULE: u32 = 1;
pub const CONFIG_PREFIX_SYMBOLS: u32 = 1;
pub const CONFIG_BCMA_SFLASH: u32 = 1;
pub const CONFIG_ZISOFS: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MEDIATEK: u32 = 1;
pub const CONFIG_SND_SOC_ADAU1372_SPI_MODULE: u32 = 1;
pub const CONFIG_CUSE_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8728_MODULE: u32 = 1;
pub const CONFIG_USB_ZERO_MODULE: u32 = 1;
pub const CONFIG_FB_SYSMEM_FOPS: u32 = 1;
pub const CONFIG_TOUCHSCREEN_WM97XX_MODULE: u32 = 1;
pub const CONFIG_NF_TABLES_IPV4: u32 = 1;
pub const CONFIG_IP_MULTICAST: u32 = 1;
pub const CONFIG_FB_RADEON_MODULE: u32 = 1;
pub const CONFIG_DM_CACHE_SMQ_MODULE: u32 = 1;
pub const CONFIG_SENSORS_AQUACOMPUTER_D5NEXT_MODULE: u32 = 1;
pub const CONFIG_DVB_MT352_MODULE: u32 = 1;
pub const CONFIG_RC_ATI_REMOTE_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_RTQ2134_MODULE: u32 = 1;
pub const CONFIG_W83627HF_WDT_MODULE: u32 = 1;
pub const CONFIG_SQUASHFS_XZ: u32 = 1;
pub const CONFIG_DRM_XE_MODULE: u32 = 1;
pub const CONFIG_FB_VOODOO1_MODULE: u32 = 1;
pub const CONFIG_WILCO_EC_EVENTS_MODULE: u32 = 1;
pub const CONFIG_USB_NET_CX82310_ETH_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CMOS_UPDATE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SOF_WM8804_MACH_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_CISCO: u32 = 1;
pub const CONFIG_REGULATOR_AS3711_MODULE: u32 = 1;
pub const CONFIG_EEPROM_MAX6875_MODULE: u32 = 1;
pub const CONFIG_ACPI_ALS_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5682S_MODULE: u32 = 1;
pub const CONFIG_W1_MASTER_MATROX_MODULE: u32 = 1;
pub const CONFIG_DRM_CIRRUS_QEMU_MODULE: u32 = 1;
pub const CONFIG_MAX31827_MODULE: u32 = 1;
pub const CONFIG_MOUSE_APPLETOUCH_MODULE: u32 = 1;
pub const CONFIG_INTEL_SPEED_SELECT_TPMI_MODULE: u32 = 1;
pub const CONFIG_CHARGER_BQ256XX_MODULE: u32 = 1;
pub const CONFIG_HID_LOGITECH_DJ_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_PTE_DEVMAP: u32 = 1;
pub const CONFIG_MFD_DLN2_MODULE: u32 = 1;
pub const CONFIG_TYPEC_MUX_WCD939X_USBSS_MODULE: u32 = 1;
pub const CONFIG_VIDEO_STK1160_MODULE: u32 = 1;
pub const CONFIG_BT_LEDS: u32 = 1;
pub const CONFIG_GIGABYTE_WMI_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DH: u32 = 1;
pub const CONFIG_FUNCTION_ERROR_INJECTION: u32 = 1;
pub const CONFIG_TICK_ONESHOT: u32 = 1;
pub const CONFIG_USB_CDNS3_PCI_WRAP_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_PCI_DEV_MODULE: u32 = 1;
pub const CONFIG_FB_I740_MODULE: u32 = 1;
pub const CONFIG_XEN_PCIDEV_FRONTEND_MODULE: u32 = 1;
pub const CONFIG_XFS_SUPPORT_ASCII_CI: u32 = 1;
pub const CONFIG_HID_BETOP_FF_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_SIERRAWIRELESS_MODULE: u32 = 1;
pub const CONFIG_INTEL_HFI_THERMAL: u32 = 1;
pub const CONFIG_CRYPTO_CTR: u32 = 1;
pub const CONFIG_SND_SOC_MAX9867_MODULE: u32 = 1;
pub const CONFIG_GPIO_TPS6586X: u32 = 1;
pub const CONFIG_CAN_F81601_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_XIRC2PS_MODULE: u32 = 1;
pub const CONFIG_COMPAT_FOR_U64_ALIGNMENT: u32 = 1;
pub const CONFIG_MTRR_SANITIZER: u32 = 1;
pub const CONFIG_GNSS_UBX_SERIAL_MODULE: u32 = 1;
pub const CONFIG_XARRAY_MULTI: u32 = 1;
pub const CONFIG_LOCK_MM_AND_FIND_VMA: u32 = 1;
pub const CONFIG_DVB_STV090x_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_RTL4_A_MODULE: u32 = 1;
pub const CONFIG_USB_CDNS3_GADGET: u32 = 1;
pub const CONFIG_CROS_EC_ISHTP_MODULE: u32 = 1;
pub const CONFIG_SCSI_HPTIOP_MODULE: u32 = 1;
pub const CONFIG_NATIONAL_PHY_MODULE: u32 = 1;
pub const CONFIG_B43LEGACY_PCICORE_AUTOSELECT: u32 = 1;
pub const CONFIG_SW_SYNC: u32 = 1;
pub const CONFIG_REGMAP_SCCB_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_LB_SS: u32 = 1;
pub const CONFIG_INTEL_VSC_MODULE: u32 = 1;
pub const CONFIG_SPI_DW_PCI_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_PDA_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TW68_MODULE: u32 = 1;
pub const CONFIG_WIRELESS_EXT: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MT2060_MODULE: u32 = 1;
pub const CONFIG_HID_PICOLCD_BACKLIGHT: u32 = 1;
pub const CONFIG_SND_SOC_RT5640_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADV_PCI1710_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_CA0110_MODULE: u32 = 1;
pub const CONFIG_GPIO_TPS65910: u32 = 1;
pub const CONFIG_NFC_ST_NCI_MODULE: u32 = 1;
pub const CONFIG_BCACHEFS_POSIX_ACL: u32 = 1;
pub const CONFIG_VIDEO_GC2145_MODULE: u32 = 1;
pub const CONFIG_MAPPING_DIRTY_HELPERS: u32 = 1;
pub const CONFIG_SND_SOC_CHV3_I2S_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV6650_MODULE: u32 = 1;
pub const CONFIG_VDPA_SIM_BLOCK_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_RS5C348_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_PV88080_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MT6357_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_FTRTC010_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MAX9759_MODULE: u32 = 1;
pub const CONFIG_SND_INTEL_DSP_CONFIG_MODULE: u32 = 1;
pub const CONFIG_STM_PROTO_SYS_T_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_ACP_PCM_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX31730_MODULE: u32 = 1;
pub const CONFIG_MODVERSIONS: u32 = 1;
pub const CONFIG_HW_RANDOM: u32 = 1;
pub const CONFIG_B43_PCI_AUTOSELECT: u32 = 1;
pub const CONFIG_MUTEX_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_MACH: u32 = 1;
pub const CONFIG_PATA_LEGACY_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_AU6610_MODULE: u32 = 1;
pub const CONFIG_CM3605_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_METEORPOINT_MODULE: u32 = 1;
pub const CONFIG_SPI_LM70_LLP_MODULE: u32 = 1;
pub const CONFIG_X86_SPEEDSTEP_LIB_MODULE: u32 = 1;
pub const CONFIG_IE6XX_WDT_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBTUSB_RTL: u32 = 1;
pub const CONFIG_HAVE_ARCH_USERFAULTFD_MINOR: u32 = 1;
pub const CONFIG_MP2629_ADC_MODULE: u32 = 1;
pub const CONFIG_SYS_HYPERVISOR: u32 = 1;
pub const CONFIG_DYNAMIC_SIGFRAME: u32 = 1;
pub const CONFIG_TOUCHSCREEN_WACOM_I2C_MODULE: u32 = 1;
pub const CONFIG_USB_LEDS_TRIGGER_USBPORT_MODULE: u32 = 1;
pub const CONFIG_BOOT_VESA_SUPPORT: u32 = 1;
pub const CONFIG_SENSORS_HP_WMI_MODULE: u32 = 1;
pub const CONFIG_ATM_IA_MODULE: u32 = 1;
pub const CONFIG_RETHOOK: u32 = 1;
pub const CONFIG_VIRTIO_VSOCKETS_COMMON_MODULE: u32 = 1;
pub const CONFIG_SND_VIRTUOSO_MODULE: u32 = 1;
pub const CONFIG_AMIGA_PARTITION: u32 = 1;
pub const CONFIG_EARLY_PRINTK: u32 = 1;
pub const CONFIG_SND_SOC_WM8804_I2C_MODULE: u32 = 1;
pub const CONFIG_THINKPAD_ACPI_ALSA_SUPPORT: u32 = 1;
pub const CONFIG_CGROUP_NET_CLASSID: u32 = 1;
pub const CONFIG_SENSORS_ADS7871_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_SYNPROXY_MODULE: u32 = 1;
pub const CONFIG_TPL0102_MODULE: u32 = 1;
pub const CONFIG_MDIO_MVUSB_MODULE: u32 = 1;
pub const CONFIG_FS_DAX: u32 = 1;
pub const CONFIG_INTEL_TH_MSU_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5677_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_737_MODULE: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_GRAPH_TRACER: u32 = 1;
pub const CONFIG_HW_RANDOM_VIA_MODULE: u32 = 1;
pub const CONFIG_SUNDANCE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_W83781D_MODULE: u32 = 1;
pub const CONFIG_PCI_EPF_VNTB_MODULE: u32 = 1;
pub const CONFIG_I2C_DESIGNWARE_PLATFORM: u32 = 1;
pub const CONFIG_BUFFER_HEAD: u32 = 1;
pub const CONFIG_CRYPTO_LIB_POLY1305_GENERIC_MODULE: u32 = 1;
pub const CONFIG_DRM_XE_JOB_TIMEOUT_MIN: u32 = 1;
pub const CONFIG_CAN_SOFTING_CS_MODULE: u32 = 1;
pub const CONFIG_DP83869_PHY_MODULE: u32 = 1;
pub const CONFIG_PTE_MARKER_UFFD_WP: u32 = 1;
pub const CONFIG_HAVE_CMPXCHG_LOCAL: u32 = 1;
pub const CONFIG_NVDIMM_PFN: u32 = 1;
pub const CONFIG_AF_KCM_MODULE: u32 = 1;
pub const CONFIG_VIDEOBUF2_CORE_MODULE: u32 = 1;
pub const CONFIG_DVB_HELENE_MODULE: u32 = 1;
pub const CONFIG_SSB_DRIVER_GPIO: u32 = 1;
pub const CONFIG_I2C_LJCA_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_IPC3: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_USER_FRIENDLY_LONG_NAMES: u32 = 1;
pub const CONFIG_SMB_SERVER_CHECK_CAP_NET_ADMIN: u32 = 1;
pub const CONFIG_CRYPTO_BLAKE2B_MODULE: u32 = 1;
pub const CONFIG_INTEL_IOMMU_SCALABLE_MODE_DEFAULT_ON: u32 = 1;
pub const CONFIG_MTD_PHYSMAP_GPIO_ADDR: u32 = 1;
pub const CONFIG_EEEPC_WMI_MODULE: u32 = 1;
pub const CONFIG_INPUT_ADXL34X_I2C_MODULE: u32 = 1;
pub const CONFIG_TREE_SRCU: u32 = 1;
pub const CONFIG_CRYPTO_NULL2: u32 = 1;
pub const CONFIG_NTFS_FS_MODULE: u32 = 1;
pub const CONFIG_VIDEO_AU0828_V4L2: u32 = 1;
pub const CONFIG_REGULATOR_MAX8998_MODULE: u32 = 1;
pub const CONFIG_ACPI_THERMAL: u32 = 1;
pub const CONFIG_SLIM_QCOM_CTRL_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_LANTIQ_GSWIP_MODULE: u32 = 1;
pub const CONFIG_DPTF_PCH_FIVR_MODULE: u32 = 1;
pub const CONFIG_SND_SEQ_UMP_CLIENT_MODULE: u32 = 1;
pub const CONFIG_RT2X00_LIB_CRYPTO: u32 = 1;
pub const CONFIG_CRYPTO_LIB_DES_MODULE: u32 = 1;
pub const CONFIG_SCSI_DH_HP_SW_MODULE: u32 = 1;
pub const CONFIG_AMD_PMF_MODULE: u32 = 1;
pub const CONFIG_HSC030PA_I2C_MODULE: u32 = 1;
pub const CONFIG_FUNCTION_ALIGNMENT_16B: u32 = 1;
pub const CONFIG_IP_SCTP_MODULE: u32 = 1;
pub const CONFIG_DVB_STB0899_MODULE: u32 = 1;
pub const CONFIG_INPUT_SOC_BUTTON_ARRAY_MODULE: u32 = 1;
pub const CONFIG_P54_PCI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_ALDERLAKE_MODULE: u32 = 1;
pub const CONFIG_INSPUR_PLATFORM_PROFILE_MODULE: u32 = 1;
pub const CONFIG_AOSONG_AGS02MA_MODULE: u32 = 1;
pub const CONFIG_ACPI_MDIO: u32 = 1;
pub const CONFIG_MARVELL_88X2222_PHY_MODULE: u32 = 1;
pub const CONFIG_LEDS_ADP5520_MODULE: u32 = 1;
pub const CONFIG_SCSI_SIM710_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_ACPI_TABLE_UPGRADE: u32 = 1;
pub const CONFIG_MADERA_IRQ_MODULE: u32 = 1;
pub const CONFIG_HUGETLB_PAGE_OPTIMIZE_VMEMMAP: u32 = 1;
pub const CONFIG_SERIAL_8250_DMA: u32 = 1;
pub const CONFIG_FUNCTION_ALIGNMENT_4B: u32 = 1;
pub const CONFIG_VIDEO_IPU3_IMGU_MODULE: u32 = 1;
pub const CONFIG_BASE_SMALL: u32 = 0;
pub const CONFIG_IWLEGACY_DEBUGFS: u32 = 1;
pub const CONFIG_INPUT_GPIO_VIBRA_MODULE: u32 = 1;
pub const CONFIG_XEN_GRANT_DEV_ALLOC_MODULE: u32 = 1;
pub const CONFIG_PM_WAKELOCKS: u32 = 1;
pub const CONFIG_COUNTER_MODULE: u32 = 1;
pub const CONFIG_SCSI_SAS_ATTRS_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_AVC_STATS: u32 = 1;
pub const CONFIG_RTL8187_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_SCODEC_CS35L56_I2C_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CMDLINE: u32 = 1;
pub const CONFIG_X86_PMEM_LEGACY_DEVICE: u32 = 1;
pub const CONFIG_NFP_APP_ABM_NIC: u32 = 1;
pub const CONFIG_SND_SEQ_DUMMY_MODULE: u32 = 1;
pub const CONFIG_QTNFMAC_MODULE: u32 = 1;
pub const CONFIG_B43LEGACY_PCI_AUTOSELECT: u32 = 1;
pub const CONFIG_DM_RAID_MODULE: u32 = 1;
pub const CONFIG_COMPACTION: u32 = 1;
pub const CONFIG_NFS_V2_MODULE: u32 = 1;
pub const CONFIG_RTW88_DEBUG: u32 = 1;
pub const CONFIG_USB_HCD_BCMA_MODULE: u32 = 1;
pub const CONFIG_SCSI_MPT3SAS_MAX_SGE: u32 = 128;
pub const CONFIG_CAN_SJA1000_ISA_MODULE: u32 = 1;
pub const CONFIG_DVB_TDA18271C2DD_MODULE: u32 = 1;
pub const CONFIG_USB_AIRSPY_MODULE: u32 = 1;
pub const CONFIG_ALIENWARE_WMI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SOF_CS42L42_MACH_MODULE: u32 = 1;
pub const CONFIG_DVB_CXD2820R_MODULE: u32 = 1;
pub const CONFIG_WM8350_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_MRVL: u32 = 1;
pub const CONFIG_VIDEO_TDA7432_MODULE: u32 = 1;
pub const CONFIG_TEST_POWER_MODULE: u32 = 1;
pub const CONFIG_SND_INTEL_NHLT: u32 = 1;
pub const CONFIG_NF_DUP_IPV6_MODULE: u32 = 1;
pub const CONFIG_RTL8723BE_MODULE: u32 = 1;
pub const CONFIG_TMP117_MODULE: u32 = 1;
pub const CONFIG_Z3FOLD_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS2404_MODULE: u32 = 1;
pub const CONFIG_DM_ERA_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_DAQ_DIO24_CS_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SONIXJ_MODULE: u32 = 1;
pub const CONFIG_MFD_CS42L43_I2C_MODULE: u32 = 1;
pub const CONFIG_SERIAL_ALTERA_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_THINKPAD_ACPI_HOTKEY_POLL: u32 = 1;
pub const CONFIG_REGULATOR_MT6323_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_F81232_MODULE: u32 = 1;
pub const CONFIG_DRM_AMDGPU_MODULE: u32 = 1;
pub const CONFIG_BLK_CGROUP_PUNT_BIO: u32 = 1;
pub const CONFIG_ARCH_HAS_UBSAN: u32 = 1;
pub const CONFIG_VIDEO_OV7670_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1553_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_HAMPSHIRE_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TSC2005_MODULE: u32 = 1;
pub const CONFIG_PROC_FS: u32 = 1;
pub const CONFIG_MMC_CB710_MODULE: u32 = 1;
pub const CONFIG_MTD_BLOCK_MODULE: u32 = 1;
pub const CONFIG_SND_OXFW_MODULE: u32 = 1;
pub const CONFIG_MPL3115_MODULE: u32 = 1;
pub const CONFIG_ACPI_HOTPLUG_MEMORY: u32 = 1;
pub const CONFIG_VIDEOBUF2_VMALLOC_MODULE: u32 = 1;
pub const CONFIG_NFT_BRIDGE_REJECT_MODULE: u32 = 1;
pub const CONFIG_GENERIC_BUG_RELATIVE_POINTERS: u32 = 1;
pub const CONFIG_SND_SOC_WM8523_MODULE: u32 = 1;
pub const CONFIG_6LOWPAN_NHC_FRAGMENT_MODULE: u32 = 1;
pub const CONFIG_SECURITY_TOMOYO: u32 = 1;
pub const CONFIG_RC_MAP_MODULE: u32 = 1;
pub const CONFIG_WEXT_PRIV: u32 = 1;
pub const CONFIG_MMU_GATHER_RCU_TABLE_FREE: u32 = 1;
pub const CONFIG_THINKPAD_ACPI_VIDEO: u32 = 1;
pub const CONFIG_VIRTIO_MMIO: u32 = 1;
pub const CONFIG_NET_VENDOR_ROCKER: u32 = 1;
pub const CONFIG_XFRM_AH_MODULE: u32 = 1;
pub const CONFIG_SCSI_LOWLEVEL: u32 = 1;
pub const CONFIG_SND_SOC_MAX98504_MODULE: u32 = 1;
pub const CONFIG_DP83822_PHY_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DH_RFC7919_GROUPS: u32 = 1;
pub const CONFIG_SND_SOC_CS42L83_MODULE: u32 = 1;
pub const CONFIG_EFI_SOFT_RESERVE: u32 = 1;
pub const CONFIG_NVME_KEYRING_MODULE: u32 = 1;
pub const CONFIG_ROSE_MODULE: u32 = 1;
pub const CONFIG_HYPERV_VSOCKETS_MODULE: u32 = 1;
pub const CONFIG_SPI_INTEL_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_ARASAN_MODULE: u32 = 1;
pub const CONFIG_INTEL_SOC_PMIC_CHTDC_TI_MODULE: u32 = 1;
pub const CONFIG_INTEL_SOC_DTS_IOSF_CORE_MODULE: u32 = 1;
pub const CONFIG_INPUT_GPIO_ROTARY_ENCODER_MODULE: u32 = 1;
pub const CONFIG_IP_VS_PROTO_AH_ESP: u32 = 1;
pub const CONFIG_MTD_QINFO_PROBE_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_POWER_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_NAU8825_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT711_SDW_MODULE: u32 = 1;
pub const CONFIG_INPUT_DRV260X_HAPTICS_MODULE: u32 = 1;
pub const CONFIG_MEMFD_CREATE: u32 = 1;
pub const CONFIG_IRQ_FORCED_THREADING: u32 = 1;
pub const CONFIG_NILFS2_FS_MODULE: u32 = 1;
pub const CONFIG_ATH9K_PCI: u32 = 1;
pub const CONFIG_GNSS_SERIAL_MODULE: u32 = 1;
pub const CONFIG_DRM_AMD_DC_FP: u32 = 1;
pub const CONFIG_TOUCHSCREEN_HIDEEP_MODULE: u32 = 1;
pub const CONFIG_EDAC_ATOMIC_SCRUB: u32 = 1;
pub const CONFIG_NFSD_FLEXFILELAYOUT: u32 = 1;
pub const CONFIG_USB_F_HID_MODULE: u32 = 1;
pub const CONFIG_NLS_ISO8859_3_MODULE: u32 = 1;
pub const CONFIG_RSI_91X_MODULE: u32 = 1;
pub const CONFIG_INTEL_IOMMU_PERF_EVENTS: u32 = 1;
pub const CONFIG_FB_OPENCORES_MODULE: u32 = 1;
pub const CONFIG_XEN_SYS_HYPERVISOR: u32 = 1;
pub const CONFIG_SND_SOC_NAU8315_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MT6315_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CMAC_MODULE: u32 = 1;
pub const CONFIG_DELL_SMBIOS_WMI: u32 = 1;
pub const CONFIG_INTEL_TELEMETRY_MODULE: u32 = 1;
pub const CONFIG_IIO_CROS_EC_LIGHT_PROX_MODULE: u32 = 1;
pub const CONFIG_MAX30100_MODULE: u32 = 1;
pub const CONFIG_LEDS_SIEMENS_SIMATIC_IPC_F7188X_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TDA18250_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCL816_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_MAX98357A_MODULE: u32 = 1;
pub const CONFIG_HID_PANTHERLORD_MODULE: u32 = 1;
pub const CONFIG_DRM_FBDEV_EMULATION: u32 = 1;
pub const CONFIG_MTDRAM_ERASE_SIZE: u32 = 128;
pub const CONFIG_SND_MODULE: u32 = 1;
pub const CONFIG_MTD_ICHXROM_MODULE: u32 = 1;
pub const CONFIG_UBIFS_FS_AUTHENTICATION: u32 = 1;
pub const CONFIG_SND_SOC_STI_SAS_MODULE: u32 = 1;
pub const CONFIG_SND_SST_ATOM_HIFI2_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SST_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_GYRO_I2C_3AXIS_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_TEQL_MODULE: u32 = 1;
pub const CONFIG_MEMSTICK_JMICRON_38X_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MCP3021_MODULE: u32 = 1;
pub const CONFIG_IR_RC6_DECODER_MODULE: u32 = 1;
pub const CONFIG_XEN_NETDEV_BACKEND_MODULE: u32 = 1;
pub const CONFIG_LTC2485_MODULE: u32 = 1;
pub const CONFIG_MFD_LP3943_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_ABB5ZES3_MODULE: u32 = 1;
pub const CONFIG_SCSI_SNIC_MODULE: u32 = 1;
pub const CONFIG_KXCJK1013_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_MCP23S08_I2C_MODULE: u32 = 1;
pub const CONFIG_MTD_OOPS_MODULE: u32 = 1;
pub const CONFIG_IWLEGACY_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TPS546D24_MODULE: u32 = 1;
pub const CONFIG_SCSI_INIA100_MODULE: u32 = 1;
pub const CONFIG_S2IO_MODULE: u32 = 1;
pub const CONFIG_IP_VS_SH_MODULE: u32 = 1;
pub const CONFIG_XEN_BALLOON: u32 = 1;
pub const CONFIG_PWM_CLK_MODULE: u32 = 1;
pub const CONFIG_VIDEO_MSP3400_MODULE: u32 = 1;
pub const CONFIG_VIDEO_BT856_MODULE: u32 = 1;
pub const CONFIG_MCTP_SERIAL_MODULE: u32 = 1;
pub const CONFIG_USB_F_OBEX_MODULE: u32 = 1;
pub const CONFIG_PLIP_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SERPENT_AVX_X86_64_MODULE: u32 = 1;
pub const CONFIG_TCG_TIS_SPI_MODULE: u32 = 1;
pub const CONFIG_MC3230_MODULE: u32 = 1;
pub const CONFIG_MT7921_COMMON_MODULE: u32 = 1;
pub const CONFIG_USB_PEGASUS_MODULE: u32 = 1;
pub const CONFIG_NMI_CHECK_CPU: u32 = 1;
pub const CONFIG_IIO_ST_MAGN_3AXIS_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_UC1701_MODULE: u32 = 1;
pub const CONFIG_HI8435_MODULE: u32 = 1;
pub const CONFIG_USB_TMC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8962_MODULE: u32 = 1;
pub const CONFIG_NET_VRF_MODULE: u32 = 1;
pub const CONFIG_INPUT_E3X0_BUTTON_MODULE: u32 = 1;
pub const CONFIG_USB_G_WEBCAM_MODULE: u32 = 1;
pub const CONFIG_SBC_EPX_C3_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_ATM_HE_USE_SUNI: u32 = 1;
pub const CONFIG_PCIE_DW: u32 = 1;
pub const CONFIG_ATH9K_PCI_NO_EEPROM_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_MIDI2: u32 = 1;
pub const CONFIG_NET_DSA_SMSC_LAN9303_MODULE: u32 = 1;
pub const CONFIG_LD_ORPHAN_WARN: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_FD_MODULE: u32 = 1;
pub const CONFIG_LCD_HX8357_MODULE: u32 = 1;
pub const CONFIG_V4L_PLATFORM_DRIVERS: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2408_READBACK: u32 = 1;
pub const CONFIG_EVM: u32 = 1;
pub const CONFIG_X9250_MODULE: u32 = 1;
pub const CONFIG_SND_PCSP_MODULE: u32 = 1;
pub const CONFIG_FB_NVIDIA_I2C: u32 = 1;
pub const CONFIG_SND_SOC_SOF_HDA_COMMON_MODULE: u32 = 1;
pub const CONFIG_RFKILL_INPUT: u32 = 1;
pub const CONFIG_NXP_TJA11XX_PHY_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_USB6501_MODULE: u32 = 1;
pub const CONFIG_RAPIDIO_MPORT_CDEV_MODULE: u32 = 1;
pub const CONFIG_FB_CIRRUS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX20751_MODULE: u32 = 1;
pub const CONFIG_DEV_DAX_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_NATSEMI: u32 = 1;
pub const CONFIG_USB_MUSB_DUAL_ROLE: u32 = 1;
pub const CONFIG_BLK_DEV_BSGLIB: u32 = 1;
pub const CONFIG_NET_DSA_TAG_MTK_MODULE: u32 = 1;
pub const CONFIG_IOMMU_MM_DATA: u32 = 1;
pub const CONFIG_GPIO_TPS68470_MODULE: u32 = 1;
pub const CONFIG_ATH5K_PCI: u32 = 1;
pub const CONFIG_MEDIA_TUNER_FC2580_MODULE: u32 = 1;
pub const CONFIG_AQUANTIA_PHY_MODULE: u32 = 1;
pub const CONFIG_MFD_IQS62X_MODULE: u32 = 1;
pub const CONFIG_TABLET_USB_HANWANG_MODULE: u32 = 1;
pub const CONFIG_USB_DWC3_HAPS_MODULE: u32 = 1;
pub const CONFIG_RTW88_8822CE_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_PCI_LIB_LEGACY: u32 = 1;
pub const CONFIG_USB_F_MASS_STORAGE_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_AAT2870_MODULE: u32 = 1;
pub const CONFIG_MFD_RT4831_MODULE: u32 = 1;
pub const CONFIG_MENF21BMC_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_ATH9K_COMMON_MODULE: u32 = 1;
pub const CONFIG_NFT_XFRM_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_GOOGLE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_QAT_C62XVF_MODULE: u32 = 1;
pub const CONFIG_DVB_STB6000_MODULE: u32 = 1;
pub const CONFIG_SERIAL_FSL_LINFLEXUART_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS35L36_MODULE: u32 = 1;
pub const CONFIG_SND_FIREWIRE_MOTU_MODULE: u32 = 1;
pub const CONFIG_FW_CS_DSP_MODULE: u32 = 1;
pub const CONFIG_COMEDI_MISC_DRIVERS: u32 = 1;
pub const CONFIG_USB_SERIAL_QCAUX_MODULE: u32 = 1;
pub const CONFIG_NFSD_BLOCKLAYOUT: u32 = 1;
pub const CONFIG_SATA_ACARD_AHCI_MODULE: u32 = 1;
pub const CONFIG_GENERIC_IRQ_MIGRATION: u32 = 1;
pub const CONFIG_NET_VENDOR_NETRONOME: u32 = 1;
pub const CONFIG_NFS_USE_KERNEL_DNS: u32 = 1;
pub const CONFIG_SENSORS_MAX31722_MODULE: u32 = 1;
pub const CONFIG_MISDN_SPEEDFAX_MODULE: u32 = 1;
pub const CONFIG_SENSORS_IBMAEM_MODULE: u32 = 1;
pub const CONFIG_SENSORS_GIGABYTE_WATERFORCE_MODULE: u32 = 1;
pub const CONFIG_DMA_ENGINE_RAID: u32 = 1;
pub const CONFIG_ARCH_HAS_FORTIFY_SOURCE: u32 = 1;
pub const CONFIG_GCC_VERSION: u32 = 140201;
pub const CONFIG_SND_HDA_I915: u32 = 1;
pub const CONFIG_CRYPTO_LIB_POLY1305_RSIZE: u32 = 11;
pub const CONFIG_SND_SEQ_UMP: u32 = 1;
pub const CONFIG_REGULATOR_MAX77541_MODULE: u32 = 1;
pub const CONFIG_QCOM_SPMI_VADC_MODULE: u32 = 1;
pub const CONFIG_HT16K33_MODULE: u32 = 1;
pub const CONFIG_EXTCON_PTN5150_MODULE: u32 = 1;
pub const CONFIG_LATTICE_ECP3_CONFIG_MODULE: u32 = 1;
pub const CONFIG_SYSCTL: u32 = 1;
pub const CONFIG_CRYPTO_DES3_EDE_X86_64_MODULE: u32 = 1;
pub const CONFIG_CC_CAN_LINK_STATIC: u32 = 1;
pub const CONFIG_842_DECOMPRESS_MODULE: u32 = 1;
pub const CONFIG_DWC_PCIE_PMU_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MR75203_MODULE: u32 = 1;
pub const CONFIG_BCM_VK_TTY: u32 = 1;
pub const CONFIG_ARCH_HAS_GCOV_PROFILE_ALL: u32 = 1;
pub const CONFIG_SND_USB_AUDIO_USE_MEDIA_CONTROLLER: u32 = 1;
pub const CONFIG_VIDEO_TLV320AIC23B_MODULE: u32 = 1;
pub const CONFIG_KERNEL_ZSTD: u32 = 1;
pub const CONFIG_BRIDGE_IGMP_SNOOPING: u32 = 1;
pub const CONFIG_SND_SOC_SRC4XXX_I2C_MODULE: u32 = 1;
pub const CONFIG_MTD_BLOCK2MTD_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_THERM_MODULE: u32 = 1;
pub const CONFIG_CAN_SLCAN_MODULE: u32 = 1;
pub const CONFIG_PCIE_DW_EP: u32 = 1;
pub const CONFIG_SND_SOC_WM_ADSP_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_TWIDJOY_MODULE: u32 = 1;
pub const CONFIG_EL3_MODULE: u32 = 1;
pub const CONFIG_PHYS_ADDR_T_64BIT: u32 = 1;
pub const CONFIG_COMEDI_DT2815_MODULE: u32 = 1;
pub const CONFIG_TI_ADS8344_MODULE: u32 = 1;
pub const CONFIG_MHI_WWAN_CTRL_MODULE: u32 = 1;
pub const CONFIG_X86_PLATFORM_DRIVERS_DELL: u32 = 1;
pub const CONFIG_SND_SOC_RT5663_MODULE: u32 = 1;
pub const CONFIG_THREAD_INFO_IN_TASK: u32 = 1;
pub const CONFIG_DVB_M88DS3103_MODULE: u32 = 1;
pub const CONFIG_NOZOMI_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCL711_MODULE: u32 = 1;
pub const CONFIG_USB_DWC3_ULPI: u32 = 1;
pub const CONFIG_SND_SOC_RT1316_SDW_MODULE: u32 = 1;
pub const CONFIG_MLX4_EN_DCB: u32 = 1;
pub const CONFIG_NET_VENDOR_LITEX: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_AUDIT_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_842_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_RTMV20_MODULE: u32 = 1;
pub const CONFIG_VT6655_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_PIXCIR_MODULE: u32 = 1;
pub const CONFIG_MLX90632_MODULE: u32 = 1;
pub const CONFIG_INTEL_IDXD_BUS_MODULE: u32 = 1;
pub const CONFIG_INTEL_TH_ACPI_MODULE: u32 = 1;
pub const CONFIG_WM831X_BACKUP_MODULE: u32 = 1;
pub const CONFIG_ADIN1100_PHY_MODULE: u32 = 1;
pub const CONFIG_HAVE_C_RECORDMCOUNT: u32 = 1;
pub const CONFIG_SENSORS_AXI_FAN_CONTROL_MODULE: u32 = 1;
pub const CONFIG_GENERIC_MSI_IRQ: u32 = 1;
pub const CONFIG_SND_SOC_AMD_ACP_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADCXX_MODULE: u32 = 1;
pub const CONFIG_DYNAMIC_FTRACE_WITH_ARGS: u32 = 1;
pub const CONFIG_SND_CS4281_MODULE: u32 = 1;
pub const CONFIG_COMEDI_8255_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MT2131_MODULE: u32 = 1;
pub const CONFIG_SENSORS_DELL_SMM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_FSL_EASRC_MODULE: u32 = 1;
pub const CONFIG_HID_THINGM_MODULE: u32 = 1;
pub const CONFIG_USB_NET_KALMIA_MODULE: u32 = 1;
pub const CONFIG_ZSWAP_SHRINKER_DEFAULT_ON: u32 = 1;
pub const CONFIG_IR_TTUSBIR_MODULE: u32 = 1;
pub const CONFIG_ATH6KL_SDIO_MODULE: u32 = 1;
pub const CONFIG_USB_NET_DM9601_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_TRACEHOOK: u32 = 1;
pub const CONFIG_RTC_DRV_WILCO_EC_MODULE: u32 = 1;
pub const CONFIG_SSB_PCIHOST: u32 = 1;
pub const CONFIG_FXAS21002C_MODULE: u32 = 1;
pub const CONFIG_RPMSG_CHAR_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_KBL_RT5663_MAX98927_MACH_MODULE: u32 = 1;
pub const CONFIG_WATCHDOG_PRETIMEOUT_GOV: u32 = 1;
pub const CONFIG_IR_MCEUSB_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WCD938X_SDW_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_ACCEL_I2C_3AXIS_MODULE: u32 = 1;
pub const CONFIG_LDM_PARTITION: u32 = 1;
pub const CONFIG_CIFS_MODULE: u32 = 1;
pub const CONFIG_DRM_FBDEV_OVERALLOC: u32 = 100;
pub const CONFIG_SMSC37B787_WDT_MODULE: u32 = 1;
pub const CONFIG_XFRM_USER_MODULE: u32 = 1;
pub const CONFIG_BMI160_I2C_MODULE: u32 = 1;
pub const CONFIG_I3C_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_BIC_MODULE: u32 = 1;
pub const CONFIG_YAMAHA_YAS530_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_REQUEST_TIMEOUT: u32 = 20000;
pub const CONFIG_EXTCON_PALMAS_MODULE: u32 = 1;
pub const CONFIG_LEDS_PCA9532_MODULE: u32 = 1;
pub const CONFIG_TASK_DELAY_ACCT: u32 = 1;
pub const CONFIG_IR_IGORPLUGUSB_MODULE: u32 = 1;
pub const CONFIG_INPUT_PCF50633_PMU_MODULE: u32 = 1;
pub const CONFIG_INPUT_DA9063_ONKEY_MODULE: u32 = 1;
pub const CONFIG_SCSI_DH_EMC_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE: u32 = 1;
pub const CONFIG_EXTCON_USB_GPIO_MODULE: u32 = 1;
pub const CONFIG_NET_NS: u32 = 1;
pub const CONFIG_USB_ISP1760_DUAL_ROLE: u32 = 1;
pub const CONFIG_SENSORS_TMP401_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MAX1586_MODULE: u32 = 1;
pub const CONFIG_REISERFS_FS_XATTR: u32 = 1;
pub const CONFIG_SENSORS_ADT7475_MODULE: u32 = 1;
pub const CONFIG_MEMORY: u32 = 1;
pub const CONFIG_HAVE_PERF_EVENTS: u32 = 1;
pub const CONFIG_PCMCIA_XIRCOM_MODULE: u32 = 1;
pub const CONFIG_EVM_ADD_XATTRS: u32 = 1;
pub const CONFIG_COMEDI_II_PCI20KC_MODULE: u32 = 1;
pub const CONFIG_EISA_VLB_PRIMING: u32 = 1;
pub const CONFIG_B53_SRAB_DRIVER_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBTUSB_AUTOSUSPEND: u32 = 1;
pub const CONFIG_CRYPTO_DEV_QAT_C62X_MODULE: u32 = 1;
pub const CONFIG_DVB_MANTIS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LIS3_I2C_MODULE: u32 = 1;
pub const CONFIG_GPD_POCKET_FAN_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_ST_ES8336_MACH_MODULE: u32 = 1;
pub const CONFIG_RT2800PCI_RT35XX: u32 = 1;
pub const CONFIG_MTD_NAND_GPIO_MODULE: u32 = 1;
pub const CONFIG_CAN_C_CAN_MODULE: u32 = 1;
pub const CONFIG_BTT: u32 = 1;
pub const CONFIG_ATA_SFF: u32 = 1;
pub const CONFIG_LEDS_MENF21BMC_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_WALKERA0701_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LRW_MODULE: u32 = 1;
pub const CONFIG_QRTR_TUN_MODULE: u32 = 1;
pub const CONFIG_NVME_TCP_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1685_FAMILY_MODULE: u32 = 1;
pub const CONFIG_TI_ADS124S08_MODULE: u32 = 1;
pub const CONFIG_VFIO_CONTAINER: u32 = 1;
pub const CONFIG_REGULATOR_WM8350_MODULE: u32 = 1;
pub const CONFIG_IWLWIFI_OPMODE_MODULAR: u32 = 1;
pub const CONFIG_NET_EMATCH_CMP_MODULE: u32 = 1;
pub const CONFIG_UV_MMTIMER_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_T613_MODULE: u32 = 1;
pub const CONFIG_SND_VIA82XX_MODEM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8580_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_DMI: u32 = 1;
pub const CONFIG_SND_MTPAV_MODULE: u32 = 1;
pub const CONFIG_PPP_ASYNC_MODULE: u32 = 1;
pub const CONFIG_MD_RAID10_MODULE: u32 = 1;
pub const CONFIG_NFSD_SCSILAYOUT: u32 = 1;
pub const CONFIG_HID_NINTENDO_MODULE: u32 = 1;
pub const CONFIG_HAVE_ALIGNED_STRUCT_PAGE: u32 = 1;
pub const CONFIG_SSB_SDIOHOST_POSSIBLE: u32 = 1;
pub const CONFIG_SENSORS_APPLESMC_MODULE: u32 = 1;
pub const CONFIG_DRM_SIMPLEDRM: u32 = 1;
pub const CONFIG_NET_VENDOR_SOLARFLARE: u32 = 1;
pub const CONFIG_CAN_GW_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_866_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ABITUGURU3_MODULE: u32 = 1;
pub const CONFIG_CRAMFS_MODULE: u32 = 1;
pub const CONFIG_RADIO_SAA7706H_MODULE: u32 = 1;
pub const CONFIG_SKGE_GENESIS: u32 = 1;
pub const CONFIG_WM831X_POWER_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_SUNRISEPOINT_MODULE: u32 = 1;
pub const CONFIG_TINYDRM_ILI9341_MODULE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_TRANSIENT_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_LM8323_MODULE: u32 = 1;
pub const CONFIG_CC_HAS_IBT: u32 = 1;
pub const CONFIG_STMMAC_ETH_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_T1_MODULE: u32 = 1;
pub const CONFIG_PCIE_DW_PLAT: u32 = 1;
pub const CONFIG_BACKLIGHT_RT4831_MODULE: u32 = 1;
pub const CONFIG_COMEDI_AIO_AIO12_8_MODULE: u32 = 1;
pub const CONFIG_NFSD_V4_SECURITY_LABEL: u32 = 1;
pub const CONFIG_QCOM_HIDMA_MGMT_MODULE: u32 = 1;
pub const CONFIG_CEPH_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_BLK_DEV_PMEM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT722_SDCA_SDW_MODULE: u32 = 1;
pub const CONFIG_XFRM_ESP_MODULE: u32 = 1;
pub const CONFIG_AUDIT: u32 = 1;
pub const CONFIG_VIDEO_OV8858_MODULE: u32 = 1;
pub const CONFIG_WILCO_EC_MODULE: u32 = 1;
pub const CONFIG_CHR_DEV_ST_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_TPS65910_MODULE: u32 = 1;
pub const CONFIG_BATTERY_RT5033_MODULE: u32 = 1;
pub const CONFIG_BCH_MODULE: u32 = 1;
pub const CONFIG_INTEL_IOMMU: u32 = 1;
pub const CONFIG_DVB_GP8PSK_FE_MODULE: u32 = 1;
pub const CONFIG_V4L2_CCI_I2C_MODULE: u32 = 1;
pub const CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE: u32 = 1;
pub const CONFIG_DM_MULTIPATH_MODULE: u32 = 1;
pub const CONFIG_HAVE_RETHOOK: u32 = 1;
pub const CONFIG_CRYPTO_USER_API_SKCIPHER_MODULE: u32 = 1;
pub const CONFIG_SURFACE_PLATFORM_PROFILE_MODULE: u32 = 1;
pub const CONFIG_FW_ATTR_CLASS_MODULE: u32 = 1;
pub const CONFIG_SCSI_3W_SAS_MODULE: u32 = 1;
pub const CONFIG_BPF_JIT_ALWAYS_ON: u32 = 1;
pub const CONFIG_COMEDI_NI_ATMIO16D_MODULE: u32 = 1;
pub const CONFIG_TPS6594_PFSM_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MC13892_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM80_MODULE: u32 = 1;
pub const CONFIG_NET_9P_FD_MODULE: u32 = 1;
pub const CONFIG_EXTCON_FSA9480_MODULE: u32 = 1;
pub const CONFIG_LTO_NONE: u32 = 1;
pub const CONFIG_PCI_HYPERV_MODULE: u32 = 1;
pub const CONFIG_PCIEASPM: u32 = 1;
pub const CONFIG_PM_ADVANCED_DEBUG: u32 = 1;
pub const CONFIG_DEBUG_FS_ALLOW_ALL: u32 = 1;
pub const CONFIG_SND_SOC_AW87390_MODULE: u32 = 1;
pub const CONFIG_MT76_LEDS: u32 = 1;
pub const CONFIG_INTEL_IDMA64_MODULE: u32 = 1;
pub const CONFIG_VME_TSI148_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5514_MODULE: u32 = 1;
pub const CONFIG_ATA_PIIX: u32 = 1;
pub const CONFIG_B43LEGACY_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8904_MODULE: u32 = 1;
pub const CONFIG_AIC7XXX_REG_PRETTY_PRINT: u32 = 1;
pub const CONFIG_HID_MULTITOUCH_MODULE: u32 = 1;
pub const CONFIG_ECRYPT_FS_MESSAGING: u32 = 1;
pub const CONFIG_RTW88_8821CU_MODULE: u32 = 1;
pub const CONFIG_MARVELL_88Q2XXX_PHY_MODULE: u32 = 1;
pub const CONFIG_FB_DEFERRED_IO: u32 = 1;
pub const CONFIG_SATA_AHCI_MODULE: u32 = 1;
pub const CONFIG_COMEDI_MITE_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SOF_SSP_COMMON_MODULE: u32 = 1;
pub const CONFIG_TI_TSC2046_MODULE: u32 = 1;
pub const CONFIG_TI_ADS8688_MODULE: u32 = 1;
pub const CONFIG_SND_AMD_ASOC_RENOIR_MODULE: u32 = 1;
pub const CONFIG_RTW88_8723DE_MODULE: u32 = 1;
pub const CONFIG_SLAB_FREELIST_RANDOM: u32 = 1;
pub const CONFIG_DVB_USB_A800_MODULE: u32 = 1;
pub const CONFIG_SYSTEMPORT_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_CHT_BSW_RT5645_MACH_MODULE: u32 = 1;
pub const CONFIG_HAVE_STATIC_CALL: u32 = 1;
pub const CONFIG_XEN_BALLOON_MEMORY_HOTPLUG: u32 = 1;
pub const CONFIG_SECURITY: u32 = 1;
pub const CONFIG_REGULATOR_RAA215300_MODULE: u32 = 1;
pub const CONFIG_I2C_SI470X_MODULE: u32 = 1;
pub const CONFIG_DVB_A8293_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ASC7621_MODULE: u32 = 1;
pub const CONFIG_OPTPROBES: u32 = 1;
pub const CONFIG_USB_AMD5536UDC_MODULE: u32 = 1;
pub const CONFIG_BE2NET_BE3: u32 = 1;
pub const CONFIG_IQS621_ALS_MODULE: u32 = 1;
pub const CONFIG_CHARGER_BQ2415X_MODULE: u32 = 1;
pub const CONFIG_NETXEN_NIC_MODULE: u32 = 1;
pub const CONFIG_BNX2X_SRIOV: u32 = 1;
pub const CONFIG_ACPI_NUMA: u32 = 1;
pub const CONFIG_HID_PXRC_MODULE: u32 = 1;
pub const CONFIG_BLK_CGROUP_RWSTAT: u32 = 1;
pub const CONFIG_INTERCONNECT: u32 = 1;
pub const CONFIG_ATM_TCP_MODULE: u32 = 1;
pub const CONFIG_MAX_SKB_FRAGS: u32 = 17;
pub const CONFIG_USB_GR_UDC_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_CXUSB_ANALOG: u32 = 1;
pub const CONFIG_AD74413R_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_ISL9305_MODULE: u32 = 1;
pub const CONFIG_INTEL_BYTCRC_PWRSRC_MODULE: u32 = 1;
pub const CONFIG_USB_CDNSP_PCI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_ELKHARTLAKE_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS35L56_SPI_MODULE: u32 = 1;
pub const CONFIG_PCIE_DW_PLAT_EP: u32 = 1;
pub const CONFIG_HID_ELECOM_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_PCD8544_MODULE: u32 = 1;
pub const CONFIG_SND_TIMER_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ICP_MULTI_MODULE: u32 = 1;
pub const CONFIG_BATTERY_DA9150_MODULE: u32 = 1;
pub const CONFIG_KVM_MMIO: u32 = 1;
pub const CONFIG_USB_EHCI_TT_NEWSCHED: u32 = 1;
pub const CONFIG_FAT_DEFAULT_CODEPAGE: u32 = 437;
pub const CONFIG_ALTERA_FREEZE_BRIDGE_MODULE: u32 = 1;
pub const CONFIG_TCM_FC_MODULE: u32 = 1;
pub const CONFIG_IPV6_MROUTE_MULTIPLE_TABLES: u32 = 1;
pub const CONFIG_BLK_DEV: u32 = 1;
pub const CONFIG_SND_SOC_PCM179X_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TLV320AIC31XX_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_FSL_MQS_MODULE: u32 = 1;
pub const CONFIG_SERIO_I8042: u32 = 1;
pub const CONFIG_MAC80211_RC_DEFAULT: &[u8; 12usize] = b"minstrel_ht\0";
pub const CONFIG_NIC7018_WDT_MODULE: u32 = 1;
pub const CONFIG_FARSYNC_MODULE: u32 = 1;
pub const CONFIG_RTL8187_LEDS: u32 = 1;
pub const CONFIG_NFS_ACL_SUPPORT_MODULE: u32 = 1;
pub const CONFIG_RT2800USB_RT55XX: u32 = 1;
pub const CONFIG_CHARGER_ADP5061_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2433_MODULE: u32 = 1;
pub const CONFIG_CHROME_PLATFORMS: u32 = 1;
pub const CONFIG_BATTERY_SAMSUNG_SDI: u32 = 1;
pub const CONFIG_ATL1_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SBRMI_MODULE: u32 = 1;
pub const CONFIG_APPLICOM_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_OMNINET_MODULE: u32 = 1;
pub const CONFIG_HDLC_PPP_MODULE: u32 = 1;
pub const CONFIG_X86_AMD_PLATFORM_DEVICE: u32 = 1;
pub const CONFIG_BRIDGE_NETFILTER_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_SCALABLE_MODULE: u32 = 1;
pub const CONFIG_DRM_XE_PREEMPT_TIMEOUT_MIN: u32 = 1;
pub const CONFIG_DVB_MB86A20S_MODULE: u32 = 1;
pub const CONFIG_CC_HAS_ASM_GOTO_TIED_OUTPUT: u32 = 1;
pub const CONFIG_VIRTIO_IOMMU: u32 = 1;
pub const CONFIG_MLX5_SF_MANAGER: u32 = 1;
pub const CONFIG_PATA_TRIFLEX_MODULE: u32 = 1;
pub const CONFIG_LEDS_MLXREG_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCL818_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_TMDC_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_KFENCE: u32 = 1;
pub const CONFIG_MCP4922_MODULE: u32 = 1;
pub const CONFIG_SERIAL_ALTERA_UART_MAXPORTS: u32 = 4;
pub const CONFIG_SND_SYNTH_EMUX_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OG01A1B_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_SILABS: u32 = 1;
pub const CONFIG_IOMMU_API: u32 = 1;
pub const CONFIG_GPIO_GENERIC: u32 = 1;
pub const CONFIG_USB_CDNS3_HOST: u32 = 1;
pub const CONFIG_TRACING_SUPPORT: u32 = 1;
pub const CONFIG_INET_ESPINTCP: u32 = 1;
pub const CONFIG_SND_SOC_PCM3060_MODULE: u32 = 1;
pub const CONFIG_UNIX98_PTYS: u32 = 1;
pub const CONFIG_MS_BLOCK_MODULE: u32 = 1;
pub const CONFIG_VFIO_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ASUS_WMI_MODULE: u32 = 1;
pub const CONFIG_MT76x2E_MODULE: u32 = 1;
pub const CONFIG_NFC_MICROREAD_MEI_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CONNMARK_MODULE: u32 = 1;
pub const CONFIG_MINIX_SUBPARTITION: u32 = 1;
pub const CONFIG_CHROMEOS_PSTORE_MODULE: u32 = 1;
pub const CONFIG_NET_RX_BUSY_POLL: u32 = 1;
pub const CONFIG_RADIO_WL1273_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SMSC47B397_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_MICHAEL_MIC_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_SOCIONEXT: u32 = 1;
pub const CONFIG_TCP_AO: u32 = 1;
pub const CONFIG_IMA_QUEUE_EARLY_BOOT_KEYS: u32 = 1;
pub const CONFIG_CRYPTO_ANSI_CPRNG_MODULE: u32 = 1;
pub const CONFIG_SURFACE_AGGREGATOR_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SELINUX: u32 = 1;
pub const CONFIG_ZONE_DMA32: u32 = 1;
pub const CONFIG_NET_SCHED: u32 = 1;
pub const CONFIG_LCD_LMS501KF03_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TPS65086_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CONNSECMARK_MODULE: u32 = 1;
pub const CONFIG_INPUT_ATC260X_ONKEY_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCL726_MODULE: u32 = 1;
pub const CONFIG_MFD_CS47L85: u32 = 1;
pub const CONFIG_LIQUIDIO_MODULE: u32 = 1;
pub const CONFIG_STAGING_MEDIA: u32 = 1;
pub const CONFIG_NVME_RDMA_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_KEXEC: u32 = 1;
pub const CONFIG_DRM_PANEL: u32 = 1;
pub const CONFIG_DVB_PLL_MODULE: u32 = 1;
pub const CONFIG_PRINTK_TIME: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_AVS_MACH_MAX98373_MODULE: u32 = 1;
pub const CONFIG_AD7091R_MODULE: u32 = 1;
pub const CONFIG_PANEL_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_RT5759_MODULE: u32 = 1;
pub const CONFIG_SERIAL_JSM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_GLK_MODULE: u32 = 1;
pub const CONFIG_VIDEO_VIVID_MAX_DEVS: u32 = 64;
pub const CONFIG_RXPERF_MODULE: u32 = 1;
pub const CONFIG_INPUT_MOUSEDEV_SCREEN_Y: u32 = 768;
pub const CONFIG_SENSORS_MP5023_MODULE: u32 = 1;
pub const CONFIG_SENSORS_PECI_DIMMTEMP_MODULE: u32 = 1;
pub const CONFIG_TRACE_IRQFLAGS_NMI_SUPPORT: u32 = 1;
pub const CONFIG_TASKS_RCU_GENERIC: u32 = 1;
pub const CONFIG_SECCOMP_FILTER: u32 = 1;
pub const CONFIG_PATA_HPT37X_MODULE: u32 = 1;
pub const CONFIG_SENSORS_RM3100_SPI_MODULE: u32 = 1;
pub const CONFIG_MPU3050_MODULE: u32 = 1;
pub const CONFIG_UIO_PCI_GENERIC_MODULE: u32 = 1;
pub const CONFIG_PPP: u32 = 1;
pub const CONFIG_RFD_FTL_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_QUOTA_MODULE: u32 = 1;
pub const CONFIG_TI_ST_MODULE: u32 = 1;
pub const CONFIG_ARCH_MAY_HAVE_PC_FDC: u32 = 1;
pub const CONFIG_SNET_VDPA_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_PIE_MODULE: u32 = 1;
pub const CONFIG_BOSCH_BNO055_SERIAL_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ATMEL_MXT_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_SENSEHAT_MODULE: u32 = 1;
pub const CONFIG_NFT_FIB_IPV4_MODULE: u32 = 1;
pub const CONFIG_CLOSURES: u32 = 1;
pub const CONFIG_HAVE_KERNEL_LZO: u32 = 1;
pub const CONFIG_ASYNC_CORE_MODULE: u32 = 1;
pub const CONFIG_INTEL_PMC_CORE_MODULE: u32 = 1;
pub const CONFIG_BUILDTIME_MCOUNT_SORT: u32 = 1;
pub const CONFIG_NET_SCH_MULTIQ_MODULE: u32 = 1;
pub const CONFIG_INET_DIAG_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_GHASH: u32 = 1;
pub const CONFIG_OCFS2_DEBUG_MASKLOG: u32 = 1;
pub const CONFIG_GENERIC_ENTRY: u32 = 1;
pub const CONFIG_SND_SOC_WM8741_MODULE: u32 = 1;
pub const CONFIG_PSTORE: u32 = 1;
pub const CONFIG_OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW: u32 = 1;
pub const CONFIG_SCSI_LPFC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS53L30_MODULE: u32 = 1;
pub const CONFIG_DVB_MN88443X_MODULE: u32 = 1;
pub const CONFIG_ACPI_TABLE_LIB: u32 = 1;
pub const CONFIG_VDPA_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_SIDTAB_HASH_BITS: u32 = 9;
pub const CONFIG_IIO_ST_LSM9DS0_SPI_MODULE: u32 = 1;
pub const CONFIG_NFC_ST95HF_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_FTP_MODULE: u32 = 1;
pub const CONFIG_VIDEO_RDACM21_MODULE: u32 = 1;
pub const CONFIG_MAC80211_RC_MINSTREL: u32 = 1;
pub const CONFIG_IIO_CONSUMERS_PER_TRIGGER: u32 = 2;
pub const CONFIG_NF_CT_PROTO_UDPLITE: u32 = 1;
pub const CONFIG_RPCSEC_GSS_KRB5_ENCTYPES_AES_SHA2: u32 = 1;
pub const CONFIG_SPEAKUP_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_TARGET_SYNPROXY_MODULE: u32 = 1;
pub const CONFIG_FPGA_MGR_MICROCHIP_SPI_MODULE: u32 = 1;
pub const CONFIG_HANGCHECK_TIMER_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_WARRIOR_MODULE: u32 = 1;
pub const CONFIG_COMEDI_AIO_IIRO_16_MODULE: u32 = 1;
pub const CONFIG_SENSORS_W83627EHF_MODULE: u32 = 1;
pub const CONFIG_ELF_CORE: u32 = 1;
pub const CONFIG_PTP_DFL_TOD_MODULE: u32 = 1;
pub const CONFIG_DEV_COREDUMP: u32 = 1;
pub const CONFIG_NOTIFIER_ERROR_INJECTION_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM73_MODULE: u32 = 1;
pub const CONFIG_VIA_VELOCITY_MODULE: u32 = 1;
pub const CONFIG_KVM_EXTERNAL_WRITE_TRACKING: u32 = 1;
pub const CONFIG_SENSORS_PC87360_MODULE: u32 = 1;
pub const CONFIG_DVB_LNBH29_MODULE: u32 = 1;
pub const CONFIG_TEXTSEARCH: u32 = 1;
pub const CONFIG_DRM_AMDGPU_USERPTR: u32 = 1;
pub const CONFIG_VIDEO_IVTV_MODULE: u32 = 1;
pub const CONFIG_ACPI_DOCK: u32 = 1;
pub const CONFIG_SND_SOC_CS4341_MODULE: u32 = 1;
pub const CONFIG_USB_DWC3_MODULE: u32 = 1;
pub const CONFIG_KS8851_MODULE: u32 = 1;
pub const CONFIG_XEN_HAVE_PVMMU: u32 = 1;
pub const CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS: u32 = 1;
pub const CONFIG_MTD_JEDECPROBE_MODULE: u32 = 1;
pub const CONFIG_TSYS01_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_ABEOZ9_MODULE: u32 = 1;
pub const CONFIG_NF_CT_NETLINK_HELPER_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_ON_DEMAND_PAGING: u32 = 1;
pub const CONFIG_HAVE_CONTEXT_TRACKING_USER: u32 = 1;
pub const CONFIG_INA2XX_ADC_MODULE: u32 = 1;
pub const CONFIG_CXL_PMEM_MODULE: u32 = 1;
pub const CONFIG_EFI_TEST_MODULE: u32 = 1;
pub const CONFIG_MTD_ONENAND_VERIFY_WRITE: u32 = 1;
pub const CONFIG_INPUT_PCF8574_MODULE: u32 = 1;
pub const CONFIG_SENSIRION_SGP40_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_INTEL_SKL_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MC34VR500_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MT6660_MODULE: u32 = 1;
pub const CONFIG_USB_SUPPORT: u32 = 1;
pub const CONFIG_SOFT_WATCHDOG_PRETIMEOUT: u32 = 1;
pub const CONFIG_XEN_UNPOPULATED_ALLOC: u32 = 1;
pub const CONFIG_BCM84881_PHY: u32 = 1;
pub const CONFIG_NVME_TARGET_MODULE: u32 = 1;
pub const CONFIG_I2C_SCMI_MODULE: u32 = 1;
pub const CONFIG_I2C_VIA_MODULE: u32 = 1;
pub const CONFIG_BMC150_MAGN_SPI_MODULE: u32 = 1;
pub const CONFIG_MOTORCOMM_PHY_MODULE: u32 = 1;
pub const CONFIG_INPUT_MAX8925_ONKEY_MODULE: u32 = 1;
pub const CONFIG_CC_NO_STRINGOP_OVERFLOW: u32 = 1;
pub const CONFIG_CRYPTO_DEV_QAT_C3XXX_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_MMIO_CMDLINE_DEVICES: u32 = 1;
pub const CONFIG_SND_SOC_SOF_GEMINILAKE_MODULE: u32 = 1;
pub const CONFIG_SND_INTEL8X0M_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_WRITE_MOUNTED: u32 = 1;
pub const CONFIG_ACPI_DEBUG: u32 = 1;
pub const CONFIG_SENSORS_ACBEL_FSG032_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_PREEMPT_TIMEOUT_COMPUTE: u32 = 7500;
pub const CONFIG_MODIFY_LDT_SYSCALL: u32 = 1;
pub const CONFIG_SENSORS_ADC128D818_MODULE: u32 = 1;
pub const CONFIG_KEMPLD_WDT_MODULE: u32 = 1;
pub const CONFIG_SURFACE3_WMI_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_BQ32K_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_PAC7311_MODULE: u32 = 1;
pub const CONFIG_HID_JABRA_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ST: u32 = 1;
pub const CONFIG_MLX5_VFIO_PCI_MODULE: u32 = 1;
pub const CONFIG_MAX44009_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCMAD_MODULE: u32 = 1;
pub const CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS: u32 = 1;
pub const CONFIG_VIDEO_CCS_MODULE: u32 = 1;
pub const CONFIG_VIA_WDT_MODULE: u32 = 1;
pub const CONFIG_PCP_BATCH_SCALE_MAX: u32 = 5;
pub const CONFIG_CAN_F81604_MODULE: u32 = 1;
pub const CONFIG_UCLAMP_TASK: u32 = 1;
pub const CONFIG_BLK_DEV_NVME_MODULE: u32 = 1;
pub const CONFIG_BRCMFMAC_PROTO_BCDC: u32 = 1;
pub const CONFIG_MOST_COMPONENTS_MODULE: u32 = 1;
pub const CONFIG_TWL4030_CORE: u32 = 1;
pub const CONFIG_SOC_BUS: u32 = 1;
pub const CONFIG_SPI_ZYNQMP_GQSPI_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_EASYTOUCH: u32 = 1;
pub const CONFIG_SND_SOC_TAS6424_MODULE: u32 = 1;
pub const CONFIG_STAGING: u32 = 1;
pub const CONFIG_NET_VENDOR_SIS: u32 = 1;
pub const CONFIG_F2FS_FS_MODULE: u32 = 1;
pub const CONFIG_TI_ADS1100_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_EDT_FT5X06_MODULE: u32 = 1;
pub const CONFIG_FPGA_DFL_FME_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RL6347A_MODULE: u32 = 1;
pub const CONFIG_FB_RIVA_I2C: u32 = 1;
pub const CONFIG_SENSORS_LIS3LV02D_MODULE: u32 = 1;
pub const CONFIG_LEDS_MT6370_FLASH_MODULE: u32 = 1;
pub const CONFIG_CC_HAS_AUTO_VAR_INIT_ZERO_BARE: u32 = 1;
pub const CONFIG_USB_CDNS3_MODULE: u32 = 1;
pub const CONFIG_DM_MULTIPATH_IOA_MODULE: u32 = 1;
pub const CONFIG_EXTCON_MAX14577_MODULE: u32 = 1;
pub const CONFIG_AD9523_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5645_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_ACP_PROBES_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_INTEL_HDMI_SILENT_STREAM: u32 = 1;
pub const CONFIG_FIREWIRE_MODULE: u32 = 1;
pub const CONFIG_MLX5_TC_SAMPLE: u32 = 1;
pub const CONFIG_BYTCRC_PMIC_OPREGION: u32 = 1;
pub const CONFIG_WIZNET_W5100_SPI_MODULE: u32 = 1;
pub const CONFIG_CHARGER_CROS_USBPD_MODULE: u32 = 1;
pub const CONFIG_ATM_MODULE: u32 = 1;
pub const CONFIG_MMIOTRACE: u32 = 1;
pub const CONFIG_MAX63XX_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_PAGE_POOL: u32 = 1;
pub const CONFIG_SURFACE_AGGREGATOR_TABLET_SWITCH_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_16550A_VARIANTS: u32 = 1;
pub const CONFIG_REGULATOR_MT6358_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SM4_MODULE: u32 = 1;
pub const CONFIG_INIT_STACK_ALL_ZERO: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ST1232_MODULE: u32 = 1;
pub const CONFIG_SCSI_FC_ATTRS_MODULE: u32 = 1;
pub const CONFIG_VT_CONSOLE: u32 = 1;
pub const CONFIG_EDAC_SBRIDGE_MODULE: u32 = 1;
pub const CONFIG_HID_UCLOGIC_MODULE: u32 = 1;
pub const CONFIG_VFIO_MDEV_MODULE: u32 = 1;
pub const CONFIG_HW_RANDOM_VIRTIO_MODULE: u32 = 1;
pub const CONFIG_NVME_TARGET_PASSTHRU: u32 = 1;
pub const CONFIG_COMEDI_PCMCIA_DRIVERS_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_88PG86X_MODULE: u32 = 1;
pub const CONFIG_ACPI_APEI: u32 = 1;
pub const CONFIG_SND_SOC_PCM186X_MODULE: u32 = 1;
pub const CONFIG_SND_ES1968_RADIO: u32 = 1;
pub const CONFIG_MT7615E_MODULE: u32 = 1;
pub const CONFIG_LEDS_GPIO_MODULE: u32 = 1;
pub const CONFIG_SENSIRION_SGP30_MODULE: u32 = 1;
pub const CONFIG_SND_SB_COMMON_MODULE: u32 = 1;
pub const CONFIG_LED_TRIGGER_PHY: u32 = 1;
pub const CONFIG_CFG80211_WEXT_EXPORT: u32 = 1;
pub const CONFIG_SND_CS46XX_MODULE: u32 = 1;
pub const CONFIG_SCHED_INFO: u32 = 1;
pub const CONFIG_USB_GSPCA_STK014_MODULE: u32 = 1;
pub const CONFIG_MQ_IOSCHED_KYBER_MODULE: u32 = 1;
pub const CONFIG_ACPI_DEBUGGER: u32 = 1;
pub const CONFIG_IP_VS_FTP_MODULE: u32 = 1;
pub const CONFIG_AS_VERSION: u32 = 24100;
pub const CONFIG_CC_HAS_INT128: u32 = 1;
pub const CONFIG_KEYBOARD_APPLESPI_MODULE: u32 = 1;
pub const CONFIG_EFI_COCO_SECRET: u32 = 1;
pub const CONFIG_FANOTIFY_ACCESS_PERMISSIONS: u32 = 1;
pub const CONFIG_SENSORS_LM3533_MODULE: u32 = 1;
pub const CONFIG_EFI_EARLYCON: u32 = 1;
pub const CONFIG_IIO_ST_PRESS_I2C_MODULE: u32 = 1;
pub const CONFIG_STM_SOURCE_FTRACE_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_NODE_DEV_GROUP: u32 = 1;
pub const CONFIG_DRM_HYPERV_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX18_MODULE: u32 = 1;
pub const CONFIG_XILINX_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_VMWARE_PVSCSI_MODULE: u32 = 1;
pub const CONFIG_CFG80211_WEXT: u32 = 1;
pub const CONFIG_VIRTIO_VSOCKETS_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MARVELL: u32 = 1;
pub const CONFIG_VIDEO_OV8856_MODULE: u32 = 1;
pub const CONFIG_SERIAL_SCCNXP_CONSOLE: u32 = 1;
pub const CONFIG_SMARTJOYPLUS_FF: u32 = 1;
pub const CONFIG_SND_SOC_XTFPGA_I2S_MODULE: u32 = 1;
pub const CONFIG_I2C_PARPORT_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_PHYSDEV_MODULE: u32 = 1;
pub const CONFIG_NOP_USB_XCEIV_MODULE: u32 = 1;
pub const CONFIG_RTW89_DEBUGFS: u32 = 1;
pub const CONFIG_NET_SOCK_MSG: u32 = 1;
pub const CONFIG_GPIO_DA9052_MODULE: u32 = 1;
pub const CONFIG_BRCMFMAC_PCIE: u32 = 1;
pub const CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE: u32 = 1;
pub const CONFIG_EXTCON_MAX77843_MODULE: u32 = 1;
pub const CONFIG_SND_VIA82XX_MODULE: u32 = 1;
pub const CONFIG_CC10001_ADC_MODULE: u32 = 1;
pub const CONFIG_NFC_PN533_MODULE: u32 = 1;
pub const CONFIG_FPGA_MGR_LATTICE_SYSCONFIG_SPI_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_DIBUSB_MB_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_DWLIB: u32 = 1;
pub const CONFIG_TWL6030_GPADC_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_GPIO_MODULE: u32 = 1;
pub const CONFIG_SND_DARLA20_MODULE: u32 = 1;
pub const CONFIG_MFD_MAX77843: u32 = 1;
pub const CONFIG_SND_SOC_SOF_IPC4: u32 = 1;
pub const CONFIG_SND_SEQ_MIDI_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_RAM_MODULE: u32 = 1;
pub const CONFIG_USB_F_NCM_MODULE: u32 = 1;
pub const CONFIG_SENSORS_AHT10_MODULE: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS: u32 = 16;
pub const CONFIG_TOUCHSCREEN_AD7879_MODULE: u32 = 1;
pub const CONFIG_MMA9553_MODULE: u32 = 1;
pub const CONFIG_SENSORS_HDAPS_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_STATE_MODULE: u32 = 1;
pub const CONFIG_DVB_L64781_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_RM_TS_MODULE: u32 = 1;
pub const CONFIG_INPUT_EVBUG_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_BRCM_LEGACY_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_BCM_SF2_MODULE: u32 = 1;
pub const CONFIG_LOGIRUMBLEPAD2_FF: u32 = 1;
pub const CONFIG_SND_INDIGOIOX_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV772X_MODULE: u32 = 1;
pub const CONFIG_MFD_TPS6586X: u32 = 1;
pub const CONFIG_SND_ASIHPI_MODULE: u32 = 1;
pub const CONFIG_EROFS_FS_XATTR: u32 = 1;
pub const CONFIG_SND_SOC_SOF_MODULE: u32 = 1;
pub const CONFIG_BSD_DISKLABEL: u32 = 1;
pub const CONFIG_RTC_DRV_M48T35_MODULE: u32 = 1;
pub const CONFIG_I2C_TAOS_EVM_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CAST_COMMON_MODULE: u32 = 1;
pub const CONFIG_COMEDI_KCOMEDILIB_MODULE: u32 = 1;
pub const CONFIG_FB_HGA_MODULE: u32 = 1;
pub const CONFIG_IIO_TRIGGERED_BUFFER_MODULE: u32 = 1;
pub const CONFIG_XEN_PVH: u32 = 1;
pub const CONFIG_RTC_DRV_PCF2127_MODULE: u32 = 1;
pub const CONFIG_USB_STORAGE_FREECOM_MODULE: u32 = 1;
pub const CONFIG_LCD_VGG2432A4_MODULE: u32 = 1;
pub const CONFIG_MFD_TPS65086_MODULE: u32 = 1;
pub const CONFIG_SCSI_BUSLOGIC_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_LOG_MODULE: u32 = 1;
pub const CONFIG_VIDEO_THS8200_MODULE: u32 = 1;
pub const CONFIG_MICROCHIP_PHY_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ADS7846_MODULE: u32 = 1;
pub const CONFIG_AD5766_MODULE: u32 = 1;
pub const CONFIG_OPENVSWITCH_VXLAN_MODULE: u32 = 1;
pub const CONFIG_FONT_6x10: u32 = 1;
pub const CONFIG_GADGET_UAC1: u32 = 1;
pub const CONFIG_IR_RC5_DECODER_MODULE: u32 = 1;
pub const CONFIG_MTD_PSTORE_MODULE: u32 = 1;
pub const CONFIG_FIREWIRE_NOSY_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_GRED_MODULE: u32 = 1;
pub const CONFIG_PCI_DIRECT: u32 = 1;
pub const CONFIG_MMC_VIA_SDMMC_MODULE: u32 = 1;
pub const CONFIG_DRM: u32 = 1;
pub const CONFIG_FUSION_MAX_SGE: u32 = 128;
pub const CONFIG_RTC_DRV_DA9055_MODULE: u32 = 1;
pub const CONFIG_DRM_XEN: u32 = 1;
pub const CONFIG_DRM_PANEL_MIPI_DBI_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_FORCE_PROBE: &[u8; 1usize] = b"\0";
pub const CONFIG_DMABUF_HEAPS_SYSTEM: u32 = 1;
pub const CONFIG_MCP4018_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5682_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ADC_MODULE: u32 = 1;
pub const CONFIG_AD7150_MODULE: u32 = 1;
pub const CONFIG_MEDIA_RADIO_SUPPORT: u32 = 1;
pub const CONFIG_PCF50633_GPIO_MODULE: u32 = 1;
pub const CONFIG_HID_SEMITEK_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AW88261_MODULE: u32 = 1;
pub const CONFIG_VIDEO_S5K5BAF_MODULE: u32 = 1;
pub const CONFIG_IWL4965_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_SJA1105_PTP: u32 = 1;
pub const CONFIG_PCIE_DPC: u32 = 1;
pub const CONFIG_GPIO_IDIO_16_MODULE: u32 = 1;
pub const CONFIG_POSIX_MQUEUE_SYSCTL: u32 = 1;
pub const CONFIG_NVMEM_SPMI_SDAM_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_TIMESLICE_DURATION: u32 = 1;
pub const CONFIG_VHOST_MENU: u32 = 1;
pub const CONFIG_RTC_DRV_MAX6900_MODULE: u32 = 1;
pub const CONFIG_ICS932S401_MODULE: u32 = 1;
pub const CONFIG_RIONET_TX_SIZE: u32 = 128;
pub const CONFIG_XILINX_GMII2RGMII_MODULE: u32 = 1;
pub const CONFIG_COMMON_CLK_TPS68470_MODULE: u32 = 1;
pub const CONFIG_GPIO_WINBOND_MODULE: u32 = 1;
pub const CONFIG_DRM_GUD_MODULE: u32 = 1;
pub const CONFIG_UDMABUF: u32 = 1;
pub const CONFIG_SENSORS_MAX1111_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_PADLOCK_AES_MODULE: u32 = 1;
pub const CONFIG_INTEL_TH_STH_MODULE: u32 = 1;
pub const CONFIG_SAMSUNG_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_BE2NET_HWMON: u32 = 1;
pub const CONFIG_USB_USS720_MODULE: u32 = 1;
pub const CONFIG_DRM_EXEC_MODULE: u32 = 1;
pub const CONFIG_DEBUG_MISC: u32 = 1;
pub const CONFIG_LEDS_DAC124S085_MODULE: u32 = 1;
pub const CONFIG_FB_CFB_COPYAREA: u32 = 1;
pub const CONFIG_USB_F_ECM_MODULE: u32 = 1;
pub const CONFIG_GPIO_IT87_MODULE: u32 = 1;
pub const CONFIG_MOUSE_GPIO_MODULE: u32 = 1;
pub const CONFIG_USB_SISUSBVGA_MODULE: u32 = 1;
pub const CONFIG_DVB_RTL2830_MODULE: u32 = 1;
pub const CONFIG_I40E_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_STP_MODULE: u32 = 1;
pub const CONFIG_HAVE_KVM_IRQCHIP: u32 = 1;
pub const CONFIG_SND_SOC_MTK_BTCVSD_MODULE: u32 = 1;
pub const CONFIG_RT73USB_MODULE: u32 = 1;
pub const CONFIG_USB_ULPI_BUS_MODULE: u32 = 1;
pub const CONFIG_CROS_USBPD_NOTIFY_MODULE: u32 = 1;
pub const CONFIG_DE2104X_DSL: u32 = 0;
pub const CONFIG_BRIDGE_EBT_ARP_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_MICROSEMI: u32 = 1;
pub const CONFIG_BALLOON_COMPACTION: u32 = 1;
pub const CONFIG_BMC150_ACCEL_I2C_MODULE: u32 = 1;
pub const CONFIG_CHARGER_MAX8997_MODULE: u32 = 1;
pub const CONFIG_USB_CYTHERM_MODULE: u32 = 1;
pub const CONFIG_MFD_TWL4030_AUDIO: u32 = 1;
pub const CONFIG_HX711_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MSM8916_WCD_ANALOG_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_EUI64_MODULE: u32 = 1;
pub const CONFIG_MWIFIEX_MODULE: u32 = 1;
pub const CONFIG_HP_ILO_MODULE: u32 = 1;
pub const CONFIG_BINARY_PRINTF: u32 = 1;
pub const CONFIG_SATA_DWC_OLD_DMA: u32 = 1;
pub const CONFIG_USB_STORAGE_JUMPSHOT_MODULE: u32 = 1;
pub const CONFIG_GPIO_MC33880_MODULE: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK_VMW_MODULE: u32 = 1;
pub const CONFIG_NXP_C45_TJA11XX_PHY_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SGTL5000_MODULE: u32 = 1;
pub const CONFIG_INTEL_IDXD_SVM: u32 = 1;
pub const CONFIG_NET_SCH_PLUG_MODULE: u32 = 1;
pub const CONFIG_SND_GINA20_MODULE: u32 = 1;
pub const CONFIG_VFIO_GROUP: u32 = 1;
pub const CONFIG_ACPI_REV_OVERRIDE_POSSIBLE: u32 = 1;
pub const CONFIG_HAVE_PREEMPT_DYNAMIC_CALL: u32 = 1;
pub const CONFIG_AS_AVX512: u32 = 1;
pub const CONFIG_HARDLOCKUP_CHECK_TIMESTAMP: u32 = 1;
pub const CONFIG_SCHED_CLUSTER: u32 = 1;
pub const CONFIG_TRACER_MAX_TRACE: u32 = 1;
pub const CONFIG_USB_KEENE_MODULE: u32 = 1;
pub const CONFIG_ZSTD_DECOMPRESS: u32 = 1;
pub const CONFIG_SND_SOC_SIMPLE_AMPLIFIER_MODULE: u32 = 1;
pub const CONFIG_MTD_CFI_AMDSTD_MODULE: u32 = 1;
pub const CONFIG_CLK_TWL6040_MODULE: u32 = 1;
pub const CONFIG_LEDS_WM831X_STATUS_MODULE: u32 = 1;
pub const CONFIG_MT7925_COMMON_MODULE: u32 = 1;
pub const CONFIG_INTEL_IOMMU_DEFAULT_ON: u32 = 1;
pub const CONFIG_PAGE_IDLE_FLAG: u32 = 1;
pub const CONFIG_SGI_PARTITION: u32 = 1;
pub const CONFIG_INPUT_SPARSEKMAP_MODULE: u32 = 1;
pub const CONFIG_GPIO_PALMAS: u32 = 1;
pub const CONFIG_PTDUMP_CORE: u32 = 1;
pub const CONFIG_CAN_CAN327_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_RTL: u32 = 1;
pub const CONFIG_CRYPTO_TWOFISH_X86_64_3WAY_MODULE: u32 = 1;
pub const CONFIG_AS73211_MODULE: u32 = 1;
pub const CONFIG_ADIS16400_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_AUDIO_APB_CODEC_MODULE: u32 = 1;
pub const CONFIG_AIC7XXX_CMDS_PER_DEVICE: u32 = 8;
pub const CONFIG_SYSFS_SYSCALL: u32 = 1;
pub const CONFIG_WLAN_VENDOR_QUANTENNA: u32 = 1;
pub const CONFIG_RTL8192EE_MODULE: u32 = 1;
pub const CONFIG_SECURITY_INFINIBAND: u32 = 1;
pub const CONFIG_TCG_XEN_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_REALTEK_RTL8365MB_MODULE: u32 = 1;
pub const CONFIG_SND_PCM_TIMER: u32 = 1;
pub const CONFIG_DVB_STV6110_MODULE: u32 = 1;
pub const CONFIG_MPL115_I2C_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1685: u32 = 1;
pub const CONFIG_AC97_BUS_MODULE: u32 = 1;
pub const CONFIG_CW1200_MODULE: u32 = 1;
pub const CONFIG_ENVELOPE_DETECTOR_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_SET_DIRECT_MAP: u32 = 1;
pub const CONFIG_SYSVIPC_SYSCTL: u32 = 1;
pub const CONFIG_SND_FIREWORKS_MODULE: u32 = 1;
pub const CONFIG_QEDI_MODULE: u32 = 1;
pub const CONFIG_NVME_FABRICS_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_TI: u32 = 1;
pub const CONFIG_HID_NTRIG_MODULE: u32 = 1;
pub const CONFIG_IP_VS_IPV6: u32 = 1;
pub const CONFIG_X86_64_ACPI_NUMA: u32 = 1;
pub const CONFIG_DMA_SHARED_BUFFER: u32 = 1;
pub const CONFIG_RTC_SYSTOHC: u32 = 1;
pub const CONFIG_DVB_USB_NOVA_T_USB2_MODULE: u32 = 1;
pub const CONFIG_VHOST_SCSI_MODULE: u32 = 1;
pub const CONFIG_CIFS_POSIX: u32 = 1;
pub const CONFIG_AMD_XGBE_HAVE_ECC: u32 = 1;
pub const CONFIG_PATA_RDC_MODULE: u32 = 1;
pub const CONFIG_SND_PORTMAN2X4_MODULE: u32 = 1;
pub const CONFIG_USB_EPSON2888: u32 = 1;
pub const CONFIG_AF_RXRPC_IPV6: u32 = 1;
pub const CONFIG_ADIS16475_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ZET6223_MODULE: u32 = 1;
pub const CONFIG_SND_INDIGODJ_MODULE: u32 = 1;
pub const CONFIG_SENSORS_W83L785TS_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_MXUPORT_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS28E04_MODULE: u32 = 1;
pub const CONFIG_DECOMPRESS_GZIP: u32 = 1;
pub const CONFIG_SND_AW2_MODULE: u32 = 1;
pub const CONFIG_SENSORS_EMC2103_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_CELTIC_MODULE: u32 = 1;
pub const CONFIG_SND_AU8830_MODULE: u32 = 1;
pub const CONFIG_SPI_SC18IS602_MODULE: u32 = 1;
pub const CONFIG_RTLLIB_CRYPTO_WEP_MODULE: u32 = 1;
pub const CONFIG_THERMAL_GOV_POWER_ALLOCATOR: u32 = 1;
pub const CONFIG_VIRTIO_MENU: u32 = 1;
pub const CONFIG_VIRTIO_BLK: u32 = 1;
pub const CONFIG_AX88796B_PHY_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_CS_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_SJA1105_TAS: u32 = 1;
pub const CONFIG_DECOMPRESS_LZO: u32 = 1;
pub const CONFIG_CRYPTO_XXHASH_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_ARK3116_MODULE: u32 = 1;
pub const CONFIG_64BIT: u32 = 1;
pub const CONFIG_SND_MIXART_MODULE: u32 = 1;
pub const CONFIG_PATA_PARPORT_ATEN_MODULE: u32 = 1;
pub const CONFIG_PARPORT_PANEL_MODULE: u32 = 1;
pub const CONFIG_QUOTA: u32 = 1;
pub const CONFIG_SND_BT87X_MODULE: u32 = 1;
pub const CONFIG_IIO_CROS_EC_SENSORS_CORE_MODULE: u32 = 1;
pub const CONFIG_FW_LOADER_COMPRESS_ZSTD: u32 = 1;
pub const CONFIG_SENSORS_WM8350_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CURVE25519_MODULE: u32 = 1;
pub const CONFIG_DM9102_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TLV320ADCX140_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_MIO_CS_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_PARALLEL: u32 = 1;
pub const CONFIG_SND_INTEL_BYT_PREFER_SOF: u32 = 1;
pub const CONFIG_SENSORS_LINEAGE_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_COMETLAKE_MODULE: u32 = 1;
pub const CONFIG_CAN_EMS_PCMCIA_MODULE: u32 = 1;
pub const CONFIG_MLX5_SF: u32 = 1;
pub const CONFIG_SCSI_MPT2SAS_MAX_SGE: u32 = 128;
pub const CONFIG_ZBUD: u32 = 1;
pub const CONFIG_CRYPTO_DEV_QAT_420XX_MODULE: u32 = 1;
pub const CONFIG_MMC_SDHCI_PLTFM_MODULE: u32 = 1;
pub const CONFIG_I2C_CHARDEV: u32 = 1;
pub const CONFIG_KFENCE_SAMPLE_INTERVAL: u32 = 0;
pub const CONFIG_RCU_NOCB_CPU: u32 = 1;
pub const CONFIG_X86_SGX_KVM: u32 = 1;
pub const CONFIG_ADXL367_MODULE: u32 = 1;
pub const CONFIG_MFD_MADERA_MODULE: u32 = 1;
pub const CONFIG_RPMSG_QCOM_GLINK_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_FC0013_MODULE: u32 = 1;
pub const CONFIG_LLC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SOF_NAU8825_MACH_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_NANDSIM_MODULE: u32 = 1;
pub const CONFIG_HAVE_JUMP_LABEL_HACK: u32 = 1;
pub const CONFIG_SND_HDA_SCODEC_CS35L56_SPI_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MAX8649_MODULE: u32 = 1;
pub const CONFIG_ARCH_USE_QUEUED_RWLOCKS: u32 = 1;
pub const CONFIG_VIDEO_ADV7183_MODULE: u32 = 1;
pub const CONFIG_GENWQE_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TEA5761_MODULE: u32 = 1;
pub const CONFIG_MFD_MC13XXX_SPI_MODULE: u32 = 1;
pub const CONFIG_SC92031_MODULE: u32 = 1;
pub const CONFIG_IDPF_MODULE: u32 = 1;
pub const CONFIG_REGMAP_MMIO: u32 = 1;
pub const CONFIG_ARCH_HAS_PKEYS: u32 = 1;
pub const CONFIG_REGULATOR_RT5190A_MODULE: u32 = 1;
pub const CONFIG_SND_TRIDENT_MODULE: u32 = 1;
pub const CONFIG_INTEL_HID_EVENT_MODULE: u32 = 1;
pub const CONFIG_GPIO_MB86S7X_MODULE: u32 = 1;
pub const CONFIG_ENERGY_MODEL: u32 = 1;
pub const CONFIG_NETWORK_SECMARK: u32 = 1;
pub const CONFIG_SND_RIPTIDE_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TEST_SUPPORT: u32 = 1;
pub const CONFIG_POWER_RESET_ATC260X_MODULE: u32 = 1;
pub const CONFIG_SND_CTXFI_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS_BROADCAST: u32 = 1;
pub const CONFIG_RPCSEC_GSS_KRB5_ENCTYPES_CAMELLIA: u32 = 1;
pub const CONFIG_VIDEO_TVAUDIO_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MAX8907_MODULE: u32 = 1;
pub const CONFIG_RXKAD: u32 = 1;
pub const CONFIG_CRYPTO_SIMD_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WCD934X_MODULE: u32 = 1;
pub const CONFIG_HID_HOLTEK_MODULE: u32 = 1;
pub const CONFIG_TYPEC_MUX_FSA4480_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ES7241_MODULE: u32 = 1;
pub const CONFIG_POWER_SUPPLY_HWMON: u32 = 1;
pub const CONFIG_ARCH_HAS_ELFCORE_COMPAT: u32 = 1;
pub const CONFIG_DRM_PANEL_ORISETECH_OTA5601A_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_SAMSUNG_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_PCI: u32 = 1;
pub const CONFIG_LIB80211_CRYPT_CCMP_MODULE: u32 = 1;
pub const CONFIG_HAVE_MIXED_BREAKPOINTS_REGS: u32 = 1;
pub const CONFIG_DA_MON_EVENTS_ID: u32 = 1;
pub const CONFIG_USB_GSPCA_DTCS033_MODULE: u32 = 1;
pub const CONFIG_SCD4X_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1672_MODULE: u32 = 1;
pub const CONFIG_INTEL_MEI_MODULE: u32 = 1;
pub const CONFIG_QCOM_SPMI_ADC5_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_SSU100_MODULE: u32 = 1;
pub const CONFIG_BATMAN_ADV_DAT: u32 = 1;
pub const CONFIG_MOUSE_PS2_SYNAPTICS: u32 = 1;
pub const CONFIG_DVB_USB_DIB3000MC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS35L56_MODULE: u32 = 1;
pub const CONFIG_ATA_BMDMA: u32 = 1;
pub const CONFIG_NFC_SIM_MODULE: u32 = 1;
pub const CONFIG_ATALK_MODULE: u32 = 1;
pub const CONFIG_XZ_DEC_ARMTHUMB: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SOF_PCM512x_MACH_MODULE: u32 = 1;
pub const CONFIG_B43_BCMA: u32 = 1;
pub const CONFIG_SND_SOC_RT5631_MODULE: u32 = 1;
pub const CONFIG_AD7791_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS35L33_MODULE: u32 = 1;
pub const CONFIG_MTD_SWAP_MODULE: u32 = 1;
pub const CONFIG_USB_F_UAC1_MODULE: u32 = 1;
pub const CONFIG_DW_EDMA_MODULE: u32 = 1;
pub const CONFIG_XILINX_XDMA_MODULE: u32 = 1;
pub const CONFIG_JFFS2_CMODE_FAVOURLZO: u32 = 1;
pub const CONFIG_SND_SOC_HDAC_HDA_MODULE: u32 = 1;
pub const CONFIG_RTW89_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MAX98363_MODULE: u32 = 1;
pub const CONFIG_MEMORY_FAILURE: u32 = 1;
pub const CONFIG_NFS_V4_1: u32 = 1;
pub const CONFIG_SKFP_MODULE: u32 = 1;
pub const CONFIG_ARCH_USE_CMPXCHG_LOCKREF: u32 = 1;
pub const CONFIG_ARCH_WANT_FRAME_POINTERS: u32 = 1;
pub const CONFIG_REGMAP: u32 = 1;
pub const CONFIG_SFC_MCDI_MON: u32 = 1;
pub const CONFIG_PATA_PARPORT_FIT2_MODULE: u32 = 1;
pub const CONFIG_6PACK_MODULE: u32 = 1;
pub const CONFIG_NLS_UTF8_MODULE: u32 = 1;
pub const CONFIG_TI_TMAG5273_MODULE: u32 = 1;
pub const CONFIG_RADIO_SI470X_MODULE: u32 = 1;
pub const CONFIG_FB_IOMEM_HELPERS: u32 = 1;
pub const CONFIG_PCIE_PME: u32 = 1;
pub const CONFIG_CIFS_SWN_UPCALL: u32 = 1;
pub const CONFIG_TINYDRM_ILI9225_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_XPAD_MODULE: u32 = 1;
pub const CONFIG_FB_ATY_BACKLIGHT: u32 = 1;
pub const CONFIG_LIBWX_MODULE: u32 = 1;
pub const CONFIG_BCMA_HOST_SOC: u32 = 1;
pub const CONFIG_PHY_PXA_28NM_USB2_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SSM2602_I2C_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_CLIENT_MODULE: u32 = 1;
pub const CONFIG_HARDENED_USERCOPY: u32 = 1;
pub const CONFIG_KS7010_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_ISERT_MODULE: u32 = 1;
pub const CONFIG_ADIS16130_MODULE: u32 = 1;
pub const CONFIG_BAYCOM_PAR_MODULE: u32 = 1;
pub const CONFIG_DRM_AMD_ACP: u32 = 1;
pub const CONFIG_HAVE_MOD_ARCH_SPECIFIC: u32 = 1;
pub const CONFIG_FB_NOTIFY: u32 = 1;
pub const CONFIG_CAN_DEV_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_WM831X_MODULE: u32 = 1;
pub const CONFIG_INPUT_YEALINK_MODULE: u32 = 1;
pub const CONFIG_BMI088_ACCEL_SPI_MODULE: u32 = 1;
pub const CONFIG_KVM_XEN: u32 = 1;
pub const CONFIG_IIO_KX022A_SPI_MODULE: u32 = 1;
pub const CONFIG_COMEDI_VMK80XX_MODULE: u32 = 1;
pub const CONFIG_INTEL_PMT_TELEMETRY_MODULE: u32 = 1;
pub const CONFIG_DVB_DIB3000MB_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_CC2520_MODULE: u32 = 1;
pub const CONFIG_FW_CFG_SYSFS_MODULE: u32 = 1;
pub const CONFIG_USB_PXA27X_MODULE: u32 = 1;
pub const CONFIG_ADV_SWBUTTON_MODULE: u32 = 1;
pub const CONFIG_MFD_DA9055: u32 = 1;
pub const CONFIG_SENSORS_NCT6683_MODULE: u32 = 1;
pub const CONFIG_AD5755_MODULE: u32 = 1;
pub const CONFIG_TI_ADC081C_MODULE: u32 = 1;
pub const CONFIG_PKCS8_PRIVATE_KEY_PARSER_MODULE: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_SPKOUT_MODULE: u32 = 1;
pub const CONFIG_TYPEC_NVIDIA_ALTMODE_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_M41T80_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_ACP_I2S_MODULE: u32 = 1;
pub const CONFIG_STRICT_MODULE_RWX: u32 = 1;
pub const CONFIG_SND_SOC_XILINX_AUDIO_FORMATTER_MODULE: u32 = 1;
pub const CONFIG_VHOST_IOTLB_MODULE: u32 = 1;
pub const CONFIG_SERIAL_MEN_Z135_MODULE: u32 = 1;
pub const CONFIG_PCCARD_NONSTATIC: u32 = 1;
pub const CONFIG_VT6656_MODULE: u32 = 1;
pub const CONFIG_XEN_SCSI_FRONTEND_MODULE: u32 = 1;
pub const CONFIG_USB_USBNET_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_LSM6DSX_MODULE: u32 = 1;
pub const CONFIG_LEDS_SIEMENS_SIMATIC_IPC_MODULE: u32 = 1;
pub const CONFIG_NET_DEVLINK: u32 = 1;
pub const CONFIG_INTEL_SOC_PMIC_BXTWC_MODULE: u32 = 1;
pub const CONFIG_EBC_C384_WDT_MODULE: u32 = 1;
pub const CONFIG_PROC_PID_ARCH_STATUS: u32 = 1;
pub const CONFIG_CPU_SUP_CENTAUR: u32 = 1;
pub const CONFIG_SND_SOC_CS4271_MODULE: u32 = 1;
pub const CONFIG_CB710_CORE_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_PL2303_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_POLICE_MODULE: u32 = 1;
pub const CONFIG_AIC79XX_DEBUG_MASK: u32 = 0;
pub const CONFIG_ASM_MODVERSIONS: u32 = 1;
pub const CONFIG_UEFI_CPER: u32 = 1;
pub const CONFIG_IMA_ARCH_POLICY: u32 = 1;
pub const CONFIG_HAVE_INTEL_TXT: u32 = 1;
pub const CONFIG_HAMRADIO: u32 = 1;
pub const CONFIG_SYSCTL_EXCEPTION_TRACE: u32 = 1;
pub const CONFIG_M62332_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_IDT821034_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_PCAP_MODULE: u32 = 1;
pub const CONFIG_SERIAL_UARTLITE_NR_UARTS: u32 = 1;
pub const CONFIG_SYSVIPC_COMPAT: u32 = 1;
pub const CONFIG_MFD_SY7636A_MODULE: u32 = 1;
pub const CONFIG_GPIO_PCA953X_MODULE: u32 = 1;
pub const CONFIG_INPUT_XEN_KBDDEV_FRONTEND_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_PCI_SHPC: u32 = 1;
pub const CONFIG_AD7091R5_MODULE: u32 = 1;
pub const CONFIG_HINIC_MODULE: u32 = 1;
pub const CONFIG_ADIS16240_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_CINERGY_T2_MODULE: u32 = 1;
pub const CONFIG_CEC_SECO_RC: u32 = 1;
pub const CONFIG_FHANDLE: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_3XXX_MODULE: u32 = 1;
pub const CONFIG_FS_VERITY_BUILTIN_SIGNATURES: u32 = 1;
pub const CONFIG_SERIAL_ALTERA_UART_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_ETS_MODULE: u32 = 1;
pub const CONFIG_USB_MICROTEK_MODULE: u32 = 1;
pub const CONFIG_HAVE_SAMPLE_FTRACE_DIRECT_MULTI: u32 = 1;
pub const CONFIG_PANASONIC_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_ACP_COMMON_MODULE: u32 = 1;
pub const CONFIG_INPUT_MC13783_PWRBUTTON_MODULE: u32 = 1;
pub const CONFIG_HID_SMARTJOYPLUS_MODULE: u32 = 1;
pub const CONFIG_WATCHDOG_OPEN_TIMEOUT: u32 = 0;
pub const CONFIG_ATA_GENERIC: u32 = 1;
pub const CONFIG_INTEL_VSEC_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_GOODIX_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LIB_SHA256: u32 = 1;
pub const CONFIG_NEW_LEDS: u32 = 1;
pub const CONFIG_SND_SST_ATOM_HIFI2_PLATFORM_PCI_MODULE: u32 = 1;
pub const CONFIG_SWAP: u32 = 1;
pub const CONFIG_CRC64: u32 = 1;
pub const CONFIG_MTD_MCHP23K256_MODULE: u32 = 1;
pub const CONFIG_AD5592R_BASE_MODULE: u32 = 1;
pub const CONFIG_MTD_ONENAND_MODULE: u32 = 1;
pub const CONFIG_FW_CACHE: u32 = 1;
pub const CONFIG_WATCHDOG_PRETIMEOUT_DEFAULT_GOV_NOOP: u32 = 1;
pub const CONFIG_B53_SPI_DRIVER_MODULE: u32 = 1;
pub const CONFIG_NFT_BRIDGE_META_MODULE: u32 = 1;
pub const CONFIG_IIO_RESCALE_MODULE: u32 = 1;
pub const CONFIG_GENERIC_ADC_BATTERY_MODULE: u32 = 1;
pub const CONFIG_MOUSE_ELAN_I2C_I2C: u32 = 1;
pub const CONFIG_RTC_DRV_DS1511_MODULE: u32 = 1;
pub const CONFIG_USB_NET_CDC_SUBSET_ENABLE_MODULE: u32 = 1;
pub const CONFIG_IP_FIB_TRIE_STATS: u32 = 1;
pub const CONFIG_CRYPTO_SHA256_SSSE3_MODULE: u32 = 1;
pub const CONFIG_ATM_FORE200E_MODULE: u32 = 1;
pub const CONFIG_VIDEO_SOLO6X10_MODULE: u32 = 1;
pub const CONFIG_MLX5_EN_RXNFC: u32 = 1;
pub const CONFIG_DMABUF_MOVE_NOTIFY: u32 = 1;
pub const CONFIG_NET_SCH_HFSC_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_RV3029C2_MODULE: u32 = 1;
pub const CONFIG_GPIO_TWL6040_MODULE: u32 = 1;
pub const CONFIG_ADIN_PHY_MODULE: u32 = 1;
pub const CONFIG_WIL6210_MODULE: u32 = 1;
pub const CONFIG_SND_ISIGHT_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_DISKONCHIP_MODULE: u32 = 1;
pub const CONFIG_INTEL_MRFLD_ADC_MODULE: u32 = 1;
pub const CONFIG_MAC80211_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SKL_NAU88L25_SSM4567_MACH_MODULE: u32 = 1;
pub const CONFIG_SPI_ALTERA_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH: u32 = 1;
pub const CONFIG_MEGARAID_MM_MODULE: u32 = 1;
pub const CONFIG_BME680_I2C_MODULE: u32 = 1;
pub const CONFIG_ARCH_USES_PG_UNCACHED: u32 = 1;
pub const CONFIG_CRC_CCITT: u32 = 1;
pub const CONFIG_SND_SOC_TS3A227E_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_XILINX_I2S_MODULE: u32 = 1;
pub const CONFIG_IPVLAN_L3S: u32 = 1;
pub const CONFIG_DRM_ACCEL_HABANALABS_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_CAVIUM: u32 = 1;
pub const CONFIG_GPIOLIB_IRQCHIP: u32 = 1;
pub const CONFIG_BPF_UNPRIV_DEFAULT_OFF: u32 = 1;
pub const CONFIG_DVB_TDA8261_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_EXT_CORE_MODULE: u32 = 1;
pub const CONFIG_IGBVF_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_SD: u32 = 1;
pub const CONFIG_SND_SEQ_VIRMIDI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_APOLLOLAKE_MODULE: u32 = 1;
pub const CONFIG_MFD_MAX14577: u32 = 1;
pub const CONFIG_NET_NCSI: u32 = 1;
pub const CONFIG_PHYSICAL_ALIGN: u32 = 2097152;
pub const CONFIG_SND_SOC_SOF_HDA_LINK_BASELINE_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TC358746_MODULE: u32 = 1;
pub const CONFIG_ACPI_LEGACY_TABLES_LOOKUP: u32 = 1;
pub const CONFIG_INPUT_AD714X_SPI_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_NETLINK_MODULE: u32 = 1;
pub const CONFIG_VITESSE_PHY_MODULE: u32 = 1;
pub const CONFIG_MODULE_UNLOAD: u32 = 1;
pub const CONFIG_KEXEC_BZIMAGE_VERIFY_SIG: u32 = 1;
pub const CONFIG_CLOCKSOURCE_WATCHDOG_MAX_SKEW_US: u32 = 100;
pub const CONFIG_FSCACHE_STATS: u32 = 1;
pub const CONFIG_DEVFREQ_GOV_USERSPACE: u32 = 1;
pub const CONFIG_INTEL_SDSI_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_MTHCA_MODULE: u32 = 1;
pub const CONFIG_VIDEO_MAX9271_LIB_MODULE: u32 = 1;
pub const CONFIG_SYSTEM76_ACPI_MODULE: u32 = 1;
pub const CONFIG_PREEMPT_COUNT: u32 = 1;
pub const CONFIG_SENSORS_MAX6650_MODULE: u32 = 1;
pub const CONFIG_SPI_SLAVE: u32 = 1;
pub const CONFIG_USB_GSPCA_BENQ_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_ENGLEDER: u32 = 1;
pub const CONFIG_HAVE_ACPI_APEI_NMI: u32 = 1;
pub const CONFIG_REGULATOR_TPS65023_MODULE: u32 = 1;
pub const CONFIG_BT_LE: u32 = 1;
pub const CONFIG_PINCTRL_SX150X: u32 = 1;
pub const CONFIG_SND_AC97_CODEC_MODULE: u32 = 1;
pub const CONFIG_PCI_SW_SWITCHTEC_MODULE: u32 = 1;
pub const CONFIG_ARCH_WANT_OLD_COMPAT_IPC: u32 = 1;
pub const CONFIG_RTC_DRV_CROS_EC_MODULE: u32 = 1;
pub const CONFIG_HID_U2FZERO_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_DA7219_MODULE: u32 = 1;
pub const CONFIG_MOXA_SMARTIO_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AK4613_MODULE: u32 = 1;
pub const CONFIG_VIDEO_MT9V032_MODULE: u32 = 1;
pub const CONFIG_XIAOMI_WMI_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_CXUSB_MODULE: u32 = 1;
pub const CONFIG_TSL2583_MODULE: u32 = 1;
pub const CONFIG_RT2500PCI_MODULE: u32 = 1;
pub const CONFIG_RWSEM_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_SENSORS_LM85_MODULE: u32 = 1;
pub const CONFIG_AD525X_DPOT_MODULE: u32 = 1;
pub const CONFIG_SND_ATIIXP_MODULE: u32 = 1;
pub const CONFIG_MEDIATEK_GE_PHY_MODULE: u32 = 1;
pub const CONFIG_VL6180_MODULE: u32 = 1;
pub const CONFIG_DIMLIB: u32 = 1;
pub const CONFIG_MEDIA_TUNER_M88RS6000T_MODULE: u32 = 1;
pub const CONFIG_TRACER_SNAPSHOT: u32 = 1;
pub const CONFIG_INFINIBAND_IPOIB_CM: u32 = 1;
pub const CONFIG_COMEDI_PARPORT_MODULE: u32 = 1;
pub const CONFIG_GPIO_PCA9570_MODULE: u32 = 1;
pub const CONFIG_HID_PICOLCD_LCD: u32 = 1;
pub const CONFIG_HAVE_RELIABLE_STACKTRACE: u32 = 1;
pub const CONFIG_SENSORS_MLXREG_FAN_MODULE: u32 = 1;
pub const CONFIG_HAVE_NOINSTR_HACK: u32 = 1;
pub const CONFIG_CC_HAS_ASM_GOTO_OUTPUT: u32 = 1;
pub const CONFIG_BITREVERSE: u32 = 1;
pub const CONFIG_SENSORS_LT7182S_MODULE: u32 = 1;
pub const CONFIG_DEVPORT: u32 = 1;
pub const CONFIG_IGC_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX88_ENABLE_VP3054: u32 = 1;
pub const CONFIG_MFD_ATC260X_I2C_MODULE: u32 = 1;
pub const CONFIG_PREEMPTION: u32 = 1;
pub const CONFIG_DRM_I915_COMPRESS_ERROR: u32 = 1;
pub const CONFIG_IOSCHED_BFQ_MODULE: u32 = 1;
pub const CONFIG_MACB_USE_HWSTAMP: u32 = 1;
pub const CONFIG_SENSORS_LTC2947_I2C_MODULE: u32 = 1;
pub const CONFIG_INTEL_RST_MODULE: u32 = 1;
pub const CONFIG_X509_CERTIFICATE_PARSER: u32 = 1;
pub const CONFIG_GPIO_PCIE_IDIO_24_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_RAM_SIZE: u32 = 65536;
pub const CONFIG_USB_SERIAL_WWAN_MODULE: u32 = 1;
pub const CONFIG_VIDEO_DW9719_MODULE: u32 = 1;
pub const CONFIG_REGMAP_I3C_MODULE: u32 = 1;
pub const CONFIG_SND_ICE1724_MODULE: u32 = 1;
pub const CONFIG_MAC_PARTITION: u32 = 1;
pub const CONFIG_CONSOLE_POLL: u32 = 1;
pub const CONFIG_EARLY_PRINTK_USB: u32 = 1;
pub const CONFIG_VIDEO_OV8865_MODULE: u32 = 1;
pub const CONFIG_INTEL_MEI_PXP_MODULE: u32 = 1;
pub const CONFIG_HID_ALPS_MODULE: u32 = 1;
pub const CONFIG_IIO_ADIS_LIB_BUFFER: u32 = 1;
pub const CONFIG_SENSORS_DA9052_ADC_MODULE: u32 = 1;
pub const CONFIG_NFT_TPROXY_MODULE: u32 = 1;
pub const CONFIG_XFS_POSIX_ACL: u32 = 1;
pub const CONFIG_TTY_PRINTK_LEVEL: u32 = 6;
pub const CONFIG_PTP_1588_CLOCK_KVM_MODULE: u32 = 1;
pub const CONFIG_VFIO_PCI_CORE_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_DA9034_MODULE: u32 = 1;
pub const CONFIG_RV_MON_WWNR: u32 = 1;
pub const CONFIG_IIO_ST_LSM6DSX_SPI_MODULE: u32 = 1;
pub const CONFIG_MLXREG_IO_MODULE: u32 = 1;
pub const CONFIG_INT3406_THERMAL_MODULE: u32 = 1;
pub const CONFIG_PATA_PARPORT_FRIQ_MODULE: u32 = 1;
pub const CONFIG_MSI_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_XEN_PRIVCMD_EVENTFD: u32 = 1;
pub const CONFIG_PDS_CORE_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DT2801_MODULE: u32 = 1;
pub const CONFIG_BRCMFMAC_USB: u32 = 1;
pub const CONFIG_TOUCHSCREEN_DYNAPRO_MODULE: u32 = 1;
pub const CONFIG_FB_MODE_HELPERS: u32 = 1;
pub const CONFIG_UBSAN: u32 = 1;
pub const CONFIG_NLS_ISO8859_13_MODULE: u32 = 1;
pub const CONFIG_MTD_MTDRAM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TLV320AIC3X_I2C_MODULE: u32 = 1;
pub const CONFIG_PCI_PRI: u32 = 1;
pub const CONFIG_MT76_CONNAC_LIB_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SM4_AESNI_AVX_X86_64_MODULE: u32 = 1;
pub const CONFIG_EXTCON_MAX77693_MODULE: u32 = 1;
pub const CONFIG_X86_L1_CACHE_SHIFT: u32 = 6;
pub const CONFIG_BATTERY_BQ27XXX_HDQ_MODULE: u32 = 1;
pub const CONFIG_X86_PAT: u32 = 1;
pub const CONFIG_USB_STORAGE_ONETOUCH_MODULE: u32 = 1;
pub const CONFIG_NLS_ISO8859_8_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SKL_NAU88L25_MAX98357A_MACH_MODULE: u32 = 1;
pub const CONFIG_RT2400PCI_MODULE: u32 = 1;
pub const CONFIG_ICE_HWMON: u32 = 1;
pub const CONFIG_NF_CONNTRACK_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_PCF8523_MODULE: u32 = 1;
pub const CONFIG_EROFS_FS_MODULE: u32 = 1;
pub const CONFIG_HID_PICOLCD_CIR: u32 = 1;
pub const CONFIG_BACKLIGHT_PANDORA_MODULE: u32 = 1;
pub const CONFIG_COMEDI_GSC_HPDI_MODULE: u32 = 1;
pub const CONFIG_NI_XGE_MANAGEMENT_ENET_MODULE: u32 = 1;
pub const CONFIG_FB_NVIDIA_MODULE: u32 = 1;
pub const CONFIG_EFI_RUNTIME_WRAPPERS: u32 = 1;
pub const CONFIG_LCD_CLASS_DEVICE_MODULE: u32 = 1;
pub const CONFIG_MDIO_DEVRES: u32 = 1;
pub const CONFIG_LSM: &[u8; 42usize] = b"landlock,lockdown,yama,integrity,apparmor\0";
pub const CONFIG_SENSORS_OCC_MODULE: u32 = 1;
pub const CONFIG_ARCH_DMA_ADDR_T_64BIT: u32 = 1;
pub const CONFIG_FILE_LOCKING: u32 = 1;
pub const CONFIG_PATA_HPT3X3_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_XIRLINK_CIT_MODULE: u32 = 1;
pub const CONFIG_AD2S1200_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_STK17TA8_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SN9C20X_MODULE: u32 = 1;
pub const CONFIG_CRC64_ROCKSOFT: u32 = 1;
pub const CONFIG_RMI4_F03: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_ELO: u32 = 1;
pub const CONFIG_TCG_TIS_I2C_CR50_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1302_MODULE: u32 = 1;
pub const CONFIG_USB_CHAOSKEY_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST: u32 = 1;
pub const CONFIG_TEST_BPF_MODULE: u32 = 1;
pub const CONFIG_FS_DAX_PMD: u32 = 1;
pub const CONFIG_BACKLIGHT_LV5207LP_MODULE: u32 = 1;
pub const CONFIG_KARMA_PARTITION: u32 = 1;
pub const CONFIG_FB_SM501_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_I2C_AND_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_PS_MODULE: u32 = 1;
pub const CONFIG_NETPOLL: u32 = 1;
pub const CONFIG_COMEDI_ISADMA_MODULE: u32 = 1;
pub const CONFIG_ZSWAP: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_AUDPTR_MODULE: u32 = 1;
pub const CONFIG_MAC80211_MESSAGE_TRACING: u32 = 1;
pub const CONFIG_SENSORS_F71882FG_MODULE: u32 = 1;
pub const CONFIG_ACPI_APEI_GHES: u32 = 1;
pub const CONFIG_SND_SOC_UDA1334_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_TOPLEVEL: u32 = 1;
pub const CONFIG_PINCTRL_ICELAKE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADT7310_MODULE: u32 = 1;
pub const CONFIG_AIO: u32 = 1;
pub const CONFIG_SERIO_ARC_PS2_MODULE: u32 = 1;
pub const CONFIG_DVB_TDA8083_MODULE: u32 = 1;
pub const CONFIG_NET_MPLS_GSO_MODULE: u32 = 1;
pub const CONFIG_NFC_FDP_I2C_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1347_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_LPASS_WSA_MACRO_MODULE: u32 = 1;
pub const CONFIG_CLKEVT_I8253: u32 = 1;
pub const CONFIG_DVB_USB_AZ6007_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_USERSPACE_CONSUMER_MODULE: u32 = 1;
pub const CONFIG_NET_EMATCH: u32 = 1;
pub const CONFIG_PERF_EVENTS: u32 = 1;
pub const CONFIG_MMC_REALTEK_USB_MODULE: u32 = 1;
pub const CONFIG_GENERIC_TIME_VSYSCALL: u32 = 1;
pub const CONFIG_IP_NF_TARGET_REJECT_MODULE: u32 = 1;
pub const CONFIG_INTEL_SCU_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MP8859_MODULE: u32 = 1;
pub const CONFIG_HAVE_MOVE_PMD: u32 = 1;
pub const CONFIG_ZIIRAVE_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_CHOKE_MODULE: u32 = 1;
pub const CONFIG_LTC2688_MODULE: u32 = 1;
pub const CONFIG_IOMMU_IO_PGTABLE: u32 = 1;
pub const CONFIG_GVE_MODULE: u32 = 1;
pub const CONFIG_LEDS_CLASS: u32 = 1;
pub const CONFIG_COMEDI_BOND_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_DIGITV_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_HL_MODULE: u32 = 1;
pub const CONFIG_PERF_EVENTS_INTEL_CSTATE_MODULE: u32 = 1;
pub const CONFIG_KALLSYMS_BASE_RELATIVE: u32 = 1;
pub const CONFIG_TIPC_MEDIA_IB: u32 = 1;
pub const CONFIG_VIDEO_SAA7110_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_XRS700X_MODULE: u32 = 1;
pub const CONFIG_MTD_L440GX_MODULE: u32 = 1;
pub const CONFIG_GPIO_GPIO_MM_MODULE: u32 = 1;
pub const CONFIG_INPUT_IQS626A_MODULE: u32 = 1;
pub const CONFIG_IP_VS_TAB_BITS: u32 = 12;
pub const CONFIG_COMEDI_NI_AT_AO_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_OPTS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_DA9055_MODULE: u32 = 1;
pub const CONFIG_INPUT_TWL4030_PWRBUTTON_MODULE: u32 = 1;
pub const CONFIG_SCSI_SAS_HOST_SMP: u32 = 1;
pub const CONFIG_BCACHE_ASYNC_REGISTRATION: u32 = 1;
pub const CONFIG_VERSION_SIGNATURE: &[u8; 34usize] = b"Ubuntu 6.8.0-45.45-generic 6.8.12\0";
pub const CONFIG_PLAYSTATION_FF: u32 = 1;
pub const CONFIG_RTC_INTF_DEV: u32 = 1;
pub const CONFIG_SND_HDA_SCODEC_CS35L41_SPI_MODULE: u32 = 1;
pub const CONFIG_HID_SIGMAMICRO_MODULE: u32 = 1;
pub const CONFIG_SPI_SIFIVE_MODULE: u32 = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_4: u32 = 1;
pub const CONFIG_IIO_ST_SENSORS_SPI_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_SPI_MODULE: u32 = 1;
pub const CONFIG_DELL_WMI_SYSMAN_MODULE: u32 = 1;
pub const CONFIG_EISA_VIRTUAL_ROOT: u32 = 1;
pub const CONFIG_HID_SUPPORT: u32 = 1;
pub const CONFIG_DCACHE_WORD_ACCESS: u32 = 1;
pub const CONFIG_IP6_NF_TARGET_NPT_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_CE6230_MODULE: u32 = 1;
pub const CONFIG_RTW88_8822BE_MODULE: u32 = 1;
pub const CONFIG_ADF4377_MODULE: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK_INES_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV5675_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_SYMBOL_MODULE: u32 = 1;
pub const CONFIG_PSTORE_COMPRESS: u32 = 1;
pub const CONFIG_CHARGER_MAX77693_MODULE: u32 = 1;
pub const CONFIG_MAGIC_SYSRQ_SERIAL_SEQUENCE: &[u8; 1usize] = b"\0";
pub const CONFIG_REGULATOR_MAX8952_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_HDMI_CODEC_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_OSF_MODULE: u32 = 1;
pub const CONFIG_MLX_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_ADIS16460_MODULE: u32 = 1;
pub const CONFIG_USB_MIDI_GADGET_MODULE: u32 = 1;
pub const CONFIG_SATA_QSTOR_MODULE: u32 = 1;
pub const CONFIG_VIDEO_GO7007_MODULE: u32 = 1;
pub const CONFIG_PATA_SIS: u32 = 1;
pub const CONFIG_MESSAGE_LOGLEVEL_DEFAULT: u32 = 4;
pub const CONFIG_GPIO_TWL4030_MODULE: u32 = 1;
pub const CONFIG_AMD_NB: u32 = 1;
pub const CONFIG_SND_VIRMIDI_MODULE: u32 = 1;
pub const CONFIG_LIB80211_CRYPT_TKIP_MODULE: u32 = 1;
pub const CONFIG_APDS9960_MODULE: u32 = 1;
pub const CONFIG_NGBE_MODULE: u32 = 1;
pub const CONFIG_LOCKUP_DETECTOR: u32 = 1;
pub const CONFIG_QSEMI_PHY_MODULE: u32 = 1;
pub const CONFIG_IP_VS_PROTO_UDP: u32 = 1;
pub const CONFIG_HSC030PA_MODULE: u32 = 1;
pub const CONFIG_VIDEO_BT866_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CAMERA_SENSOR: u32 = 1;
pub const CONFIG_NLS_DEFAULT: &[u8; 5usize] = b"utf8\0";
pub const CONFIG_WATCHDOG_PRETIMEOUT_GOV_NOOP: u32 = 1;
pub const CONFIG_ACPI_CONTAINER: u32 = 1;
pub const CONFIG_SND_DMA_SGBUF: u32 = 1;
pub const CONFIG_UTS_NS: u32 = 1;
pub const CONFIG_I2C_AMD_MP2_MODULE: u32 = 1;
pub const CONFIG_NF_CT_PROTO_GRE: u32 = 1;
pub const CONFIG_SND_CTL_LED_MODULE: u32 = 1;
pub const CONFIG_VIDEO_NOMODESET: u32 = 1;
pub const CONFIG_PAGE_REPORTING: u32 = 1;
pub const CONFIG_HDMI_LPE_AUDIO_MODULE: u32 = 1;
pub const CONFIG_WMI_BMOF_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_BCSP: u32 = 1;
pub const CONFIG_NF_CT_NETLINK_MODULE: u32 = 1;
pub const CONFIG_AHCI_DWC_MODULE: u32 = 1;
pub const CONFIG_EFS_FS_MODULE: u32 = 1;
pub const CONFIG_AUXDISPLAY: u32 = 1;
pub const CONFIG_SVC_I3C_MASTER_MODULE: u32 = 1;
pub const CONFIG_USB_NET_SR9800_MODULE: u32 = 1;
pub const CONFIG_DMA_ENGINE: u32 = 1;
pub const CONFIG_NET_EMATCH_TEXT_MODULE: u32 = 1;
pub const CONFIG_SCA3300_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_ANALOG_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_PCI1XXXX_MODULE: u32 = 1;
pub const CONFIG_ADIS16209_MODULE: u32 = 1;
pub const CONFIG_X86_ACPI_CPUFREQ: u32 = 1;
pub const CONFIG_HID_WIIMOTE_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_AS3711_MODULE: u32 = 1;
pub const CONFIG_APDS9300_MODULE: u32 = 1;
pub const CONFIG_USB_MA901_MODULE: u32 = 1;
pub const CONFIG_P54_SPI_MODULE: u32 = 1;
pub const CONFIG_IAVF_MODULE: u32 = 1;
pub const CONFIG_RDS_TCP_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD: u32 = 1;
pub const CONFIG_CGROUP_PIDS: u32 = 1;
pub const CONFIG_CRYPTO_AEAD2: u32 = 1;
pub const CONFIG_CRYPTO_FCRYPT_MODULE: u32 = 1;
pub const CONFIG_DEBUG_INFO: u32 = 1;
pub const CONFIG_XEN_PVHVM_GUEST: u32 = 1;
pub const CONFIG_X86_HV_CALLBACK_VECTOR: u32 = 1;
pub const CONFIG_NFC_NCI_MODULE: u32 = 1;
pub const CONFIG_TOSHIBA_BT_RFKILL_MODULE: u32 = 1;
pub const CONFIG_WATCHDOG_PRETIMEOUT_GOV_PANIC_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_MODULE: u32 = 1;
pub const CONFIG_NET_IPIP_MODULE: u32 = 1;
pub const CONFIG_IP_VS_SH_TAB_BITS: u32 = 8;
pub const CONFIG_USB_SERIAL_IPAQ_MODULE: u32 = 1;
pub const CONFIG_PCI_ENDPOINT: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_HL_MODULE: u32 = 1;
pub const CONFIG_IPU_BRIDGE_MODULE: u32 = 1;
pub const CONFIG_CHROMEOS_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_DRM_AMD_SECURE_DISPLAY: u32 = 1;
pub const CONFIG_NFC_DIGITAL_MODULE: u32 = 1;
pub const CONFIG_LEDS_TCA6507_MODULE: u32 = 1;
pub const CONFIG_SND_USB_POD_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ALGAPI2: u32 = 1;
pub const CONFIG_SATA_SIS_MODULE: u32 = 1;
pub const CONFIG_PHYSICAL_START: u32 = 16777216;
pub const CONFIG_NETFILTER_XT_TARGET_LED_MODULE: u32 = 1;
pub const CONFIG_WEXT_SPY: u32 = 1;
pub const CONFIG_UBIFS_FS_LZO: u32 = 1;
pub const CONFIG_SI1145_MODULE: u32 = 1;
pub const CONFIG_USB_G_ACM_MS_MODULE: u32 = 1;
pub const CONFIG_ACPI_SBS_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_ADP5589_MODULE: u32 = 1;
pub const CONFIG_MCP41010_MODULE: u32 = 1;
pub const CONFIG_GENERIC_IRQ_RESERVATION_MODE: u32 = 1;
pub const CONFIG_FB_3DFX_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_SILEAD_MODULE: u32 = 1;
pub const CONFIG_X86_PMEM_LEGACY: u32 = 1;
pub const CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS: u32 = 1;
pub const CONFIG_RTW89_DEBUG: u32 = 1;
pub const CONFIG_INPUT: u32 = 1;
pub const CONFIG_RTW89_8852A_MODULE: u32 = 1;
pub const CONFIG_MICROCHIP_T1_PHY_MODULE: u32 = 1;
pub const CONFIG_PCI200SYN_MODULE: u32 = 1;
pub const CONFIG_PPPOATM_MODULE: u32 = 1;
pub const CONFIG_PDS_VFIO_PCI_MODULE: u32 = 1;
pub const CONFIG_INV_ICM42600_I2C_MODULE: u32 = 1;
pub const CONFIG_SENSORS_XDPE152_MODULE: u32 = 1;
pub const CONFIG_SIOX_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SOF_AMD_ACP63_MODULE: u32 = 1;
pub const CONFIG_BT_NXPUART_MODULE: u32 = 1;
pub const CONFIG_PMIC_DA9052: u32 = 1;
pub const CONFIG_PATA_OPTI_MODULE: u32 = 1;
pub const CONFIG_PROC_SYSCTL: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_REALTEK_MODULE: u32 = 1;
pub const CONFIG_ATH6KL_MODULE: u32 = 1;
pub const CONFIG_FWNODE_MDIO: u32 = 1;
pub const CONFIG_HAVE_PERF_EVENTS_NMI: u32 = 1;
pub const CONFIG_SND_SOC_FSL_ASRC_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_REALTEK_RTL8366RB_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CT_MODULE: u32 = 1;
pub const CONFIG_RD_LZ4: u32 = 1;
pub const CONFIG_CPU_MITIGATIONS: u32 = 1;
pub const CONFIG_MMU: u32 = 1;
pub const CONFIG_DVB_CX24123_MODULE: u32 = 1;
pub const CONFIG_RTW89_8851B_MODULE: u32 = 1;
pub const CONFIG_MEDIA_CONTROLLER_DVB: u32 = 1;
pub const CONFIG_NET_DSA_MV88E6XXX_PTP: u32 = 1;
pub const CONFIG_OCFS2_FS_MODULE: u32 = 1;
pub const CONFIG_KFENCE_NUM_OBJECTS: u32 = 255;
pub const CONFIG_ATH11K_DEBUGFS: u32 = 1;
pub const CONFIG_USB_KAWETH_MODULE: u32 = 1;
pub const CONFIG_USB_SIERRA_NET_MODULE: u32 = 1;
pub const CONFIG_AIC7XXX_RESET_DELAY_MS: u32 = 5000;
pub const CONFIG_VMWARE_BALLOON_MODULE: u32 = 1;
pub const CONFIG_LD_VERSION: u32 = 24100;
pub const CONFIG_BRIDGE_EBT_NFLOG_MODULE: u32 = 1;
pub const CONFIG_CAN_SJA1000_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_HAVE_HARDLOCKUP_DETECTOR_BUDDY: u32 = 1;
pub const CONFIG_VIDEO_DW9768_MODULE: u32 = 1;
pub const CONFIG_TABLET_USB_AIPTEK_MODULE: u32 = 1;
pub const CONFIG_BNXT_SRIOV: u32 = 1;
pub const CONFIG_INTEL_SCU: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_CHT_BSW_NAU8824_MACH_MODULE: u32 = 1;
pub const CONFIG_AGP: u32 = 1;
pub const CONFIG_ZPOOL: u32 = 1;
pub const CONFIG_CC_HAS_SLS: u32 = 1;
pub const CONFIG_REGULATOR_TPS6524X_MODULE: u32 = 1;
pub const CONFIG_INPUT_AD714X_MODULE: u32 = 1;
pub const CONFIG_SENSORS_GL520SM_MODULE: u32 = 1;
pub const CONFIG_E1000_MODULE: u32 = 1;
pub const CONFIG_SCSI_SYM53C8XX_MMIO: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const KASAN_ABI_VERSION: u32 = 5;
pub const __BITS_PER_LONG: u32 = 64;
pub const BITS_PER_LONG: u32 = 64;
pub const BITS_PER_LONG_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const KCSAN_ACCESS_WRITE: u32 = 1;
pub const KCSAN_ACCESS_COMPOUND: u32 = 2;
pub const KCSAN_ACCESS_ATOMIC: u32 = 4;
pub const KCSAN_ACCESS_ASSERT: u32 = 8;
pub const KCSAN_ACCESS_SCOPED: u32 = 16;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const MAX_ERRNO: u32 = 4095;
pub const KERN_SOH: &[u8; 2usize] = b"\x01\0";
pub const KERN_SOH_ASCII: u8 = 1u8;
pub const KERN_EMERG: &[u8; 3usize] = b"\x010\0";
pub const KERN_ALERT: &[u8; 3usize] = b"\x011\0";
pub const KERN_CRIT: &[u8; 3usize] = b"\x012\0";
pub const KERN_ERR: &[u8; 3usize] = b"\x013\0";
pub const KERN_WARNING: &[u8; 3usize] = b"\x014\0";
pub const KERN_NOTICE: &[u8; 3usize] = b"\x015\0";
pub const KERN_INFO: &[u8; 3usize] = b"\x016\0";
pub const KERN_DEBUG: &[u8; 3usize] = b"\x017\0";
pub const KERN_DEFAULT: &[u8; 1usize] = b"\0";
pub const KERN_CONT: &[u8; 3usize] = b"\x01c\0";
pub const LOGLEVEL_SCHED: i32 = -2;
pub const LOGLEVEL_DEFAULT: i32 = -1;
pub const LOGLEVEL_EMERG: u32 = 0;
pub const LOGLEVEL_ALERT: u32 = 1;
pub const LOGLEVEL_CRIT: u32 = 2;
pub const LOGLEVEL_ERR: u32 = 3;
pub const LOGLEVEL_WARNING: u32 = 4;
pub const LOGLEVEL_NOTICE: u32 = 5;
pub const LOGLEVEL_INFO: u32 = 6;
pub const LOGLEVEL_DEBUG: u32 = 7;
pub const HAS_KERNEL_IBT: u32 = 0;
pub const ENDBR_INSN_SIZE: u32 = 0;
pub const ASM_RET: &[u8; 25usize] = b"jmp __x86_return_thunk\n\t\0";
pub const BITS_PER_BYTE: u32 = 8;
pub const HZ: u32 = 100;
pub const EXEC_PAGESIZE: u32 = 4096;
pub const NOGROUP: i32 = -1;
pub const MAXHOSTNAMELEN: u32 = 64;
pub const USER_HZ: u32 = 100;
pub const CLOCKS_PER_SEC: u32 = 100;
pub const _Q_LOCKED_OFFSET: u32 = 0;
pub const _Q_LOCKED_BITS: u32 = 8;
pub const _Q_PENDING_OFFSET: u32 = 8;
pub const _Q_PENDING_BITS: u32 = 8;
pub const _Q_TAIL_IDX_OFFSET: u32 = 16;
pub const _Q_TAIL_IDX_BITS: u32 = 2;
pub const _Q_TAIL_CPU_OFFSET: u32 = 18;
pub const _Q_TAIL_CPU_BITS: u32 = 14;
pub const _Q_TAIL_OFFSET: u32 = 16;
pub const _Q_LOCKED_VAL: u32 = 1;
pub const _Q_PENDING_VAL: u32 = 256;
pub const MAX_LOCKDEP_SUBCLASSES: u32 = 8;
pub const SPINLOCK_MAGIC: u32 = 3735899821;
pub const DEFAULT_RATELIMIT_INTERVAL: u32 = 5000;
pub const DEFAULT_RATELIMIT_BURST: u32 = 10;
pub const PRINTK_MAX_SINGLE_HEADER_LEN: u32 = 2;
pub const MESSAGE_LOGLEVEL_DEFAULT: u32 = 4;
pub const CONSOLE_LOGLEVEL_SILENT: u32 = 0;
pub const CONSOLE_LOGLEVEL_MIN: u32 = 1;
pub const CONSOLE_LOGLEVEL_DEBUG: u32 = 10;
pub const CONSOLE_LOGLEVEL_MOTORMOUTH: u32 = 15;
pub const CONSOLE_LOGLEVEL_DEFAULT: u32 = 7;
pub const CONSOLE_LOGLEVEL_QUIET: u32 = 3;
pub const DEVKMSG_STR_MAX_SIZE: u32 = 10;
pub const FW_BUG: &[u8; 17usize] = b"[Firmware Bug]: \0";
pub const FW_WARN: &[u8; 18usize] = b"[Firmware Warn]: \0";
pub const FW_INFO: &[u8; 18usize] = b"[Firmware Info]: \0";
pub const HW_ERR: &[u8; 19usize] = b"[Hardware Error]: \0";
pub const DEPRECATED: &[u8; 15usize] = b"[Deprecated]: \0";
pub const EX_DATA_REG_SHIFT: u32 = 8;
pub const EX_DATA_FLAG_SHIFT: u32 = 12;
pub const EX_DATA_IMM_SHIFT: u32 = 16;
pub const EX_TYPE_NONE: u32 = 0;
pub const EX_TYPE_DEFAULT: u32 = 1;
pub const EX_TYPE_FAULT: u32 = 2;
pub const EX_TYPE_UACCESS: u32 = 3;
pub const EX_TYPE_COPY: u32 = 4;
pub const EX_TYPE_CLEAR_FS: u32 = 5;
pub const EX_TYPE_FPU_RESTORE: u32 = 6;
pub const EX_TYPE_BPF: u32 = 7;
pub const EX_TYPE_WRMSR: u32 = 8;
pub const EX_TYPE_RDMSR: u32 = 9;
pub const EX_TYPE_WRMSR_SAFE: u32 = 10;
pub const EX_TYPE_RDMSR_SAFE: u32 = 11;
pub const EX_TYPE_WRMSR_IN_MCE: u32 = 12;
pub const EX_TYPE_RDMSR_IN_MCE: u32 = 13;
pub const EX_TYPE_DEFAULT_MCE_SAFE: u32 = 14;
pub const EX_TYPE_FAULT_MCE_SAFE: u32 = 15;
pub const EX_TYPE_POP_REG: u32 = 16;
pub const EX_TYPE_IMM_REG: u32 = 17;
pub const EX_TYPE_FAULT_SGX: u32 = 18;
pub const EX_TYPE_UCOPY_LEN: u32 = 19;
pub const EX_TYPE_ZEROPAD: u32 = 20;
pub const DEFINE_EXTABLE_TYPE_REG : & [u8 ; 533usize] = b".macro extable_type_reg type:req reg:req\n.set .Lfound, 0\n.set .Lregnr, 0\n.irp rs,rax,rcx,rdx,rbx,rsp,rbp,rsi,rdi,r8,r9,r10,r11,r12,r13,r14,r15\n.ifc \\reg, %%\\rs\n.set .Lfound, .Lfound+1\n.long \\type + (.Lregnr << 8)\n.endif\n.set .Lregnr, .Lregnr+1\n.endr\n.set .Lregnr, 0\n.irp rs,eax,ecx,edx,ebx,esp,ebp,esi,edi,r8d,r9d,r10d,r11d,r12d,r13d,r14d,r15d\n.ifc \\reg, %%\\rs\n.set .Lfound, .Lfound+1\n.long \\type + (.Lregnr << 8)\n.endif\n.set .Lregnr, .Lregnr+1\n.endr\n.if (.Lfound != 1)\n.error \"extable_type_reg: bad register argument\"\n.endif\n.endm\n\0" ;
pub const UNDEFINE_EXTABLE_TYPE_REG: &[u8; 26usize] = b".purgem extable_type_reg\n\0";
pub const BYTES_NOP1: u32 = 144;
pub const ASM_NOP_MAX: u32 = 11;
pub const JUMP_TYPE_FALSE: u32 = 0;
pub const JUMP_TYPE_TRUE: u32 = 1;
pub const JUMP_TYPE_LINKED: u32 = 2;
pub const JUMP_TYPE_MASK: u32 = 3;
pub const CLS_BITS: u32 = 6;
pub const _DPRINTK_CLASS_DFLT: u32 = 63;
pub const _DPRINTK_FLAGS_NONE: u32 = 0;
pub const _DPRINTK_FLAGS_PRINT: u32 = 1;
pub const _DPRINTK_FLAGS_INCL_MODNAME: u32 = 2;
pub const _DPRINTK_FLAGS_INCL_FUNCNAME: u32 = 4;
pub const _DPRINTK_FLAGS_INCL_LINENO: u32 = 8;
pub const _DPRINTK_FLAGS_INCL_TID: u32 = 16;
pub const _DPRINTK_FLAGS_INCL_SOURCENAME: u32 = 32;
pub const _DPRINTK_FLAGS_INCL_ANY: u32 = 62;
pub const _DPRINTK_FLAGS_DEFAULT: u32 = 0;
pub const PREEMPT_BITS: u32 = 8;
pub const SOFTIRQ_BITS: u32 = 8;
pub const HARDIRQ_BITS: u32 = 4;
pub const NMI_BITS: u32 = 4;
pub const PREEMPT_SHIFT: u32 = 0;
pub const SOFTIRQ_SHIFT: u32 = 8;
pub const HARDIRQ_SHIFT: u32 = 16;
pub const NMI_SHIFT: u32 = 20;
pub const PREEMPT_OFFSET: u32 = 1;
pub const SOFTIRQ_OFFSET: u32 = 256;
pub const HARDIRQ_OFFSET: u32 = 65536;
pub const NMI_OFFSET: u32 = 1048576;
pub const SOFTIRQ_DISABLE_OFFSET: u32 = 512;
pub const INIT_PREEMPT_COUNT: u32 = 1;
pub const NR_CPUS: u32 = 8192;
pub const MIN_THREADS_LEFT_FOR_ROOT: u32 = 4;
pub const PIDS_PER_CPU_DEFAULT: u32 = 1024;
pub const PIDS_PER_CPU_MIN: u32 = 8;
pub const PER_CPU_SHARED_ALIGNED_SECTION: &[u8; 1usize] = b"\0";
pub const PER_CPU_ALIGNED_SECTION: &[u8; 1usize] = b"\0";
pub const PER_CPU_FIRST_SECTION: &[u8; 8usize] = b"..first\0";
pub const PER_CPU_BASE_SECTION: &[u8; 14usize] = b".data..percpu\0";
pub const SI_LOAD_SHIFT: u32 = 16;
pub const L1_CACHE_SHIFT: u32 = 6;
pub const L1_CACHE_BYTES: u32 = 64;
pub const INTERNODE_CACHE_SHIFT: u32 = 6;
pub const INTERNODE_CACHE_BYTES: u32 = 64;
pub const SMP_CACHE_BYTES: u32 = 64;
pub const STATIC_CALL_SITE_TAIL: u32 = 1;
pub const STATIC_CALL_SITE_INIT: u32 = 2;
pub const STATIC_CALL_SITE_FLAGS: u32 = 3;
pub const PREEMPT_NEED_RESCHED: u32 = 2147483648;
pub const PREEMPT_ENABLED: u32 = 2147483648;
pub const PREEMPT_DISABLE_OFFSET: u32 = 1;
pub const PREEMPT_LOCK_OFFSET: u32 = 1;
pub const SOFTIRQ_LOCK_OFFSET: u32 = 513;
pub const X86_EFLAGS_CF_BIT: u32 = 0;
pub const X86_EFLAGS_FIXED_BIT: u32 = 1;
pub const X86_EFLAGS_PF_BIT: u32 = 2;
pub const X86_EFLAGS_AF_BIT: u32 = 4;
pub const X86_EFLAGS_ZF_BIT: u32 = 6;
pub const X86_EFLAGS_SF_BIT: u32 = 7;
pub const X86_EFLAGS_TF_BIT: u32 = 8;
pub const X86_EFLAGS_IF_BIT: u32 = 9;
pub const X86_EFLAGS_DF_BIT: u32 = 10;
pub const X86_EFLAGS_OF_BIT: u32 = 11;
pub const X86_EFLAGS_IOPL_BIT: u32 = 12;
pub const X86_EFLAGS_NT_BIT: u32 = 14;
pub const X86_EFLAGS_RF_BIT: u32 = 16;
pub const X86_EFLAGS_VM_BIT: u32 = 17;
pub const X86_EFLAGS_AC_BIT: u32 = 18;
pub const X86_EFLAGS_VIF_BIT: u32 = 19;
pub const X86_EFLAGS_VIP_BIT: u32 = 20;
pub const X86_EFLAGS_ID_BIT: u32 = 21;
pub const X86_CR0_PE_BIT: u32 = 0;
pub const X86_CR0_MP_BIT: u32 = 1;
pub const X86_CR0_EM_BIT: u32 = 2;
pub const X86_CR0_TS_BIT: u32 = 3;
pub const X86_CR0_ET_BIT: u32 = 4;
pub const X86_CR0_NE_BIT: u32 = 5;
pub const X86_CR0_WP_BIT: u32 = 16;
pub const X86_CR0_AM_BIT: u32 = 18;
pub const X86_CR0_NW_BIT: u32 = 29;
pub const X86_CR0_CD_BIT: u32 = 30;
pub const X86_CR0_PG_BIT: u32 = 31;
pub const X86_CR3_PWT_BIT: u32 = 3;
pub const X86_CR3_PCD_BIT: u32 = 4;
pub const X86_CR3_PCID_BITS: u32 = 12;
pub const X86_CR3_LAM_U57_BIT: u32 = 61;
pub const X86_CR3_LAM_U48_BIT: u32 = 62;
pub const X86_CR3_PCID_NOFLUSH_BIT: u32 = 63;
pub const X86_CR4_VME_BIT: u32 = 0;
pub const X86_CR4_PVI_BIT: u32 = 1;
pub const X86_CR4_TSD_BIT: u32 = 2;
pub const X86_CR4_DE_BIT: u32 = 3;
pub const X86_CR4_PSE_BIT: u32 = 4;
pub const X86_CR4_PAE_BIT: u32 = 5;
pub const X86_CR4_MCE_BIT: u32 = 6;
pub const X86_CR4_PGE_BIT: u32 = 7;
pub const X86_CR4_PCE_BIT: u32 = 8;
pub const X86_CR4_OSFXSR_BIT: u32 = 9;
pub const X86_CR4_OSXMMEXCPT_BIT: u32 = 10;
pub const X86_CR4_UMIP_BIT: u32 = 11;
pub const X86_CR4_LA57_BIT: u32 = 12;
pub const X86_CR4_VMXE_BIT: u32 = 13;
pub const X86_CR4_SMXE_BIT: u32 = 14;
pub const X86_CR4_FSGSBASE_BIT: u32 = 16;
pub const X86_CR4_PCIDE_BIT: u32 = 17;
pub const X86_CR4_OSXSAVE_BIT: u32 = 18;
pub const X86_CR4_SMEP_BIT: u32 = 20;
pub const X86_CR4_SMAP_BIT: u32 = 21;
pub const X86_CR4_PKE_BIT: u32 = 22;
pub const X86_CR4_CET_BIT: u32 = 23;
pub const X86_CR4_LAM_SUP_BIT: u32 = 28;
pub const CX86_PCR0: u32 = 32;
pub const CX86_GCR: u32 = 184;
pub const CX86_CCR0: u32 = 192;
pub const CX86_CCR1: u32 = 193;
pub const CX86_CCR2: u32 = 194;
pub const CX86_CCR3: u32 = 195;
pub const CX86_CCR4: u32 = 232;
pub const CX86_CCR5: u32 = 233;
pub const CX86_CCR6: u32 = 234;
pub const CX86_CCR7: u32 = 235;
pub const CX86_PCR1: u32 = 240;
pub const CX86_DIR0: u32 = 254;
pub const CX86_DIR1: u32 = 255;
pub const CX86_ARR_BASE: u32 = 196;
pub const CX86_RCR_BASE: u32 = 220;
pub const X86_VM_MASK: u32 = 0;
pub const CR3_PCID_MASK: u32 = 4095;
pub const X86_CR3_PTI_PCID_USER_BIT: u32 = 11;
pub const UNWIND_HINT_TYPE_UNDEFINED: u32 = 0;
pub const UNWIND_HINT_TYPE_END_OF_STACK: u32 = 1;
pub const UNWIND_HINT_TYPE_CALL: u32 = 2;
pub const UNWIND_HINT_TYPE_REGS: u32 = 3;
pub const UNWIND_HINT_TYPE_REGS_PARTIAL: u32 = 4;
pub const UNWIND_HINT_TYPE_FUNC: u32 = 5;
pub const UNWIND_HINT_TYPE_SAVE: u32 = 6;
pub const UNWIND_HINT_TYPE_RESTORE: u32 = 7;
pub const ANNOTATE_NOENDBR: &[u8; 64usize] =
    b"986: \n\t.pushsection .discard.noendbr\n\t.long 986b\n\t.popsection\n\t\0";
pub const ASM_REACHABLE: &[u8; 65usize] =
    b"998:\n\t.pushsection .discard.reachable\n\t.long 998b\n\t.popsection\n\t\0";
pub const ALT_FLAGS_SHIFT: u32 = 16;
pub const ALT_FLAG_NOT: u32 = 1;
pub const ALT_FLAG_DIRECT_CALL: u32 = 2;
pub const LOCK_PREFIX_HERE: &[u8; 70usize] =
    b".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\0";
pub const LOCK_PREFIX: &[u8; 78usize] =
    b".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; \0";
pub const ANNOTATE_IGNORE_ALTERNATIVE: &[u8; 67usize] =
    b"999:\n\t.pushsection .discard.ignore_alts\n\t.long 999b\n\t.popsection\n\t\0";
pub const ALT_CALL_INSTR: &[u8; 14usize] = b"call BUG_func\0";
pub const alt_end_marker: &[u8; 4usize] = b"663\0";
pub const alt_slen: &[u8; 10usize] = b"662b-661b\0";
pub const alt_total_slen: &[u8; 10usize] = b"663b-661b\0";
pub const NEED_3DNOW: u32 = 0;
pub const NEED_MOVBE: u32 = 0;
pub const NEED_PSE: u32 = 0;
pub const NEED_PGE: u32 = 0;
pub const REQUIRED_MASK2: u32 = 0;
pub const REQUIRED_MASK4: u32 = 0;
pub const REQUIRED_MASK5: u32 = 0;
pub const REQUIRED_MASK6: u32 = 0;
pub const REQUIRED_MASK7: u32 = 0;
pub const REQUIRED_MASK8: u32 = 0;
pub const REQUIRED_MASK9: u32 = 0;
pub const REQUIRED_MASK10: u32 = 0;
pub const REQUIRED_MASK11: u32 = 0;
pub const REQUIRED_MASK12: u32 = 0;
pub const REQUIRED_MASK13: u32 = 0;
pub const REQUIRED_MASK14: u32 = 0;
pub const REQUIRED_MASK15: u32 = 0;
pub const REQUIRED_MASK16: u32 = 0;
pub const REQUIRED_MASK17: u32 = 0;
pub const REQUIRED_MASK18: u32 = 0;
pub const REQUIRED_MASK19: u32 = 0;
pub const REQUIRED_MASK20: u32 = 0;
pub const REQUIRED_MASK21: u32 = 0;
pub const DISABLE_UMIP: u32 = 0;
pub const DISABLE_PCID: u32 = 0;
pub const DISABLE_PKU: u32 = 0;
pub const DISABLE_OSPKE: u32 = 0;
pub const DISABLE_LA57: u32 = 0;
pub const DISABLE_PTI: u32 = 0;
pub const DISABLE_RETPOLINE: u32 = 0;
pub const DISABLE_RETHUNK: u32 = 0;
pub const DISABLE_UNRET: u32 = 0;
pub const DISABLE_CALL_DEPTH_TRACKING: u32 = 0;
pub const DISABLE_LAM: u32 = 0;
pub const DISABLE_ENQCMD: u32 = 0;
pub const DISABLE_SGX: u32 = 0;
pub const DISABLE_XENPV: u32 = 0;
pub const DISABLE_TDX_GUEST: u32 = 0;
pub const DISABLE_USER_SHSTK: u32 = 0;
pub const DISABLED_MASK1: u32 = 0;
pub const DISABLED_MASK2: u32 = 0;
pub const DISABLED_MASK4: u32 = 0;
pub const DISABLED_MASK5: u32 = 0;
pub const DISABLED_MASK6: u32 = 0;
pub const DISABLED_MASK7: u32 = 0;
pub const DISABLED_MASK8: u32 = 0;
pub const DISABLED_MASK9: u32 = 0;
pub const DISABLED_MASK10: u32 = 0;
pub const DISABLED_MASK11: u32 = 0;
pub const DISABLED_MASK12: u32 = 0;
pub const DISABLED_MASK13: u32 = 0;
pub const DISABLED_MASK14: u32 = 0;
pub const DISABLED_MASK15: u32 = 0;
pub const DISABLED_MASK16: u32 = 0;
pub const DISABLED_MASK17: u32 = 0;
pub const DISABLED_MASK19: u32 = 0;
pub const DISABLED_MASK20: u32 = 0;
pub const DISABLED_MASK21: u32 = 0;
pub const NCAPINTS: u32 = 22;
pub const NBUGINTS: u32 = 2;
pub const X86_FEATURE_FPU: u32 = 0;
pub const X86_FEATURE_VME: u32 = 1;
pub const X86_FEATURE_DE: u32 = 2;
pub const X86_FEATURE_PSE: u32 = 3;
pub const X86_FEATURE_TSC: u32 = 4;
pub const X86_FEATURE_MSR: u32 = 5;
pub const X86_FEATURE_PAE: u32 = 6;
pub const X86_FEATURE_MCE: u32 = 7;
pub const X86_FEATURE_CX8: u32 = 8;
pub const X86_FEATURE_APIC: u32 = 9;
pub const X86_FEATURE_SEP: u32 = 11;
pub const X86_FEATURE_MTRR: u32 = 12;
pub const X86_FEATURE_PGE: u32 = 13;
pub const X86_FEATURE_MCA: u32 = 14;
pub const X86_FEATURE_CMOV: u32 = 15;
pub const X86_FEATURE_PAT: u32 = 16;
pub const X86_FEATURE_PSE36: u32 = 17;
pub const X86_FEATURE_PN: u32 = 18;
pub const X86_FEATURE_CLFLUSH: u32 = 19;
pub const X86_FEATURE_DS: u32 = 21;
pub const X86_FEATURE_ACPI: u32 = 22;
pub const X86_FEATURE_MMX: u32 = 23;
pub const X86_FEATURE_FXSR: u32 = 24;
pub const X86_FEATURE_XMM: u32 = 25;
pub const X86_FEATURE_XMM2: u32 = 26;
pub const X86_FEATURE_SELFSNOOP: u32 = 27;
pub const X86_FEATURE_HT: u32 = 28;
pub const X86_FEATURE_ACC: u32 = 29;
pub const X86_FEATURE_IA64: u32 = 30;
pub const X86_FEATURE_PBE: u32 = 31;
pub const X86_FEATURE_SYSCALL: u32 = 43;
pub const X86_FEATURE_MP: u32 = 51;
pub const X86_FEATURE_NX: u32 = 52;
pub const X86_FEATURE_MMXEXT: u32 = 54;
pub const X86_FEATURE_FXSR_OPT: u32 = 57;
pub const X86_FEATURE_GBPAGES: u32 = 58;
pub const X86_FEATURE_RDTSCP: u32 = 59;
pub const X86_FEATURE_LM: u32 = 61;
pub const X86_FEATURE_3DNOWEXT: u32 = 62;
pub const X86_FEATURE_3DNOW: u32 = 63;
pub const X86_FEATURE_RECOVERY: u32 = 64;
pub const X86_FEATURE_LONGRUN: u32 = 65;
pub const X86_FEATURE_LRTI: u32 = 67;
pub const X86_FEATURE_CXMMX: u32 = 96;
pub const X86_FEATURE_K6_MTRR: u32 = 97;
pub const X86_FEATURE_CYRIX_ARR: u32 = 98;
pub const X86_FEATURE_CENTAUR_MCR: u32 = 99;
pub const X86_FEATURE_K8: u32 = 100;
pub const X86_FEATURE_ZEN5: u32 = 101;
pub const X86_FEATURE_P3: u32 = 102;
pub const X86_FEATURE_P4: u32 = 103;
pub const X86_FEATURE_CONSTANT_TSC: u32 = 104;
pub const X86_FEATURE_UP: u32 = 105;
pub const X86_FEATURE_ART: u32 = 106;
pub const X86_FEATURE_ARCH_PERFMON: u32 = 107;
pub const X86_FEATURE_PEBS: u32 = 108;
pub const X86_FEATURE_BTS: u32 = 109;
pub const X86_FEATURE_SYSCALL32: u32 = 110;
pub const X86_FEATURE_SYSENTER32: u32 = 111;
pub const X86_FEATURE_REP_GOOD: u32 = 112;
pub const X86_FEATURE_AMD_LBR_V2: u32 = 113;
pub const X86_FEATURE_CLEAR_CPU_BUF: u32 = 114;
pub const X86_FEATURE_ACC_POWER: u32 = 115;
pub const X86_FEATURE_NOPL: u32 = 116;
pub const X86_FEATURE_ALWAYS: u32 = 117;
pub const X86_FEATURE_XTOPOLOGY: u32 = 118;
pub const X86_FEATURE_TSC_RELIABLE: u32 = 119;
pub const X86_FEATURE_NONSTOP_TSC: u32 = 120;
pub const X86_FEATURE_CPUID: u32 = 121;
pub const X86_FEATURE_EXTD_APICID: u32 = 122;
pub const X86_FEATURE_AMD_DCM: u32 = 123;
pub const X86_FEATURE_APERFMPERF: u32 = 124;
pub const X86_FEATURE_RAPL: u32 = 125;
pub const X86_FEATURE_NONSTOP_TSC_S3: u32 = 126;
pub const X86_FEATURE_TSC_KNOWN_FREQ: u32 = 127;
pub const X86_FEATURE_XMM3: u32 = 128;
pub const X86_FEATURE_PCLMULQDQ: u32 = 129;
pub const X86_FEATURE_DTES64: u32 = 130;
pub const X86_FEATURE_MWAIT: u32 = 131;
pub const X86_FEATURE_DSCPL: u32 = 132;
pub const X86_FEATURE_VMX: u32 = 133;
pub const X86_FEATURE_SMX: u32 = 134;
pub const X86_FEATURE_EST: u32 = 135;
pub const X86_FEATURE_TM2: u32 = 136;
pub const X86_FEATURE_SSSE3: u32 = 137;
pub const X86_FEATURE_CID: u32 = 138;
pub const X86_FEATURE_SDBG: u32 = 139;
pub const X86_FEATURE_FMA: u32 = 140;
pub const X86_FEATURE_CX16: u32 = 141;
pub const X86_FEATURE_XTPR: u32 = 142;
pub const X86_FEATURE_PDCM: u32 = 143;
pub const X86_FEATURE_PCID: u32 = 145;
pub const X86_FEATURE_DCA: u32 = 146;
pub const X86_FEATURE_XMM4_1: u32 = 147;
pub const X86_FEATURE_XMM4_2: u32 = 148;
pub const X86_FEATURE_X2APIC: u32 = 149;
pub const X86_FEATURE_MOVBE: u32 = 150;
pub const X86_FEATURE_POPCNT: u32 = 151;
pub const X86_FEATURE_TSC_DEADLINE_TIMER: u32 = 152;
pub const X86_FEATURE_AES: u32 = 153;
pub const X86_FEATURE_XSAVE: u32 = 154;
pub const X86_FEATURE_OSXSAVE: u32 = 155;
pub const X86_FEATURE_AVX: u32 = 156;
pub const X86_FEATURE_F16C: u32 = 157;
pub const X86_FEATURE_RDRAND: u32 = 158;
pub const X86_FEATURE_HYPERVISOR: u32 = 159;
pub const X86_FEATURE_XSTORE: u32 = 162;
pub const X86_FEATURE_XSTORE_EN: u32 = 163;
pub const X86_FEATURE_XCRYPT: u32 = 166;
pub const X86_FEATURE_XCRYPT_EN: u32 = 167;
pub const X86_FEATURE_ACE2: u32 = 168;
pub const X86_FEATURE_ACE2_EN: u32 = 169;
pub const X86_FEATURE_PHE: u32 = 170;
pub const X86_FEATURE_PHE_EN: u32 = 171;
pub const X86_FEATURE_PMM: u32 = 172;
pub const X86_FEATURE_PMM_EN: u32 = 173;
pub const X86_FEATURE_LAHF_LM: u32 = 192;
pub const X86_FEATURE_CMP_LEGACY: u32 = 193;
pub const X86_FEATURE_SVM: u32 = 194;
pub const X86_FEATURE_EXTAPIC: u32 = 195;
pub const X86_FEATURE_CR8_LEGACY: u32 = 196;
pub const X86_FEATURE_ABM: u32 = 197;
pub const X86_FEATURE_SSE4A: u32 = 198;
pub const X86_FEATURE_MISALIGNSSE: u32 = 199;
pub const X86_FEATURE_3DNOWPREFETCH: u32 = 200;
pub const X86_FEATURE_OSVW: u32 = 201;
pub const X86_FEATURE_IBS: u32 = 202;
pub const X86_FEATURE_XOP: u32 = 203;
pub const X86_FEATURE_SKINIT: u32 = 204;
pub const X86_FEATURE_WDT: u32 = 205;
pub const X86_FEATURE_LWP: u32 = 207;
pub const X86_FEATURE_FMA4: u32 = 208;
pub const X86_FEATURE_TCE: u32 = 209;
pub const X86_FEATURE_NODEID_MSR: u32 = 211;
pub const X86_FEATURE_TBM: u32 = 213;
pub const X86_FEATURE_TOPOEXT: u32 = 214;
pub const X86_FEATURE_PERFCTR_CORE: u32 = 215;
pub const X86_FEATURE_PERFCTR_NB: u32 = 216;
pub const X86_FEATURE_BPEXT: u32 = 218;
pub const X86_FEATURE_PTSC: u32 = 219;
pub const X86_FEATURE_PERFCTR_LLC: u32 = 220;
pub const X86_FEATURE_MWAITX: u32 = 221;
pub const X86_FEATURE_RING3MWAIT: u32 = 224;
pub const X86_FEATURE_CPUID_FAULT: u32 = 225;
pub const X86_FEATURE_CPB: u32 = 226;
pub const X86_FEATURE_EPB: u32 = 227;
pub const X86_FEATURE_CAT_L3: u32 = 228;
pub const X86_FEATURE_CAT_L2: u32 = 229;
pub const X86_FEATURE_CDP_L3: u32 = 230;
pub const X86_FEATURE_TDX_HOST_PLATFORM: u32 = 231;
pub const X86_FEATURE_HW_PSTATE: u32 = 232;
pub const X86_FEATURE_PROC_FEEDBACK: u32 = 233;
pub const X86_FEATURE_XCOMPACTED: u32 = 234;
pub const X86_FEATURE_PTI: u32 = 235;
pub const X86_FEATURE_KERNEL_IBRS: u32 = 236;
pub const X86_FEATURE_RSB_VMEXIT: u32 = 237;
pub const X86_FEATURE_INTEL_PPIN: u32 = 238;
pub const X86_FEATURE_CDP_L2: u32 = 239;
pub const X86_FEATURE_MSR_SPEC_CTRL: u32 = 240;
pub const X86_FEATURE_SSBD: u32 = 241;
pub const X86_FEATURE_MBA: u32 = 242;
pub const X86_FEATURE_RSB_CTXSW: u32 = 243;
pub const X86_FEATURE_PERFMON_V2: u32 = 244;
pub const X86_FEATURE_USE_IBPB: u32 = 245;
pub const X86_FEATURE_USE_IBRS_FW: u32 = 246;
pub const X86_FEATURE_SPEC_STORE_BYPASS_DISABLE: u32 = 247;
pub const X86_FEATURE_LS_CFG_SSBD: u32 = 248;
pub const X86_FEATURE_IBRS: u32 = 249;
pub const X86_FEATURE_IBPB: u32 = 250;
pub const X86_FEATURE_STIBP: u32 = 251;
pub const X86_FEATURE_ZEN: u32 = 252;
pub const X86_FEATURE_L1TF_PTEINV: u32 = 253;
pub const X86_FEATURE_IBRS_ENHANCED: u32 = 254;
pub const X86_FEATURE_MSR_IA32_FEAT_CTL: u32 = 255;
pub const X86_FEATURE_TPR_SHADOW: u32 = 256;
pub const X86_FEATURE_FLEXPRIORITY: u32 = 257;
pub const X86_FEATURE_EPT: u32 = 258;
pub const X86_FEATURE_VPID: u32 = 259;
pub const X86_FEATURE_VMMCALL: u32 = 271;
pub const X86_FEATURE_XENPV: u32 = 272;
pub const X86_FEATURE_EPT_AD: u32 = 273;
pub const X86_FEATURE_VMCALL: u32 = 274;
pub const X86_FEATURE_VMW_VMMCALL: u32 = 275;
pub const X86_FEATURE_PVUNLOCK: u32 = 276;
pub const X86_FEATURE_VCPUPREEMPT: u32 = 277;
pub const X86_FEATURE_TDX_GUEST: u32 = 278;
pub const X86_FEATURE_FSGSBASE: u32 = 288;
pub const X86_FEATURE_TSC_ADJUST: u32 = 289;
pub const X86_FEATURE_SGX: u32 = 290;
pub const X86_FEATURE_BMI1: u32 = 291;
pub const X86_FEATURE_HLE: u32 = 292;
pub const X86_FEATURE_AVX2: u32 = 293;
pub const X86_FEATURE_FDP_EXCPTN_ONLY: u32 = 294;
pub const X86_FEATURE_SMEP: u32 = 295;
pub const X86_FEATURE_BMI2: u32 = 296;
pub const X86_FEATURE_ERMS: u32 = 297;
pub const X86_FEATURE_INVPCID: u32 = 298;
pub const X86_FEATURE_RTM: u32 = 299;
pub const X86_FEATURE_CQM: u32 = 300;
pub const X86_FEATURE_ZERO_FCS_FDS: u32 = 301;
pub const X86_FEATURE_MPX: u32 = 302;
pub const X86_FEATURE_RDT_A: u32 = 303;
pub const X86_FEATURE_AVX512F: u32 = 304;
pub const X86_FEATURE_AVX512DQ: u32 = 305;
pub const X86_FEATURE_RDSEED: u32 = 306;
pub const X86_FEATURE_ADX: u32 = 307;
pub const X86_FEATURE_SMAP: u32 = 308;
pub const X86_FEATURE_AVX512IFMA: u32 = 309;
pub const X86_FEATURE_CLFLUSHOPT: u32 = 311;
pub const X86_FEATURE_CLWB: u32 = 312;
pub const X86_FEATURE_INTEL_PT: u32 = 313;
pub const X86_FEATURE_AVX512PF: u32 = 314;
pub const X86_FEATURE_AVX512ER: u32 = 315;
pub const X86_FEATURE_AVX512CD: u32 = 316;
pub const X86_FEATURE_SHA_NI: u32 = 317;
pub const X86_FEATURE_AVX512BW: u32 = 318;
pub const X86_FEATURE_AVX512VL: u32 = 319;
pub const X86_FEATURE_XSAVEOPT: u32 = 320;
pub const X86_FEATURE_XSAVEC: u32 = 321;
pub const X86_FEATURE_XGETBV1: u32 = 322;
pub const X86_FEATURE_XSAVES: u32 = 323;
pub const X86_FEATURE_XFD: u32 = 324;
pub const X86_FEATURE_CQM_LLC: u32 = 352;
pub const X86_FEATURE_CQM_OCCUP_LLC: u32 = 353;
pub const X86_FEATURE_CQM_MBM_TOTAL: u32 = 354;
pub const X86_FEATURE_CQM_MBM_LOCAL: u32 = 355;
pub const X86_FEATURE_FENCE_SWAPGS_USER: u32 = 356;
pub const X86_FEATURE_FENCE_SWAPGS_KERNEL: u32 = 357;
pub const X86_FEATURE_SPLIT_LOCK_DETECT: u32 = 358;
pub const X86_FEATURE_PER_THREAD_MBA: u32 = 359;
pub const X86_FEATURE_SGX1: u32 = 360;
pub const X86_FEATURE_SGX2: u32 = 361;
pub const X86_FEATURE_ENTRY_IBPB: u32 = 362;
pub const X86_FEATURE_RRSBA_CTRL: u32 = 363;
pub const X86_FEATURE_RETPOLINE: u32 = 364;
pub const X86_FEATURE_RETPOLINE_LFENCE: u32 = 365;
pub const X86_FEATURE_RETHUNK: u32 = 366;
pub const X86_FEATURE_UNRET: u32 = 367;
pub const X86_FEATURE_USE_IBPB_FW: u32 = 368;
pub const X86_FEATURE_RSB_VMEXIT_LITE: u32 = 369;
pub const X86_FEATURE_SGX_EDECCSSA: u32 = 370;
pub const X86_FEATURE_CALL_DEPTH: u32 = 371;
pub const X86_FEATURE_MSR_TSX_CTRL: u32 = 372;
pub const X86_FEATURE_SMBA: u32 = 373;
pub const X86_FEATURE_BMEC: u32 = 374;
pub const X86_FEATURE_USER_SHSTK: u32 = 375;
pub const X86_FEATURE_SRSO: u32 = 376;
pub const X86_FEATURE_SRSO_ALIAS: u32 = 377;
pub const X86_FEATURE_IBPB_ON_VMEXIT: u32 = 378;
pub const X86_FEATURE_APIC_MSRS_FENCE: u32 = 379;
pub const X86_FEATURE_ZEN2: u32 = 380;
pub const X86_FEATURE_ZEN3: u32 = 381;
pub const X86_FEATURE_ZEN4: u32 = 382;
pub const X86_FEATURE_ZEN1: u32 = 383;
pub const X86_FEATURE_AVX_VNNI: u32 = 388;
pub const X86_FEATURE_AVX512_BF16: u32 = 389;
pub const X86_FEATURE_CMPCCXADD: u32 = 391;
pub const X86_FEATURE_ARCH_PERFMON_EXT: u32 = 392;
pub const X86_FEATURE_FZRM: u32 = 394;
pub const X86_FEATURE_FSRS: u32 = 395;
pub const X86_FEATURE_FSRC: u32 = 396;
pub const X86_FEATURE_LKGS: u32 = 402;
pub const X86_FEATURE_AMX_FP16: u32 = 405;
pub const X86_FEATURE_AVX_IFMA: u32 = 407;
pub const X86_FEATURE_LAM: u32 = 410;
pub const X86_FEATURE_CLZERO: u32 = 416;
pub const X86_FEATURE_IRPERF: u32 = 417;
pub const X86_FEATURE_XSAVEERPTR: u32 = 418;
pub const X86_FEATURE_RDPRU: u32 = 420;
pub const X86_FEATURE_WBNOINVD: u32 = 425;
pub const X86_FEATURE_AMD_IBPB: u32 = 428;
pub const X86_FEATURE_AMD_IBRS: u32 = 430;
pub const X86_FEATURE_AMD_STIBP: u32 = 431;
pub const X86_FEATURE_AMD_STIBP_ALWAYS_ON: u32 = 433;
pub const X86_FEATURE_AMD_PPIN: u32 = 439;
pub const X86_FEATURE_AMD_SSBD: u32 = 440;
pub const X86_FEATURE_VIRT_SSBD: u32 = 441;
pub const X86_FEATURE_AMD_SSB_NO: u32 = 442;
pub const X86_FEATURE_CPPC: u32 = 443;
pub const X86_FEATURE_AMD_PSFD: u32 = 444;
pub const X86_FEATURE_BTC_NO: u32 = 445;
pub const X86_FEATURE_BRS: u32 = 447;
pub const X86_FEATURE_DTHERM: u32 = 448;
pub const X86_FEATURE_IDA: u32 = 449;
pub const X86_FEATURE_ARAT: u32 = 450;
pub const X86_FEATURE_PLN: u32 = 452;
pub const X86_FEATURE_PTS: u32 = 454;
pub const X86_FEATURE_HWP: u32 = 455;
pub const X86_FEATURE_HWP_NOTIFY: u32 = 456;
pub const X86_FEATURE_HWP_ACT_WINDOW: u32 = 457;
pub const X86_FEATURE_HWP_EPP: u32 = 458;
pub const X86_FEATURE_HWP_PKG_REQ: u32 = 459;
pub const X86_FEATURE_HFI: u32 = 467;
pub const X86_FEATURE_NPT: u32 = 480;
pub const X86_FEATURE_LBRV: u32 = 481;
pub const X86_FEATURE_SVML: u32 = 482;
pub const X86_FEATURE_NRIPS: u32 = 483;
pub const X86_FEATURE_TSCRATEMSR: u32 = 484;
pub const X86_FEATURE_VMCBCLEAN: u32 = 485;
pub const X86_FEATURE_FLUSHBYASID: u32 = 486;
pub const X86_FEATURE_DECODEASSISTS: u32 = 487;
pub const X86_FEATURE_PAUSEFILTER: u32 = 490;
pub const X86_FEATURE_PFTHRESHOLD: u32 = 492;
pub const X86_FEATURE_AVIC: u32 = 493;
pub const X86_FEATURE_V_VMSAVE_VMLOAD: u32 = 495;
pub const X86_FEATURE_VGIF: u32 = 496;
pub const X86_FEATURE_X2AVIC: u32 = 498;
pub const X86_FEATURE_V_SPEC_CTRL: u32 = 500;
pub const X86_FEATURE_VNMI: u32 = 505;
pub const X86_FEATURE_SVME_ADDR_CHK: u32 = 508;
pub const X86_FEATURE_AVX512VBMI: u32 = 513;
pub const X86_FEATURE_UMIP: u32 = 514;
pub const X86_FEATURE_PKU: u32 = 515;
pub const X86_FEATURE_OSPKE: u32 = 516;
pub const X86_FEATURE_WAITPKG: u32 = 517;
pub const X86_FEATURE_AVX512_VBMI2: u32 = 518;
pub const X86_FEATURE_SHSTK: u32 = 519;
pub const X86_FEATURE_GFNI: u32 = 520;
pub const X86_FEATURE_VAES: u32 = 521;
pub const X86_FEATURE_VPCLMULQDQ: u32 = 522;
pub const X86_FEATURE_AVX512_VNNI: u32 = 523;
pub const X86_FEATURE_AVX512_BITALG: u32 = 524;
pub const X86_FEATURE_TME: u32 = 525;
pub const X86_FEATURE_AVX512_VPOPCNTDQ: u32 = 526;
pub const X86_FEATURE_LA57: u32 = 528;
pub const X86_FEATURE_RDPID: u32 = 534;
pub const X86_FEATURE_BUS_LOCK_DETECT: u32 = 536;
pub const X86_FEATURE_CLDEMOTE: u32 = 537;
pub const X86_FEATURE_MOVDIRI: u32 = 539;
pub const X86_FEATURE_MOVDIR64B: u32 = 540;
pub const X86_FEATURE_ENQCMD: u32 = 541;
pub const X86_FEATURE_SGX_LC: u32 = 542;
pub const X86_FEATURE_OVERFLOW_RECOV: u32 = 544;
pub const X86_FEATURE_SUCCOR: u32 = 545;
pub const X86_FEATURE_SMCA: u32 = 547;
pub const X86_FEATURE_AVX512_4VNNIW: u32 = 578;
pub const X86_FEATURE_AVX512_4FMAPS: u32 = 579;
pub const X86_FEATURE_FSRM: u32 = 580;
pub const X86_FEATURE_AVX512_VP2INTERSECT: u32 = 584;
pub const X86_FEATURE_SRBDS_CTRL: u32 = 585;
pub const X86_FEATURE_MD_CLEAR: u32 = 586;
pub const X86_FEATURE_RTM_ALWAYS_ABORT: u32 = 587;
pub const X86_FEATURE_TSX_FORCE_ABORT: u32 = 589;
pub const X86_FEATURE_SERIALIZE: u32 = 590;
pub const X86_FEATURE_HYBRID_CPU: u32 = 591;
pub const X86_FEATURE_TSXLDTRK: u32 = 592;
pub const X86_FEATURE_PCONFIG: u32 = 594;
pub const X86_FEATURE_ARCH_LBR: u32 = 595;
pub const X86_FEATURE_IBT: u32 = 596;
pub const X86_FEATURE_AMX_BF16: u32 = 598;
pub const X86_FEATURE_AVX512_FP16: u32 = 599;
pub const X86_FEATURE_AMX_TILE: u32 = 600;
pub const X86_FEATURE_AMX_INT8: u32 = 601;
pub const X86_FEATURE_SPEC_CTRL: u32 = 602;
pub const X86_FEATURE_INTEL_STIBP: u32 = 603;
pub const X86_FEATURE_FLUSH_L1D: u32 = 604;
pub const X86_FEATURE_ARCH_CAPABILITIES: u32 = 605;
pub const X86_FEATURE_CORE_CAPABILITIES: u32 = 606;
pub const X86_FEATURE_SPEC_CTRL_SSBD: u32 = 607;
pub const X86_FEATURE_SME: u32 = 608;
pub const X86_FEATURE_SEV: u32 = 609;
pub const X86_FEATURE_VM_PAGE_FLUSH: u32 = 610;
pub const X86_FEATURE_SEV_ES: u32 = 611;
pub const X86_FEATURE_V_TSC_AUX: u32 = 617;
pub const X86_FEATURE_SME_COHERENT: u32 = 618;
pub const X86_FEATURE_DEBUG_SWAP: u32 = 622;
pub const X86_FEATURE_NO_NESTED_DATA_BP: u32 = 640;
pub const X86_FEATURE_WRMSR_XX_BASE_NS: u32 = 641;
pub const X86_FEATURE_LFENCE_RDTSC: u32 = 642;
pub const X86_FEATURE_NULL_SEL_CLR_BASE: u32 = 646;
pub const X86_FEATURE_AUTOIBRS: u32 = 648;
pub const X86_FEATURE_NO_SMM_CTL_MSR: u32 = 649;
pub const X86_FEATURE_SBPB: u32 = 667;
pub const X86_FEATURE_IBPB_BRTYPE: u32 = 668;
pub const X86_FEATURE_SRSO_NO: u32 = 669;
pub const X86_FEATURE_CLEAR_BHB_LOOP: u32 = 673;
pub const X86_FEATURE_BHI_CTRL: u32 = 674;
pub const X86_FEATURE_CLEAR_BHB_HW: u32 = 675;
pub const X86_FEATURE_CLEAR_BHB_LOOP_ON_VMEXIT: u32 = 676;
pub const MSR_EFER: u32 = 3221225600;
pub const MSR_STAR: u32 = 3221225601;
pub const MSR_LSTAR: u32 = 3221225602;
pub const MSR_CSTAR: u32 = 3221225603;
pub const MSR_SYSCALL_MASK: u32 = 3221225604;
pub const MSR_FS_BASE: u32 = 3221225728;
pub const MSR_GS_BASE: u32 = 3221225729;
pub const MSR_KERNEL_GS_BASE: u32 = 3221225730;
pub const MSR_TSC_AUX: u32 = 3221225731;
pub const _EFER_SCE: u32 = 0;
pub const _EFER_LME: u32 = 8;
pub const _EFER_LMA: u32 = 10;
pub const _EFER_NX: u32 = 11;
pub const _EFER_SVME: u32 = 12;
pub const _EFER_LMSLE: u32 = 13;
pub const _EFER_FFXSR: u32 = 14;
pub const _EFER_AUTOIBRS: u32 = 21;
pub const EFER_SCE: u32 = 1;
pub const EFER_LME: u32 = 256;
pub const EFER_LMA: u32 = 1024;
pub const EFER_NX: u32 = 2048;
pub const EFER_SVME: u32 = 4096;
pub const EFER_LMSLE: u32 = 8192;
pub const EFER_FFXSR: u32 = 16384;
pub const EFER_AUTOIBRS: u32 = 2097152;
pub const MSR_TEST_CTRL: u32 = 51;
pub const MSR_TEST_CTRL_SPLIT_LOCK_DETECT_BIT: u32 = 29;
pub const MSR_IA32_SPEC_CTRL: u32 = 72;
pub const SPEC_CTRL_STIBP_SHIFT: u32 = 1;
pub const SPEC_CTRL_SSBD_SHIFT: u32 = 2;
pub const SPEC_CTRL_RRSBA_DIS_S_SHIFT: u32 = 6;
pub const SPEC_CTRL_BHI_DIS_S_SHIFT: u32 = 10;
pub const MSR_IA32_PRED_CMD: u32 = 73;
pub const MSR_PPIN_CTL: u32 = 78;
pub const MSR_PPIN: u32 = 79;
pub const MSR_IA32_PERFCTR0: u32 = 193;
pub const MSR_IA32_PERFCTR1: u32 = 194;
pub const MSR_FSB_FREQ: u32 = 205;
pub const MSR_PLATFORM_INFO: u32 = 206;
pub const MSR_PLATFORM_INFO_CPUID_FAULT_BIT: u32 = 31;
pub const MSR_IA32_UMWAIT_CONTROL: u32 = 225;
pub const MSR_IA32_UMWAIT_CONTROL_TIME_MASK: i32 = -4;
pub const MSR_IA32_CORE_CAPS: u32 = 207;
pub const MSR_IA32_CORE_CAPS_INTEGRITY_CAPS_BIT: u32 = 2;
pub const MSR_IA32_CORE_CAPS_SPLIT_LOCK_DETECT_BIT: u32 = 5;
pub const MSR_PKG_CST_CONFIG_CONTROL: u32 = 226;
pub const NHM_C3_AUTO_DEMOTE: u32 = 33554432;
pub const NHM_C1_AUTO_DEMOTE: u32 = 67108864;
pub const ATM_LNC_C6_AUTO_DEMOTE: u32 = 33554432;
pub const SNB_C3_AUTO_UNDEMOTE: u32 = 134217728;
pub const SNB_C1_AUTO_UNDEMOTE: u32 = 268435456;
pub const MSR_MTRRcap: u32 = 254;
pub const MSR_IA32_ARCH_CAPABILITIES: u32 = 266;
pub const MSR_IA32_FLUSH_CMD: u32 = 267;
pub const MSR_IA32_BBL_CR_CTL: u32 = 281;
pub const MSR_IA32_BBL_CR_CTL3: u32 = 286;
pub const MSR_IA32_TSX_CTRL: u32 = 290;
pub const MSR_IA32_MCU_OPT_CTRL: u32 = 291;
pub const MSR_IA32_SYSENTER_CS: u32 = 372;
pub const MSR_IA32_SYSENTER_ESP: u32 = 373;
pub const MSR_IA32_SYSENTER_EIP: u32 = 374;
pub const MSR_IA32_MCG_CAP: u32 = 377;
pub const MSR_IA32_MCG_STATUS: u32 = 378;
pub const MSR_IA32_MCG_CTL: u32 = 379;
pub const MSR_ERROR_CONTROL: u32 = 383;
pub const MSR_IA32_MCG_EXT_CTL: u32 = 1232;
pub const MSR_OFFCORE_RSP_0: u32 = 422;
pub const MSR_OFFCORE_RSP_1: u32 = 423;
pub const MSR_TURBO_RATIO_LIMIT: u32 = 429;
pub const MSR_TURBO_RATIO_LIMIT1: u32 = 430;
pub const MSR_TURBO_RATIO_LIMIT2: u32 = 431;
pub const MSR_SNOOP_RSP_0: u32 = 4904;
pub const MSR_SNOOP_RSP_1: u32 = 4905;
pub const MSR_LBR_SELECT: u32 = 456;
pub const MSR_LBR_TOS: u32 = 457;
pub const MSR_IA32_POWER_CTL: u32 = 508;
pub const MSR_IA32_POWER_CTL_BIT_EE: u32 = 19;
pub const MSR_INTEGRITY_CAPS: u32 = 729;
pub const MSR_INTEGRITY_CAPS_ARRAY_BIST_BIT: u32 = 2;
pub const MSR_INTEGRITY_CAPS_PERIODIC_BIST_BIT: u32 = 4;
pub const MSR_LBR_NHM_FROM: u32 = 1664;
pub const MSR_LBR_NHM_TO: u32 = 1728;
pub const MSR_LBR_CORE_FROM: u32 = 64;
pub const MSR_LBR_CORE_TO: u32 = 96;
pub const MSR_LBR_INFO_0: u32 = 3520;
pub const LBR_INFO_CYCLES: u32 = 65535;
pub const LBR_INFO_BR_TYPE_OFFSET: u32 = 56;
pub const LBR_INFO_BR_TYPE: u64 = 1080863910568919040;
pub const LBR_INFO_BR_CNTR_OFFSET: u32 = 32;
pub const LBR_INFO_BR_CNTR_NUM: u32 = 4;
pub const LBR_INFO_BR_CNTR_BITS: u32 = 2;
pub const MSR_ARCH_LBR_CTL: u32 = 5326;
pub const ARCH_LBR_CTL_CPL_OFFSET: u32 = 1;
pub const ARCH_LBR_CTL_CPL: u32 = 6;
pub const ARCH_LBR_CTL_STACK_OFFSET: u32 = 3;
pub const ARCH_LBR_CTL_STACK: u32 = 8;
pub const ARCH_LBR_CTL_FILTER_OFFSET: u32 = 16;
pub const ARCH_LBR_CTL_FILTER: u32 = 8323072;
pub const MSR_ARCH_LBR_DEPTH: u32 = 5327;
pub const MSR_ARCH_LBR_FROM_0: u32 = 5376;
pub const MSR_ARCH_LBR_TO_0: u32 = 5632;
pub const MSR_ARCH_LBR_INFO_0: u32 = 4608;
pub const MSR_IA32_PEBS_ENABLE: u32 = 1009;
pub const MSR_PEBS_DATA_CFG: u32 = 1010;
pub const MSR_IA32_DS_AREA: u32 = 1536;
pub const MSR_IA32_PERF_CAPABILITIES: u32 = 837;
pub const PERF_CAP_METRICS_IDX: u32 = 15;
pub const PERF_CAP_PT_IDX: u32 = 16;
pub const MSR_PEBS_LD_LAT_THRESHOLD: u32 = 1014;
pub const PERF_CAP_PEBS_FORMAT: u32 = 3840;
pub const MSR_IA32_RTIT_CTL: u32 = 1392;
pub const RTIT_CTL_MTC_RANGE_OFFSET: u32 = 14;
pub const RTIT_CTL_MTC_RANGE: u32 = 245760;
pub const RTIT_CTL_CYC_THRESH_OFFSET: u32 = 19;
pub const RTIT_CTL_CYC_THRESH: u32 = 7864320;
pub const RTIT_CTL_PSB_FREQ_OFFSET: u32 = 24;
pub const RTIT_CTL_PSB_FREQ: u32 = 251658240;
pub const RTIT_CTL_ADDR0_OFFSET: u32 = 32;
pub const RTIT_CTL_ADDR0: u64 = 64424509440;
pub const RTIT_CTL_ADDR1_OFFSET: u32 = 36;
pub const RTIT_CTL_ADDR1: u64 = 1030792151040;
pub const RTIT_CTL_ADDR2_OFFSET: u32 = 40;
pub const RTIT_CTL_ADDR2: u64 = 16492674416640;
pub const RTIT_CTL_ADDR3_OFFSET: u32 = 44;
pub const RTIT_CTL_ADDR3: u64 = 263882790666240;
pub const MSR_IA32_RTIT_STATUS: u32 = 1393;
pub const RTIT_STATUS_BYTECNT_OFFSET: u32 = 32;
pub const RTIT_STATUS_BYTECNT: u64 = 562945658454016;
pub const MSR_IA32_RTIT_ADDR0_A: u32 = 1408;
pub const MSR_IA32_RTIT_ADDR0_B: u32 = 1409;
pub const MSR_IA32_RTIT_ADDR1_A: u32 = 1410;
pub const MSR_IA32_RTIT_ADDR1_B: u32 = 1411;
pub const MSR_IA32_RTIT_ADDR2_A: u32 = 1412;
pub const MSR_IA32_RTIT_ADDR2_B: u32 = 1413;
pub const MSR_IA32_RTIT_ADDR3_A: u32 = 1414;
pub const MSR_IA32_RTIT_ADDR3_B: u32 = 1415;
pub const MSR_IA32_RTIT_CR3_MATCH: u32 = 1394;
pub const MSR_IA32_RTIT_OUTPUT_BASE: u32 = 1376;
pub const MSR_IA32_RTIT_OUTPUT_MASK: u32 = 1377;
pub const MSR_MTRRfix64K_00000: u32 = 592;
pub const MSR_MTRRfix16K_80000: u32 = 600;
pub const MSR_MTRRfix16K_A0000: u32 = 601;
pub const MSR_MTRRfix4K_C0000: u32 = 616;
pub const MSR_MTRRfix4K_C8000: u32 = 617;
pub const MSR_MTRRfix4K_D0000: u32 = 618;
pub const MSR_MTRRfix4K_D8000: u32 = 619;
pub const MSR_MTRRfix4K_E0000: u32 = 620;
pub const MSR_MTRRfix4K_E8000: u32 = 621;
pub const MSR_MTRRfix4K_F0000: u32 = 622;
pub const MSR_MTRRfix4K_F8000: u32 = 623;
pub const MSR_MTRRdefType: u32 = 767;
pub const MSR_IA32_CR_PAT: u32 = 631;
pub const MSR_IA32_DEBUGCTLMSR: u32 = 473;
pub const MSR_IA32_LASTBRANCHFROMIP: u32 = 475;
pub const MSR_IA32_LASTBRANCHTOIP: u32 = 476;
pub const MSR_IA32_LASTINTFROMIP: u32 = 477;
pub const MSR_IA32_LASTINTTOIP: u32 = 478;
pub const MSR_IA32_PASID: u32 = 3475;
pub const DEBUGCTLMSR_LBR: u32 = 1;
pub const DEBUGCTLMSR_BTF_SHIFT: u32 = 1;
pub const DEBUGCTLMSR_BTF: u32 = 2;
pub const DEBUGCTLMSR_BUS_LOCK_DETECT: u32 = 4;
pub const DEBUGCTLMSR_TR: u32 = 64;
pub const DEBUGCTLMSR_BTS: u32 = 128;
pub const DEBUGCTLMSR_BTINT: u32 = 256;
pub const DEBUGCTLMSR_BTS_OFF_OS: u32 = 512;
pub const DEBUGCTLMSR_BTS_OFF_USR: u32 = 1024;
pub const DEBUGCTLMSR_FREEZE_LBRS_ON_PMI: u32 = 2048;
pub const DEBUGCTLMSR_FREEZE_PERFMON_ON_PMI: u32 = 4096;
pub const DEBUGCTLMSR_FREEZE_IN_SMM_BIT: u32 = 14;
pub const DEBUGCTLMSR_FREEZE_IN_SMM: u32 = 16384;
pub const MSR_PEBS_FRONTEND: u32 = 1015;
pub const MSR_IA32_MC0_CTL: u32 = 1024;
pub const MSR_IA32_MC0_STATUS: u32 = 1025;
pub const MSR_IA32_MC0_ADDR: u32 = 1026;
pub const MSR_IA32_MC0_MISC: u32 = 1027;
pub const MSR_PKG_C3_RESIDENCY: u32 = 1016;
pub const MSR_PKG_C6_RESIDENCY: u32 = 1017;
pub const MSR_ATOM_PKG_C6_RESIDENCY: u32 = 1018;
pub const MSR_PKG_C7_RESIDENCY: u32 = 1018;
pub const MSR_CORE_C3_RESIDENCY: u32 = 1020;
pub const MSR_CORE_C6_RESIDENCY: u32 = 1021;
pub const MSR_CORE_C7_RESIDENCY: u32 = 1022;
pub const MSR_KNL_CORE_C6_RESIDENCY: u32 = 1023;
pub const MSR_PKG_C2_RESIDENCY: u32 = 1549;
pub const MSR_PKG_C8_RESIDENCY: u32 = 1584;
pub const MSR_PKG_C9_RESIDENCY: u32 = 1585;
pub const MSR_PKG_C10_RESIDENCY: u32 = 1586;
pub const MSR_PKGC3_IRTL: u32 = 1546;
pub const MSR_PKGC6_IRTL: u32 = 1547;
pub const MSR_PKGC7_IRTL: u32 = 1548;
pub const MSR_PKGC8_IRTL: u32 = 1587;
pub const MSR_PKGC9_IRTL: u32 = 1588;
pub const MSR_PKGC10_IRTL: u32 = 1589;
pub const MSR_VR_CURRENT_CONFIG: u32 = 1537;
pub const MSR_RAPL_POWER_UNIT: u32 = 1542;
pub const MSR_PKG_POWER_LIMIT: u32 = 1552;
pub const MSR_PKG_ENERGY_STATUS: u32 = 1553;
pub const MSR_PKG_PERF_STATUS: u32 = 1555;
pub const MSR_PKG_POWER_INFO: u32 = 1556;
pub const MSR_DRAM_POWER_LIMIT: u32 = 1560;
pub const MSR_DRAM_ENERGY_STATUS: u32 = 1561;
pub const MSR_DRAM_PERF_STATUS: u32 = 1563;
pub const MSR_DRAM_POWER_INFO: u32 = 1564;
pub const MSR_PP0_POWER_LIMIT: u32 = 1592;
pub const MSR_PP0_ENERGY_STATUS: u32 = 1593;
pub const MSR_PP0_POLICY: u32 = 1594;
pub const MSR_PP0_PERF_STATUS: u32 = 1595;
pub const MSR_PP1_POWER_LIMIT: u32 = 1600;
pub const MSR_PP1_ENERGY_STATUS: u32 = 1601;
pub const MSR_PP1_POLICY: u32 = 1602;
pub const MSR_AMD_RAPL_POWER_UNIT: u32 = 3221291673;
pub const MSR_AMD_CORE_ENERGY_STATUS: u32 = 3221291674;
pub const MSR_AMD_PKG_ENERGY_STATUS: u32 = 3221291675;
pub const MSR_CONFIG_TDP_NOMINAL: u32 = 1608;
pub const MSR_CONFIG_TDP_LEVEL_1: u32 = 1609;
pub const MSR_CONFIG_TDP_LEVEL_2: u32 = 1610;
pub const MSR_CONFIG_TDP_CONTROL: u32 = 1611;
pub const MSR_TURBO_ACTIVATION_RATIO: u32 = 1612;
pub const MSR_PLATFORM_ENERGY_STATUS: u32 = 1613;
pub const MSR_SECONDARY_TURBO_RATIO_LIMIT: u32 = 1616;
pub const MSR_PKG_WEIGHTED_CORE_C0_RES: u32 = 1624;
pub const MSR_PKG_ANY_CORE_C0_RES: u32 = 1625;
pub const MSR_PKG_ANY_GFXE_C0_RES: u32 = 1626;
pub const MSR_PKG_BOTH_CORE_GFXE_C0_RES: u32 = 1627;
pub const MSR_CORE_C1_RES: u32 = 1632;
pub const MSR_MODULE_C6_RES_MS: u32 = 1636;
pub const MSR_CC6_DEMOTION_POLICY_CONFIG: u32 = 1640;
pub const MSR_MC6_DEMOTION_POLICY_CONFIG: u32 = 1641;
pub const MSR_ATOM_CORE_RATIOS: u32 = 1642;
pub const MSR_ATOM_CORE_VIDS: u32 = 1643;
pub const MSR_ATOM_CORE_TURBO_RATIOS: u32 = 1644;
pub const MSR_ATOM_CORE_TURBO_VIDS: u32 = 1645;
pub const MSR_CORE_PERF_LIMIT_REASONS: u32 = 1680;
pub const MSR_GFX_PERF_LIMIT_REASONS: u32 = 1712;
pub const MSR_RING_PERF_LIMIT_REASONS: u32 = 1713;
pub const MSR_IA32_U_CET: u32 = 1696;
pub const MSR_IA32_S_CET: u32 = 1698;
pub const MSR_IA32_PL0_SSP: u32 = 1700;
pub const MSR_IA32_PL1_SSP: u32 = 1701;
pub const MSR_IA32_PL2_SSP: u32 = 1702;
pub const MSR_IA32_PL3_SSP: u32 = 1703;
pub const MSR_IA32_INT_SSP_TAB: u32 = 1704;
pub const MSR_PPERF: u32 = 1614;
pub const MSR_PERF_LIMIT_REASONS: u32 = 1615;
pub const MSR_PM_ENABLE: u32 = 1904;
pub const MSR_HWP_CAPABILITIES: u32 = 1905;
pub const MSR_HWP_REQUEST_PKG: u32 = 1906;
pub const MSR_HWP_INTERRUPT: u32 = 1907;
pub const MSR_HWP_REQUEST: u32 = 1908;
pub const MSR_HWP_STATUS: u32 = 1911;
pub const HWP_BASE_BIT: u32 = 128;
pub const HWP_NOTIFICATIONS_BIT: u32 = 256;
pub const HWP_ACTIVITY_WINDOW_BIT: u32 = 512;
pub const HWP_ENERGY_PERF_PREFERENCE_BIT: u32 = 1024;
pub const HWP_PACKAGE_LEVEL_REQUEST_BIT: u32 = 2048;
pub const HWP_EPP_PERFORMANCE: u32 = 0;
pub const HWP_EPP_BALANCE_PERFORMANCE: u32 = 128;
pub const HWP_EPP_BALANCE_POWERSAVE: u32 = 192;
pub const HWP_EPP_POWERSAVE: u32 = 255;
pub const MSR_AMD64_MC0_MASK: u32 = 3221291076;
pub const MSR_IA32_MC0_CTL2: u32 = 640;
pub const MSR_P6_PERFCTR0: u32 = 193;
pub const MSR_P6_PERFCTR1: u32 = 194;
pub const MSR_P6_EVNTSEL0: u32 = 390;
pub const MSR_P6_EVNTSEL1: u32 = 391;
pub const MSR_KNC_PERFCTR0: u32 = 32;
pub const MSR_KNC_PERFCTR1: u32 = 33;
pub const MSR_KNC_EVNTSEL0: u32 = 40;
pub const MSR_KNC_EVNTSEL1: u32 = 41;
pub const MSR_IA32_PMC0: u32 = 1217;
pub const MSR_RELOAD_PMC0: u32 = 5313;
pub const MSR_RELOAD_FIXED_CTR0: u32 = 4873;
pub const MSR_IA32_MKTME_KEYID_PARTITIONING: u32 = 135;
pub const MSR_AMD64_PATCH_LEVEL: u32 = 139;
pub const MSR_AMD64_TSC_RATIO: u32 = 3221225732;
pub const MSR_AMD64_NB_CFG: u32 = 3221291039;
pub const MSR_AMD64_PATCH_LOADER: u32 = 3221291040;
pub const MSR_AMD_PERF_CTL: u32 = 3221291106;
pub const MSR_AMD_PERF_STATUS: u32 = 3221291107;
pub const MSR_AMD_PSTATE_DEF_BASE: u32 = 3221291108;
pub const MSR_AMD64_OSVW_ID_LENGTH: u32 = 3221291328;
pub const MSR_AMD64_OSVW_STATUS: u32 = 3221291329;
pub const MSR_AMD_PPIN_CTL: u32 = 3221291760;
pub const MSR_AMD_PPIN: u32 = 3221291761;
pub const MSR_AMD64_CPUID_FN_1: u32 = 3221295108;
pub const MSR_AMD64_LS_CFG: u32 = 3221295136;
pub const MSR_AMD64_DC_CFG: u32 = 3221295138;
pub const MSR_AMD64_TW_CFG: u32 = 3221295139;
pub const MSR_AMD64_DE_CFG: u32 = 3221295145;
pub const MSR_AMD64_DE_CFG_LFENCE_SERIALIZE_BIT: u32 = 1;
pub const MSR_AMD64_DE_CFG_ZEN2_FP_BACKUP_FIX_BIT: u32 = 9;
pub const MSR_AMD64_BU_CFG2: u32 = 3221295146;
pub const MSR_AMD64_IBSFETCHCTL: u32 = 3221295152;
pub const MSR_AMD64_IBSFETCHLINAD: u32 = 3221295153;
pub const MSR_AMD64_IBSFETCHPHYSAD: u32 = 3221295154;
pub const MSR_AMD64_IBSFETCH_REG_COUNT: u32 = 3;
pub const MSR_AMD64_IBSFETCH_REG_MASK: u32 = 7;
pub const MSR_AMD64_IBSOPCTL: u32 = 3221295155;
pub const MSR_AMD64_IBSOPRIP: u32 = 3221295156;
pub const MSR_AMD64_IBSOPDATA: u32 = 3221295157;
pub const MSR_AMD64_IBSOPDATA2: u32 = 3221295158;
pub const MSR_AMD64_IBSOPDATA3: u32 = 3221295159;
pub const MSR_AMD64_IBSDCLINAD: u32 = 3221295160;
pub const MSR_AMD64_IBSDCPHYSAD: u32 = 3221295161;
pub const MSR_AMD64_IBSOP_REG_COUNT: u32 = 7;
pub const MSR_AMD64_IBSOP_REG_MASK: u32 = 127;
pub const MSR_AMD64_IBSCTL: u32 = 3221295162;
pub const MSR_AMD64_IBSBRTARGET: u32 = 3221295163;
pub const MSR_AMD64_ICIBSEXTDCTL: u32 = 3221295164;
pub const MSR_AMD64_IBSOPDATA4: u32 = 3221295165;
pub const MSR_AMD64_IBS_REG_COUNT_MAX: u32 = 8;
pub const MSR_AMD64_SVM_AVIC_DOORBELL: u32 = 3221291291;
pub const MSR_AMD64_VM_PAGE_FLUSH: u32 = 3221291294;
pub const MSR_AMD64_SEV_ES_GHCB: u32 = 3221291312;
pub const MSR_AMD64_SEV: u32 = 3221291313;
pub const MSR_AMD64_SEV_ENABLED_BIT: u32 = 0;
pub const MSR_AMD64_SEV_ES_ENABLED_BIT: u32 = 1;
pub const MSR_AMD64_SEV_SNP_ENABLED_BIT: u32 = 2;
pub const MSR_AMD64_VIRT_SPEC_CTRL: u32 = 3221291295;
pub const MSR_AMD_CPPC_CAP1: u32 = 3221291696;
pub const MSR_AMD_CPPC_ENABLE: u32 = 3221291697;
pub const MSR_AMD_CPPC_CAP2: u32 = 3221291698;
pub const MSR_AMD_CPPC_REQ: u32 = 3221291699;
pub const MSR_AMD_CPPC_STATUS: u32 = 3221291700;
pub const MSR_AMD64_PERF_CNTR_GLOBAL_STATUS: u32 = 3221226240;
pub const MSR_AMD64_PERF_CNTR_GLOBAL_CTL: u32 = 3221226241;
pub const MSR_AMD64_PERF_CNTR_GLOBAL_STATUS_CLR: u32 = 3221226242;
pub const MSR_AMD64_LBR_SELECT: u32 = 3221225742;
pub const MSR_ZEN4_BP_CFG: u32 = 3221295150;
pub const MSR_ZEN4_BP_CFG_SHARED_BTB_FIX_BIT: u32 = 5;
pub const MSR_F19H_UMC_PERF_CTL: u32 = 3221293056;
pub const MSR_F19H_UMC_PERF_CTR: u32 = 3221293057;
pub const MSR_ZEN2_SPECTRAL_CHICKEN: u32 = 3221295331;
pub const MSR_F17H_IRPERF: u32 = 3221225705;
pub const MSR_F16H_L2I_PERF_CTL: u32 = 3221291568;
pub const MSR_F16H_L2I_PERF_CTR: u32 = 3221291569;
pub const MSR_F16H_DR1_ADDR_MASK: u32 = 3221295129;
pub const MSR_F16H_DR2_ADDR_MASK: u32 = 3221295130;
pub const MSR_F16H_DR3_ADDR_MASK: u32 = 3221295131;
pub const MSR_F16H_DR0_ADDR_MASK: u32 = 3221295143;
pub const MSR_F15H_CU_PWR_ACCUMULATOR: u32 = 3221291130;
pub const MSR_F15H_CU_MAX_PWR_ACCUMULATOR: u32 = 3221291131;
pub const MSR_F15H_PERF_CTL: u32 = 3221291520;
pub const MSR_F15H_PERF_CTL0: u32 = 3221291520;
pub const MSR_F15H_PERF_CTL1: u32 = 3221291522;
pub const MSR_F15H_PERF_CTL2: u32 = 3221291524;
pub const MSR_F15H_PERF_CTL3: u32 = 3221291526;
pub const MSR_F15H_PERF_CTL4: u32 = 3221291528;
pub const MSR_F15H_PERF_CTL5: u32 = 3221291530;
pub const MSR_F15H_PERF_CTR: u32 = 3221291521;
pub const MSR_F15H_PERF_CTR0: u32 = 3221291521;
pub const MSR_F15H_PERF_CTR1: u32 = 3221291523;
pub const MSR_F15H_PERF_CTR2: u32 = 3221291525;
pub const MSR_F15H_PERF_CTR3: u32 = 3221291527;
pub const MSR_F15H_PERF_CTR4: u32 = 3221291529;
pub const MSR_F15H_PERF_CTR5: u32 = 3221291531;
pub const MSR_F15H_NB_PERF_CTL: u32 = 3221291584;
pub const MSR_F15H_NB_PERF_CTR: u32 = 3221291585;
pub const MSR_F15H_PTSC: u32 = 3221291648;
pub const MSR_F15H_IC_CFG: u32 = 3221295137;
pub const MSR_F15H_EX_CFG: u32 = 3221295148;
pub const MSR_FAM10H_MMIO_CONF_BASE: u32 = 3221291096;
pub const FAM10H_MMIO_CONF_ENABLE: u32 = 1;
pub const FAM10H_MMIO_CONF_BUSRANGE_MASK: u32 = 15;
pub const FAM10H_MMIO_CONF_BUSRANGE_SHIFT: u32 = 2;
pub const FAM10H_MMIO_CONF_BASE_MASK: u32 = 268435455;
pub const FAM10H_MMIO_CONF_BASE_SHIFT: u32 = 20;
pub const MSR_FAM10H_NODE_ID: u32 = 3221295116;
pub const MSR_K8_TOP_MEM1: u32 = 3221291034;
pub const MSR_K8_TOP_MEM2: u32 = 3221291037;
pub const MSR_AMD64_SYSCFG: u32 = 3221291024;
pub const MSR_AMD64_SYSCFG_MEM_ENCRYPT_BIT: u32 = 23;
pub const MSR_K8_INT_PENDING_MSG: u32 = 3221291093;
pub const K8_INTP_C1E_ACTIVE_MASK: u32 = 402653184;
pub const MSR_K8_TSEG_ADDR: u32 = 3221291282;
pub const MSR_K8_TSEG_MASK: u32 = 3221291283;
pub const K8_MTRRFIXRANGE_DRAM_ENABLE: u32 = 262144;
pub const K8_MTRRFIXRANGE_DRAM_MODIFY: u32 = 524288;
pub const K8_MTRR_RDMEM_WRMEM_MASK: u32 = 404232216;
pub const MSR_K7_EVNTSEL0: u32 = 3221291008;
pub const MSR_K7_PERFCTR0: u32 = 3221291012;
pub const MSR_K7_EVNTSEL1: u32 = 3221291009;
pub const MSR_K7_PERFCTR1: u32 = 3221291013;
pub const MSR_K7_EVNTSEL2: u32 = 3221291010;
pub const MSR_K7_PERFCTR2: u32 = 3221291014;
pub const MSR_K7_EVNTSEL3: u32 = 3221291011;
pub const MSR_K7_PERFCTR3: u32 = 3221291015;
pub const MSR_K7_CLK_CTL: u32 = 3221291035;
pub const MSR_K7_HWCR: u32 = 3221291029;
pub const MSR_K7_HWCR_SMMLOCK_BIT: u32 = 0;
pub const MSR_K7_HWCR_IRPERF_EN_BIT: u32 = 30;
pub const MSR_K7_FID_VID_CTL: u32 = 3221291073;
pub const MSR_K7_FID_VID_STATUS: u32 = 3221291074;
pub const MSR_K6_WHCR: u32 = 3221225602;
pub const MSR_K6_UWCCR: u32 = 3221225605;
pub const MSR_K6_EPMR: u32 = 3221225606;
pub const MSR_K6_PSOR: u32 = 3221225607;
pub const MSR_K6_PFIR: u32 = 3221225608;
pub const MSR_IDT_FCR1: u32 = 263;
pub const MSR_IDT_FCR2: u32 = 264;
pub const MSR_IDT_FCR3: u32 = 265;
pub const MSR_IDT_FCR4: u32 = 266;
pub const MSR_IDT_MCR0: u32 = 272;
pub const MSR_IDT_MCR1: u32 = 273;
pub const MSR_IDT_MCR2: u32 = 274;
pub const MSR_IDT_MCR3: u32 = 275;
pub const MSR_IDT_MCR4: u32 = 276;
pub const MSR_IDT_MCR5: u32 = 277;
pub const MSR_IDT_MCR6: u32 = 278;
pub const MSR_IDT_MCR7: u32 = 279;
pub const MSR_IDT_MCR_CTRL: u32 = 288;
pub const MSR_VIA_FCR: u32 = 4359;
pub const MSR_VIA_LONGHAUL: u32 = 4362;
pub const MSR_VIA_RNG: u32 = 4363;
pub const MSR_VIA_BCR2: u32 = 4423;
pub const MSR_TMTA_LONGRUN_CTRL: u32 = 2156298256;
pub const MSR_TMTA_LONGRUN_FLAGS: u32 = 2156298257;
pub const MSR_TMTA_LRTI_READOUT: u32 = 2156298264;
pub const MSR_TMTA_LRTI_VOLT_MHZ: u32 = 2156298266;
pub const MSR_IA32_P5_MC_ADDR: u32 = 0;
pub const MSR_IA32_P5_MC_TYPE: u32 = 1;
pub const MSR_IA32_TSC: u32 = 16;
pub const MSR_IA32_PLATFORM_ID: u32 = 23;
pub const MSR_IA32_EBL_CR_POWERON: u32 = 42;
pub const MSR_EBC_FREQUENCY_ID: u32 = 44;
pub const MSR_SMI_COUNT: u32 = 52;
pub const MSR_IA32_FEAT_CTL: u32 = 58;
pub const MSR_IA32_TSC_ADJUST: u32 = 59;
pub const MSR_IA32_BNDCFGS: u32 = 3472;
pub const MSR_IA32_BNDCFGS_RSVD: u32 = 4092;
pub const MSR_IA32_XFD: u32 = 452;
pub const MSR_IA32_XFD_ERR: u32 = 453;
pub const MSR_IA32_XSS: u32 = 3488;
pub const MSR_IA32_APICBASE: u32 = 27;
pub const MSR_IA32_APICBASE_BSP: u32 = 256;
pub const MSR_IA32_APICBASE_ENABLE: u32 = 2048;
pub const MSR_IA32_APICBASE_BASE: u32 = 4294963200;
pub const MSR_IA32_UCODE_WRITE: u32 = 121;
pub const MSR_IA32_UCODE_REV: u32 = 139;
pub const MSR_IA32_SGXLEPUBKEYHASH0: u32 = 140;
pub const MSR_IA32_SGXLEPUBKEYHASH1: u32 = 141;
pub const MSR_IA32_SGXLEPUBKEYHASH2: u32 = 142;
pub const MSR_IA32_SGXLEPUBKEYHASH3: u32 = 143;
pub const MSR_IA32_SMM_MONITOR_CTL: u32 = 155;
pub const MSR_IA32_SMBASE: u32 = 158;
pub const MSR_IA32_PERF_STATUS: u32 = 408;
pub const MSR_IA32_PERF_CTL: u32 = 409;
pub const INTEL_PERF_CTL_MASK: u32 = 65535;
pub const MSR_AMD_DBG_EXTN_CFG: u32 = 3221225743;
pub const MSR_AMD_SAMP_BR_FROM: u32 = 3221291776;
pub const MSR_IA32_MPERF: u32 = 231;
pub const MSR_IA32_APERF: u32 = 232;
pub const MSR_IA32_THERM_CONTROL: u32 = 410;
pub const MSR_IA32_THERM_INTERRUPT: u32 = 411;
pub const THERM_INT_HIGH_ENABLE: u32 = 1;
pub const THERM_INT_LOW_ENABLE: u32 = 2;
pub const THERM_INT_PLN_ENABLE: u32 = 16777216;
pub const MSR_IA32_THERM_STATUS: u32 = 412;
pub const THERM_STATUS_PROCHOT: u32 = 1;
pub const THERM_STATUS_POWER_LIMIT: u32 = 1024;
pub const MSR_THERM2_CTL: u32 = 413;
pub const MSR_THERM2_CTL_TM_SELECT: u32 = 65536;
pub const MSR_IA32_MISC_ENABLE: u32 = 416;
pub const MSR_IA32_TEMPERATURE_TARGET: u32 = 418;
pub const MSR_MISC_FEATURE_CONTROL: u32 = 420;
pub const MSR_MISC_PWR_MGMT: u32 = 426;
pub const MSR_IA32_ENERGY_PERF_BIAS: u32 = 432;
pub const ENERGY_PERF_BIAS_PERFORMANCE: u32 = 0;
pub const ENERGY_PERF_BIAS_BALANCE_PERFORMANCE: u32 = 4;
pub const ENERGY_PERF_BIAS_NORMAL: u32 = 6;
pub const ENERGY_PERF_BIAS_NORMAL_POWERSAVE: u32 = 7;
pub const ENERGY_PERF_BIAS_BALANCE_POWERSAVE: u32 = 8;
pub const ENERGY_PERF_BIAS_POWERSAVE: u32 = 15;
pub const MSR_IA32_PACKAGE_THERM_STATUS: u32 = 433;
pub const PACKAGE_THERM_STATUS_PROCHOT: u32 = 1;
pub const PACKAGE_THERM_STATUS_POWER_LIMIT: u32 = 1024;
pub const PACKAGE_THERM_STATUS_HFI_UPDATED: u32 = 67108864;
pub const MSR_IA32_PACKAGE_THERM_INTERRUPT: u32 = 434;
pub const PACKAGE_THERM_INT_HIGH_ENABLE: u32 = 1;
pub const PACKAGE_THERM_INT_LOW_ENABLE: u32 = 2;
pub const PACKAGE_THERM_INT_PLN_ENABLE: u32 = 16777216;
pub const PACKAGE_THERM_INT_HFI_ENABLE: u32 = 33554432;
pub const THERM_INT_THRESHOLD0_ENABLE: u32 = 32768;
pub const THERM_SHIFT_THRESHOLD0: u32 = 8;
pub const THERM_MASK_THRESHOLD0: u32 = 32512;
pub const THERM_INT_THRESHOLD1_ENABLE: u32 = 8388608;
pub const THERM_SHIFT_THRESHOLD1: u32 = 16;
pub const THERM_MASK_THRESHOLD1: u32 = 8323072;
pub const THERM_STATUS_THRESHOLD0: u32 = 64;
pub const THERM_LOG_THRESHOLD0: u32 = 128;
pub const THERM_STATUS_THRESHOLD1: u32 = 256;
pub const THERM_LOG_THRESHOLD1: u32 = 512;
pub const MSR_IA32_MISC_ENABLE_FAST_STRING_BIT: u32 = 0;
pub const MSR_IA32_MISC_ENABLE_FAST_STRING: u32 = 1;
pub const MSR_IA32_MISC_ENABLE_TCC_BIT: u32 = 1;
pub const MSR_IA32_MISC_ENABLE_TCC: u32 = 2;
pub const MSR_IA32_MISC_ENABLE_EMON_BIT: u32 = 7;
pub const MSR_IA32_MISC_ENABLE_EMON: u32 = 128;
pub const MSR_IA32_MISC_ENABLE_BTS_UNAVAIL_BIT: u32 = 11;
pub const MSR_IA32_MISC_ENABLE_BTS_UNAVAIL: u32 = 2048;
pub const MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL_BIT: u32 = 12;
pub const MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL: u32 = 4096;
pub const MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP_BIT: u32 = 16;
pub const MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP: u32 = 65536;
pub const MSR_IA32_MISC_ENABLE_MWAIT_BIT: u32 = 18;
pub const MSR_IA32_MISC_ENABLE_MWAIT: u32 = 262144;
pub const MSR_IA32_MISC_ENABLE_LIMIT_CPUID_BIT: u32 = 22;
pub const MSR_IA32_MISC_ENABLE_LIMIT_CPUID: u32 = 4194304;
pub const MSR_IA32_MISC_ENABLE_XTPR_DISABLE_BIT: u32 = 23;
pub const MSR_IA32_MISC_ENABLE_XTPR_DISABLE: u32 = 8388608;
pub const MSR_IA32_MISC_ENABLE_XD_DISABLE_BIT: u32 = 34;
pub const MSR_IA32_MISC_ENABLE_XD_DISABLE: u64 = 17179869184;
pub const MSR_IA32_MISC_ENABLE_X87_COMPAT_BIT: u32 = 2;
pub const MSR_IA32_MISC_ENABLE_X87_COMPAT: u32 = 4;
pub const MSR_IA32_MISC_ENABLE_TM1_BIT: u32 = 3;
pub const MSR_IA32_MISC_ENABLE_TM1: u32 = 8;
pub const MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE_BIT: u32 = 4;
pub const MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE: u32 = 16;
pub const MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE_BIT: u32 = 6;
pub const MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE: u32 = 64;
pub const MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK_BIT: u32 = 8;
pub const MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK: u32 = 256;
pub const MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE_BIT: u32 = 9;
pub const MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE: u32 = 512;
pub const MSR_IA32_MISC_ENABLE_FERR_BIT: u32 = 10;
pub const MSR_IA32_MISC_ENABLE_FERR: u32 = 1024;
pub const MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX_BIT: u32 = 10;
pub const MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX: u32 = 1024;
pub const MSR_IA32_MISC_ENABLE_TM2_BIT: u32 = 13;
pub const MSR_IA32_MISC_ENABLE_TM2: u32 = 8192;
pub const MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE_BIT: u32 = 19;
pub const MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE: u32 = 524288;
pub const MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK_BIT: u32 = 20;
pub const MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK: u32 = 1048576;
pub const MSR_IA32_MISC_ENABLE_L1D_CONTEXT_BIT: u32 = 24;
pub const MSR_IA32_MISC_ENABLE_L1D_CONTEXT: u32 = 16777216;
pub const MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE_BIT: u32 = 37;
pub const MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE: u64 = 137438953472;
pub const MSR_IA32_MISC_ENABLE_TURBO_DISABLE_BIT: u32 = 38;
pub const MSR_IA32_MISC_ENABLE_TURBO_DISABLE: u64 = 274877906944;
pub const MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE_BIT: u32 = 39;
pub const MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE: u64 = 549755813888;
pub const MSR_MISC_FEATURES_ENABLES: u32 = 320;
pub const MSR_MISC_FEATURES_ENABLES_CPUID_FAULT_BIT: u32 = 0;
pub const MSR_MISC_FEATURES_ENABLES_RING3MWAIT_BIT: u32 = 1;
pub const MSR_IA32_TSC_DEADLINE: u32 = 1760;
pub const MSR_TSX_FORCE_ABORT: u32 = 271;
pub const MSR_TFA_RTM_FORCE_ABORT_BIT: u32 = 0;
pub const MSR_TFA_TSX_CPUID_CLEAR_BIT: u32 = 1;
pub const MSR_TFA_SDV_ENABLE_RTM_BIT: u32 = 2;
pub const MSR_IA32_MCG_EAX: u32 = 384;
pub const MSR_IA32_MCG_EBX: u32 = 385;
pub const MSR_IA32_MCG_ECX: u32 = 386;
pub const MSR_IA32_MCG_EDX: u32 = 387;
pub const MSR_IA32_MCG_ESI: u32 = 388;
pub const MSR_IA32_MCG_EDI: u32 = 389;
pub const MSR_IA32_MCG_EBP: u32 = 390;
pub const MSR_IA32_MCG_ESP: u32 = 391;
pub const MSR_IA32_MCG_EFLAGS: u32 = 392;
pub const MSR_IA32_MCG_EIP: u32 = 393;
pub const MSR_IA32_MCG_RESERVED: u32 = 394;
pub const MSR_P4_BPU_PERFCTR0: u32 = 768;
pub const MSR_P4_BPU_PERFCTR1: u32 = 769;
pub const MSR_P4_BPU_PERFCTR2: u32 = 770;
pub const MSR_P4_BPU_PERFCTR3: u32 = 771;
pub const MSR_P4_MS_PERFCTR0: u32 = 772;
pub const MSR_P4_MS_PERFCTR1: u32 = 773;
pub const MSR_P4_MS_PERFCTR2: u32 = 774;
pub const MSR_P4_MS_PERFCTR3: u32 = 775;
pub const MSR_P4_FLAME_PERFCTR0: u32 = 776;
pub const MSR_P4_FLAME_PERFCTR1: u32 = 777;
pub const MSR_P4_FLAME_PERFCTR2: u32 = 778;
pub const MSR_P4_FLAME_PERFCTR3: u32 = 779;
pub const MSR_P4_IQ_PERFCTR0: u32 = 780;
pub const MSR_P4_IQ_PERFCTR1: u32 = 781;
pub const MSR_P4_IQ_PERFCTR2: u32 = 782;
pub const MSR_P4_IQ_PERFCTR3: u32 = 783;
pub const MSR_P4_IQ_PERFCTR4: u32 = 784;
pub const MSR_P4_IQ_PERFCTR5: u32 = 785;
pub const MSR_P4_BPU_CCCR0: u32 = 864;
pub const MSR_P4_BPU_CCCR1: u32 = 865;
pub const MSR_P4_BPU_CCCR2: u32 = 866;
pub const MSR_P4_BPU_CCCR3: u32 = 867;
pub const MSR_P4_MS_CCCR0: u32 = 868;
pub const MSR_P4_MS_CCCR1: u32 = 869;
pub const MSR_P4_MS_CCCR2: u32 = 870;
pub const MSR_P4_MS_CCCR3: u32 = 871;
pub const MSR_P4_FLAME_CCCR0: u32 = 872;
pub const MSR_P4_FLAME_CCCR1: u32 = 873;
pub const MSR_P4_FLAME_CCCR2: u32 = 874;
pub const MSR_P4_FLAME_CCCR3: u32 = 875;
pub const MSR_P4_IQ_CCCR0: u32 = 876;
pub const MSR_P4_IQ_CCCR1: u32 = 877;
pub const MSR_P4_IQ_CCCR2: u32 = 878;
pub const MSR_P4_IQ_CCCR3: u32 = 879;
pub const MSR_P4_IQ_CCCR4: u32 = 880;
pub const MSR_P4_IQ_CCCR5: u32 = 881;
pub const MSR_P4_ALF_ESCR0: u32 = 970;
pub const MSR_P4_ALF_ESCR1: u32 = 971;
pub const MSR_P4_BPU_ESCR0: u32 = 946;
pub const MSR_P4_BPU_ESCR1: u32 = 947;
pub const MSR_P4_BSU_ESCR0: u32 = 928;
pub const MSR_P4_BSU_ESCR1: u32 = 929;
pub const MSR_P4_CRU_ESCR0: u32 = 952;
pub const MSR_P4_CRU_ESCR1: u32 = 953;
pub const MSR_P4_CRU_ESCR2: u32 = 972;
pub const MSR_P4_CRU_ESCR3: u32 = 973;
pub const MSR_P4_CRU_ESCR4: u32 = 992;
pub const MSR_P4_CRU_ESCR5: u32 = 993;
pub const MSR_P4_DAC_ESCR0: u32 = 936;
pub const MSR_P4_DAC_ESCR1: u32 = 937;
pub const MSR_P4_FIRM_ESCR0: u32 = 932;
pub const MSR_P4_FIRM_ESCR1: u32 = 933;
pub const MSR_P4_FLAME_ESCR0: u32 = 934;
pub const MSR_P4_FLAME_ESCR1: u32 = 935;
pub const MSR_P4_FSB_ESCR0: u32 = 930;
pub const MSR_P4_FSB_ESCR1: u32 = 931;
pub const MSR_P4_IQ_ESCR0: u32 = 954;
pub const MSR_P4_IQ_ESCR1: u32 = 955;
pub const MSR_P4_IS_ESCR0: u32 = 948;
pub const MSR_P4_IS_ESCR1: u32 = 949;
pub const MSR_P4_ITLB_ESCR0: u32 = 950;
pub const MSR_P4_ITLB_ESCR1: u32 = 951;
pub const MSR_P4_IX_ESCR0: u32 = 968;
pub const MSR_P4_IX_ESCR1: u32 = 969;
pub const MSR_P4_MOB_ESCR0: u32 = 938;
pub const MSR_P4_MOB_ESCR1: u32 = 939;
pub const MSR_P4_MS_ESCR0: u32 = 960;
pub const MSR_P4_MS_ESCR1: u32 = 961;
pub const MSR_P4_PMH_ESCR0: u32 = 940;
pub const MSR_P4_PMH_ESCR1: u32 = 941;
pub const MSR_P4_RAT_ESCR0: u32 = 956;
pub const MSR_P4_RAT_ESCR1: u32 = 957;
pub const MSR_P4_SAAT_ESCR0: u32 = 942;
pub const MSR_P4_SAAT_ESCR1: u32 = 943;
pub const MSR_P4_SSU_ESCR0: u32 = 958;
pub const MSR_P4_SSU_ESCR1: u32 = 959;
pub const MSR_P4_TBPU_ESCR0: u32 = 962;
pub const MSR_P4_TBPU_ESCR1: u32 = 963;
pub const MSR_P4_TC_ESCR0: u32 = 964;
pub const MSR_P4_TC_ESCR1: u32 = 965;
pub const MSR_P4_U2L_ESCR0: u32 = 944;
pub const MSR_P4_U2L_ESCR1: u32 = 945;
pub const MSR_P4_PEBS_MATRIX_VERT: u32 = 1010;
pub const MSR_CORE_PERF_FIXED_CTR0: u32 = 777;
pub const MSR_CORE_PERF_FIXED_CTR1: u32 = 778;
pub const MSR_CORE_PERF_FIXED_CTR2: u32 = 779;
pub const MSR_CORE_PERF_FIXED_CTR3: u32 = 780;
pub const MSR_CORE_PERF_FIXED_CTR_CTRL: u32 = 909;
pub const MSR_CORE_PERF_GLOBAL_STATUS: u32 = 910;
pub const MSR_CORE_PERF_GLOBAL_CTRL: u32 = 911;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL: u32 = 912;
pub const MSR_PERF_METRICS: u32 = 809;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_TRACE_TOPA_PMI_BIT: u32 = 55;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_TRACE_TOPA_PMI: u64 = 36028797018963968;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_OVF_BUF_BIT: u32 = 62;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_OVF_BUF: u64 = 4611686018427387904;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_COND_CHGD_BIT: u32 = 63;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_COND_CHGD: i64 = -9223372036854775808;
pub const MSR_GEODE_BUSCONT_CONF0: u32 = 6400;
pub const MSR_IA32_VMX_BASIC: u32 = 1152;
pub const MSR_IA32_VMX_PINBASED_CTLS: u32 = 1153;
pub const MSR_IA32_VMX_PROCBASED_CTLS: u32 = 1154;
pub const MSR_IA32_VMX_EXIT_CTLS: u32 = 1155;
pub const MSR_IA32_VMX_ENTRY_CTLS: u32 = 1156;
pub const MSR_IA32_VMX_MISC: u32 = 1157;
pub const MSR_IA32_VMX_CR0_FIXED0: u32 = 1158;
pub const MSR_IA32_VMX_CR0_FIXED1: u32 = 1159;
pub const MSR_IA32_VMX_CR4_FIXED0: u32 = 1160;
pub const MSR_IA32_VMX_CR4_FIXED1: u32 = 1161;
pub const MSR_IA32_VMX_VMCS_ENUM: u32 = 1162;
pub const MSR_IA32_VMX_PROCBASED_CTLS2: u32 = 1163;
pub const MSR_IA32_VMX_EPT_VPID_CAP: u32 = 1164;
pub const MSR_IA32_VMX_TRUE_PINBASED_CTLS: u32 = 1165;
pub const MSR_IA32_VMX_TRUE_PROCBASED_CTLS: u32 = 1166;
pub const MSR_IA32_VMX_TRUE_EXIT_CTLS: u32 = 1167;
pub const MSR_IA32_VMX_TRUE_ENTRY_CTLS: u32 = 1168;
pub const MSR_IA32_VMX_VMFUNC: u32 = 1169;
pub const MSR_IA32_VMX_PROCBASED_CTLS3: u32 = 1170;
pub const VMX_BASIC_VMCS_SIZE_SHIFT: u32 = 32;
pub const VMX_BASIC_TRUE_CTLS: u64 = 36028797018963968;
pub const VMX_BASIC_64: u64 = 281474976710656;
pub const VMX_BASIC_MEM_TYPE_SHIFT: u32 = 50;
pub const VMX_BASIC_MEM_TYPE_MASK: u64 = 16888498602639360;
pub const VMX_BASIC_MEM_TYPE_WB: u32 = 6;
pub const VMX_BASIC_INOUT: u64 = 18014398509481984;
pub const MSR_IA32_L3_QOS_CFG: u32 = 3201;
pub const MSR_IA32_L2_QOS_CFG: u32 = 3202;
pub const MSR_IA32_QM_EVTSEL: u32 = 3213;
pub const MSR_IA32_QM_CTR: u32 = 3214;
pub const MSR_IA32_PQR_ASSOC: u32 = 3215;
pub const MSR_IA32_L3_CBM_BASE: u32 = 3216;
pub const MSR_IA32_L2_CBM_BASE: u32 = 3344;
pub const MSR_IA32_MBA_THRTL_BASE: u32 = 3408;
pub const MSR_IA32_MBA_BW_BASE: u32 = 3221225984;
pub const MSR_IA32_SMBA_BW_BASE: u32 = 3221226112;
pub const MSR_IA32_EVT_CFG_BASE: u32 = 3221226496;
pub const MSR_IA32_VMX_MISC_INTEL_PT: u32 = 16384;
pub const MSR_IA32_VMX_MISC_VMWRITE_SHADOW_RO_FIELDS: u32 = 536870912;
pub const MSR_IA32_VMX_MISC_PREEMPTION_TIMER_SCALE: u32 = 31;
pub const MSR_VM_CR: u32 = 3221291284;
pub const MSR_VM_IGNNE: u32 = 3221291285;
pub const MSR_VM_HSAVE_PA: u32 = 3221291287;
pub const SVM_VM_CR_VALID_MASK: u32 = 31;
pub const SVM_VM_CR_SVM_LOCK_MASK: u32 = 8;
pub const SVM_VM_CR_SVM_DIS_MASK: u32 = 16;
pub const MSR_IA32_HW_FEEDBACK_PTR: u32 = 6096;
pub const MSR_IA32_HW_FEEDBACK_CONFIG: u32 = 6097;
pub const MSR_IA32_XAPIC_DISABLE_STATUS: u32 = 189;
pub const ORC_REG_UNDEFINED: u32 = 0;
pub const ORC_REG_PREV_SP: u32 = 1;
pub const ORC_REG_DX: u32 = 2;
pub const ORC_REG_DI: u32 = 3;
pub const ORC_REG_BP: u32 = 4;
pub const ORC_REG_SP: u32 = 5;
pub const ORC_REG_R10: u32 = 6;
pub const ORC_REG_R13: u32 = 7;
pub const ORC_REG_BP_INDIRECT: u32 = 8;
pub const ORC_REG_SP_INDIRECT: u32 = 9;
pub const ORC_REG_MAX: u32 = 15;
pub const ORC_TYPE_UNDEFINED: u32 = 0;
pub const ORC_TYPE_END_OF_STACK: u32 = 1;
pub const ORC_TYPE_CALL: u32 = 2;
pub const ORC_TYPE_REGS: u32 = 3;
pub const ORC_TYPE_REGS_PARTIAL: u32 = 4;
pub const RET_DEPTH_SHIFT: u32 = 5;
pub const RSB_RET_STUFF_LOOPS: u32 = 16;
pub const RET_DEPTH_INIT: i64 = -9223372036854775808;
pub const RET_DEPTH_INIT_FROM_CALL: i64 = -288230376151711744;
pub const RET_DEPTH_CREDIT: i32 = -1;
pub const KVM_STEAL_TIME_preempted: u32 = 16;
pub const pt_regs_bx: u32 = 40;
pub const pt_regs_cx: u32 = 88;
pub const pt_regs_dx: u32 = 96;
pub const pt_regs_sp: u32 = 152;
pub const pt_regs_bp: u32 = 32;
pub const pt_regs_si: u32 = 104;
pub const pt_regs_di: u32 = 112;
pub const pt_regs_r8: u32 = 72;
pub const pt_regs_r9: u32 = 64;
pub const pt_regs_r10: u32 = 56;
pub const pt_regs_r11: u32 = 48;
pub const pt_regs_r12: u32 = 24;
pub const pt_regs_r13: u32 = 16;
pub const pt_regs_r14: u32 = 8;
pub const pt_regs_r15: u32 = 0;
pub const pt_regs_flags: u32 = 144;
pub const saved_context_cr0: u32 = 200;
pub const saved_context_cr2: u32 = 208;
pub const saved_context_cr3: u32 = 216;
pub const saved_context_cr4: u32 = 224;
pub const saved_context_gdt_desc: u32 = 266;
pub const FIXED_stack_canary: u32 = 40;
pub const TASK_threadsp: u32 = 9304;
pub const TASK_stack_canary: u32 = 2472;
pub const pbe_address: u32 = 0;
pub const pbe_orig_address: u32 = 8;
pub const pbe_next: u32 = 16;
pub const IA32_SIGCONTEXT_ax: u32 = 44;
pub const IA32_SIGCONTEXT_bx: u32 = 32;
pub const IA32_SIGCONTEXT_cx: u32 = 40;
pub const IA32_SIGCONTEXT_dx: u32 = 36;
pub const IA32_SIGCONTEXT_si: u32 = 20;
pub const IA32_SIGCONTEXT_di: u32 = 16;
pub const IA32_SIGCONTEXT_bp: u32 = 24;
pub const IA32_SIGCONTEXT_sp: u32 = 28;
pub const IA32_SIGCONTEXT_ip: u32 = 56;
pub const IA32_RT_SIGFRAME_sigcontext: u32 = 164;
pub const XEN_vcpu_info_mask: u32 = 1;
pub const XEN_vcpu_info_pending: u32 = 0;
pub const XEN_vcpu_info_arch_cr2: u32 = 16;
pub const TDX_MODULE_rcx: u32 = 0;
pub const TDX_MODULE_rdx: u32 = 8;
pub const TDX_MODULE_r8: u32 = 16;
pub const TDX_MODULE_r9: u32 = 24;
pub const TDX_MODULE_r10: u32 = 32;
pub const TDX_MODULE_r11: u32 = 40;
pub const TDX_MODULE_r12: u32 = 48;
pub const TDX_MODULE_r13: u32 = 56;
pub const TDX_MODULE_r14: u32 = 64;
pub const TDX_MODULE_r15: u32 = 72;
pub const TDX_MODULE_rbx: u32 = 80;
pub const TDX_MODULE_rdi: u32 = 88;
pub const TDX_MODULE_rsi: u32 = 96;
pub const BP_scratch: u32 = 484;
pub const BP_secure_boot: u32 = 492;
pub const BP_loadflags: u32 = 529;
pub const BP_hardware_subarch: u32 = 572;
pub const BP_version: u32 = 518;
pub const BP_kernel_alignment: u32 = 560;
pub const BP_init_size: u32 = 608;
pub const BP_pref_address: u32 = 600;
pub const PTREGS_SIZE: u32 = 168;
pub const TLB_STATE_user_pcid_flush_mask: u32 = 22;
pub const CPU_ENTRY_AREA_entry_stack: u32 = 4096;
pub const SIZEOF_entry_stack: u32 = 4096;
pub const MASK_entry_stack: i32 = -4096;
pub const TSS_sp0: u32 = 4;
pub const TSS_sp1: u32 = 12;
pub const TSS_sp2: u32 = 20;
pub const X86_top_of_stack: u32 = 24;
pub const X86_current_task: u32 = 0;
pub const X86_call_depth: u32 = 16;
pub const ARIA_CTX_enc_key: u32 = 0;
pub const ARIA_CTX_dec_key: u32 = 272;
pub const ARIA_CTX_rounds: u32 = 544;
pub const RETPOLINE_THUNK_SIZE: u32 = 32;
pub const RSB_CLEAR_LOOPS: u32 = 32;
pub const ANNOTATE_RETPOLINE_SAFE: &[u8; 70usize] =
    b"999:\n\t.pushsection .discard.retpoline_safe\n\t.long 999b\n\t.popsection\n\t\0";
pub const GDT_ENTRY_BOOT_CS: u32 = 2;
pub const GDT_ENTRY_BOOT_DS: u32 = 3;
pub const GDT_ENTRY_BOOT_TSS: u32 = 4;
pub const __BOOT_CS: u32 = 16;
pub const __BOOT_DS: u32 = 24;
pub const __BOOT_TSS: u32 = 32;
pub const SEGMENT_RPL_MASK: u32 = 3;
pub const USER_SEGMENT_RPL_MASK: u32 = 2;
pub const USER_RPL: u32 = 3;
pub const SEGMENT_TI_MASK: u32 = 4;
pub const SEGMENT_LDT: u32 = 4;
pub const SEGMENT_GDT: u32 = 0;
pub const GDT_ENTRY_INVALID_SEG: u32 = 0;
pub const GDT_ENTRY_KERNEL32_CS: u32 = 1;
pub const GDT_ENTRY_KERNEL_CS: u32 = 2;
pub const GDT_ENTRY_KERNEL_DS: u32 = 3;
pub const GDT_ENTRY_DEFAULT_USER32_CS: u32 = 4;
pub const GDT_ENTRY_DEFAULT_USER_DS: u32 = 5;
pub const GDT_ENTRY_DEFAULT_USER_CS: u32 = 6;
pub const GDT_ENTRY_TSS: u32 = 8;
pub const GDT_ENTRY_LDT: u32 = 10;
pub const GDT_ENTRY_TLS_MIN: u32 = 12;
pub const GDT_ENTRY_TLS_MAX: u32 = 14;
pub const GDT_ENTRY_CPUNODE: u32 = 15;
pub const GDT_ENTRIES: u32 = 16;
pub const __KERNEL32_CS: u32 = 8;
pub const __KERNEL_CS: u32 = 16;
pub const __KERNEL_DS: u32 = 24;
pub const __USER32_CS: u32 = 35;
pub const __USER_DS: u32 = 43;
pub const __USER_CS: u32 = 51;
pub const __CPUNODE_SEG: u32 = 123;
pub const IDT_ENTRIES: u32 = 256;
pub const NUM_EXCEPTION_VECTORS: u32 = 32;
pub const EXCEPTION_ERRCODE_MASK: u32 = 537033984;
pub const GDT_SIZE: u32 = 128;
pub const GDT_ENTRY_TLS_ENTRIES: u32 = 3;
pub const TLS_SIZE: u32 = 24;
pub const VDSO_CPUNODE_BITS: u32 = 12;
pub const VDSO_CPUNODE_MASK: u32 = 4095;
pub const EARLY_IDT_HANDLER_SIZE: u32 = 9;
pub const XEN_EARLY_IDT_HANDLER_SIZE: u32 = 8;
pub const _DESC_ACCESSED: u32 = 1;
pub const _DESC_DATA_WRITABLE: u32 = 2;
pub const _DESC_CODE_READABLE: u32 = 2;
pub const _DESC_DATA_EXPAND_DOWN: u32 = 4;
pub const _DESC_CODE_CONFORMING: u32 = 4;
pub const _DESC_CODE_EXECUTABLE: u32 = 8;
pub const _DESC_S: u32 = 16;
pub const _DESC_PRESENT: u32 = 128;
pub const _DESC_LONG_CODE: u32 = 8192;
pub const _DESC_DB: u32 = 16384;
pub const _DESC_GRANULARITY_4K: u32 = 32768;
pub const _DESC_DATA: u32 = 147;
pub const _DESC_CODE: u32 = 155;
pub const DESC_DATA16: u32 = 147;
pub const DESC_CODE16: u32 = 155;
pub const DESC_DATA32: u32 = 49299;
pub const DESC_DATA32_BIOS: u32 = 16531;
pub const DESC_CODE32: u32 = 49307;
pub const DESC_CODE32_BIOS: u32 = 16539;
pub const DESC_DATA64: u32 = 49299;
pub const DESC_CODE64: u32 = 41115;
pub const BOOT_IDT_ENTRIES: u32 = 32;
pub const AR_TYPE_RODATA: u32 = 0;
pub const AR_TYPE_RWDATA: u32 = 512;
pub const AR_TYPE_RODATA_EXPDOWN: u32 = 1024;
pub const AR_TYPE_RWDATA_EXPDOWN: u32 = 1536;
pub const AR_TYPE_XOCODE: u32 = 2048;
pub const AR_TYPE_XRCODE: u32 = 2560;
pub const AR_TYPE_XOCODE_CONF: u32 = 3072;
pub const AR_TYPE_XRCODE_CONF: u32 = 3584;
pub const AR_TYPE_MASK: u32 = 3584;
pub const AR_DPL0: u32 = 0;
pub const AR_DPL3: u32 = 24576;
pub const AR_DPL_MASK: u32 = 24576;
pub const AR_A: u32 = 256;
pub const AR_S: u32 = 4096;
pub const AR_P: u32 = 32768;
pub const AR_AVL: u32 = 1048576;
pub const AR_L: u32 = 2097152;
pub const AR_DB: u32 = 4194304;
pub const AR_G: u32 = 8388608;
pub const PAGE_SHIFT: u32 = 12;
pub const HUGE_MAX_HSTATE: u32 = 2;
pub const KASAN_STACK_ORDER: u32 = 0;
pub const THREAD_SIZE_ORDER: u32 = 2;
pub const EXCEPTION_STACK_ORDER: u32 = 1;
pub const IRQ_STACK_ORDER: u32 = 2;
pub const IST_INDEX_DF: u32 = 0;
pub const IST_INDEX_NMI: u32 = 1;
pub const IST_INDEX_DB: u32 = 2;
pub const IST_INDEX_MCE: u32 = 3;
pub const IST_INDEX_VC: u32 = 4;
pub const __PHYSICAL_MASK_SHIFT: u32 = 52;
pub const KERNEL_IMAGE_SIZE: u32 = 1073741824;
pub const _PAGE_BIT_PRESENT: u32 = 0;
pub const _PAGE_BIT_RW: u32 = 1;
pub const _PAGE_BIT_USER: u32 = 2;
pub const _PAGE_BIT_PWT: u32 = 3;
pub const _PAGE_BIT_PCD: u32 = 4;
pub const _PAGE_BIT_ACCESSED: u32 = 5;
pub const _PAGE_BIT_DIRTY: u32 = 6;
pub const _PAGE_BIT_PSE: u32 = 7;
pub const _PAGE_BIT_PAT: u32 = 7;
pub const _PAGE_BIT_GLOBAL: u32 = 8;
pub const _PAGE_BIT_SOFTW1: u32 = 9;
pub const _PAGE_BIT_SOFTW2: u32 = 10;
pub const _PAGE_BIT_SOFTW3: u32 = 11;
pub const _PAGE_BIT_PAT_LARGE: u32 = 12;
pub const _PAGE_BIT_SOFTW4: u32 = 57;
pub const _PAGE_BIT_SOFTW5: u32 = 58;
pub const _PAGE_BIT_PKEY_BIT0: u32 = 59;
pub const _PAGE_BIT_PKEY_BIT1: u32 = 60;
pub const _PAGE_BIT_PKEY_BIT2: u32 = 61;
pub const _PAGE_BIT_PKEY_BIT3: u32 = 62;
pub const _PAGE_BIT_NX: u32 = 63;
pub const _PAGE_BIT_SPECIAL: u32 = 9;
pub const _PAGE_BIT_CPA_TEST: u32 = 9;
pub const _PAGE_BIT_UFFD_WP: u32 = 10;
pub const _PAGE_BIT_SOFT_DIRTY: u32 = 11;
pub const _PAGE_BIT_DEVMAP: u32 = 57;
pub const _PAGE_BIT_SAVED_DIRTY: u32 = 58;
pub const _PAGE_BIT_PROTNONE: u32 = 8;
pub const SECTION_SIZE_BITS: u32 = 27;
pub const SHARED_KERNEL_PMD: u32 = 0;
pub const PTRS_PER_PGD: u32 = 512;
pub const P4D_SHIFT: u32 = 39;
pub const MAX_PTRS_PER_P4D: u32 = 512;
pub const MAX_POSSIBLE_PHYSMEM_BITS: u32 = 52;
pub const PUD_SHIFT: u32 = 30;
pub const PTRS_PER_PUD: u32 = 512;
pub const PMD_SHIFT: u32 = 21;
pub const PTRS_PER_PMD: u32 = 512;
pub const PTRS_PER_PTE: u32 = 512;
pub const GUARD_HOLE_PGD_ENTRY: i32 = -256;
pub const LDT_PGD_ENTRY: i32 = -240;
pub const __VMALLOC_BASE_L4: i64 = -60473139527680;
pub const __VMALLOC_BASE_L5: i64 = -27021597764222976;
pub const VMALLOC_SIZE_TB_L4: u32 = 32;
pub const VMALLOC_SIZE_TB_L5: u32 = 12800;
pub const __VMEMMAP_BASE_L4: i64 = -24189255811072;
pub const __VMEMMAP_BASE_L5: i64 = -12384898975268864;
pub const EARLY_DYNAMIC_PAGE_TABLES: u32 = 64;
pub const PGD_ALLOWED_BITS: i32 = -1;
pub const PARAVIRT_CALL : & [u8 ; 94usize] = b"999:\n\t.pushsection .discard.retpoline_safe\n\t.long 999b\n\t.popsection\n\tcall *%[paravirt_opptr];\0" ;
pub const ASM_UD2: &[u8; 17usize] = b".byte 0x0f, 0x0b\0";
pub const INSN_UD2: u32 = 2831;
pub const LEN_UD2: u32 = 2;
pub const CUT_HERE: &[u8; 38usize] = b"------------[ cut here ]------------\n\0";
pub const BUGFLAG_WARNING: u32 = 1;
pub const BUGFLAG_ONCE: u32 = 2;
pub const BUGFLAG_DONE: u32 = 4;
pub const BUGFLAG_NO_CUT_HERE: u32 = 8;
pub const PANIC_CPU_INVALID: i32 = -1;
pub const TAINT_PROPRIETARY_MODULE: u32 = 0;
pub const TAINT_FORCED_MODULE: u32 = 1;
pub const TAINT_CPU_OUT_OF_SPEC: u32 = 2;
pub const TAINT_FORCED_RMMOD: u32 = 3;
pub const TAINT_MACHINE_CHECK: u32 = 4;
pub const TAINT_BAD_PAGE: u32 = 5;
pub const TAINT_USER: u32 = 6;
pub const TAINT_DIE: u32 = 7;
pub const TAINT_OVERRIDDEN_ACPI_TABLE: u32 = 8;
pub const TAINT_WARN: u32 = 9;
pub const TAINT_CRAP: u32 = 10;
pub const TAINT_FIRMWARE_WORKAROUND: u32 = 11;
pub const TAINT_OOT_MODULE: u32 = 12;
pub const TAINT_UNSIGNED_MODULE: u32 = 13;
pub const TAINT_SOFTLOCKUP: u32 = 14;
pub const TAINT_LIVEPATCH: u32 = 15;
pub const TAINT_AUX: u32 = 16;
pub const TAINT_RANDSTRUCT: u32 = 17;
pub const TAINT_TEST: u32 = 18;
pub const TAINT_FLAGS_COUNT: u32 = 19;
pub const TAINT_FLAGS_MAX: u32 = 524287;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const UINT_MAX: i32 = -1;
pub const ULONG_MAX: i32 = -1;
pub const ULLONG_MAX: i32 = -1;
pub const UINTPTR_MAX: i32 = -1;
pub const _BITOPS_LONG_SHIFT: u32 = 6;
pub const REG_IN: &[u8; 2usize] = b"D\0";
pub const REG_OUT: &[u8; 2usize] = b"a\0";
pub const BITOP_LE_SWIZZLE: u32 = 0;
pub const STACK_MAGIC: u32 = 3735928559;
pub const READ: u32 = 0;
pub const WRITE: u32 = 1;
pub const ERESTARTSYS: u32 = 512;
pub const ERESTARTNOINTR: u32 = 513;
pub const ERESTARTNOHAND: u32 = 514;
pub const ENOIOCTLCMD: u32 = 515;
pub const ERESTART_RESTARTBLOCK: u32 = 516;
pub const EPROBE_DEFER: u32 = 517;
pub const EOPENSTALE: u32 = 518;
pub const ENOPARAM: u32 = 519;
pub const EBADHANDLE: u32 = 521;
pub const ENOTSYNC: u32 = 522;
pub const EBADCOOKIE: u32 = 523;
pub const ENOTSUPP: u32 = 524;
pub const ETOOSMALL: u32 = 525;
pub const ESERVERFAULT: u32 = 526;
pub const EBADTYPE: u32 = 527;
pub const EJUKEBOX: u32 = 528;
pub const EIOCBQUEUED: u32 = 529;
pub const ERECALLCONFLICT: u32 = 530;
pub const ENOGRACE: u32 = 531;
pub const __HAVE_ARCH_MEMCPY: u32 = 1;
pub const __HAVE_ARCH_MEMCPY_FLUSHCACHE: u32 = 1;
pub const BITMAP_MEM_ALIGNMENT: u32 = 8;
pub const BITMAP_MEM_MASK: u32 = 7;
pub const __X86_CASE_B: u32 = 1;
pub const __X86_CASE_W: u32 = 2;
pub const __X86_CASE_L: u32 = 4;
pub const __X86_CASE_Q: u32 = 8;
pub const ___GFP_DMA: u32 = 1;
pub const ___GFP_HIGHMEM: u32 = 2;
pub const ___GFP_DMA32: u32 = 4;
pub const ___GFP_MOVABLE: u32 = 8;
pub const ___GFP_RECLAIMABLE: u32 = 16;
pub const ___GFP_HIGH: u32 = 32;
pub const ___GFP_IO: u32 = 64;
pub const ___GFP_FS: u32 = 128;
pub const ___GFP_ZERO: u32 = 256;
pub const ___GFP_DIRECT_RECLAIM: u32 = 1024;
pub const ___GFP_KSWAPD_RECLAIM: u32 = 2048;
pub const ___GFP_WRITE: u32 = 4096;
pub const ___GFP_NOWARN: u32 = 8192;
pub const ___GFP_RETRY_MAYFAIL: u32 = 16384;
pub const ___GFP_NOFAIL: u32 = 32768;
pub const ___GFP_NORETRY: u32 = 65536;
pub const ___GFP_MEMALLOC: u32 = 131072;
pub const ___GFP_COMP: u32 = 262144;
pub const ___GFP_NOMEMALLOC: u32 = 524288;
pub const ___GFP_HARDWALL: u32 = 1048576;
pub const ___GFP_THISNODE: u32 = 2097152;
pub const ___GFP_ACCOUNT: u32 = 4194304;
pub const ___GFP_ZEROTAGS: u32 = 8388608;
pub const ___GFP_SKIP_ZERO: u32 = 0;
pub const ___GFP_SKIP_KASAN: u32 = 0;
pub const ___GFP_NOLOCKDEP: u32 = 0;
pub const NODES_SHIFT: u32 = 10;
pub const MAX_NUMNODES: u32 = 1024;
pub const NUMA_NO_NODE: i32 = -1;
pub const NUMA_NO_MEMBLK: i32 = -1;
pub const ENCODE_FRAME_POINTER: &[u8; 20usize] = b"lea 1(%rsp), %rbp\n\t\0";
pub const PV_SAVE_ALL_CALLER_REGS: &[u8; 79usize] =
    b"push %rcx;push %rdx;push %rsi;push %rdi;push %r8;push %r9;push %r10;push %r11;\0";
pub const PV_RESTORE_ALL_CALLER_REGS: &[u8; 71usize] =
    b"pop %r11;pop %r10;pop %r9;pop %r8;pop %rdi;pop %rsi;pop %rdx;pop %rcx;\0";
pub const __HAVE_ARCH_GATE_AREA: u32 = 1;
pub const TOP_OF_KERNEL_STACK_PADDING: u32 = 0;
pub const FRAME_SIZE: u32 = 168;
pub const PTRACE_GETREGS: u32 = 12;
pub const PTRACE_SETREGS: u32 = 13;
pub const PTRACE_GETFPREGS: u32 = 14;
pub const PTRACE_SETFPREGS: u32 = 15;
pub const PTRACE_GETFPXREGS: u32 = 18;
pub const PTRACE_SETFPXREGS: u32 = 19;
pub const PTRACE_OLDSETOPTIONS: u32 = 21;
pub const PTRACE_GET_THREAD_AREA: u32 = 25;
pub const PTRACE_SET_THREAD_AREA: u32 = 26;
pub const PTRACE_ARCH_PRCTL: u32 = 30;
pub const PTRACE_SYSEMU: u32 = 31;
pub const PTRACE_SYSEMU_SINGLESTEP: u32 = 32;
pub const PTRACE_SINGLEBLOCK: u32 = 33;
pub const LDT_ENTRIES: u32 = 8192;
pub const LDT_ENTRY_SIZE: u32 = 8;
pub const MODIFY_LDT_CONTENTS_DATA: u32 = 0;
pub const MODIFY_LDT_CONTENTS_STACK: u32 = 1;
pub const MODIFY_LDT_CONTENTS_CODE: u32 = 2;
pub const NR_REG_ARGUMENTS: u32 = 6;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const X86_FXSR_MAGIC: u32 = 0;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const TRACEPOINT_DEFS_H: u32 = 1;
pub const MXCSR_DEFAULT: u32 = 8064;
pub const NVMXINTS: u32 = 5;
pub const VMX_FEATURE_INTR_EXITING: u32 = 0;
pub const VMX_FEATURE_NMI_EXITING: u32 = 3;
pub const VMX_FEATURE_VIRTUAL_NMIS: u32 = 5;
pub const VMX_FEATURE_PREEMPTION_TIMER: u32 = 6;
pub const VMX_FEATURE_POSTED_INTR: u32 = 7;
pub const VMX_FEATURE_INVVPID: u32 = 16;
pub const VMX_FEATURE_EPT_EXECUTE_ONLY: u32 = 17;
pub const VMX_FEATURE_EPT_AD: u32 = 18;
pub const VMX_FEATURE_EPT_1GB: u32 = 19;
pub const VMX_FEATURE_FLEXPRIORITY: u32 = 24;
pub const VMX_FEATURE_APICV: u32 = 25;
pub const VMX_FEATURE_EPTP_SWITCHING: u32 = 28;
pub const VMX_FEATURE_INTR_WINDOW_EXITING: u32 = 34;
pub const VMX_FEATURE_USE_TSC_OFFSETTING: u32 = 35;
pub const VMX_FEATURE_HLT_EXITING: u32 = 39;
pub const VMX_FEATURE_INVLPG_EXITING: u32 = 41;
pub const VMX_FEATURE_MWAIT_EXITING: u32 = 42;
pub const VMX_FEATURE_RDPMC_EXITING: u32 = 43;
pub const VMX_FEATURE_RDTSC_EXITING: u32 = 44;
pub const VMX_FEATURE_CR3_LOAD_EXITING: u32 = 47;
pub const VMX_FEATURE_CR3_STORE_EXITING: u32 = 48;
pub const VMX_FEATURE_TERTIARY_CONTROLS: u32 = 49;
pub const VMX_FEATURE_CR8_LOAD_EXITING: u32 = 51;
pub const VMX_FEATURE_CR8_STORE_EXITING: u32 = 52;
pub const VMX_FEATURE_VIRTUAL_TPR: u32 = 53;
pub const VMX_FEATURE_NMI_WINDOW_EXITING: u32 = 54;
pub const VMX_FEATURE_MOV_DR_EXITING: u32 = 55;
pub const VMX_FEATURE_UNCOND_IO_EXITING: u32 = 56;
pub const VMX_FEATURE_USE_IO_BITMAPS: u32 = 57;
pub const VMX_FEATURE_MONITOR_TRAP_FLAG: u32 = 59;
pub const VMX_FEATURE_USE_MSR_BITMAPS: u32 = 60;
pub const VMX_FEATURE_MONITOR_EXITING: u32 = 61;
pub const VMX_FEATURE_PAUSE_EXITING: u32 = 62;
pub const VMX_FEATURE_SEC_CONTROLS: u32 = 63;
pub const VMX_FEATURE_VIRT_APIC_ACCESSES: u32 = 64;
pub const VMX_FEATURE_EPT: u32 = 65;
pub const VMX_FEATURE_DESC_EXITING: u32 = 66;
pub const VMX_FEATURE_RDTSCP: u32 = 67;
pub const VMX_FEATURE_VIRTUAL_X2APIC: u32 = 68;
pub const VMX_FEATURE_VPID: u32 = 69;
pub const VMX_FEATURE_WBINVD_EXITING: u32 = 70;
pub const VMX_FEATURE_UNRESTRICTED_GUEST: u32 = 71;
pub const VMX_FEATURE_APIC_REGISTER_VIRT: u32 = 72;
pub const VMX_FEATURE_VIRT_INTR_DELIVERY: u32 = 73;
pub const VMX_FEATURE_PAUSE_LOOP_EXITING: u32 = 74;
pub const VMX_FEATURE_RDRAND_EXITING: u32 = 75;
pub const VMX_FEATURE_INVPCID: u32 = 76;
pub const VMX_FEATURE_VMFUNC: u32 = 77;
pub const VMX_FEATURE_SHADOW_VMCS: u32 = 78;
pub const VMX_FEATURE_ENCLS_EXITING: u32 = 79;
pub const VMX_FEATURE_RDSEED_EXITING: u32 = 80;
pub const VMX_FEATURE_PAGE_MOD_LOGGING: u32 = 81;
pub const VMX_FEATURE_EPT_VIOLATION_VE: u32 = 82;
pub const VMX_FEATURE_PT_CONCEAL_VMX: u32 = 83;
pub const VMX_FEATURE_XSAVES: u32 = 84;
pub const VMX_FEATURE_MODE_BASED_EPT_EXEC: u32 = 86;
pub const VMX_FEATURE_PT_USE_GPA: u32 = 88;
pub const VMX_FEATURE_TSC_SCALING: u32 = 89;
pub const VMX_FEATURE_USR_WAIT_PAUSE: u32 = 90;
pub const VMX_FEATURE_ENCLV_EXITING: u32 = 92;
pub const VMX_FEATURE_BUS_LOCK_DETECTION: u32 = 94;
pub const VMX_FEATURE_NOTIFY_VM_EXITING: u32 = 95;
pub const VMX_FEATURE_IPI_VIRT: u32 = 100;
pub const NET_IP_ALIGN: u32 = 0;
pub const HBP_NUM: u32 = 4;
pub const ARCH_MIN_MMSTRUCT_ALIGN: u32 = 0;
pub const X86_VENDOR_INTEL: u32 = 0;
pub const X86_VENDOR_CYRIX: u32 = 1;
pub const X86_VENDOR_AMD: u32 = 2;
pub const X86_VENDOR_UMC: u32 = 3;
pub const X86_VENDOR_CENTAUR: u32 = 5;
pub const X86_VENDOR_TRANSMETA: u32 = 7;
pub const X86_VENDOR_NSC: u32 = 8;
pub const X86_VENDOR_HYGON: u32 = 9;
pub const X86_VENDOR_ZHAOXIN: u32 = 10;
pub const X86_VENDOR_VORTEX: u32 = 11;
pub const X86_VENDOR_NUM: u32 = 12;
pub const X86_VENDOR_UNKNOWN: u32 = 255;
pub const IO_BITMAP_BITS: u32 = 65536;
pub const IO_BITMAP_BYTES: u32 = 8192;
pub const HAVE_ARCH_PICK_MMAP_LAYOUT: u32 = 1;
pub const BASE_PREFETCH: &[u8; 15usize] = b"prefetcht0 %P1\0";
pub const X86_CAP_FMT_NUM: &[u8; 6usize] = b"%d:%d\0";
pub const X86_CAP_FMT: &[u8; 3usize] = b"%s\0";
pub const MAX_CPU_FEATURES: u32 = 704;
pub const CPU_FEATURE_TYPEFMT: &[u8; 26usize] = b"x86,ven%04Xfam%04Xmod%04X\0";
pub const TIF_NOTIFY_RESUME: u32 = 1;
pub const TIF_SIGPENDING: u32 = 2;
pub const TIF_NEED_RESCHED: u32 = 3;
pub const TIF_SINGLESTEP: u32 = 4;
pub const TIF_SSBD: u32 = 5;
pub const TIF_SPEC_IB: u32 = 9;
pub const TIF_SPEC_L1D_FLUSH: u32 = 10;
pub const TIF_USER_RETURN_NOTIFY: u32 = 11;
pub const TIF_UPROBE: u32 = 12;
pub const TIF_PATCH_PENDING: u32 = 13;
pub const TIF_NEED_FPU_LOAD: u32 = 14;
pub const TIF_NOCPUID: u32 = 15;
pub const TIF_NOTSC: u32 = 16;
pub const TIF_NOTIFY_SIGNAL: u32 = 17;
pub const TIF_MEMDIE: u32 = 20;
pub const TIF_POLLING_NRFLAG: u32 = 21;
pub const TIF_IO_BITMAP: u32 = 22;
pub const TIF_SPEC_FORCE_UPDATE: u32 = 23;
pub const TIF_FORCED_TF: u32 = 24;
pub const TIF_BLOCKSTEP: u32 = 25;
pub const TIF_LAZY_MMU_UPDATES: u32 = 27;
pub const TIF_ADDR32: u32 = 29;
pub const _TIF_NOTIFY_RESUME: u32 = 2;
pub const _TIF_SIGPENDING: u32 = 4;
pub const _TIF_NEED_RESCHED: u32 = 8;
pub const _TIF_SINGLESTEP: u32 = 16;
pub const _TIF_SSBD: u32 = 32;
pub const _TIF_SPEC_IB: u32 = 512;
pub const _TIF_SPEC_L1D_FLUSH: u32 = 1024;
pub const _TIF_USER_RETURN_NOTIFY: u32 = 2048;
pub const _TIF_UPROBE: u32 = 4096;
pub const _TIF_PATCH_PENDING: u32 = 8192;
pub const _TIF_NEED_FPU_LOAD: u32 = 16384;
pub const _TIF_NOCPUID: u32 = 32768;
pub const _TIF_NOTSC: u32 = 65536;
pub const _TIF_NOTIFY_SIGNAL: u32 = 131072;
pub const _TIF_POLLING_NRFLAG: u32 = 2097152;
pub const _TIF_IO_BITMAP: u32 = 4194304;
pub const _TIF_SPEC_FORCE_UPDATE: u32 = 8388608;
pub const _TIF_FORCED_TF: u32 = 16777216;
pub const _TIF_BLOCKSTEP: u32 = 33554432;
pub const _TIF_LAZY_MMU_UPDATES: u32 = 134217728;
pub const _TIF_ADDR32: u32 = 536870912;
pub const _TIF_WORK_CTXSW_BASE: u32 = 42041376;
pub const _TIF_WORK_CTXSW: u32 = 42041888;
pub const _TIF_WORK_CTXSW_PREV: u32 = 46238240;
pub const _TIF_WORK_CTXSW_NEXT: u32 = 42041888;
pub const TS_COMPAT: u32 = 2;
pub const TS_I386_REGS_POKED: u32 = 4;
pub const PAGE_POISON: u32 = 170;
pub const RED_INACTIVE: u64 = 718624318471594843;
pub const RED_ACTIVE: i64 = -2863912482255763264;
pub const SLUB_RED_INACTIVE: u32 = 187;
pub const SLUB_RED_ACTIVE: u32 = 204;
pub const POISON_INUSE: u32 = 90;
pub const POISON_FREE: u32 = 107;
pub const POISON_END: u32 = 165;
pub const POISON_FREE_INITMEM: u32 = 204;
pub const JBD_POISON_FREE: u32 = 91;
pub const JBD2_POISON_FREE: u32 = 92;
pub const POOL_POISON_FREED: u32 = 167;
pub const POOL_POISON_ALLOCATED: u32 = 169;
pub const ATM_POISON_FREE: u32 = 18;
pub const ATM_POISON: u32 = 3735928559;
pub const MUTEX_DEBUG_INIT: u32 = 17;
pub const MUTEX_DEBUG_FREE: u32 = 34;
pub const KEY_DESTROY: u32 = 189;
pub const STARTUP_READ_APICID: u32 = 2147483648;
pub const STARTUP_PARALLEL_MASK: u32 = 4278190080;
pub const force_read_lock_recursive: u32 = 0;
pub const SINGLE_DEPTH_NESTING: u32 = 1;
pub const LOCK_SECTION_END: &[u8; 12usize] = b".previous\n\t\0";
pub const RWLOCK_MAGIC: u32 = 3736018669;
pub const SPIN_THRESHOLD: u32 = 32768;
pub const _Q_PENDING_LOOPS: u32 = 512;
pub const _QW_WAITING: u32 = 256;
pub const _QW_LOCKED: u32 = 255;
pub const _QW_WMASK: u32 = 511;
pub const _QR_SHIFT: u32 = 9;
pub const _QR_BIAS: u32 = 512;
pub const STAT_HAVE_NSEC: u32 = 1;
pub const S_IFMT: u32 = 61440;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFLNK: u32 = 40960;
pub const S_IFREG: u32 = 32768;
pub const S_IFBLK: u32 = 24576;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFIFO: u32 = 4096;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRWXU: u32 = 448;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXG: u32 = 56;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXO: u32 = 7;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const STATX_TYPE: u32 = 1;
pub const STATX_MODE: u32 = 2;
pub const STATX_NLINK: u32 = 4;
pub const STATX_UID: u32 = 8;
pub const STATX_GID: u32 = 16;
pub const STATX_ATIME: u32 = 32;
pub const STATX_MTIME: u32 = 64;
pub const STATX_CTIME: u32 = 128;
pub const STATX_INO: u32 = 256;
pub const STATX_SIZE: u32 = 512;
pub const STATX_BLOCKS: u32 = 1024;
pub const STATX_BASIC_STATS: u32 = 2047;
pub const STATX_BTIME: u32 = 2048;
pub const STATX_MNT_ID: u32 = 4096;
pub const STATX_DIOALIGN: u32 = 8192;
pub const STATX_MNT_ID_UNIQUE: u32 = 16384;
pub const STATX__RESERVED: u32 = 2147483648;
pub const STATX_ATTR_COMPRESSED: u32 = 4;
pub const STATX_ATTR_IMMUTABLE: u32 = 16;
pub const STATX_ATTR_APPEND: u32 = 32;
pub const STATX_ATTR_NODUMP: u32 = 64;
pub const STATX_ATTR_ENCRYPTED: u32 = 2048;
pub const STATX_ATTR_AUTOMOUNT: u32 = 4096;
pub const STATX_ATTR_MOUNT_ROOT: u32 = 8192;
pub const STATX_ATTR_VERITY: u32 = 1048576;
pub const STATX_ATTR_DAX: u32 = 2097152;
pub const S_IRWXUGO: u32 = 511;
pub const S_IALLUGO: u32 = 4095;
pub const S_IRUGO: u32 = 292;
pub const S_IWUGO: u32 = 146;
pub const S_IXUGO: u32 = 73;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const MSEC_PER_SEC: u32 = 1000;
pub const USEC_PER_MSEC: u32 = 1000;
pub const NSEC_PER_USEC: u32 = 1000;
pub const NSEC_PER_MSEC: u32 = 1000000;
pub const USEC_PER_SEC: u32 = 1000000;
pub const NSEC_PER_SEC: u32 = 1000000000;
pub const PSEC_PER_SEC: u64 = 1000000000000;
pub const FSEC_PER_SEC: u64 = 1000000000000000;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_SGI_CYCLE: u32 = 10;
pub const CLOCK_TAI: u32 = 11;
pub const MAX_CLOCKS: u32 = 16;
pub const CLOCKS_MASK: u32 = 1;
pub const CLOCKS_MONO: u32 = 1;
pub const TIMER_ABSTIME: u32 = 1;
pub const PSEC_PER_NSEC: u32 = 1000;
pub const TIME_UPTIME_SEC_MAX: u32 = 946080000;
pub const NTP_API: u32 = 4;
pub const ADJ_OFFSET: u32 = 1;
pub const ADJ_FREQUENCY: u32 = 2;
pub const ADJ_MAXERROR: u32 = 4;
pub const ADJ_ESTERROR: u32 = 8;
pub const ADJ_STATUS: u32 = 16;
pub const ADJ_TIMECONST: u32 = 32;
pub const ADJ_TAI: u32 = 128;
pub const ADJ_SETOFFSET: u32 = 256;
pub const ADJ_MICRO: u32 = 4096;
pub const ADJ_NANO: u32 = 8192;
pub const ADJ_TICK: u32 = 16384;
pub const MOD_OFFSET: u32 = 1;
pub const MOD_FREQUENCY: u32 = 2;
pub const MOD_MAXERROR: u32 = 4;
pub const MOD_ESTERROR: u32 = 8;
pub const MOD_STATUS: u32 = 16;
pub const MOD_TIMECONST: u32 = 32;
pub const MOD_TAI: u32 = 128;
pub const MOD_MICRO: u32 = 4096;
pub const MOD_NANO: u32 = 8192;
pub const STA_PLL: u32 = 1;
pub const STA_PPSFREQ: u32 = 2;
pub const STA_PPSTIME: u32 = 4;
pub const STA_FLL: u32 = 8;
pub const STA_INS: u32 = 16;
pub const STA_DEL: u32 = 32;
pub const STA_UNSYNC: u32 = 64;
pub const STA_FREQHOLD: u32 = 128;
pub const STA_PPSSIGNAL: u32 = 256;
pub const STA_PPSJITTER: u32 = 512;
pub const STA_PPSWANDER: u32 = 1024;
pub const STA_PPSERROR: u32 = 2048;
pub const STA_CLOCKERR: u32 = 4096;
pub const STA_NANO: u32 = 8192;
pub const STA_MODE: u32 = 16384;
pub const STA_CLK: u32 = 32768;
pub const STA_RONLY: u32 = 65280;
pub const TIME_OK: u32 = 0;
pub const TIME_INS: u32 = 1;
pub const TIME_DEL: u32 = 2;
pub const TIME_OOP: u32 = 3;
pub const TIME_WAIT: u32 = 4;
pub const TIME_ERROR: u32 = 5;
pub const TIME_BAD: u32 = 5;
pub const ADJ_ADJTIME: u32 = 32768;
pub const ADJ_OFFSET_SINGLESHOT: u32 = 1;
pub const ADJ_OFFSET_READONLY: u32 = 8192;
pub const SHIFT_PLL: u32 = 2;
pub const SHIFT_FLL: u32 = 2;
pub const MAXTC: u32 = 10;
pub const SHIFT_USEC: u32 = 16;
pub const PPM_SCALE_INV_SHIFT: u32 = 19;
pub const MAXPHASE: u32 = 500000000;
pub const MAXFREQ: u32 = 500000;
pub const MINSEC: u32 = 256;
pub const MAXSEC: u32 = 2048;
pub const NTP_PHASE_LIMIT: u32 = 16000000;
pub const NTP_SCALE_SHIFT: u32 = 32;
pub const NTP_INTERVAL_FREQ: u32 = 1000;
pub const NTP_INTERVAL_LENGTH: u32 = 1000000;
pub const PIT_TICK_RATE: u32 = 1193182;
pub const DEFAULT_OVERFLOWUID: u32 = 65534;
pub const DEFAULT_OVERFLOWGID: u32 = 65534;
pub const DEFAULT_FS_OVERFLOWUID: u32 = 65534;
pub const DEFAULT_FS_OVERFLOWGID: u32 = 65534;
pub const KSTAT_ATTR_FS_IOC_FLAGS: u32 = 1050740;
pub const KSTAT_ATTR_VFS_FLAGS: u32 = 48;
pub const STATX_CHANGE_COOKIE: u32 = 1073741824;
pub const STATX_ATTR_CHANGE_MONOTONIC: i64 = -9223372036854775808;
pub const BUILD_ID_SIZE_MAX: u32 = 20;
pub const WQ_FLAG_EXCLUSIVE: u32 = 1;
pub const WQ_FLAG_WOKEN: u32 = 2;
pub const WQ_FLAG_CUSTOM: u32 = 4;
pub const WQ_FLAG_DONE: u32 = 8;
pub const WQ_FLAG_PRIORITY: u32 = 16;
pub const OSQ_UNLOCKED_VAL: u32 = 0;
pub const KCSAN_SEQLOCK_REGION_MAX: u32 = 1000;
pub const GRND_NONBLOCK: u32 = 1;
pub const GRND_RANDOM: u32 = 2;
pub const GRND_INSECURE: u32 = 4;
pub const PB_migratetype_bits: u32 = 3;
pub const NR_PAGEFLAGS: u32 = 26;
pub const MAX_NR_ZONES: u32 = 5;
pub const NR_CPUS_BITS: u32 = 13;
pub const SPINLOCK_SIZE: u32 = 4;
pub const LRU_GEN_WIDTH: u32 = 3;
pub const __LRU_REFS_WIDTH: u32 = 2;
pub const ZONES_SHIFT: u32 = 3;
pub const ZONES_WIDTH: u32 = 3;
pub const SECTIONS_WIDTH: u32 = 0;
pub const NODES_WIDTH: u32 = 10;
pub const KASAN_TAG_WIDTH: u32 = 0;
pub const LAST__PID_SHIFT: u32 = 8;
pub const LAST__PID_MASK: u32 = 255;
pub const LAST__CPU_SHIFT: u32 = 13;
pub const LAST__CPU_MASK: u32 = 8191;
pub const LAST_CPUPID_SHIFT: u32 = 21;
pub const LAST_CPUPID_WIDTH: u32 = 21;
pub const AT_SYSINFO_EHDR: u32 = 33;
pub const AT_VECTOR_SIZE_ARCH: u32 = 3;
pub const AT_NULL: u32 = 0;
pub const AT_IGNORE: u32 = 1;
pub const AT_EXECFD: u32 = 2;
pub const AT_PHDR: u32 = 3;
pub const AT_PHENT: u32 = 4;
pub const AT_PHNUM: u32 = 5;
pub const AT_PAGESZ: u32 = 6;
pub const AT_BASE: u32 = 7;
pub const AT_FLAGS: u32 = 8;
pub const AT_ENTRY: u32 = 9;
pub const AT_NOTELF: u32 = 10;
pub const AT_UID: u32 = 11;
pub const AT_EUID: u32 = 12;
pub const AT_GID: u32 = 13;
pub const AT_EGID: u32 = 14;
pub const AT_PLATFORM: u32 = 15;
pub const AT_HWCAP: u32 = 16;
pub const AT_CLKTCK: u32 = 17;
pub const AT_SECURE: u32 = 23;
pub const AT_BASE_PLATFORM: u32 = 24;
pub const AT_RANDOM: u32 = 25;
pub const AT_HWCAP2: u32 = 26;
pub const AT_RSEQ_FEATURE_SIZE: u32 = 27;
pub const AT_RSEQ_ALIGN: u32 = 28;
pub const AT_EXECFN: u32 = 31;
pub const AT_MINSIGSTKSZ: u32 = 51;
pub const AT_VECTOR_SIZE_BASE: u32 = 22;
pub const NUM_ACTIVE_RCU_POLL_OLDSTATE: u32 = 2;
pub const TRC_NEED_QS: u32 = 1;
pub const TRC_NEED_QS_CHECKED: u32 = 2;
pub const NUM_ACTIVE_RCU_POLL_FULL_OLDSTATE: u32 = 4;
pub const MAPLE_NODE_SLOTS: u32 = 31;
pub const MAPLE_RANGE64_SLOTS: u32 = 16;
pub const MAPLE_ARANGE64_SLOTS: u32 = 10;
pub const MAPLE_ALLOC_SLOTS: u32 = 30;
pub const MAPLE_NODE_MASK: u32 = 255;
pub const MT_FLAGS_ALLOC_RANGE: u32 = 1;
pub const MT_FLAGS_USE_RCU: u32 = 2;
pub const MT_FLAGS_HEIGHT_OFFSET: u32 = 2;
pub const MT_FLAGS_HEIGHT_MASK: u32 = 124;
pub const MT_FLAGS_LOCK_MASK: u32 = 768;
pub const MT_FLAGS_LOCK_IRQ: u32 = 256;
pub const MT_FLAGS_LOCK_BH: u32 = 512;
pub const MT_FLAGS_LOCK_EXTERN: u32 = 768;
pub const MT_FLAGS_ALLOC_WRAPPED: u32 = 2048;
pub const MAPLE_HEIGHT_MAX: u32 = 31;
pub const MAPLE_NODE_TYPE_MASK: u32 = 15;
pub const MAPLE_NODE_TYPE_SHIFT: u32 = 3;
pub const MAPLE_RESERVED_RANGE: u32 = 4096;
pub const RWSEM_UNLOCKED_VALUE: u32 = 0;
pub const UPROBE_HANDLER_REMOVE: u32 = 1;
pub const UPROBE_HANDLER_MASK: u32 = 1;
pub const MAX_URETPROBE_DEPTH: u32 = 64;
pub const TICK_NSEC: u32 = 1000000;
pub const HZ_TO_MSEC_SHR32: u32 = 31;
pub const MSEC_TO_HZ_SHR32: u32 = 31;
pub const HZ_TO_MSEC_NUM: u32 = 1;
pub const HZ_TO_MSEC_DEN: u32 = 1;
pub const MSEC_TO_HZ_NUM: u32 = 1;
pub const MSEC_TO_HZ_DEN: u32 = 1;
pub const HZ_TO_USEC_SHR32: u32 = 22;
pub const USEC_TO_HZ_SHR32: u32 = 41;
pub const HZ_TO_USEC_NUM: u32 = 1000;
pub const HZ_TO_USEC_DEN: u32 = 1;
pub const USEC_TO_HZ_NUM: u32 = 1;
pub const USEC_TO_HZ_DEN: u32 = 1000;
pub const HZ_TO_NSEC_NUM: u32 = 1000000;
pub const HZ_TO_NSEC_DEN: u32 = 1;
pub const NSEC_TO_HZ_NUM: u32 = 1;
pub const NSEC_TO_HZ_DEN: u32 = 1000000;
pub const SHIFT_HZ: u32 = 10;
pub const TICK_USEC: u32 = 1000;
pub const USER_TICK_USEC: u32 = 10000;
pub const SEC_JIFFIE_SC: u32 = 21;
pub const NSEC_JIFFIE_SC: u32 = 51;
pub const TIMESTAMP_SIZE: u32 = 30;
pub const LOW_RES_NSEC: u32 = 1000000;
pub const KTIME_LOW_RES: u32 = 1000000;
pub const TIMER_CPUMASK: u32 = 262143;
pub const TIMER_MIGRATING: u32 = 262144;
pub const TIMER_BASEMASK: u32 = 524287;
pub const TIMER_DEFERRABLE: u32 = 524288;
pub const TIMER_PINNED: u32 = 1048576;
pub const TIMER_IRQSAFE: u32 = 2097152;
pub const TIMER_INIT_FLAGS: u32 = 3670016;
pub const TIMER_ARRAYSHIFT: u32 = 22;
pub const TIMER_ARRAYMASK: u32 = 4290772992;
pub const TIMER_TRACE_FLAGMASK: u32 = 3932160;
pub const NEXT_TIMER_MAX_DELTA: u32 = 1073741823;
pub const RCU_DONE_TAIL: u32 = 0;
pub const RCU_WAIT_TAIL: u32 = 1;
pub const RCU_NEXT_READY_TAIL: u32 = 2;
pub const RCU_NEXT_TAIL: u32 = 3;
pub const RCU_CBLIST_NSEGS: u32 = 4;
pub const RCU_FANOUT: u32 = 64;
pub const RCU_FANOUT_LEAF: u32 = 16;
pub const RCU_FANOUT_1: u32 = 16;
pub const RCU_FANOUT_2: u32 = 1024;
pub const RCU_FANOUT_3: u32 = 65536;
pub const RCU_FANOUT_4: u32 = 4194304;
pub const RCU_NUM_LVLS: u32 = 3;
pub const NUM_RCU_LVL_0: u32 = 1;
pub const SRCU_SIZE_SMALL: u32 = 0;
pub const SRCU_SIZE_ALLOC: u32 = 1;
pub const SRCU_SIZE_WAIT_BARRIER: u32 = 2;
pub const SRCU_SIZE_WAIT_CALL: u32 = 3;
pub const SRCU_SIZE_WAIT_CBS1: u32 = 4;
pub const SRCU_SIZE_WAIT_CBS2: u32 = 5;
pub const SRCU_SIZE_WAIT_CBS3: u32 = 6;
pub const SRCU_SIZE_WAIT_CBS4: u32 = 7;
pub const SRCU_SIZE_BIG: u32 = 8;
pub const SRCU_STATE_IDLE: u32 = 0;
pub const SRCU_STATE_SCAN1: u32 = 1;
pub const SRCU_STATE_SCAN2: u32 = 2;
pub const SRCU_NMI_UNKNOWN: u32 = 0;
pub const SRCU_NMI_UNSAFE: u32 = 1;
pub const SRCU_NMI_SAFE: u32 = 2;
pub const NOTIFY_DONE: u32 = 0;
pub const NOTIFY_OK: u32 = 1;
pub const NOTIFY_STOP_MASK: u32 = 32768;
pub const NOTIFY_BAD: u32 = 32770;
pub const NOTIFY_STOP: u32 = 32769;
pub const NETLINK_URELEASE: u32 = 1;
pub const KBD_KEYCODE: u32 = 1;
pub const KBD_UNBOUND_KEYCODE: u32 = 2;
pub const KBD_UNICODE: u32 = 3;
pub const KBD_KEYSYM: u32 = 4;
pub const KBD_POST_KEYSYM: u32 = 5;
pub const MAX_UINSN_BYTES: u32 = 16;
pub const UPROBE_XOL_SLOT_BYTES: u32 = 128;
pub const UPROBE_SWBP_INSN: u32 = 204;
pub const UPROBE_SWBP_INSN_SIZE: u32 = 1;
pub const LINUX_MM_DEBUG_H: u32 = 1;
pub const PERCPU_MODULE_RESERVE: u32 = 8192;
pub const PCPU_MIN_ALLOC_SHIFT: u32 = 2;
pub const PCPU_MIN_ALLOC_SIZE: u32 = 4;
pub const PERCPU_DYNAMIC_SIZE_SHIFT: u32 = 12;
pub const PERCPU_DYNAMIC_EARLY_SIZE: u32 = 81920;
pub const PERCPU_DYNAMIC_RESERVE: u32 = 114688;
pub const MM_CONTEXT_UPROBE_IA32: u32 = 0;
pub const MM_CONTEXT_HAS_VSYSCALL: u32 = 1;
pub const MM_CONTEXT_LOCK_LAM: u32 = 2;
pub const MM_CONTEXT_FORCE_TAGGED_SVA: u32 = 3;
pub const AT_VECTOR_SIZE: u32 = 52;
pub const INIT_PASID: u32 = 0;
pub const ENCODE_PAGE_BITS: u32 = 3;
pub const MM_MT_FLAGS: u32 = 771;
pub const PAGEFLAGS_MASK: u32 = 67108863;
pub const PAGE_POISON_PATTERN: i32 = -1;
pub const FOLIO_PF_ANY: u32 = 0;
pub const FOLIO_PF_HEAD: u32 = 0;
pub const FOLIO_PF_ONLY_HEAD: u32 = 0;
pub const FOLIO_PF_NO_TAIL: u32 = 0;
pub const FOLIO_PF_NO_COMPOUND: u32 = 0;
pub const FOLIO_PF_SECOND: u32 = 1;
pub const MAGIC_HWPOISON: u32 = 1213681747;
pub const PAGE_MAPPING_ANON: u32 = 1;
pub const PAGE_MAPPING_MOVABLE: u32 = 2;
pub const PAGE_MAPPING_KSM: u32 = 3;
pub const PAGE_MAPPING_FLAGS: u32 = 3;
pub const PAGE_TYPE_BASE: u32 = 4026531840;
pub const PAGE_MAPCOUNT_RESERVE: i32 = -128;
pub const PG_buddy: u32 = 128;
pub const PG_offline: u32 = 256;
pub const PG_table: u32 = 512;
pub const PG_guard: u32 = 1024;
pub const PG_hugetlb: u32 = 2048;
pub const MAX_PAGE_ORDER: u32 = 10;
pub const MAX_ORDER_NR_PAGES: u32 = 1024;
pub const NR_PAGE_ORDERS: u32 = 11;
pub const PAGE_ALLOC_COSTLY_ORDER: u32 = 3;
pub const MIGRATETYPE_MASK: u32 = 7;
pub const LRU_BASE: u32 = 0;
pub const LRU_ACTIVE: u32 = 1;
pub const LRU_FILE: u32 = 2;
pub const WORKINGSET_ANON: u32 = 0;
pub const WORKINGSET_FILE: u32 = 1;
pub const ANON_AND_FILE: u32 = 2;
pub const MIN_NR_GENS: u32 = 2;
pub const MAX_NR_GENS: u32 = 4;
pub const MAX_NR_TIERS: u32 = 4;
pub const MIN_LRU_BATCH: u32 = 64;
pub const MAX_LRU_BATCH: u32 = 4096;
pub const NR_HIST_GENS: u32 = 1;
pub const NR_BLOOM_FILTERS: u32 = 2;
pub const MEMCG_NR_GENS: u32 = 3;
pub const MEMCG_NR_BINS: u32 = 8;
pub const NR_PCP_THP: u32 = 1;
pub const ASYNC_AND_SYNC: u32 = 2;
pub const ZONEID_SHIFT: u32 = 13;
pub const ZONES_MASK: u32 = 7;
pub const NODES_MASK: u32 = 1023;
pub const SECTIONS_MASK: u32 = 0;
pub const LAST_CPUPID_MASK: u32 = 2097151;
pub const KASAN_TAG_MASK: u32 = 0;
pub const ZONEID_MASK: u32 = 8191;
pub const DEF_PRIORITY: u32 = 12;
pub const MAX_ZONES_PER_ZONELIST: u32 = 5120;
pub const PA_SECTION_SHIFT: u32 = 27;
pub const PFN_SECTION_SHIFT: u32 = 15;
pub const PAGES_PER_SECTION: u32 = 32768;
pub const PAGE_SECTION_MASK: i32 = -32768;
pub const SUBSECTION_SHIFT: u32 = 21;
pub const SUBSECTION_SIZE: u32 = 2097152;
pub const PFN_SUBSECTION_SHIFT: u32 = 9;
pub const PAGES_PER_SUBSECTION: u32 = 512;
pub const PAGE_SUBSECTION_MASK: i32 = -512;
pub const SUBSECTIONS_PER_SECTION: u32 = 64;
pub const MPC_SIGNATURE: &[u8; 5usize] = b"PCMP\0";
pub const MP_PROCESSOR: u32 = 0;
pub const MP_BUS: u32 = 1;
pub const MP_IOAPIC: u32 = 2;
pub const MP_INTSRC: u32 = 3;
pub const MP_LINTSRC: u32 = 4;
pub const MP_TRANSLATION: u32 = 192;
pub const CPU_ENABLED: u32 = 1;
pub const CPU_BOOTPROCESSOR: u32 = 2;
pub const CPU_STEPPING_MASK: u32 = 15;
pub const CPU_MODEL_MASK: u32 = 240;
pub const CPU_FAMILY_MASK: u32 = 3840;
pub const BUSTYPE_EISA: &[u8; 5usize] = b"EISA\0";
pub const BUSTYPE_ISA: &[u8; 4usize] = b"ISA\0";
pub const BUSTYPE_INTERN: &[u8; 7usize] = b"INTERN\0";
pub const BUSTYPE_MCA: &[u8; 4usize] = b"MCA\0";
pub const BUSTYPE_VL: &[u8; 3usize] = b"VL\0";
pub const BUSTYPE_PCI: &[u8; 4usize] = b"PCI\0";
pub const BUSTYPE_PCMCIA: &[u8; 7usize] = b"PCMCIA\0";
pub const BUSTYPE_CBUS: &[u8; 5usize] = b"CBUS\0";
pub const BUSTYPE_CBUSII: &[u8; 7usize] = b"CBUSII\0";
pub const BUSTYPE_FUTURE: &[u8; 7usize] = b"FUTURE\0";
pub const BUSTYPE_MBI: &[u8; 4usize] = b"MBI\0";
pub const BUSTYPE_MBII: &[u8; 5usize] = b"MBII\0";
pub const BUSTYPE_MPI: &[u8; 4usize] = b"MPI\0";
pub const BUSTYPE_MPSA: &[u8; 5usize] = b"MPSA\0";
pub const BUSTYPE_NUBUS: &[u8; 6usize] = b"NUBUS\0";
pub const BUSTYPE_TC: &[u8; 3usize] = b"TC\0";
pub const BUSTYPE_VME: &[u8; 4usize] = b"VME\0";
pub const BUSTYPE_XPRESS: &[u8; 7usize] = b"XPRESS\0";
pub const MPC_APIC_USABLE: u32 = 1;
pub const MP_IRQPOL_DEFAULT: u32 = 0;
pub const MP_IRQPOL_ACTIVE_HIGH: u32 = 1;
pub const MP_IRQPOL_RESERVED: u32 = 2;
pub const MP_IRQPOL_ACTIVE_LOW: u32 = 3;
pub const MP_IRQPOL_MASK: u32 = 3;
pub const MP_IRQTRIG_DEFAULT: u32 = 0;
pub const MP_IRQTRIG_EDGE: u32 = 4;
pub const MP_IRQTRIG_RESERVED: u32 = 8;
pub const MP_IRQTRIG_LEVEL: u32 = 12;
pub const MP_IRQTRIG_MASK: u32 = 12;
pub const MP_APIC_ALL: u32 = 255;
pub const MPC_OEM_SIGNATURE: &[u8; 5usize] = b"_OEM\0";
pub const SETUP_NONE: u32 = 0;
pub const SETUP_E820_EXT: u32 = 1;
pub const SETUP_DTB: u32 = 2;
pub const SETUP_PCI: u32 = 3;
pub const SETUP_EFI: u32 = 4;
pub const SETUP_APPLE_PROPERTIES: u32 = 5;
pub const SETUP_JAILHOUSE: u32 = 6;
pub const SETUP_CC_BLOB: u32 = 7;
pub const SETUP_IMA: u32 = 8;
pub const SETUP_RNG_SEED: u32 = 9;
pub const SETUP_ENUM_MAX: u32 = 9;
pub const SETUP_INDIRECT: u32 = 2147483648;
pub const SETUP_TYPE_MAX: u32 = 2147483657;
pub const RAMDISK_IMAGE_START_MASK: u32 = 2047;
pub const RAMDISK_PROMPT_FLAG: u32 = 32768;
pub const RAMDISK_LOAD_FLAG: u32 = 16384;
pub const LOADED_HIGH: u32 = 1;
pub const KASLR_FLAG: u32 = 2;
pub const QUIET_FLAG: u32 = 32;
pub const KEEP_SEGMENTS: u32 = 64;
pub const CAN_USE_HEAP: u32 = 128;
pub const XLF_KERNEL_64: u32 = 1;
pub const XLF_CAN_BE_LOADED_ABOVE_4G: u32 = 2;
pub const XLF_EFI_HANDOVER_32: u32 = 4;
pub const XLF_EFI_HANDOVER_64: u32 = 8;
pub const XLF_EFI_KEXEC: u32 = 16;
pub const XLF_5LEVEL: u32 = 32;
pub const XLF_5LEVEL_ENABLED: u32 = 64;
pub const XLF_MEM_ENCRYPTION: u32 = 128;
pub const VIDEO_TYPE_MDA: u32 = 16;
pub const VIDEO_TYPE_CGA: u32 = 17;
pub const VIDEO_TYPE_EGAM: u32 = 32;
pub const VIDEO_TYPE_EGAC: u32 = 33;
pub const VIDEO_TYPE_VGAC: u32 = 34;
pub const VIDEO_TYPE_VLFB: u32 = 35;
pub const VIDEO_TYPE_PICA_S3: u32 = 48;
pub const VIDEO_TYPE_MIPS_G364: u32 = 49;
pub const VIDEO_TYPE_SGI: u32 = 51;
pub const VIDEO_TYPE_TGAC: u32 = 64;
pub const VIDEO_TYPE_SUN: u32 = 80;
pub const VIDEO_TYPE_SUNPCI: u32 = 81;
pub const VIDEO_TYPE_PMAC: u32 = 96;
pub const VIDEO_TYPE_EFI: u32 = 112;
pub const VIDEO_FLAGS_NOCURSOR: u32 = 1;
pub const VIDEO_CAPABILITY_SKIP_QUIRKS: u32 = 1;
pub const VIDEO_CAPABILITY_64BIT_BASE: u32 = 2;
pub const APM_STATE_READY: u32 = 0;
pub const APM_STATE_STANDBY: u32 = 1;
pub const APM_STATE_SUSPEND: u32 = 2;
pub const APM_STATE_OFF: u32 = 3;
pub const APM_STATE_BUSY: u32 = 4;
pub const APM_STATE_REJECT: u32 = 5;
pub const APM_STATE_OEM_SYS: u32 = 32;
pub const APM_STATE_OEM_DEV: u32 = 64;
pub const APM_STATE_DISABLE: u32 = 0;
pub const APM_STATE_ENABLE: u32 = 1;
pub const APM_STATE_DISENGAGE: u32 = 0;
pub const APM_STATE_ENGAGE: u32 = 1;
pub const APM_SYS_STANDBY: u32 = 1;
pub const APM_SYS_SUSPEND: u32 = 2;
pub const APM_NORMAL_RESUME: u32 = 3;
pub const APM_CRITICAL_RESUME: u32 = 4;
pub const APM_LOW_BATTERY: u32 = 5;
pub const APM_POWER_STATUS_CHANGE: u32 = 6;
pub const APM_UPDATE_TIME: u32 = 7;
pub const APM_CRITICAL_SUSPEND: u32 = 8;
pub const APM_USER_STANDBY: u32 = 9;
pub const APM_USER_SUSPEND: u32 = 10;
pub const APM_STANDBY_RESUME: u32 = 11;
pub const APM_CAPABILITY_CHANGE: u32 = 12;
pub const APM_USER_HIBERNATION: u32 = 13;
pub const APM_HIBERNATION_RESUME: u32 = 14;
pub const APM_SUCCESS: u32 = 0;
pub const APM_DISABLED: u32 = 1;
pub const APM_CONNECTED: u32 = 2;
pub const APM_NOT_CONNECTED: u32 = 3;
pub const APM_16_CONNECTED: u32 = 5;
pub const APM_16_UNSUPPORTED: u32 = 6;
pub const APM_32_CONNECTED: u32 = 7;
pub const APM_32_UNSUPPORTED: u32 = 8;
pub const APM_BAD_DEVICE: u32 = 9;
pub const APM_BAD_PARAM: u32 = 10;
pub const APM_NOT_ENGAGED: u32 = 11;
pub const APM_BAD_FUNCTION: u32 = 12;
pub const APM_RESUME_DISABLED: u32 = 13;
pub const APM_NO_ERROR: u32 = 83;
pub const APM_BAD_STATE: u32 = 96;
pub const APM_NO_EVENTS: u32 = 128;
pub const APM_NOT_PRESENT: u32 = 134;
pub const APM_DEVICE_BIOS: u32 = 0;
pub const APM_DEVICE_ALL: u32 = 1;
pub const APM_DEVICE_DISPLAY: u32 = 256;
pub const APM_DEVICE_STORAGE: u32 = 512;
pub const APM_DEVICE_PARALLEL: u32 = 768;
pub const APM_DEVICE_SERIAL: u32 = 1024;
pub const APM_DEVICE_NETWORK: u32 = 1280;
pub const APM_DEVICE_PCMCIA: u32 = 1536;
pub const APM_DEVICE_BATTERY: u32 = 32768;
pub const APM_DEVICE_OEM: u32 = 57344;
pub const APM_DEVICE_OLD_ALL: u32 = 65535;
pub const APM_DEVICE_CLASS: u32 = 255;
pub const APM_DEVICE_MASK: u32 = 65280;
pub const APM_MAX_BATTERIES: u32 = 2;
pub const APM_CAP_GLOBAL_STANDBY: u32 = 1;
pub const APM_CAP_GLOBAL_SUSPEND: u32 = 2;
pub const APM_CAP_RESUME_STANDBY_TIMER: u32 = 4;
pub const APM_CAP_RESUME_SUSPEND_TIMER: u32 = 8;
pub const APM_CAP_RESUME_STANDBY_RING: u32 = 16;
pub const APM_CAP_RESUME_SUSPEND_RING: u32 = 32;
pub const APM_CAP_RESUME_STANDBY_PCMCIA: u32 = 64;
pub const APM_CAP_RESUME_SUSPEND_PCMCIA: u32 = 128;
pub const APM_16_BIT_SUPPORT: u32 = 1;
pub const APM_32_BIT_SUPPORT: u32 = 2;
pub const APM_IDLE_SLOWS_CLOCK: u32 = 4;
pub const APM_BIOS_DISABLED: u32 = 8;
pub const APM_BIOS_DISENGAGED: u32 = 16;
pub const APM_FUNC_INST_CHECK: u32 = 21248;
pub const APM_FUNC_REAL_CONN: u32 = 21249;
pub const APM_FUNC_16BIT_CONN: u32 = 21250;
pub const APM_FUNC_32BIT_CONN: u32 = 21251;
pub const APM_FUNC_DISCONN: u32 = 21252;
pub const APM_FUNC_IDLE: u32 = 21253;
pub const APM_FUNC_BUSY: u32 = 21254;
pub const APM_FUNC_SET_STATE: u32 = 21255;
pub const APM_FUNC_ENABLE_PM: u32 = 21256;
pub const APM_FUNC_RESTORE_BIOS: u32 = 21257;
pub const APM_FUNC_GET_STATUS: u32 = 21258;
pub const APM_FUNC_GET_EVENT: u32 = 21259;
pub const APM_FUNC_GET_STATE: u32 = 21260;
pub const APM_FUNC_ENABLE_DEV_PM: u32 = 21261;
pub const APM_FUNC_VERSION: u32 = 21262;
pub const APM_FUNC_ENGAGE_PM: u32 = 21263;
pub const APM_FUNC_GET_CAP: u32 = 21264;
pub const APM_FUNC_RESUME_TIMER: u32 = 21265;
pub const APM_FUNC_RESUME_ON_RING: u32 = 21266;
pub const APM_FUNC_TIMER: u32 = 21267;
pub const APM_FUNC_DISABLE_TIMER: u32 = 0;
pub const APM_FUNC_GET_TIMER: u32 = 1;
pub const APM_FUNC_SET_TIMER: u32 = 2;
pub const APM_FUNC_DISABLE_RING: u32 = 0;
pub const APM_FUNC_ENABLE_RING: u32 = 1;
pub const APM_FUNC_GET_RING: u32 = 2;
pub const APM_FUNC_TIMER_DISABLE: u32 = 0;
pub const APM_FUNC_TIMER_ENABLE: u32 = 1;
pub const APM_FUNC_TIMER_GET: u32 = 2;
pub const EDDNR: u32 = 489;
pub const EDDBUF: u32 = 3328;
pub const EDDMAXNR: u32 = 6;
pub const EDDEXTSIZE: u32 = 8;
pub const EDDPARMSIZE: u32 = 74;
pub const CHECKEXTENSIONSPRESENT: u32 = 65;
pub const GETDEVICEPARAMETERS: u32 = 72;
pub const LEGACYGETDEVICEPARAMETERS: u32 = 8;
pub const EDDMAGIC1: u32 = 21930;
pub const EDDMAGIC2: u32 = 43605;
pub const READ_SECTORS: u32 = 2;
pub const EDD_MBR_SIG_OFFSET: u32 = 440;
pub const EDD_MBR_SIG_BUF: u32 = 656;
pub const EDD_MBR_SIG_MAX: u32 = 16;
pub const EDD_MBR_SIG_NR_BUF: u32 = 490;
pub const EDD_EXT_FIXED_DISK_ACCESS: u32 = 1;
pub const EDD_EXT_DEVICE_LOCKING_AND_EJECTING: u32 = 2;
pub const EDD_EXT_ENHANCED_DISK_DRIVE_SUPPORT: u32 = 4;
pub const EDD_EXT_64BIT_EXTENSIONS: u32 = 8;
pub const EDD_INFO_DMA_BOUNDARY_ERROR_TRANSPARENT: u32 = 1;
pub const EDD_INFO_GEOMETRY_VALID: u32 = 2;
pub const EDD_INFO_REMOVABLE: u32 = 4;
pub const EDD_INFO_WRITE_VERIFY: u32 = 8;
pub const EDD_INFO_MEDIA_CHANGE_NOTIFICATION: u32 = 16;
pub const EDD_INFO_LOCKABLE: u32 = 32;
pub const EDD_INFO_NO_MEDIA_PRESENT: u32 = 64;
pub const EDD_INFO_USE_INT13_FN50: u32 = 128;
pub const E820_MAX_ENTRIES_ZEROPAGE: u32 = 128;
pub const JAILHOUSE_SETUP_REQUIRED_VERSION: u32 = 1;
pub const IO_APIC_DEFAULT_PHYS_BASE: u32 = 4273995776;
pub const APIC_DEFAULT_PHYS_BASE: u32 = 4276092928;
pub const IO_APIC_SLOT_SIZE: u32 = 1024;
pub const APIC_DELIVERY_MODE_FIXED: u32 = 0;
pub const APIC_DELIVERY_MODE_LOWESTPRIO: u32 = 1;
pub const APIC_DELIVERY_MODE_SMI: u32 = 2;
pub const APIC_DELIVERY_MODE_NMI: u32 = 4;
pub const APIC_DELIVERY_MODE_INIT: u32 = 5;
pub const APIC_DELIVERY_MODE_EXTINT: u32 = 7;
pub const APIC_ID: u32 = 32;
pub const APIC_LVR: u32 = 48;
pub const APIC_LVR_MASK: u32 = 16711935;
pub const APIC_LVR_DIRECTED_EOI: u32 = 16777216;
pub const APIC_TASKPRI: u32 = 128;
pub const APIC_TPRI_MASK: u32 = 255;
pub const APIC_ARBPRI: u32 = 144;
pub const APIC_ARBPRI_MASK: u32 = 255;
pub const APIC_PROCPRI: u32 = 160;
pub const APIC_EOI: u32 = 176;
pub const APIC_EOI_ACK: u32 = 0;
pub const APIC_RRR: u32 = 192;
pub const APIC_LDR: u32 = 208;
pub const APIC_LDR_MASK: u32 = 4278190080;
pub const APIC_ALL_CPUS: u32 = 255;
pub const APIC_DFR: u32 = 224;
pub const APIC_DFR_CLUSTER: u32 = 268435455;
pub const APIC_DFR_FLAT: u32 = 4294967295;
pub const APIC_SPIV: u32 = 240;
pub const APIC_SPIV_DIRECTED_EOI: u32 = 4096;
pub const APIC_SPIV_FOCUS_DISABLED: u32 = 512;
pub const APIC_SPIV_APIC_ENABLED: u32 = 256;
pub const APIC_ISR: u32 = 256;
pub const APIC_ISR_NR: u32 = 8;
pub const APIC_TMR: u32 = 384;
pub const APIC_IRR: u32 = 512;
pub const APIC_ESR: u32 = 640;
pub const APIC_ESR_SEND_CS: u32 = 1;
pub const APIC_ESR_RECV_CS: u32 = 2;
pub const APIC_ESR_SEND_ACC: u32 = 4;
pub const APIC_ESR_RECV_ACC: u32 = 8;
pub const APIC_ESR_SENDILL: u32 = 32;
pub const APIC_ESR_RECVILL: u32 = 64;
pub const APIC_ESR_ILLREGA: u32 = 128;
pub const APIC_LVTCMCI: u32 = 752;
pub const APIC_ICR: u32 = 768;
pub const APIC_DEST_SELF: u32 = 262144;
pub const APIC_DEST_ALLINC: u32 = 524288;
pub const APIC_DEST_ALLBUT: u32 = 786432;
pub const APIC_ICR_RR_MASK: u32 = 196608;
pub const APIC_ICR_RR_INVALID: u32 = 0;
pub const APIC_ICR_RR_INPROG: u32 = 65536;
pub const APIC_ICR_RR_VALID: u32 = 131072;
pub const APIC_INT_LEVELTRIG: u32 = 32768;
pub const APIC_INT_ASSERT: u32 = 16384;
pub const APIC_ICR_BUSY: u32 = 4096;
pub const APIC_DEST_LOGICAL: u32 = 2048;
pub const APIC_DEST_PHYSICAL: u32 = 0;
pub const APIC_DM_FIXED: u32 = 0;
pub const APIC_DM_FIXED_MASK: u32 = 1792;
pub const APIC_DM_LOWEST: u32 = 256;
pub const APIC_DM_SMI: u32 = 512;
pub const APIC_DM_REMRD: u32 = 768;
pub const APIC_DM_NMI: u32 = 1024;
pub const APIC_DM_INIT: u32 = 1280;
pub const APIC_DM_STARTUP: u32 = 1536;
pub const APIC_DM_EXTINT: u32 = 1792;
pub const APIC_VECTOR_MASK: u32 = 255;
pub const APIC_ICR2: u32 = 784;
pub const APIC_LVTT: u32 = 800;
pub const APIC_LVTTHMR: u32 = 816;
pub const APIC_LVTPC: u32 = 832;
pub const APIC_LVT0: u32 = 848;
pub const APIC_LVT_TIMER_ONESHOT: u32 = 0;
pub const APIC_LVT_TIMER_PERIODIC: u32 = 131072;
pub const APIC_LVT_TIMER_TSCDEADLINE: u32 = 262144;
pub const APIC_LVT_MASKED: u32 = 65536;
pub const APIC_LVT_LEVEL_TRIGGER: u32 = 32768;
pub const APIC_LVT_REMOTE_IRR: u32 = 16384;
pub const APIC_INPUT_POLARITY: u32 = 8192;
pub const APIC_SEND_PENDING: u32 = 4096;
pub const APIC_MODE_MASK: u32 = 1792;
pub const APIC_MODE_FIXED: u32 = 0;
pub const APIC_MODE_NMI: u32 = 4;
pub const APIC_MODE_EXTINT: u32 = 7;
pub const APIC_LVT1: u32 = 864;
pub const APIC_LVTERR: u32 = 880;
pub const APIC_TMICT: u32 = 896;
pub const APIC_TMCCT: u32 = 912;
pub const APIC_TDCR: u32 = 992;
pub const APIC_SELF_IPI: u32 = 1008;
pub const APIC_TDR_DIV_TMBASE: u32 = 4;
pub const APIC_TDR_DIV_1: u32 = 11;
pub const APIC_TDR_DIV_2: u32 = 0;
pub const APIC_TDR_DIV_4: u32 = 1;
pub const APIC_TDR_DIV_8: u32 = 2;
pub const APIC_TDR_DIV_16: u32 = 3;
pub const APIC_TDR_DIV_32: u32 = 8;
pub const APIC_TDR_DIV_64: u32 = 9;
pub const APIC_TDR_DIV_128: u32 = 10;
pub const APIC_EFEAT: u32 = 1024;
pub const APIC_ECTRL: u32 = 1040;
pub const APIC_EILVT_NR_AMD_K8: u32 = 1;
pub const APIC_EILVT_NR_AMD_10H: u32 = 4;
pub const APIC_EILVT_NR_MAX: u32 = 4;
pub const APIC_EILVT_MSG_FIX: u32 = 0;
pub const APIC_EILVT_MSG_SMI: u32 = 2;
pub const APIC_EILVT_MSG_NMI: u32 = 4;
pub const APIC_EILVT_MSG_EXT: u32 = 7;
pub const APIC_EILVT_MASKED: u32 = 65536;
pub const APIC_BASE_MSR: u32 = 2048;
pub const APIC_X2APIC_ID_MSR: u32 = 2050;
pub const MAX_IO_APICS: u32 = 128;
pub const MAX_LOCAL_APIC: u32 = 32768;
pub const XAPIC_DEST_CPUS_SHIFT: u32 = 4;
pub const XAPIC_DEST_CPUS_MASK: u32 = 15;
pub const XAPIC_DEST_CLUSTER_MASK: u32 = 240;
pub const BAD_APICID: u32 = 65535;
pub const MAX_MP_BUSSES: u32 = 256;
pub const MAX_IRQ_SOURCES: u32 = 1024;
pub const LOCAL_DISTANCE: u32 = 10;
pub const REMOTE_DISTANCE: u32 = 20;
pub const DISTANCE_BITS: u32 = 8;
pub const RECLAIM_DISTANCE: u32 = 30;
pub const PENALTY_FOR_NODE_WITH_CPUS: u32 = 1;
pub const GFP_MOVABLE_SHIFT: u32 = 3;
pub const GFP_ZONES_SHIFT: u32 = 2;
pub const CTL_MAXNAME: u32 = 10;
pub const UMH_NO_WAIT: u32 = 0;
pub const UMH_WAIT_EXEC: u32 = 1;
pub const UMH_WAIT_PROC: u32 = 2;
pub const UMH_KILLABLE: u32 = 4;
pub const UMH_FREEZABLE: u32 = 8;
pub const KMOD_PATH_LEN: u32 = 256;
pub const IPC_CREAT: u32 = 512;
pub const IPC_EXCL: u32 = 1024;
pub const IPC_NOWAIT: u32 = 2048;
pub const IPC_DIPC: u32 = 4096;
pub const IPC_OWN: u32 = 8192;
pub const IPC_RMID: u32 = 0;
pub const IPC_SET: u32 = 1;
pub const IPC_STAT: u32 = 2;
pub const IPC_INFO: u32 = 3;
pub const IPC_OLD: u32 = 0;
pub const IPC_64: u32 = 256;
pub const SEMOP: u32 = 1;
pub const SEMGET: u32 = 2;
pub const SEMCTL: u32 = 3;
pub const SEMTIMEDOP: u32 = 4;
pub const MSGSND: u32 = 11;
pub const MSGRCV: u32 = 12;
pub const MSGGET: u32 = 13;
pub const MSGCTL: u32 = 14;
pub const SHMAT: u32 = 21;
pub const SHMDT: u32 = 22;
pub const SHMGET: u32 = 23;
pub const SHMCTL: u32 = 24;
pub const DIPC: u32 = 25;
pub const SEM_UNDO: u32 = 4096;
pub const GETPID: u32 = 11;
pub const GETVAL: u32 = 12;
pub const GETALL: u32 = 13;
pub const GETNCNT: u32 = 14;
pub const GETZCNT: u32 = 15;
pub const SETVAL: u32 = 16;
pub const SETALL: u32 = 17;
pub const SEM_STAT: u32 = 18;
pub const SEM_INFO: u32 = 19;
pub const SEM_STAT_ANY: u32 = 20;
pub const SEMMNI: u32 = 32000;
pub const SEMMSL: u32 = 32000;
pub const SEMMNS: u32 = 1024000000;
pub const SEMOPM: u32 = 500;
pub const SEMVMX: u32 = 32767;
pub const SEMAEM: u32 = 32767;
pub const SEMUME: u32 = 500;
pub const SEMMNU: u32 = 1024000000;
pub const SEMMAP: u32 = 1024000000;
pub const SEMUSZ: u32 = 20;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_PREFER_BUSY_POLL: u32 = 69;
pub const SO_BUSY_POLL_BUDGET: u32 = 70;
pub const SO_NETNS_COOKIE: u32 = 71;
pub const SO_BUF_LOCK: u32 = 72;
pub const SO_RESERVE_MEM: u32 = 73;
pub const SO_TXREHASH: u32 = 74;
pub const SO_RCVMARK: u32 = 75;
pub const SO_PASSPIDFD: u32 = 76;
pub const SO_PEERPIDFD: u32 = 77;
pub const SOCK_IOC_TYPE: u32 = 137;
pub const SIOCGSTAMP: u32 = 35078;
pub const SIOCGSTAMPNS: u32 = 35079;
pub const SIOCADDRT: u32 = 35083;
pub const SIOCDELRT: u32 = 35084;
pub const SIOCRTMSG: u32 = 35085;
pub const SIOCGIFNAME: u32 = 35088;
pub const SIOCSIFLINK: u32 = 35089;
pub const SIOCGIFCONF: u32 = 35090;
pub const SIOCGIFFLAGS: u32 = 35091;
pub const SIOCSIFFLAGS: u32 = 35092;
pub const SIOCGIFADDR: u32 = 35093;
pub const SIOCSIFADDR: u32 = 35094;
pub const SIOCGIFDSTADDR: u32 = 35095;
pub const SIOCSIFDSTADDR: u32 = 35096;
pub const SIOCGIFBRDADDR: u32 = 35097;
pub const SIOCSIFBRDADDR: u32 = 35098;
pub const SIOCGIFNETMASK: u32 = 35099;
pub const SIOCSIFNETMASK: u32 = 35100;
pub const SIOCGIFMETRIC: u32 = 35101;
pub const SIOCSIFMETRIC: u32 = 35102;
pub const SIOCGIFMEM: u32 = 35103;
pub const SIOCSIFMEM: u32 = 35104;
pub const SIOCGIFMTU: u32 = 35105;
pub const SIOCSIFMTU: u32 = 35106;
pub const SIOCSIFNAME: u32 = 35107;
pub const SIOCSIFHWADDR: u32 = 35108;
pub const SIOCGIFENCAP: u32 = 35109;
pub const SIOCSIFENCAP: u32 = 35110;
pub const SIOCGIFHWADDR: u32 = 35111;
pub const SIOCGIFSLAVE: u32 = 35113;
pub const SIOCSIFSLAVE: u32 = 35120;
pub const SIOCADDMULTI: u32 = 35121;
pub const SIOCDELMULTI: u32 = 35122;
pub const SIOCGIFINDEX: u32 = 35123;
pub const SIOGIFINDEX: u32 = 35123;
pub const SIOCSIFPFLAGS: u32 = 35124;
pub const SIOCGIFPFLAGS: u32 = 35125;
pub const SIOCDIFADDR: u32 = 35126;
pub const SIOCSIFHWBROADCAST: u32 = 35127;
pub const SIOCGIFCOUNT: u32 = 35128;
pub const SIOCGIFBR: u32 = 35136;
pub const SIOCSIFBR: u32 = 35137;
pub const SIOCGIFTXQLEN: u32 = 35138;
pub const SIOCSIFTXQLEN: u32 = 35139;
pub const SIOCETHTOOL: u32 = 35142;
pub const SIOCGMIIPHY: u32 = 35143;
pub const SIOCGMIIREG: u32 = 35144;
pub const SIOCSMIIREG: u32 = 35145;
pub const SIOCWANDEV: u32 = 35146;
pub const SIOCOUTQNSD: u32 = 35147;
pub const SIOCGSKNS: u32 = 35148;
pub const SIOCDARP: u32 = 35155;
pub const SIOCGARP: u32 = 35156;
pub const SIOCSARP: u32 = 35157;
pub const SIOCDRARP: u32 = 35168;
pub const SIOCGRARP: u32 = 35169;
pub const SIOCSRARP: u32 = 35170;
pub const SIOCGIFMAP: u32 = 35184;
pub const SIOCSIFMAP: u32 = 35185;
pub const SIOCADDDLCI: u32 = 35200;
pub const SIOCDELDLCI: u32 = 35201;
pub const SIOCGIFVLAN: u32 = 35202;
pub const SIOCSIFVLAN: u32 = 35203;
pub const SIOCBONDENSLAVE: u32 = 35216;
pub const SIOCBONDRELEASE: u32 = 35217;
pub const SIOCBONDSETHWADDR: u32 = 35218;
pub const SIOCBONDSLAVEINFOQUERY: u32 = 35219;
pub const SIOCBONDINFOQUERY: u32 = 35220;
pub const SIOCBONDCHANGEACTIVE: u32 = 35221;
pub const SIOCBRADDBR: u32 = 35232;
pub const SIOCBRDELBR: u32 = 35233;
pub const SIOCBRADDIF: u32 = 35234;
pub const SIOCBRDELIF: u32 = 35235;
pub const SIOCSHWTSTAMP: u32 = 35248;
pub const SIOCGHWTSTAMP: u32 = 35249;
pub const SIOCDEVPRIVATE: u32 = 35312;
pub const SIOCPROTOPRIVATE: u32 = 35296;
pub const UIO_FASTIOV: u32 = 8;
pub const UIO_MAXIOV: u32 = 1024;
pub const ITER_SOURCE: u32 = 1;
pub const ITER_DEST: u32 = 0;
pub const _K_SS_MAXSIZE: u32 = 128;
pub const SOCK_SNDBUF_LOCK: u32 = 1;
pub const SOCK_RCVBUF_LOCK: u32 = 2;
pub const SOCK_BUF_LOCK_MASK: u32 = 3;
pub const SOCK_TXREHASH_DEFAULT: u32 = 255;
pub const SOCK_TXREHASH_DISABLED: u32 = 0;
pub const SOCK_TXREHASH_ENABLED: u32 = 1;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_CREDENTIALS: u32 = 2;
pub const SCM_SECURITY: u32 = 3;
pub const SCM_PIDFD: u32 = 4;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MCTP: u32 = 45;
pub const AF_MAX: u32 = 46;
pub const PF_UNSPEC: u32 = 0;
pub const PF_UNIX: u32 = 1;
pub const PF_LOCAL: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MCTP: u32 = 45;
pub const PF_MAX: u32 = 46;
pub const SOMAXCONN: u32 = 4096;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_TRYHARD: u32 = 4;
pub const MSG_CTRUNC: u32 = 8;
pub const MSG_PROBE: u32 = 16;
pub const MSG_TRUNC: u32 = 32;
pub const MSG_DONTWAIT: u32 = 64;
pub const MSG_EOR: u32 = 128;
pub const MSG_WAITALL: u32 = 256;
pub const MSG_FIN: u32 = 512;
pub const MSG_SYN: u32 = 1024;
pub const MSG_CONFIRM: u32 = 2048;
pub const MSG_RST: u32 = 4096;
pub const MSG_ERRQUEUE: u32 = 8192;
pub const MSG_NOSIGNAL: u32 = 16384;
pub const MSG_MORE: u32 = 32768;
pub const MSG_WAITFORONE: u32 = 65536;
pub const MSG_SENDPAGE_NOPOLICY: u32 = 65536;
pub const MSG_BATCH: u32 = 262144;
pub const MSG_EOF: u32 = 512;
pub const MSG_NO_SHARED_FRAGS: u32 = 524288;
pub const MSG_SENDPAGE_DECRYPTED: u32 = 1048576;
pub const MSG_ZEROCOPY: u32 = 67108864;
pub const MSG_SPLICE_PAGES: u32 = 134217728;
pub const MSG_FASTOPEN: u32 = 536870912;
pub const MSG_CMSG_CLOEXEC: u32 = 1073741824;
pub const MSG_CMSG_COMPAT: u32 = 2147483648;
pub const MSG_INTERNAL_SENDMSG_FLAGS: u32 = 135331840;
pub const SOL_IP: u32 = 0;
pub const SOL_TCP: u32 = 6;
pub const SOL_UDP: u32 = 17;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const SOL_SCTP: u32 = 132;
pub const SOL_UDPLITE: u32 = 136;
pub const SOL_RAW: u32 = 255;
pub const SOL_IPX: u32 = 256;
pub const SOL_AX25: u32 = 257;
pub const SOL_ATALK: u32 = 258;
pub const SOL_NETROM: u32 = 259;
pub const SOL_ROSE: u32 = 260;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOL_MPTCP: u32 = 284;
pub const SOL_MCTP: u32 = 285;
pub const SOL_SMC: u32 = 286;
pub const SOL_VSOCK: u32 = 287;
pub const IPX_TYPE: u32 = 1;
pub const __UAPI_DEF_IF_IFCONF: u32 = 1;
pub const __UAPI_DEF_IF_IFMAP: u32 = 1;
pub const __UAPI_DEF_IF_IFNAMSIZ: u32 = 1;
pub const __UAPI_DEF_IF_IFREQ: u32 = 1;
pub const __UAPI_DEF_IF_NET_DEVICE_FLAGS: u32 = 1;
pub const __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO: u32 = 1;
pub const __UAPI_DEF_IN_ADDR: u32 = 1;
pub const __UAPI_DEF_IN_IPPROTO: u32 = 1;
pub const __UAPI_DEF_IN_PKTINFO: u32 = 1;
pub const __UAPI_DEF_IP_MREQ: u32 = 1;
pub const __UAPI_DEF_SOCKADDR_IN: u32 = 1;
pub const __UAPI_DEF_IN_CLASS: u32 = 1;
pub const __UAPI_DEF_IN6_ADDR: u32 = 1;
pub const __UAPI_DEF_IN6_ADDR_ALT: u32 = 1;
pub const __UAPI_DEF_SOCKADDR_IN6: u32 = 1;
pub const __UAPI_DEF_IPV6_MREQ: u32 = 1;
pub const __UAPI_DEF_IPPROTO_V6: u32 = 1;
pub const __UAPI_DEF_IPV6_OPTIONS: u32 = 1;
pub const __UAPI_DEF_IN6_PKTINFO: u32 = 1;
pub const __UAPI_DEF_IP6_MTUINFO: u32 = 1;
pub const __UAPI_DEF_SOCKADDR_IPX: u32 = 1;
pub const __UAPI_DEF_IPX_ROUTE_DEFINITION: u32 = 1;
pub const __UAPI_DEF_IPX_INTERFACE_DEFINITION: u32 = 1;
pub const __UAPI_DEF_IPX_CONFIG_DATA: u32 = 1;
pub const __UAPI_DEF_IPX_ROUTE_DEF: u32 = 1;
pub const __UAPI_DEF_XATTR: u32 = 1;
pub const IFNAMSIZ: u32 = 16;
pub const IFALIASZ: u32 = 256;
pub const ALTIFNAMSIZ: u32 = 128;
pub const GENERIC_HDLC_VERSION: u32 = 4;
pub const CLOCK_DEFAULT: u32 = 0;
pub const CLOCK_EXT: u32 = 1;
pub const CLOCK_INT: u32 = 2;
pub const CLOCK_TXINT: u32 = 3;
pub const CLOCK_TXFROMRX: u32 = 4;
pub const ENCODING_DEFAULT: u32 = 0;
pub const ENCODING_NRZ: u32 = 1;
pub const ENCODING_NRZI: u32 = 2;
pub const ENCODING_FM_MARK: u32 = 3;
pub const ENCODING_FM_SPACE: u32 = 4;
pub const ENCODING_MANCHESTER: u32 = 5;
pub const PARITY_DEFAULT: u32 = 0;
pub const PARITY_NONE: u32 = 1;
pub const PARITY_CRC16_PR0: u32 = 2;
pub const PARITY_CRC16_PR1: u32 = 3;
pub const PARITY_CRC16_PR0_CCITT: u32 = 4;
pub const PARITY_CRC16_PR1_CCITT: u32 = 5;
pub const PARITY_CRC32_PR0_CCITT: u32 = 6;
pub const PARITY_CRC32_PR1_CCITT: u32 = 7;
pub const LMI_DEFAULT: u32 = 0;
pub const LMI_NONE: u32 = 1;
pub const LMI_ANSI: u32 = 2;
pub const LMI_CCITT: u32 = 3;
pub const LMI_CISCO: u32 = 4;
pub const IF_GET_IFACE: u32 = 1;
pub const IF_GET_PROTO: u32 = 2;
pub const IF_IFACE_V35: u32 = 4096;
pub const IF_IFACE_V24: u32 = 4097;
pub const IF_IFACE_X21: u32 = 4098;
pub const IF_IFACE_T1: u32 = 4099;
pub const IF_IFACE_E1: u32 = 4100;
pub const IF_IFACE_SYNC_SERIAL: u32 = 4101;
pub const IF_IFACE_X21D: u32 = 4102;
pub const IF_PROTO_HDLC: u32 = 8192;
pub const IF_PROTO_PPP: u32 = 8193;
pub const IF_PROTO_CISCO: u32 = 8194;
pub const IF_PROTO_FR: u32 = 8195;
pub const IF_PROTO_FR_ADD_PVC: u32 = 8196;
pub const IF_PROTO_FR_DEL_PVC: u32 = 8197;
pub const IF_PROTO_X25: u32 = 8198;
pub const IF_PROTO_HDLC_ETH: u32 = 8199;
pub const IF_PROTO_FR_ADD_ETH_PVC: u32 = 8200;
pub const IF_PROTO_FR_DEL_ETH_PVC: u32 = 8201;
pub const IF_PROTO_FR_PVC: u32 = 8202;
pub const IF_PROTO_FR_ETH_PVC: u32 = 8203;
pub const IF_PROTO_RAW: u32 = 8204;
pub const IFHWADDRLEN: u32 = 6;
pub const MINORBITS: u32 = 20;
pub const MINORMASK: u32 = 1048575;
pub const LIST_BL_LOCKMASK: u32 = 1;
pub const GOLDEN_RATIO_32: u32 = 1640531527;
pub const GOLDEN_RATIO_64: u64 = 7046029254386353131;
pub const DNAME_INLINE_LEN: u32 = 40;
pub const DCACHE_ENTRY_TYPE: u32 = 7340032;
pub const DCACHE_MISS_TYPE: u32 = 0;
pub const DCACHE_WHITEOUT_TYPE: u32 = 1048576;
pub const DCACHE_DIRECTORY_TYPE: u32 = 2097152;
pub const DCACHE_AUTODIR_TYPE: u32 = 3145728;
pub const DCACHE_REGULAR_TYPE: u32 = 4194304;
pub const DCACHE_SPECIAL_TYPE: u32 = 5242880;
pub const DCACHE_SYMLINK_TYPE: u32 = 6291456;
pub const SHRINKER_UNIT_BITS: u32 = 64;
pub const SHRINK_STOP: i32 = -1;
pub const SHRINK_EMPTY: i32 = -2;
pub const DEFAULT_SEEKS: u32 = 2;
pub const CSIGNAL: u32 = 255;
pub const CLONE_VM: u32 = 256;
pub const CLONE_FS: u32 = 512;
pub const CLONE_FILES: u32 = 1024;
pub const CLONE_SIGHAND: u32 = 2048;
pub const CLONE_PIDFD: u32 = 4096;
pub const CLONE_PTRACE: u32 = 8192;
pub const CLONE_VFORK: u32 = 16384;
pub const CLONE_PARENT: u32 = 32768;
pub const CLONE_THREAD: u32 = 65536;
pub const CLONE_NEWNS: u32 = 131072;
pub const CLONE_SYSVSEM: u32 = 262144;
pub const CLONE_SETTLS: u32 = 524288;
pub const CLONE_PARENT_SETTID: u32 = 1048576;
pub const CLONE_CHILD_CLEARTID: u32 = 2097152;
pub const CLONE_DETACHED: u32 = 4194304;
pub const CLONE_UNTRACED: u32 = 8388608;
pub const CLONE_CHILD_SETTID: u32 = 16777216;
pub const CLONE_NEWCGROUP: u32 = 33554432;
pub const CLONE_NEWUTS: u32 = 67108864;
pub const CLONE_NEWIPC: u32 = 134217728;
pub const CLONE_NEWUSER: u32 = 268435456;
pub const CLONE_NEWPID: u32 = 536870912;
pub const CLONE_NEWNET: u32 = 1073741824;
pub const CLONE_IO: u32 = 2147483648;
pub const CLONE_CLEAR_SIGHAND: u64 = 4294967296;
pub const CLONE_INTO_CGROUP: u64 = 8589934592;
pub const CLONE_NEWTIME: u32 = 128;
pub const CLONE_ARGS_SIZE_VER0: u32 = 64;
pub const CLONE_ARGS_SIZE_VER1: u32 = 80;
pub const CLONE_ARGS_SIZE_VER2: u32 = 88;
pub const SCHED_NORMAL: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_BATCH: u32 = 3;
pub const SCHED_IDLE: u32 = 5;
pub const SCHED_DEADLINE: u32 = 6;
pub const SCHED_RESET_ON_FORK: u32 = 1073741824;
pub const SCHED_FLAG_RESET_ON_FORK: u32 = 1;
pub const SCHED_FLAG_RECLAIM: u32 = 2;
pub const SCHED_FLAG_DL_OVERRUN: u32 = 4;
pub const SCHED_FLAG_KEEP_POLICY: u32 = 8;
pub const SCHED_FLAG_KEEP_PARAMS: u32 = 16;
pub const SCHED_FLAG_UTIL_CLAMP_MIN: u32 = 32;
pub const SCHED_FLAG_UTIL_CLAMP_MAX: u32 = 64;
pub const SCHED_FLAG_KEEP_ALL: u32 = 24;
pub const SCHED_FLAG_UTIL_CLAMP: u32 = 96;
pub const SCHED_FLAG_ALL: u32 = 127;
pub const KMSAN_RETVAL_SIZE: u32 = 800;
pub const KMSAN_PARAM_SIZE: u32 = 800;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_BOTH: i32 = -2;
pub const RUSAGE_THREAD: u32 = 1;
pub const RLIM64_INFINITY: i32 = -1;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const _STK_LIM: u32 = 8388608;
pub const MLOCK_LIMIT: u32 = 8388608;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_NPROC: u32 = 6;
pub const RLIMIT_NOFILE: u32 = 7;
pub const RLIMIT_MEMLOCK: u32 = 8;
pub const RLIMIT_AS: u32 = 9;
pub const RLIMIT_LOCKS: u32 = 10;
pub const RLIMIT_SIGPENDING: u32 = 11;
pub const RLIMIT_MSGQUEUE: u32 = 12;
pub const RLIMIT_NICE: u32 = 13;
pub const RLIMIT_RTPRIO: u32 = 14;
pub const RLIMIT_RTTIME: u32 = 15;
pub const RLIM_NLIMITS: u32 = 16;
pub const RLIM_INFINITY: i32 = -1;
pub const LT_SAVECOUNT: u32 = 32;
pub const LT_BACKTRACEDEPTH: u32 = 12;
pub const MAX_NICE: u32 = 19;
pub const MIN_NICE: i32 = -20;
pub const NICE_WIDTH: u32 = 40;
pub const MAX_RT_PRIO: u32 = 100;
pub const MAX_PRIO: u32 = 140;
pub const DEFAULT_PRIO: u32 = 120;
pub const _NSIG: u32 = 64;
pub const _NSIG_BPW: u32 = 64;
pub const _NSIG_WORDS: u32 = 1;
pub const SA_IA32_ABI: u32 = 33554432;
pub const SA_X32_ABI: u32 = 16777216;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGBUS: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGUSR1: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGUSR2: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGSTKFLT: u32 = 16;
pub const SIGCHLD: u32 = 17;
pub const SIGCONT: u32 = 18;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGURG: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGPOLL: u32 = 29;
pub const SIGPWR: u32 = 30;
pub const SIGSYS: u32 = 31;
pub const SIGUNUSED: u32 = 31;
pub const SIGRTMIN: u32 = 32;
pub const SIGRTMAX: u32 = 64;
pub const SA_RESTORER: u32 = 67108864;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_UNSUPPORTED: u32 = 1024;
pub const SA_EXPOSE_TAGBITS: u32 = 2048;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const SI_MAX_SIZE: u32 = 128;
pub const SI_USER: u32 = 0;
pub const SI_KERNEL: u32 = 128;
pub const SI_QUEUE: i32 = -1;
pub const SI_TIMER: i32 = -2;
pub const SI_MESGQ: i32 = -3;
pub const SI_ASYNCIO: i32 = -4;
pub const SI_SIGIO: i32 = -5;
pub const SI_TKILL: i32 = -6;
pub const SI_DETHREAD: i32 = -7;
pub const SI_ASYNCNL: i32 = -60;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLOPN: u32 = 2;
pub const ILL_ILLADR: u32 = 3;
pub const ILL_ILLTRP: u32 = 4;
pub const ILL_PRVOPC: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const ILL_BADIADDR: u32 = 9;
pub const __ILL_BREAK: u32 = 10;
pub const __ILL_BNDMOD: u32 = 11;
pub const NSIGILL: u32 = 11;
pub const FPE_INTDIV: u32 = 1;
pub const FPE_INTOVF: u32 = 2;
pub const FPE_FLTDIV: u32 = 3;
pub const FPE_FLTOVF: u32 = 4;
pub const FPE_FLTUND: u32 = 5;
pub const FPE_FLTRES: u32 = 6;
pub const FPE_FLTINV: u32 = 7;
pub const FPE_FLTSUB: u32 = 8;
pub const __FPE_DECOVF: u32 = 9;
pub const __FPE_DECDIV: u32 = 10;
pub const __FPE_DECERR: u32 = 11;
pub const __FPE_INVASC: u32 = 12;
pub const __FPE_INVDEC: u32 = 13;
pub const FPE_FLTUNK: u32 = 14;
pub const FPE_CONDTRAP: u32 = 15;
pub const NSIGFPE: u32 = 15;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const SEGV_BNDERR: u32 = 3;
pub const SEGV_PKUERR: u32 = 4;
pub const SEGV_ACCADI: u32 = 5;
pub const SEGV_ADIDERR: u32 = 6;
pub const SEGV_ADIPERR: u32 = 7;
pub const SEGV_MTEAERR: u32 = 8;
pub const SEGV_MTESERR: u32 = 9;
pub const SEGV_CPERR: u32 = 10;
pub const NSIGSEGV: u32 = 10;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const BUS_MCEERR_AR: u32 = 4;
pub const BUS_MCEERR_AO: u32 = 5;
pub const NSIGBUS: u32 = 5;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const TRAP_BRANCH: u32 = 3;
pub const TRAP_HWBKPT: u32 = 4;
pub const TRAP_UNK: u32 = 5;
pub const TRAP_PERF: u32 = 6;
pub const NSIGTRAP: u32 = 6;
pub const TRAP_PERF_FLAG_ASYNC: u32 = 1;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const NSIGCHLD: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const NSIGPOLL: u32 = 6;
pub const SYS_SECCOMP: u32 = 1;
pub const SYS_USER_DISPATCH: u32 = 2;
pub const NSIGSYS: u32 = 2;
pub const EMT_TAGOVF: u32 = 1;
pub const NSIGEMT: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 0;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_THREAD: u32 = 2;
pub const SIGEV_THREAD_ID: u32 = 4;
pub const SIGEV_MAX_SIZE: u32 = 64;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SS_AUTODISARM: u32 = 2147483648;
pub const SS_FLAG_BITS: u32 = 2147483648;
pub const SIGQUEUE_PREALLOC: u32 = 1;
pub const SA_IMMUTABLE: u32 = 8388608;
pub const __ARCH_UAPI_SA_FLAGS: u32 = 67108864;
pub const UAPI_SA_FLAGS: u32 = 3690989575;
pub const CPUCLOCK_PERTHREAD_MASK: u32 = 4;
pub const CPUCLOCK_CLOCK_MASK: u32 = 3;
pub const CPUCLOCK_PROF: u32 = 0;
pub const CPUCLOCK_VIRT: u32 = 1;
pub const CPUCLOCK_SCHED: u32 = 2;
pub const CPUCLOCK_MAX: u32 = 3;
pub const CLOCKFD: u32 = 3;
pub const CLOCKFD_MASK: u32 = 7;
pub const MAX_DA_NAME_LEN: u32 = 24;
pub const RV_PER_TASK_MONITORS: u32 = 1;
pub const RV_PER_TASK_MONITOR_INIT: u32 = 1;
pub const KM_MAX_IDX: u32 = 16;
pub const TASK_RUNNING: u32 = 0;
pub const TASK_INTERRUPTIBLE: u32 = 1;
pub const TASK_UNINTERRUPTIBLE: u32 = 2;
pub const __TASK_STOPPED: u32 = 4;
pub const __TASK_TRACED: u32 = 8;
pub const EXIT_DEAD: u32 = 16;
pub const EXIT_ZOMBIE: u32 = 32;
pub const EXIT_TRACE: u32 = 48;
pub const TASK_PARKED: u32 = 64;
pub const TASK_DEAD: u32 = 128;
pub const TASK_WAKEKILL: u32 = 256;
pub const TASK_WAKING: u32 = 512;
pub const TASK_NOLOAD: u32 = 1024;
pub const TASK_NEW: u32 = 2048;
pub const TASK_RTLOCK_WAIT: u32 = 4096;
pub const TASK_FREEZABLE: u32 = 8192;
pub const TASK_FROZEN: u32 = 32768;
pub const TASK_STATE_MAX: u32 = 65536;
pub const TASK_ANY: u32 = 65535;
pub const TASK_KILLABLE: u32 = 258;
pub const TASK_STOPPED: u32 = 260;
pub const TASK_TRACED: u32 = 8;
pub const TASK_IDLE: u32 = 1026;
pub const TASK_NORMAL: u32 = 3;
pub const TASK_REPORT: u32 = 127;
pub const SCHED_FIXEDPOINT_SHIFT: u32 = 10;
pub const SCHED_FIXEDPOINT_SCALE: u32 = 1024;
pub const SCHED_CAPACITY_SHIFT: u32 = 10;
pub const SCHED_CAPACITY_SCALE: u32 = 1024;
pub const UTIL_EST_WEIGHT_SHIFT: u32 = 2;
pub const UTIL_AVG_UNCHANGED: u32 = 2147483648;
pub const UCLAMP_BUCKETS: u32 = 5;
pub const TASK_REPORT_IDLE: u32 = 128;
pub const TASK_REPORT_MAX: u32 = 256;
pub const PF_VCPU: u32 = 1;
pub const PF_IDLE: u32 = 2;
pub const PF_EXITING: u32 = 4;
pub const PF_POSTCOREDUMP: u32 = 8;
pub const PF_IO_WORKER: u32 = 16;
pub const PF_WQ_WORKER: u32 = 32;
pub const PF_FORKNOEXEC: u32 = 64;
pub const PF_MCE_PROCESS: u32 = 128;
pub const PF_SUPERPRIV: u32 = 256;
pub const PF_DUMPCORE: u32 = 512;
pub const PF_SIGNALED: u32 = 1024;
pub const PF_MEMALLOC: u32 = 2048;
pub const PF_NPROC_EXCEEDED: u32 = 4096;
pub const PF_USED_MATH: u32 = 8192;
pub const PF_USER_WORKER: u32 = 16384;
pub const PF_NOFREEZE: u32 = 32768;
pub const PF__HOLE__00010000: u32 = 65536;
pub const PF_KSWAPD: u32 = 131072;
pub const PF_MEMALLOC_NOFS: u32 = 262144;
pub const PF_MEMALLOC_NOIO: u32 = 524288;
pub const PF_LOCAL_THROTTLE: u32 = 1048576;
pub const PF_KTHREAD: u32 = 2097152;
pub const PF_RANDOMIZE: u32 = 4194304;
pub const PF__HOLE__00800000: u32 = 8388608;
pub const PF__HOLE__01000000: u32 = 16777216;
pub const PF__HOLE__02000000: u32 = 33554432;
pub const PF_NO_SETAFFINITY: u32 = 67108864;
pub const PF_MCE_EARLY: u32 = 134217728;
pub const PF_MEMALLOC_PIN: u32 = 268435456;
pub const PF__HOLE__20000000: u32 = 536870912;
pub const PF__HOLE__40000000: u32 = 1073741824;
pub const PF_SUSPEND_TASK: u32 = 2147483648;
pub const PFA_NO_NEW_PRIVS: u32 = 0;
pub const PFA_SPREAD_PAGE: u32 = 1;
pub const PFA_SPREAD_SLAB: u32 = 2;
pub const PFA_SPEC_SSB_DISABLE: u32 = 3;
pub const PFA_SPEC_SSB_FORCE_DISABLE: u32 = 4;
pub const PFA_SPEC_IB_DISABLE: u32 = 5;
pub const PFA_SPEC_IB_FORCE_DISABLE: u32 = 6;
pub const PFA_SPEC_SSB_NOEXEC: u32 = 7;
pub const MIGHT_RESCHED_RCU_SHIFT: u32 = 8;
pub const MIGHT_RESCHED_PREEMPT_MASK: u32 = 255;
pub const PREEMPT_LOCK_RESCHED_OFFSETS: u32 = 1;
pub const BITS_PER_XA_VALUE: u32 = 63;
pub const XA_MAX_MARKS: u32 = 3;
pub const RADIX_TREE_ENTRY_MASK: u32 = 3;
pub const RADIX_TREE_INTERNAL_NODE: u32 = 2;
pub const RADIX_TREE_MAX_TAGS: u32 = 3;
pub const _LINUX_CAPABILITY_VERSION_1: u32 = 429392688;
pub const _LINUX_CAPABILITY_U32S_1: u32 = 1;
pub const _LINUX_CAPABILITY_VERSION_2: u32 = 537333798;
pub const _LINUX_CAPABILITY_U32S_2: u32 = 2;
pub const _LINUX_CAPABILITY_VERSION_3: u32 = 537396514;
pub const _LINUX_CAPABILITY_U32S_3: u32 = 2;
pub const VFS_CAP_REVISION_MASK: u32 = 4278190080;
pub const VFS_CAP_REVISION_SHIFT: u32 = 24;
pub const VFS_CAP_FLAGS_MASK: i64 = -4278190081;
pub const VFS_CAP_FLAGS_EFFECTIVE: u32 = 1;
pub const VFS_CAP_REVISION_1: u32 = 16777216;
pub const VFS_CAP_U32_1: u32 = 1;
pub const VFS_CAP_REVISION_2: u32 = 33554432;
pub const VFS_CAP_U32_2: u32 = 2;
pub const VFS_CAP_REVISION_3: u32 = 50331648;
pub const VFS_CAP_U32_3: u32 = 2;
pub const VFS_CAP_U32: u32 = 2;
pub const VFS_CAP_REVISION: u32 = 50331648;
pub const CAP_CHOWN: u32 = 0;
pub const CAP_DAC_OVERRIDE: u32 = 1;
pub const CAP_DAC_READ_SEARCH: u32 = 2;
pub const CAP_FOWNER: u32 = 3;
pub const CAP_FSETID: u32 = 4;
pub const CAP_KILL: u32 = 5;
pub const CAP_SETGID: u32 = 6;
pub const CAP_SETUID: u32 = 7;
pub const CAP_SETPCAP: u32 = 8;
pub const CAP_LINUX_IMMUTABLE: u32 = 9;
pub const CAP_NET_BIND_SERVICE: u32 = 10;
pub const CAP_NET_BROADCAST: u32 = 11;
pub const CAP_NET_ADMIN: u32 = 12;
pub const CAP_NET_RAW: u32 = 13;
pub const CAP_IPC_LOCK: u32 = 14;
pub const CAP_IPC_OWNER: u32 = 15;
pub const CAP_SYS_MODULE: u32 = 16;
pub const CAP_SYS_RAWIO: u32 = 17;
pub const CAP_SYS_CHROOT: u32 = 18;
pub const CAP_SYS_PTRACE: u32 = 19;
pub const CAP_SYS_PACCT: u32 = 20;
pub const CAP_SYS_ADMIN: u32 = 21;
pub const CAP_SYS_BOOT: u32 = 22;
pub const CAP_SYS_NICE: u32 = 23;
pub const CAP_SYS_RESOURCE: u32 = 24;
pub const CAP_SYS_TIME: u32 = 25;
pub const CAP_SYS_TTY_CONFIG: u32 = 26;
pub const CAP_MKNOD: u32 = 27;
pub const CAP_LEASE: u32 = 28;
pub const CAP_AUDIT_WRITE: u32 = 29;
pub const CAP_AUDIT_CONTROL: u32 = 30;
pub const CAP_SETFCAP: u32 = 31;
pub const CAP_MAC_OVERRIDE: u32 = 32;
pub const CAP_MAC_ADMIN: u32 = 33;
pub const CAP_SYSLOG: u32 = 34;
pub const CAP_WAKE_ALARM: u32 = 35;
pub const CAP_BLOCK_SUSPEND: u32 = 36;
pub const CAP_AUDIT_READ: u32 = 37;
pub const CAP_PERFMON: u32 = 38;
pub const CAP_BPF: u32 = 39;
pub const CAP_CHECKPOINT_RESTORE: u32 = 40;
pub const CAP_LAST_CAP: u32 = 40;
pub const _KERNEL_CAPABILITY_VERSION: u32 = 537396514;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_DSYNC: u32 = 4096;
pub const FASYNC: u32 = 8192;
pub const O_DIRECT: u32 = 16384;
pub const O_LARGEFILE: u32 = 32768;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_NOATIME: u32 = 262144;
pub const O_CLOEXEC: u32 = 524288;
pub const __O_SYNC: u32 = 1048576;
pub const O_SYNC: u32 = 1052672;
pub const O_PATH: u32 = 2097152;
pub const __O_TMPFILE: u32 = 4194304;
pub const O_TMPFILE: u32 = 4259840;
pub const O_NDELAY: u32 = 2048;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const F_SETSIG: u32 = 10;
pub const F_GETSIG: u32 = 11;
pub const F_GETLK64: u32 = 12;
pub const F_SETLK64: u32 = 13;
pub const F_SETLKW64: u32 = 14;
pub const F_SETOWN_EX: u32 = 15;
pub const F_GETOWN_EX: u32 = 16;
pub const F_GETOWNER_UIDS: u32 = 17;
pub const F_OFD_GETLK: u32 = 36;
pub const F_OFD_SETLK: u32 = 37;
pub const F_OFD_SETLKW: u32 = 38;
pub const F_OWNER_TID: u32 = 0;
pub const F_OWNER_PID: u32 = 1;
pub const F_OWNER_PGRP: u32 = 2;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const LOCK_MAND: u32 = 32;
pub const LOCK_READ: u32 = 64;
pub const LOCK_WRITE: u32 = 128;
pub const LOCK_RW: u32 = 192;
pub const F_LINUX_SPECIFIC_BASE: u32 = 1024;
pub const RESOLVE_NO_XDEV: u32 = 1;
pub const RESOLVE_NO_MAGICLINKS: u32 = 2;
pub const RESOLVE_NO_SYMLINKS: u32 = 4;
pub const RESOLVE_BENEATH: u32 = 8;
pub const RESOLVE_IN_ROOT: u32 = 16;
pub const RESOLVE_CACHED: u32 = 32;
pub const F_SETLEASE: u32 = 1024;
pub const F_GETLEASE: u32 = 1025;
pub const F_CANCELLK: u32 = 1029;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const F_NOTIFY: u32 = 1026;
pub const F_SETPIPE_SZ: u32 = 1031;
pub const F_GETPIPE_SZ: u32 = 1032;
pub const F_ADD_SEALS: u32 = 1033;
pub const F_GET_SEALS: u32 = 1034;
pub const F_SEAL_SEAL: u32 = 1;
pub const F_SEAL_SHRINK: u32 = 2;
pub const F_SEAL_GROW: u32 = 4;
pub const F_SEAL_WRITE: u32 = 8;
pub const F_SEAL_FUTURE_WRITE: u32 = 16;
pub const F_SEAL_EXEC: u32 = 32;
pub const F_GET_RW_HINT: u32 = 1035;
pub const F_SET_RW_HINT: u32 = 1036;
pub const F_GET_FILE_RW_HINT: u32 = 1037;
pub const F_SET_FILE_RW_HINT: u32 = 1038;
pub const RWH_WRITE_LIFE_NOT_SET: u32 = 0;
pub const RWH_WRITE_LIFE_NONE: u32 = 1;
pub const RWH_WRITE_LIFE_SHORT: u32 = 2;
pub const RWH_WRITE_LIFE_MEDIUM: u32 = 3;
pub const RWH_WRITE_LIFE_LONG: u32 = 4;
pub const RWH_WRITE_LIFE_EXTREME: u32 = 5;
pub const RWF_WRITE_LIFE_NOT_SET: u32 = 0;
pub const DN_ACCESS: u32 = 1;
pub const DN_MODIFY: u32 = 2;
pub const DN_CREATE: u32 = 4;
pub const DN_DELETE: u32 = 8;
pub const DN_RENAME: u32 = 16;
pub const DN_ATTRIB: u32 = 32;
pub const DN_MULTISHOT: u32 = 2147483648;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_EACCESS: u32 = 512;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_NO_AUTOMOUNT: u32 = 2048;
pub const AT_EMPTY_PATH: u32 = 4096;
pub const AT_STATX_SYNC_TYPE: u32 = 24576;
pub const AT_STATX_SYNC_AS_STAT: u32 = 0;
pub const AT_STATX_FORCE_SYNC: u32 = 8192;
pub const AT_STATX_DONT_SYNC: u32 = 16384;
pub const AT_RECURSIVE: u32 = 32768;
pub const AT_HANDLE_FID: u32 = 512;
pub const AT_GETATTR_NOSEC: u32 = 2147483648;
pub const VALID_OPEN_FLAGS: u32 = 8388547;
pub const VALID_RESOLVE_FLAGS: u32 = 63;
pub const OPEN_HOW_SIZE_VER0: u32 = 24;
pub const OPEN_HOW_SIZE_LATEST: u32 = 24;
pub const SIGEMT_MASK: u32 = 0;
pub const JOBCTL_STOP_SIGMASK: u32 = 65535;
pub const JOBCTL_STOP_DEQUEUED_BIT: u32 = 16;
pub const JOBCTL_STOP_PENDING_BIT: u32 = 17;
pub const JOBCTL_STOP_CONSUME_BIT: u32 = 18;
pub const JOBCTL_TRAP_STOP_BIT: u32 = 19;
pub const JOBCTL_TRAP_NOTIFY_BIT: u32 = 20;
pub const JOBCTL_TRAPPING_BIT: u32 = 21;
pub const JOBCTL_LISTENING_BIT: u32 = 22;
pub const JOBCTL_TRAP_FREEZE_BIT: u32 = 23;
pub const JOBCTL_PTRACE_FROZEN_BIT: u32 = 24;
pub const JOBCTL_STOPPED_BIT: u32 = 26;
pub const JOBCTL_TRACED_BIT: u32 = 27;
pub const JOBCTL_STOP_DEQUEUED: u32 = 65536;
pub const JOBCTL_STOP_PENDING: u32 = 131072;
pub const JOBCTL_STOP_CONSUME: u32 = 262144;
pub const JOBCTL_TRAP_STOP: u32 = 524288;
pub const JOBCTL_TRAP_NOTIFY: u32 = 1048576;
pub const JOBCTL_TRAPPING: u32 = 2097152;
pub const JOBCTL_LISTENING: u32 = 4194304;
pub const JOBCTL_TRAP_FREEZE: u32 = 8388608;
pub const JOBCTL_PTRACE_FROZEN: u32 = 16777216;
pub const JOBCTL_STOPPED: u32 = 67108864;
pub const JOBCTL_TRACED: u32 = 134217728;
pub const JOBCTL_TRAP_MASK: u32 = 1572864;
pub const JOBCTL_PENDING_MASK: u32 = 1703936;
pub const __ASM_CLAC: &[u8; 21usize] = b".byte 0x0f,0x01,0xca\0";
pub const __ASM_STAC: &[u8; 21usize] = b".byte 0x0f,0x01,0xcb\0";
pub const MMU_NOTIFIER_RANGE_BLOCKABLE: u32 = 1;
pub const INVPCID_TYPE_INDIV_ADDR: u32 = 0;
pub const INVPCID_TYPE_SINGLE_CTXT: u32 = 1;
pub const INVPCID_TYPE_ALL_INCL_GLOBAL: u32 = 2;
pub const INVPCID_TYPE_ALL_NON_GLOBAL: u32 = 3;
pub const PKRU_AD_BIT: u32 = 1;
pub const PKRU_WD_BIT: u32 = 2;
pub const PKRU_BITS_PER_PKEY: u32 = 2;
pub const PFN_PTE_SHIFT: u32 = 12;
pub const FIXMAP_PMD_NUM: u32 = 2;
pub const FIXMAP_PMD_TOP: u32 = 507;
pub const VSYSCALL_ADDR: i32 = -10485760;
pub const NR_FIX_BTMAPS: u32 = 64;
pub const FIX_BTMAPS_SLOTS: u32 = 8;
pub const TOTAL_FIX_BTMAPS: u32 = 512;
pub const SWP_TYPE_BITS: u32 = 5;
pub const SWP_OFFSET_FIRST_BIT: u32 = 9;
pub const SWP_OFFSET_SHIFT: u32 = 14;
pub const HAVE_PAGE_AGP: u32 = 1;
pub const _ASM_PGTABLE_INVERT_H: u32 = 1;
pub const PTI_PGTABLE_SWITCH_BIT: u32 = 12;
pub const __HAVE_ARCH_PFN_MODIFY_ALLOWED: u32 = 1;
pub const TLB_FLUSH_ALL: i32 = -1;
pub const TLB_GENERATION_INVALID: u32 = 0;
pub const ARCH_HAS_NOCACHE_UACCESS: u32 = 1;
pub const CLONE_LEGACY_FLAGS: u32 = 4294967295;
pub const ASSOC_ARRAY_KEY_CHUNK_SIZE: u32 = 64;
pub const KEY_POS_VIEW: u32 = 16777216;
pub const KEY_POS_READ: u32 = 33554432;
pub const KEY_POS_WRITE: u32 = 67108864;
pub const KEY_POS_SEARCH: u32 = 134217728;
pub const KEY_POS_LINK: u32 = 268435456;
pub const KEY_POS_SETATTR: u32 = 536870912;
pub const KEY_POS_ALL: u32 = 1056964608;
pub const KEY_USR_VIEW: u32 = 65536;
pub const KEY_USR_READ: u32 = 131072;
pub const KEY_USR_WRITE: u32 = 262144;
pub const KEY_USR_SEARCH: u32 = 524288;
pub const KEY_USR_LINK: u32 = 1048576;
pub const KEY_USR_SETATTR: u32 = 2097152;
pub const KEY_USR_ALL: u32 = 4128768;
pub const KEY_GRP_VIEW: u32 = 256;
pub const KEY_GRP_READ: u32 = 512;
pub const KEY_GRP_WRITE: u32 = 1024;
pub const KEY_GRP_SEARCH: u32 = 2048;
pub const KEY_GRP_LINK: u32 = 4096;
pub const KEY_GRP_SETATTR: u32 = 8192;
pub const KEY_GRP_ALL: u32 = 16128;
pub const KEY_OTH_VIEW: u32 = 1;
pub const KEY_OTH_READ: u32 = 2;
pub const KEY_OTH_WRITE: u32 = 4;
pub const KEY_OTH_SEARCH: u32 = 8;
pub const KEY_OTH_LINK: u32 = 16;
pub const KEY_OTH_SETATTR: u32 = 32;
pub const KEY_OTH_ALL: u32 = 63;
pub const KEY_PERM_UNDEF: u32 = 4294967295;
pub const KEY_FLAG_DEAD: u32 = 0;
pub const KEY_FLAG_REVOKED: u32 = 1;
pub const KEY_FLAG_IN_QUOTA: u32 = 2;
pub const KEY_FLAG_USER_CONSTRUCT: u32 = 3;
pub const KEY_FLAG_ROOT_CAN_CLEAR: u32 = 4;
pub const KEY_FLAG_INVALIDATED: u32 = 5;
pub const KEY_FLAG_BUILTIN: u32 = 6;
pub const KEY_FLAG_ROOT_CAN_INVAL: u32 = 7;
pub const KEY_FLAG_KEEP: u32 = 8;
pub const KEY_FLAG_UID_KEYRING: u32 = 9;
pub const KEY_ALLOC_IN_QUOTA: u32 = 0;
pub const KEY_ALLOC_QUOTA_OVERRUN: u32 = 1;
pub const KEY_ALLOC_NOT_IN_QUOTA: u32 = 2;
pub const KEY_ALLOC_BUILT_IN: u32 = 4;
pub const KEY_ALLOC_BYPASS_RESTRICTION: u32 = 8;
pub const KEY_ALLOC_UID_KEYRING: u32 = 16;
pub const KEY_ALLOC_SET_KEEP: u32 = 32;
pub const HIGH_RES_NSEC: u32 = 1;
pub const KTIME_HIGH_RES: u32 = 1;
pub const MONOTONIC_RES_NSEC: u32 = 1;
pub const KTIME_MONOTONIC_RES: u32 = 1;
pub const HRTIMER_STATE_INACTIVE: u32 = 0;
pub const HRTIMER_STATE_ENQUEUED: u32 = 1;
pub const ALARMTIMER_STATE_INACTIVE: u32 = 0;
pub const ALARMTIMER_STATE_ENQUEUED: u32 = 1;
pub const REQUEUE_PENDING: u32 = 1;
pub const SIGNAL_STOP_STOPPED: u32 = 1;
pub const SIGNAL_STOP_CONTINUED: u32 = 2;
pub const SIGNAL_GROUP_EXIT: u32 = 4;
pub const SIGNAL_CLD_STOPPED: u32 = 16;
pub const SIGNAL_CLD_CONTINUED: u32 = 32;
pub const SIGNAL_CLD_MASK: u32 = 48;
pub const SIGNAL_UNKILLABLE: u32 = 64;
pub const SIGNAL_STOP_MASK: u32 = 51;
pub const UUID_SIZE: u32 = 16;
pub const UUID_STRING_LEN: u32 = 36;
pub const RR_TIMESLICE: u32 = 100;
pub const IOPRIO_CLASS_SHIFT: u32 = 13;
pub const IOPRIO_NR_CLASSES: u32 = 8;
pub const IOPRIO_CLASS_MASK: u32 = 7;
pub const IOPRIO_PRIO_MASK: u32 = 8191;
pub const IOPRIO_LEVEL_NR_BITS: u32 = 3;
pub const IOPRIO_NR_LEVELS: u32 = 8;
pub const IOPRIO_LEVEL_MASK: u32 = 7;
pub const IOPRIO_BE_NR: u32 = 8;
pub const IOPRIO_NORM: u32 = 4;
pub const IOPRIO_BE_NORM: u32 = 4;
pub const IOPRIO_HINT_SHIFT: u32 = 3;
pub const IOPRIO_HINT_NR_BITS: u32 = 10;
pub const IOPRIO_NR_HINTS: u32 = 1024;
pub const IOPRIO_HINT_MASK: u32 = 1023;
pub const S_DT_SHIFT: u32 = 12;
pub const S_DT_MASK: u32 = 15;
pub const DT_UNKNOWN: u32 = 0;
pub const DT_FIFO: u32 = 1;
pub const DT_CHR: u32 = 2;
pub const DT_DIR: u32 = 4;
pub const DT_BLK: u32 = 6;
pub const DT_REG: u32 = 8;
pub const DT_LNK: u32 = 10;
pub const DT_SOCK: u32 = 12;
pub const DT_WHT: u32 = 14;
pub const DT_MAX: u32 = 16;
pub const FT_UNKNOWN: u32 = 0;
pub const FT_REG_FILE: u32 = 1;
pub const FT_DIR: u32 = 2;
pub const FT_CHRDEV: u32 = 3;
pub const FT_BLKDEV: u32 = 4;
pub const FT_FIFO: u32 = 5;
pub const FT_SOCK: u32 = 6;
pub const FT_SYMLINK: u32 = 7;
pub const FT_MAX: u32 = 8;
pub const MNT_NOSUID: u32 = 1;
pub const MNT_NODEV: u32 = 2;
pub const MNT_NOEXEC: u32 = 4;
pub const MNT_NOATIME: u32 = 8;
pub const MNT_NODIRATIME: u32 = 16;
pub const MNT_RELATIME: u32 = 32;
pub const MNT_READONLY: u32 = 64;
pub const MNT_NOSYMFOLLOW: u32 = 128;
pub const MNT_SHRINKABLE: u32 = 256;
pub const MNT_WRITE_HOLD: u32 = 512;
pub const MNT_SHARED: u32 = 4096;
pub const MNT_UNBINDABLE: u32 = 8192;
pub const MNT_SHARED_MASK: u32 = 8192;
pub const MNT_USER_SETTABLE_MASK: u32 = 255;
pub const MNT_ATIME_MASK: u32 = 56;
pub const MNT_INTERNAL: u32 = 16384;
pub const MNT_LOCK_ATIME: u32 = 262144;
pub const MNT_LOCK_NOEXEC: u32 = 524288;
pub const MNT_LOCK_NOSUID: u32 = 1048576;
pub const MNT_LOCK_NODEV: u32 = 2097152;
pub const MNT_LOCK_READONLY: u32 = 4194304;
pub const MNT_LOCKED: u32 = 8388608;
pub const MNT_DOOMED: u32 = 16777216;
pub const MNT_SYNC_UMOUNT: u32 = 33554432;
pub const MNT_MARKED: u32 = 67108864;
pub const MNT_UMOUNT: u32 = 134217728;
pub const MNT_ONRB: u32 = 268435456;
pub const SLAB_DEBUG_OBJECTS: u32 = 0;
pub const SLAB_FAILSLAB: u32 = 0;
pub const SLAB_KASAN: u32 = 0;
pub const KASAN_TAG_KERNEL: u32 = 255;
pub const KASAN_TAG_INVALID: u32 = 254;
pub const KASAN_TAG_MAX: u32 = 253;
pub const KASAN_TAG_MIN: u32 = 0;
pub const KMALLOC_SHIFT_HIGH: u32 = 13;
pub const KMALLOC_SHIFT_MAX: u32 = 22;
pub const KMALLOC_SHIFT_LOW: u32 = 3;
pub const KMALLOC_MAX_SIZE: u32 = 4194304;
pub const KMALLOC_MAX_CACHE_SIZE: u32 = 8192;
pub const KMALLOC_MAX_ORDER: u32 = 10;
pub const KMALLOC_MIN_SIZE: u32 = 8;
pub const RANDOM_KMALLOC_CACHES_NR: u32 = 15;
pub const INR_OPEN_CUR: u32 = 1024;
pub const INR_OPEN_MAX: u32 = 4096;
pub const BLOCK_SIZE_BITS: u32 = 10;
pub const BLOCK_SIZE: u32 = 1024;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const SEEK_MAX: u32 = 4;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const FILE_DEDUPE_RANGE_SAME: u32 = 0;
pub const FILE_DEDUPE_RANGE_DIFFERS: u32 = 1;
pub const NR_FILE: u32 = 8192;
pub const FS_XFLAG_REALTIME: u32 = 1;
pub const FS_XFLAG_PREALLOC: u32 = 2;
pub const FS_XFLAG_IMMUTABLE: u32 = 8;
pub const FS_XFLAG_APPEND: u32 = 16;
pub const FS_XFLAG_SYNC: u32 = 32;
pub const FS_XFLAG_NOATIME: u32 = 64;
pub const FS_XFLAG_NODUMP: u32 = 128;
pub const FS_XFLAG_RTINHERIT: u32 = 256;
pub const FS_XFLAG_PROJINHERIT: u32 = 512;
pub const FS_XFLAG_NOSYMLINKS: u32 = 1024;
pub const FS_XFLAG_EXTSIZE: u32 = 2048;
pub const FS_XFLAG_EXTSZINHERIT: u32 = 4096;
pub const FS_XFLAG_NODEFRAG: u32 = 8192;
pub const FS_XFLAG_FILESTREAM: u32 = 16384;
pub const FS_XFLAG_DAX: u32 = 32768;
pub const FS_XFLAG_COWEXTSIZE: u32 = 65536;
pub const FS_XFLAG_HASATTR: u32 = 2147483648;
pub const BMAP_IOCTL: u32 = 1;
pub const FSLABEL_MAX: u32 = 256;
pub const FS_SECRM_FL: u32 = 1;
pub const FS_UNRM_FL: u32 = 2;
pub const FS_COMPR_FL: u32 = 4;
pub const FS_SYNC_FL: u32 = 8;
pub const FS_IMMUTABLE_FL: u32 = 16;
pub const FS_APPEND_FL: u32 = 32;
pub const FS_NODUMP_FL: u32 = 64;
pub const FS_NOATIME_FL: u32 = 128;
pub const FS_DIRTY_FL: u32 = 256;
pub const FS_COMPRBLK_FL: u32 = 512;
pub const FS_NOCOMP_FL: u32 = 1024;
pub const FS_ENCRYPT_FL: u32 = 2048;
pub const FS_BTREE_FL: u32 = 4096;
pub const FS_INDEX_FL: u32 = 4096;
pub const FS_IMAGIC_FL: u32 = 8192;
pub const FS_JOURNAL_DATA_FL: u32 = 16384;
pub const FS_NOTAIL_FL: u32 = 32768;
pub const FS_DIRSYNC_FL: u32 = 65536;
pub const FS_TOPDIR_FL: u32 = 131072;
pub const FS_HUGE_FILE_FL: u32 = 262144;
pub const FS_EXTENT_FL: u32 = 524288;
pub const FS_VERITY_FL: u32 = 1048576;
pub const FS_EA_INODE_FL: u32 = 2097152;
pub const FS_EOFBLOCKS_FL: u32 = 4194304;
pub const FS_NOCOW_FL: u32 = 8388608;
pub const FS_DAX_FL: u32 = 33554432;
pub const FS_INLINE_DATA_FL: u32 = 268435456;
pub const FS_PROJINHERIT_FL: u32 = 536870912;
pub const FS_CASEFOLD_FL: u32 = 1073741824;
pub const FS_RESERVED_FL: u32 = 2147483648;
pub const FS_FL_USER_VISIBLE: u32 = 253951;
pub const FS_FL_USER_MODIFIABLE: u32 = 229631;
pub const SYNC_FILE_RANGE_WAIT_BEFORE: u32 = 1;
pub const SYNC_FILE_RANGE_WRITE: u32 = 2;
pub const SYNC_FILE_RANGE_WAIT_AFTER: u32 = 4;
pub const SYNC_FILE_RANGE_WRITE_AND_WAIT: u32 = 7;
pub const PAGE_IS_WPALLOWED: u32 = 1;
pub const PAGE_IS_WRITTEN: u32 = 2;
pub const PAGE_IS_FILE: u32 = 4;
pub const PAGE_IS_PRESENT: u32 = 8;
pub const PAGE_IS_SWAPPED: u32 = 16;
pub const PAGE_IS_PFNZERO: u32 = 32;
pub const PAGE_IS_HUGE: u32 = 64;
pub const PAGE_IS_SOFT_DIRTY: u32 = 128;
pub const PM_SCAN_WP_MATCHING: u32 = 1;
pub const PM_SCAN_CHECK_WPASYNC: u32 = 2;
pub const MAY_EXEC: u32 = 1;
pub const MAY_WRITE: u32 = 2;
pub const MAY_READ: u32 = 4;
pub const MAY_APPEND: u32 = 8;
pub const MAY_ACCESS: u32 = 16;
pub const MAY_OPEN: u32 = 32;
pub const MAY_CHDIR: u32 = 64;
pub const MAY_NOT_BLOCK: u32 = 128;
pub const ATTR_MODE: u32 = 1;
pub const ATTR_UID: u32 = 2;
pub const ATTR_GID: u32 = 4;
pub const ATTR_SIZE: u32 = 8;
pub const ATTR_ATIME: u32 = 16;
pub const ATTR_MTIME: u32 = 32;
pub const ATTR_CTIME: u32 = 64;
pub const ATTR_ATIME_SET: u32 = 128;
pub const ATTR_MTIME_SET: u32 = 256;
pub const ATTR_FORCE: u32 = 512;
pub const ATTR_KILL_SUID: u32 = 2048;
pub const ATTR_KILL_SGID: u32 = 4096;
pub const ATTR_FILE: u32 = 8192;
pub const ATTR_KILL_PRIV: u32 = 16384;
pub const ATTR_OPEN: u32 = 32768;
pub const ATTR_TIMES_SET: u32 = 65536;
pub const ATTR_TOUCH: u32 = 131072;
pub const WHITEOUT_MODE: u32 = 0;
pub const WHITEOUT_DEV: u32 = 0;
pub const XQM_USRQUOTA: u32 = 0;
pub const XQM_GRPQUOTA: u32 = 1;
pub const XQM_PRJQUOTA: u32 = 2;
pub const XQM_MAXQUOTAS: u32 = 3;
pub const FS_DQUOT_VERSION: u32 = 1;
pub const FS_DQ_ISOFT: u32 = 1;
pub const FS_DQ_IHARD: u32 = 2;
pub const FS_DQ_BSOFT: u32 = 4;
pub const FS_DQ_BHARD: u32 = 8;
pub const FS_DQ_RTBSOFT: u32 = 16;
pub const FS_DQ_RTBHARD: u32 = 32;
pub const FS_DQ_LIMIT_MASK: u32 = 63;
pub const FS_DQ_BTIMER: u32 = 64;
pub const FS_DQ_ITIMER: u32 = 128;
pub const FS_DQ_RTBTIMER: u32 = 256;
pub const FS_DQ_TIMER_MASK: u32 = 448;
pub const FS_DQ_BWARNS: u32 = 512;
pub const FS_DQ_IWARNS: u32 = 1024;
pub const FS_DQ_RTBWARNS: u32 = 2048;
pub const FS_DQ_WARNS_MASK: u32 = 3584;
pub const FS_DQ_BCOUNT: u32 = 4096;
pub const FS_DQ_ICOUNT: u32 = 8192;
pub const FS_DQ_RTBCOUNT: u32 = 16384;
pub const FS_DQ_ACCT_MASK: u32 = 28672;
pub const FS_DQ_BIGTIME: u32 = 32768;
pub const FS_QUOTA_UDQ_ACCT: u32 = 1;
pub const FS_QUOTA_UDQ_ENFD: u32 = 2;
pub const FS_QUOTA_GDQ_ACCT: u32 = 4;
pub const FS_QUOTA_GDQ_ENFD: u32 = 8;
pub const FS_QUOTA_PDQ_ACCT: u32 = 16;
pub const FS_QUOTA_PDQ_ENFD: u32 = 32;
pub const FS_USER_QUOTA: u32 = 1;
pub const FS_PROJ_QUOTA: u32 = 2;
pub const FS_GROUP_QUOTA: u32 = 4;
pub const FS_QSTAT_VERSION: u32 = 1;
pub const FS_QSTATV_VERSION1: u32 = 1;
pub const V1_INIT_ALLOC: u32 = 1;
pub const V1_INIT_REWRITE: u32 = 1;
pub const V1_DEL_ALLOC: u32 = 0;
pub const V1_DEL_REWRITE: u32 = 2;
pub const QTREE_INIT_ALLOC: u32 = 4;
pub const QTREE_INIT_REWRITE: u32 = 2;
pub const QTREE_DEL_ALLOC: u32 = 0;
pub const QTREE_DEL_REWRITE: u32 = 6;
pub const V2_INIT_ALLOC: u32 = 4;
pub const V2_INIT_REWRITE: u32 = 2;
pub const V2_DEL_ALLOC: u32 = 0;
pub const V2_DEL_REWRITE: u32 = 6;
pub const OVERFLOW_PROJID: u32 = 65534;
pub const __DQUOT_VERSION__: &[u8; 12usize] = b"dquot_6.6.0\0";
pub const MAXQUOTAS: u32 = 3;
pub const USRQUOTA: u32 = 0;
pub const GRPQUOTA: u32 = 1;
pub const PRJQUOTA: u32 = 2;
pub const SUBCMDMASK: u32 = 255;
pub const SUBCMDSHIFT: u32 = 8;
pub const Q_SYNC: u32 = 8388609;
pub const Q_QUOTAON: u32 = 8388610;
pub const Q_QUOTAOFF: u32 = 8388611;
pub const Q_GETFMT: u32 = 8388612;
pub const Q_GETINFO: u32 = 8388613;
pub const Q_SETINFO: u32 = 8388614;
pub const Q_GETQUOTA: u32 = 8388615;
pub const Q_SETQUOTA: u32 = 8388616;
pub const Q_GETNEXTQUOTA: u32 = 8388617;
pub const QFMT_VFS_OLD: u32 = 1;
pub const QFMT_VFS_V0: u32 = 2;
pub const QFMT_OCFS2: u32 = 3;
pub const QFMT_VFS_V1: u32 = 4;
pub const QFMT_SHMEM: u32 = 5;
pub const QIF_DQBLKSIZE_BITS: u32 = 10;
pub const QIF_DQBLKSIZE: u32 = 1024;
pub const IIF_BGRACE: u32 = 1;
pub const IIF_IGRACE: u32 = 2;
pub const IIF_FLAGS: u32 = 4;
pub const IIF_ALL: u32 = 7;
pub const QUOTA_NL_NOWARN: u32 = 0;
pub const QUOTA_NL_IHARDWARN: u32 = 1;
pub const QUOTA_NL_ISOFTLONGWARN: u32 = 2;
pub const QUOTA_NL_ISOFTWARN: u32 = 3;
pub const QUOTA_NL_BHARDWARN: u32 = 4;
pub const QUOTA_NL_BSOFTLONGWARN: u32 = 5;
pub const QUOTA_NL_BSOFTWARN: u32 = 6;
pub const QUOTA_NL_IHARDBELOW: u32 = 7;
pub const QUOTA_NL_ISOFTBELOW: u32 = 8;
pub const QUOTA_NL_BHARDBELOW: u32 = 9;
pub const QUOTA_NL_BSOFTBELOW: u32 = 10;
pub const QTYPE_MASK_USR: u32 = 1;
pub const QTYPE_MASK_GRP: u32 = 2;
pub const QTYPE_MASK_PRJ: u32 = 4;
pub const DQ_MOD_B: u32 = 0;
pub const DQ_BLKS_B: u32 = 1;
pub const DQ_INODES_B: u32 = 2;
pub const DQ_FAKE_B: u32 = 3;
pub const DQ_READ_B: u32 = 4;
pub const DQ_ACTIVE_B: u32 = 5;
pub const DQ_RELEASING_B: u32 = 6;
pub const DQ_LASTSET_B: u32 = 7;
pub const QC_INO_SOFT: u32 = 1;
pub const QC_INO_HARD: u32 = 2;
pub const QC_SPC_SOFT: u32 = 4;
pub const QC_SPC_HARD: u32 = 8;
pub const QC_RT_SPC_SOFT: u32 = 16;
pub const QC_RT_SPC_HARD: u32 = 32;
pub const QC_LIMIT_MASK: u32 = 63;
pub const QC_SPC_TIMER: u32 = 64;
pub const QC_INO_TIMER: u32 = 128;
pub const QC_RT_SPC_TIMER: u32 = 256;
pub const QC_TIMER_MASK: u32 = 448;
pub const QC_SPC_WARNS: u32 = 512;
pub const QC_INO_WARNS: u32 = 1024;
pub const QC_RT_SPC_WARNS: u32 = 2048;
pub const QC_WARNS_MASK: u32 = 3584;
pub const QC_SPACE: u32 = 4096;
pub const QC_INO_COUNT: u32 = 8192;
pub const QC_RT_SPACE: u32 = 16384;
pub const QC_ACCT_MASK: u32 = 28672;
pub const QC_FLAGS: u32 = 32768;
pub const QCI_SYSFILE: u32 = 1;
pub const QCI_ROOT_SQUASH: u32 = 2;
pub const QCI_ACCT_ENABLED: u32 = 4;
pub const QCI_LIMITS_ENFORCED: u32 = 8;
pub const FILESYSTEM_MAX_STACK_DEPTH: u32 = 2;
pub const IOCB_EVENTFD: u32 = 65536;
pub const IOCB_DIRECT: u32 = 131072;
pub const IOCB_WRITE: u32 = 262144;
pub const IOCB_WAITQ: u32 = 524288;
pub const IOCB_NOIO: u32 = 1048576;
pub const IOCB_ALLOC_CACHE: u32 = 2097152;
pub const IOCB_DIO_CALLER_COMP: u32 = 4194304;
pub const IOCB_AIO_RW: u32 = 8388608;
pub const IOP_FASTPERM: u32 = 1;
pub const IOP_LOOKUP: u32 = 2;
pub const IOP_NOFOLLOW: u32 = 4;
pub const IOP_XATTR: u32 = 8;
pub const IOP_DEFAULT_READLINK: u32 = 16;
pub const MAX_NON_LFS: u32 = 2147483647;
pub const FASYNC_MAGIC: u32 = 17921;
pub const SB_ENC_STRICT_MODE_FL: u32 = 1;
pub const MNT_FORCE: u32 = 1;
pub const MNT_DETACH: u32 = 2;
pub const MNT_EXPIRE: u32 = 4;
pub const UMOUNT_NOFOLLOW: u32 = 8;
pub const UMOUNT_UNUSED: u32 = 2147483648;
pub const SB_I_CGROUPWB: u32 = 1;
pub const SB_I_NOEXEC: u32 = 2;
pub const SB_I_NODEV: u32 = 4;
pub const SB_I_STABLE_WRITES: u32 = 8;
pub const SB_I_USERNS_VISIBLE: u32 = 16;
pub const SB_I_IMA_UNVERIFIABLE_SIGNATURE: u32 = 32;
pub const SB_I_UNTRUSTED_MOUNTER: u32 = 64;
pub const SB_I_EVM_UNSUPPORTED: u32 = 128;
pub const SB_I_SKIP_SYNC: u32 = 256;
pub const SB_I_PERSB_BDI: u32 = 512;
pub const SB_I_TS_EXPIRY_WARNED: u32 = 1024;
pub const SB_I_RETIRED: u32 = 2048;
pub const SB_I_NOUMASK: u32 = 4096;
pub const NOMMU_MAP_COPY: u32 = 1;
pub const NOMMU_MAP_DIRECT: u32 = 8;
pub const REMAP_FILE_DEDUP: u32 = 1;
pub const REMAP_FILE_CAN_SHORTEN: u32 = 2;
pub const REMAP_FILE_ADVISORY: u32 = 2;
pub const COPY_FILE_SPLICE: u32 = 1;
pub const S_SYNC: u32 = 1;
pub const S_NOATIME: u32 = 2;
pub const S_APPEND: u32 = 4;
pub const S_IMMUTABLE: u32 = 8;
pub const S_DEAD: u32 = 16;
pub const S_NOQUOTA: u32 = 32;
pub const S_DIRSYNC: u32 = 64;
pub const S_NOCMTIME: u32 = 128;
pub const S_SWAPFILE: u32 = 256;
pub const S_PRIVATE: u32 = 512;
pub const S_IMA: u32 = 1024;
pub const S_AUTOMOUNT: u32 = 2048;
pub const S_NOSEC: u32 = 4096;
pub const S_DAX: u32 = 8192;
pub const S_ENCRYPTED: u32 = 16384;
pub const S_CASEFOLD: u32 = 32768;
pub const S_VERITY: u32 = 65536;
pub const S_KERNEL_FILE: u32 = 131072;
pub const I_DIRTY_SYNC: u32 = 1;
pub const I_DIRTY_DATASYNC: u32 = 2;
pub const I_DIRTY_PAGES: u32 = 4;
pub const __I_NEW: u32 = 3;
pub const I_NEW: u32 = 8;
pub const I_WILL_FREE: u32 = 16;
pub const I_FREEING: u32 = 32;
pub const I_CLEAR: u32 = 64;
pub const __I_SYNC: u32 = 7;
pub const I_SYNC: u32 = 128;
pub const I_REFERENCED: u32 = 256;
pub const __I_DIO_WAKEUP: u32 = 9;
pub const I_DIO_WAKEUP: u32 = 512;
pub const I_LINKABLE: u32 = 1024;
pub const I_DIRTY_TIME: u32 = 2048;
pub const I_WB_SWITCH: u32 = 8192;
pub const I_OVL_INUSE: u32 = 16384;
pub const I_CREATING: u32 = 32768;
pub const I_DONTCACHE: u32 = 65536;
pub const I_SYNC_QUEUED: u32 = 131072;
pub const I_PINNING_NETFS_WB: u32 = 262144;
pub const I_DIRTY_INODE: u32 = 3;
pub const I_DIRTY: u32 = 7;
pub const I_DIRTY_ALL: u32 = 2055;
pub const FS_REQUIRES_DEV: u32 = 1;
pub const FS_BINARY_MOUNTDATA: u32 = 2;
pub const FS_HAS_SUBTYPE: u32 = 4;
pub const FS_USERNS_MOUNT: u32 = 8;
pub const FS_DISALLOW_NOTIFY_PERM: u32 = 16;
pub const FS_ALLOW_IDMAP: u32 = 32;
pub const FS_RENAME_DOES_D_MOVE: u32 = 32768;
pub const CHRDEV_MAJOR_MAX: u32 = 512;
pub const CHRDEV_MAJOR_DYN_END: u32 = 234;
pub const CHRDEV_MAJOR_DYN_EXT_START: u32 = 511;
pub const CHRDEV_MAJOR_DYN_EXT_END: u32 = 384;
pub const IOCB_FLAG_RESFD: u32 = 1;
pub const IOCB_FLAG_IOPRIO: u32 = 2;
pub const _ASM_X86_UNISTD_H: u32 = 1;
pub const __X32_SYSCALL_BIT: u32 = 1073741824;
pub const __NR_read: u32 = 0;
pub const __NR_write: u32 = 1;
pub const __NR_open: u32 = 2;
pub const __NR_close: u32 = 3;
pub const __NR_stat: u32 = 4;
pub const __NR_fstat: u32 = 5;
pub const __NR_lstat: u32 = 6;
pub const __NR_poll: u32 = 7;
pub const __NR_lseek: u32 = 8;
pub const __NR_mmap: u32 = 9;
pub const __NR_mprotect: u32 = 10;
pub const __NR_munmap: u32 = 11;
pub const __NR_brk: u32 = 12;
pub const __NR_rt_sigaction: u32 = 13;
pub const __NR_rt_sigprocmask: u32 = 14;
pub const __NR_rt_sigreturn: u32 = 15;
pub const __NR_ioctl: u32 = 16;
pub const __NR_pread64: u32 = 17;
pub const __NR_pwrite64: u32 = 18;
pub const __NR_readv: u32 = 19;
pub const __NR_writev: u32 = 20;
pub const __NR_access: u32 = 21;
pub const __NR_pipe: u32 = 22;
pub const __NR_select: u32 = 23;
pub const __NR_sched_yield: u32 = 24;
pub const __NR_mremap: u32 = 25;
pub const __NR_msync: u32 = 26;
pub const __NR_mincore: u32 = 27;
pub const __NR_madvise: u32 = 28;
pub const __NR_shmget: u32 = 29;
pub const __NR_shmat: u32 = 30;
pub const __NR_shmctl: u32 = 31;
pub const __NR_dup: u32 = 32;
pub const __NR_dup2: u32 = 33;
pub const __NR_pause: u32 = 34;
pub const __NR_nanosleep: u32 = 35;
pub const __NR_getitimer: u32 = 36;
pub const __NR_alarm: u32 = 37;
pub const __NR_setitimer: u32 = 38;
pub const __NR_getpid: u32 = 39;
pub const __NR_sendfile: u32 = 40;
pub const __NR_socket: u32 = 41;
pub const __NR_connect: u32 = 42;
pub const __NR_accept: u32 = 43;
pub const __NR_sendto: u32 = 44;
pub const __NR_recvfrom: u32 = 45;
pub const __NR_sendmsg: u32 = 46;
pub const __NR_recvmsg: u32 = 47;
pub const __NR_shutdown: u32 = 48;
pub const __NR_bind: u32 = 49;
pub const __NR_listen: u32 = 50;
pub const __NR_getsockname: u32 = 51;
pub const __NR_getpeername: u32 = 52;
pub const __NR_socketpair: u32 = 53;
pub const __NR_setsockopt: u32 = 54;
pub const __NR_getsockopt: u32 = 55;
pub const __NR_clone: u32 = 56;
pub const __NR_fork: u32 = 57;
pub const __NR_vfork: u32 = 58;
pub const __NR_execve: u32 = 59;
pub const __NR_exit: u32 = 60;
pub const __NR_wait4: u32 = 61;
pub const __NR_kill: u32 = 62;
pub const __NR_uname: u32 = 63;
pub const __NR_semget: u32 = 64;
pub const __NR_semop: u32 = 65;
pub const __NR_semctl: u32 = 66;
pub const __NR_shmdt: u32 = 67;
pub const __NR_msgget: u32 = 68;
pub const __NR_msgsnd: u32 = 69;
pub const __NR_msgrcv: u32 = 70;
pub const __NR_msgctl: u32 = 71;
pub const __NR_fcntl: u32 = 72;
pub const __NR_flock: u32 = 73;
pub const __NR_fsync: u32 = 74;
pub const __NR_fdatasync: u32 = 75;
pub const __NR_truncate: u32 = 76;
pub const __NR_ftruncate: u32 = 77;
pub const __NR_getdents: u32 = 78;
pub const __NR_getcwd: u32 = 79;
pub const __NR_chdir: u32 = 80;
pub const __NR_fchdir: u32 = 81;
pub const __NR_rename: u32 = 82;
pub const __NR_mkdir: u32 = 83;
pub const __NR_rmdir: u32 = 84;
pub const __NR_creat: u32 = 85;
pub const __NR_link: u32 = 86;
pub const __NR_unlink: u32 = 87;
pub const __NR_symlink: u32 = 88;
pub const __NR_readlink: u32 = 89;
pub const __NR_chmod: u32 = 90;
pub const __NR_fchmod: u32 = 91;
pub const __NR_chown: u32 = 92;
pub const __NR_fchown: u32 = 93;
pub const __NR_lchown: u32 = 94;
pub const __NR_umask: u32 = 95;
pub const __NR_gettimeofday: u32 = 96;
pub const __NR_getrlimit: u32 = 97;
pub const __NR_getrusage: u32 = 98;
pub const __NR_sysinfo: u32 = 99;
pub const __NR_times: u32 = 100;
pub const __NR_ptrace: u32 = 101;
pub const __NR_getuid: u32 = 102;
pub const __NR_syslog: u32 = 103;
pub const __NR_getgid: u32 = 104;
pub const __NR_setuid: u32 = 105;
pub const __NR_setgid: u32 = 106;
pub const __NR_geteuid: u32 = 107;
pub const __NR_getegid: u32 = 108;
pub const __NR_setpgid: u32 = 109;
pub const __NR_getppid: u32 = 110;
pub const __NR_getpgrp: u32 = 111;
pub const __NR_setsid: u32 = 112;
pub const __NR_setreuid: u32 = 113;
pub const __NR_setregid: u32 = 114;
pub const __NR_getgroups: u32 = 115;
pub const __NR_setgroups: u32 = 116;
pub const __NR_setresuid: u32 = 117;
pub const __NR_getresuid: u32 = 118;
pub const __NR_setresgid: u32 = 119;
pub const __NR_getresgid: u32 = 120;
pub const __NR_getpgid: u32 = 121;
pub const __NR_setfsuid: u32 = 122;
pub const __NR_setfsgid: u32 = 123;
pub const __NR_getsid: u32 = 124;
pub const __NR_capget: u32 = 125;
pub const __NR_capset: u32 = 126;
pub const __NR_rt_sigpending: u32 = 127;
pub const __NR_rt_sigtimedwait: u32 = 128;
pub const __NR_rt_sigqueueinfo: u32 = 129;
pub const __NR_rt_sigsuspend: u32 = 130;
pub const __NR_sigaltstack: u32 = 131;
pub const __NR_utime: u32 = 132;
pub const __NR_mknod: u32 = 133;
pub const __NR_uselib: u32 = 134;
pub const __NR_personality: u32 = 135;
pub const __NR_ustat: u32 = 136;
pub const __NR_statfs: u32 = 137;
pub const __NR_fstatfs: u32 = 138;
pub const __NR_sysfs: u32 = 139;
pub const __NR_getpriority: u32 = 140;
pub const __NR_setpriority: u32 = 141;
pub const __NR_sched_setparam: u32 = 142;
pub const __NR_sched_getparam: u32 = 143;
pub const __NR_sched_setscheduler: u32 = 144;
pub const __NR_sched_getscheduler: u32 = 145;
pub const __NR_sched_get_priority_max: u32 = 146;
pub const __NR_sched_get_priority_min: u32 = 147;
pub const __NR_sched_rr_get_interval: u32 = 148;
pub const __NR_mlock: u32 = 149;
pub const __NR_munlock: u32 = 150;
pub const __NR_mlockall: u32 = 151;
pub const __NR_munlockall: u32 = 152;
pub const __NR_vhangup: u32 = 153;
pub const __NR_modify_ldt: u32 = 154;
pub const __NR_pivot_root: u32 = 155;
pub const __NR__sysctl: u32 = 156;
pub const __NR_prctl: u32 = 157;
pub const __NR_arch_prctl: u32 = 158;
pub const __NR_adjtimex: u32 = 159;
pub const __NR_setrlimit: u32 = 160;
pub const __NR_chroot: u32 = 161;
pub const __NR_sync: u32 = 162;
pub const __NR_acct: u32 = 163;
pub const __NR_settimeofday: u32 = 164;
pub const __NR_mount: u32 = 165;
pub const __NR_umount2: u32 = 166;
pub const __NR_swapon: u32 = 167;
pub const __NR_swapoff: u32 = 168;
pub const __NR_reboot: u32 = 169;
pub const __NR_sethostname: u32 = 170;
pub const __NR_setdomainname: u32 = 171;
pub const __NR_iopl: u32 = 172;
pub const __NR_ioperm: u32 = 173;
pub const __NR_create_module: u32 = 174;
pub const __NR_init_module: u32 = 175;
pub const __NR_delete_module: u32 = 176;
pub const __NR_get_kernel_syms: u32 = 177;
pub const __NR_query_module: u32 = 178;
pub const __NR_quotactl: u32 = 179;
pub const __NR_nfsservctl: u32 = 180;
pub const __NR_getpmsg: u32 = 181;
pub const __NR_putpmsg: u32 = 182;
pub const __NR_afs_syscall: u32 = 183;
pub const __NR_tuxcall: u32 = 184;
pub const __NR_security: u32 = 185;
pub const __NR_gettid: u32 = 186;
pub const __NR_readahead: u32 = 187;
pub const __NR_setxattr: u32 = 188;
pub const __NR_lsetxattr: u32 = 189;
pub const __NR_fsetxattr: u32 = 190;
pub const __NR_getxattr: u32 = 191;
pub const __NR_lgetxattr: u32 = 192;
pub const __NR_fgetxattr: u32 = 193;
pub const __NR_listxattr: u32 = 194;
pub const __NR_llistxattr: u32 = 195;
pub const __NR_flistxattr: u32 = 196;
pub const __NR_removexattr: u32 = 197;
pub const __NR_lremovexattr: u32 = 198;
pub const __NR_fremovexattr: u32 = 199;
pub const __NR_tkill: u32 = 200;
pub const __NR_time: u32 = 201;
pub const __NR_futex: u32 = 202;
pub const __NR_sched_setaffinity: u32 = 203;
pub const __NR_sched_getaffinity: u32 = 204;
pub const __NR_set_thread_area: u32 = 205;
pub const __NR_io_setup: u32 = 206;
pub const __NR_io_destroy: u32 = 207;
pub const __NR_io_getevents: u32 = 208;
pub const __NR_io_submit: u32 = 209;
pub const __NR_io_cancel: u32 = 210;
pub const __NR_get_thread_area: u32 = 211;
pub const __NR_lookup_dcookie: u32 = 212;
pub const __NR_epoll_create: u32 = 213;
pub const __NR_epoll_ctl_old: u32 = 214;
pub const __NR_epoll_wait_old: u32 = 215;
pub const __NR_remap_file_pages: u32 = 216;
pub const __NR_getdents64: u32 = 217;
pub const __NR_set_tid_address: u32 = 218;
pub const __NR_restart_syscall: u32 = 219;
pub const __NR_semtimedop: u32 = 220;
pub const __NR_fadvise64: u32 = 221;
pub const __NR_timer_create: u32 = 222;
pub const __NR_timer_settime: u32 = 223;
pub const __NR_timer_gettime: u32 = 224;
pub const __NR_timer_getoverrun: u32 = 225;
pub const __NR_timer_delete: u32 = 226;
pub const __NR_clock_settime: u32 = 227;
pub const __NR_clock_gettime: u32 = 228;
pub const __NR_clock_getres: u32 = 229;
pub const __NR_clock_nanosleep: u32 = 230;
pub const __NR_exit_group: u32 = 231;
pub const __NR_epoll_wait: u32 = 232;
pub const __NR_epoll_ctl: u32 = 233;
pub const __NR_tgkill: u32 = 234;
pub const __NR_utimes: u32 = 235;
pub const __NR_vserver: u32 = 236;
pub const __NR_mbind: u32 = 237;
pub const __NR_set_mempolicy: u32 = 238;
pub const __NR_get_mempolicy: u32 = 239;
pub const __NR_mq_open: u32 = 240;
pub const __NR_mq_unlink: u32 = 241;
pub const __NR_mq_timedsend: u32 = 242;
pub const __NR_mq_timedreceive: u32 = 243;
pub const __NR_mq_notify: u32 = 244;
pub const __NR_mq_getsetattr: u32 = 245;
pub const __NR_kexec_load: u32 = 246;
pub const __NR_waitid: u32 = 247;
pub const __NR_add_key: u32 = 248;
pub const __NR_request_key: u32 = 249;
pub const __NR_keyctl: u32 = 250;
pub const __NR_ioprio_set: u32 = 251;
pub const __NR_ioprio_get: u32 = 252;
pub const __NR_inotify_init: u32 = 253;
pub const __NR_inotify_add_watch: u32 = 254;
pub const __NR_inotify_rm_watch: u32 = 255;
pub const __NR_migrate_pages: u32 = 256;
pub const __NR_openat: u32 = 257;
pub const __NR_mkdirat: u32 = 258;
pub const __NR_mknodat: u32 = 259;
pub const __NR_fchownat: u32 = 260;
pub const __NR_futimesat: u32 = 261;
pub const __NR_newfstatat: u32 = 262;
pub const __NR_unlinkat: u32 = 263;
pub const __NR_renameat: u32 = 264;
pub const __NR_linkat: u32 = 265;
pub const __NR_symlinkat: u32 = 266;
pub const __NR_readlinkat: u32 = 267;
pub const __NR_fchmodat: u32 = 268;
pub const __NR_faccessat: u32 = 269;
pub const __NR_pselect6: u32 = 270;
pub const __NR_ppoll: u32 = 271;
pub const __NR_unshare: u32 = 272;
pub const __NR_set_robust_list: u32 = 273;
pub const __NR_get_robust_list: u32 = 274;
pub const __NR_splice: u32 = 275;
pub const __NR_tee: u32 = 276;
pub const __NR_sync_file_range: u32 = 277;
pub const __NR_vmsplice: u32 = 278;
pub const __NR_move_pages: u32 = 279;
pub const __NR_utimensat: u32 = 280;
pub const __NR_epoll_pwait: u32 = 281;
pub const __NR_signalfd: u32 = 282;
pub const __NR_timerfd_create: u32 = 283;
pub const __NR_eventfd: u32 = 284;
pub const __NR_fallocate: u32 = 285;
pub const __NR_timerfd_settime: u32 = 286;
pub const __NR_timerfd_gettime: u32 = 287;
pub const __NR_accept4: u32 = 288;
pub const __NR_signalfd4: u32 = 289;
pub const __NR_eventfd2: u32 = 290;
pub const __NR_epoll_create1: u32 = 291;
pub const __NR_dup3: u32 = 292;
pub const __NR_pipe2: u32 = 293;
pub const __NR_inotify_init1: u32 = 294;
pub const __NR_preadv: u32 = 295;
pub const __NR_pwritev: u32 = 296;
pub const __NR_rt_tgsigqueueinfo: u32 = 297;
pub const __NR_perf_event_open: u32 = 298;
pub const __NR_recvmmsg: u32 = 299;
pub const __NR_fanotify_init: u32 = 300;
pub const __NR_fanotify_mark: u32 = 301;
pub const __NR_prlimit64: u32 = 302;
pub const __NR_name_to_handle_at: u32 = 303;
pub const __NR_open_by_handle_at: u32 = 304;
pub const __NR_clock_adjtime: u32 = 305;
pub const __NR_syncfs: u32 = 306;
pub const __NR_sendmmsg: u32 = 307;
pub const __NR_setns: u32 = 308;
pub const __NR_getcpu: u32 = 309;
pub const __NR_process_vm_readv: u32 = 310;
pub const __NR_process_vm_writev: u32 = 311;
pub const __NR_kcmp: u32 = 312;
pub const __NR_finit_module: u32 = 313;
pub const __NR_sched_setattr: u32 = 314;
pub const __NR_sched_getattr: u32 = 315;
pub const __NR_renameat2: u32 = 316;
pub const __NR_seccomp: u32 = 317;
pub const __NR_getrandom: u32 = 318;
pub const __NR_memfd_create: u32 = 319;
pub const __NR_kexec_file_load: u32 = 320;
pub const __NR_bpf: u32 = 321;
pub const __NR_execveat: u32 = 322;
pub const __NR_userfaultfd: u32 = 323;
pub const __NR_membarrier: u32 = 324;
pub const __NR_mlock2: u32 = 325;
pub const __NR_copy_file_range: u32 = 326;
pub const __NR_preadv2: u32 = 327;
pub const __NR_pwritev2: u32 = 328;
pub const __NR_pkey_mprotect: u32 = 329;
pub const __NR_pkey_alloc: u32 = 330;
pub const __NR_pkey_free: u32 = 331;
pub const __NR_statx: u32 = 332;
pub const __NR_io_pgetevents: u32 = 333;
pub const __NR_rseq: u32 = 334;
pub const __NR_pidfd_send_signal: u32 = 424;
pub const __NR_io_uring_setup: u32 = 425;
pub const __NR_io_uring_enter: u32 = 426;
pub const __NR_io_uring_register: u32 = 427;
pub const __NR_open_tree: u32 = 428;
pub const __NR_move_mount: u32 = 429;
pub const __NR_fsopen: u32 = 430;
pub const __NR_fsconfig: u32 = 431;
pub const __NR_fsmount: u32 = 432;
pub const __NR_fspick: u32 = 433;
pub const __NR_pidfd_open: u32 = 434;
pub const __NR_clone3: u32 = 435;
pub const __NR_close_range: u32 = 436;
pub const __NR_openat2: u32 = 437;
pub const __NR_pidfd_getfd: u32 = 438;
pub const __NR_faccessat2: u32 = 439;
pub const __NR_process_madvise: u32 = 440;
pub const __NR_epoll_pwait2: u32 = 441;
pub const __NR_mount_setattr: u32 = 442;
pub const __NR_quotactl_fd: u32 = 443;
pub const __NR_landlock_create_ruleset: u32 = 444;
pub const __NR_landlock_add_rule: u32 = 445;
pub const __NR_landlock_restrict_self: u32 = 446;
pub const __NR_memfd_secret: u32 = 447;
pub const __NR_process_mrelease: u32 = 448;
pub const __NR_futex_waitv: u32 = 449;
pub const __NR_set_mempolicy_home_node: u32 = 450;
pub const __NR_cachestat: u32 = 451;
pub const __NR_fchmodat2: u32 = 452;
pub const __NR_map_shadow_stack: u32 = 453;
pub const __NR_futex_wake: u32 = 454;
pub const __NR_futex_wait: u32 = 455;
pub const __NR_futex_requeue: u32 = 456;
pub const __NR_statmount: u32 = 457;
pub const __NR_listmount: u32 = 458;
pub const __NR_lsm_get_self_attr: u32 = 459;
pub const __NR_lsm_set_self_attr: u32 = 460;
pub const __NR_lsm_list_modules: u32 = 461;
pub const __NR_syscalls: u32 = 462;
pub const __NR_x32_rt_sigaction: u32 = 512;
pub const __NR_x32_rt_sigreturn: u32 = 513;
pub const __NR_x32_ioctl: u32 = 514;
pub const __NR_x32_readv: u32 = 515;
pub const __NR_x32_writev: u32 = 516;
pub const __NR_x32_recvfrom: u32 = 517;
pub const __NR_x32_sendmsg: u32 = 518;
pub const __NR_x32_recvmsg: u32 = 519;
pub const __NR_x32_execve: u32 = 520;
pub const __NR_x32_ptrace: u32 = 521;
pub const __NR_x32_rt_sigpending: u32 = 522;
pub const __NR_x32_rt_sigtimedwait: u32 = 523;
pub const __NR_x32_rt_sigqueueinfo: u32 = 524;
pub const __NR_x32_sigaltstack: u32 = 525;
pub const __NR_x32_timer_create: u32 = 526;
pub const __NR_x32_mq_notify: u32 = 527;
pub const __NR_x32_kexec_load: u32 = 528;
pub const __NR_x32_waitid: u32 = 529;
pub const __NR_x32_set_robust_list: u32 = 530;
pub const __NR_x32_get_robust_list: u32 = 531;
pub const __NR_x32_vmsplice: u32 = 532;
pub const __NR_x32_move_pages: u32 = 533;
pub const __NR_x32_preadv: u32 = 534;
pub const __NR_x32_pwritev: u32 = 535;
pub const __NR_x32_rt_tgsigqueueinfo: u32 = 536;
pub const __NR_x32_recvmmsg: u32 = 537;
pub const __NR_x32_sendmmsg: u32 = 538;
pub const __NR_x32_process_vm_readv: u32 = 539;
pub const __NR_x32_process_vm_writev: u32 = 540;
pub const __NR_x32_setsockopt: u32 = 541;
pub const __NR_x32_getsockopt: u32 = 542;
pub const __NR_x32_io_setup: u32 = 543;
pub const __NR_x32_io_submit: u32 = 544;
pub const __NR_x32_execveat: u32 = 545;
pub const __NR_x32_preadv2: u32 = 546;
pub const __NR_x32_pwritev2: u32 = 547;
pub const __NR_x32_syscalls: u32 = 548;
pub const __NR_ia32_restart_syscall: u32 = 0;
pub const __NR_ia32_exit: u32 = 1;
pub const __NR_ia32_fork: u32 = 2;
pub const __NR_ia32_read: u32 = 3;
pub const __NR_ia32_write: u32 = 4;
pub const __NR_ia32_open: u32 = 5;
pub const __NR_ia32_close: u32 = 6;
pub const __NR_ia32_waitpid: u32 = 7;
pub const __NR_ia32_creat: u32 = 8;
pub const __NR_ia32_link: u32 = 9;
pub const __NR_ia32_unlink: u32 = 10;
pub const __NR_ia32_execve: u32 = 11;
pub const __NR_ia32_chdir: u32 = 12;
pub const __NR_ia32_time: u32 = 13;
pub const __NR_ia32_mknod: u32 = 14;
pub const __NR_ia32_chmod: u32 = 15;
pub const __NR_ia32_lchown: u32 = 16;
pub const __NR_ia32_break: u32 = 17;
pub const __NR_ia32_oldstat: u32 = 18;
pub const __NR_ia32_lseek: u32 = 19;
pub const __NR_ia32_getpid: u32 = 20;
pub const __NR_ia32_mount: u32 = 21;
pub const __NR_ia32_umount: u32 = 22;
pub const __NR_ia32_setuid: u32 = 23;
pub const __NR_ia32_getuid: u32 = 24;
pub const __NR_ia32_stime: u32 = 25;
pub const __NR_ia32_ptrace: u32 = 26;
pub const __NR_ia32_alarm: u32 = 27;
pub const __NR_ia32_oldfstat: u32 = 28;
pub const __NR_ia32_pause: u32 = 29;
pub const __NR_ia32_utime: u32 = 30;
pub const __NR_ia32_stty: u32 = 31;
pub const __NR_ia32_gtty: u32 = 32;
pub const __NR_ia32_access: u32 = 33;
pub const __NR_ia32_nice: u32 = 34;
pub const __NR_ia32_ftime: u32 = 35;
pub const __NR_ia32_sync: u32 = 36;
pub const __NR_ia32_kill: u32 = 37;
pub const __NR_ia32_rename: u32 = 38;
pub const __NR_ia32_mkdir: u32 = 39;
pub const __NR_ia32_rmdir: u32 = 40;
pub const __NR_ia32_dup: u32 = 41;
pub const __NR_ia32_pipe: u32 = 42;
pub const __NR_ia32_times: u32 = 43;
pub const __NR_ia32_prof: u32 = 44;
pub const __NR_ia32_brk: u32 = 45;
pub const __NR_ia32_setgid: u32 = 46;
pub const __NR_ia32_getgid: u32 = 47;
pub const __NR_ia32_signal: u32 = 48;
pub const __NR_ia32_geteuid: u32 = 49;
pub const __NR_ia32_getegid: u32 = 50;
pub const __NR_ia32_acct: u32 = 51;
pub const __NR_ia32_umount2: u32 = 52;
pub const __NR_ia32_lock: u32 = 53;
pub const __NR_ia32_ioctl: u32 = 54;
pub const __NR_ia32_fcntl: u32 = 55;
pub const __NR_ia32_mpx: u32 = 56;
pub const __NR_ia32_setpgid: u32 = 57;
pub const __NR_ia32_ulimit: u32 = 58;
pub const __NR_ia32_oldolduname: u32 = 59;
pub const __NR_ia32_umask: u32 = 60;
pub const __NR_ia32_chroot: u32 = 61;
pub const __NR_ia32_ustat: u32 = 62;
pub const __NR_ia32_dup2: u32 = 63;
pub const __NR_ia32_getppid: u32 = 64;
pub const __NR_ia32_getpgrp: u32 = 65;
pub const __NR_ia32_setsid: u32 = 66;
pub const __NR_ia32_sigaction: u32 = 67;
pub const __NR_ia32_sgetmask: u32 = 68;
pub const __NR_ia32_ssetmask: u32 = 69;
pub const __NR_ia32_setreuid: u32 = 70;
pub const __NR_ia32_setregid: u32 = 71;
pub const __NR_ia32_sigsuspend: u32 = 72;
pub const __NR_ia32_sigpending: u32 = 73;
pub const __NR_ia32_sethostname: u32 = 74;
pub const __NR_ia32_setrlimit: u32 = 75;
pub const __NR_ia32_getrlimit: u32 = 76;
pub const __NR_ia32_getrusage: u32 = 77;
pub const __NR_ia32_gettimeofday: u32 = 78;
pub const __NR_ia32_settimeofday: u32 = 79;
pub const __NR_ia32_getgroups: u32 = 80;
pub const __NR_ia32_setgroups: u32 = 81;
pub const __NR_ia32_select: u32 = 82;
pub const __NR_ia32_symlink: u32 = 83;
pub const __NR_ia32_oldlstat: u32 = 84;
pub const __NR_ia32_readlink: u32 = 85;
pub const __NR_ia32_uselib: u32 = 86;
pub const __NR_ia32_swapon: u32 = 87;
pub const __NR_ia32_reboot: u32 = 88;
pub const __NR_ia32_readdir: u32 = 89;
pub const __NR_ia32_mmap: u32 = 90;
pub const __NR_ia32_munmap: u32 = 91;
pub const __NR_ia32_truncate: u32 = 92;
pub const __NR_ia32_ftruncate: u32 = 93;
pub const __NR_ia32_fchmod: u32 = 94;
pub const __NR_ia32_fchown: u32 = 95;
pub const __NR_ia32_getpriority: u32 = 96;
pub const __NR_ia32_setpriority: u32 = 97;
pub const __NR_ia32_profil: u32 = 98;
pub const __NR_ia32_statfs: u32 = 99;
pub const __NR_ia32_fstatfs: u32 = 100;
pub const __NR_ia32_ioperm: u32 = 101;
pub const __NR_ia32_socketcall: u32 = 102;
pub const __NR_ia32_syslog: u32 = 103;
pub const __NR_ia32_setitimer: u32 = 104;
pub const __NR_ia32_getitimer: u32 = 105;
pub const __NR_ia32_stat: u32 = 106;
pub const __NR_ia32_lstat: u32 = 107;
pub const __NR_ia32_fstat: u32 = 108;
pub const __NR_ia32_olduname: u32 = 109;
pub const __NR_ia32_iopl: u32 = 110;
pub const __NR_ia32_vhangup: u32 = 111;
pub const __NR_ia32_idle: u32 = 112;
pub const __NR_ia32_vm86old: u32 = 113;
pub const __NR_ia32_wait4: u32 = 114;
pub const __NR_ia32_swapoff: u32 = 115;
pub const __NR_ia32_sysinfo: u32 = 116;
pub const __NR_ia32_ipc: u32 = 117;
pub const __NR_ia32_fsync: u32 = 118;
pub const __NR_ia32_sigreturn: u32 = 119;
pub const __NR_ia32_clone: u32 = 120;
pub const __NR_ia32_setdomainname: u32 = 121;
pub const __NR_ia32_uname: u32 = 122;
pub const __NR_ia32_modify_ldt: u32 = 123;
pub const __NR_ia32_adjtimex: u32 = 124;
pub const __NR_ia32_mprotect: u32 = 125;
pub const __NR_ia32_sigprocmask: u32 = 126;
pub const __NR_ia32_create_module: u32 = 127;
pub const __NR_ia32_init_module: u32 = 128;
pub const __NR_ia32_delete_module: u32 = 129;
pub const __NR_ia32_get_kernel_syms: u32 = 130;
pub const __NR_ia32_quotactl: u32 = 131;
pub const __NR_ia32_getpgid: u32 = 132;
pub const __NR_ia32_fchdir: u32 = 133;
pub const __NR_ia32_bdflush: u32 = 134;
pub const __NR_ia32_sysfs: u32 = 135;
pub const __NR_ia32_personality: u32 = 136;
pub const __NR_ia32_afs_syscall: u32 = 137;
pub const __NR_ia32_setfsuid: u32 = 138;
pub const __NR_ia32_setfsgid: u32 = 139;
pub const __NR_ia32__llseek: u32 = 140;
pub const __NR_ia32_getdents: u32 = 141;
pub const __NR_ia32__newselect: u32 = 142;
pub const __NR_ia32_flock: u32 = 143;
pub const __NR_ia32_msync: u32 = 144;
pub const __NR_ia32_readv: u32 = 145;
pub const __NR_ia32_writev: u32 = 146;
pub const __NR_ia32_getsid: u32 = 147;
pub const __NR_ia32_fdatasync: u32 = 148;
pub const __NR_ia32__sysctl: u32 = 149;
pub const __NR_ia32_mlock: u32 = 150;
pub const __NR_ia32_munlock: u32 = 151;
pub const __NR_ia32_mlockall: u32 = 152;
pub const __NR_ia32_munlockall: u32 = 153;
pub const __NR_ia32_sched_setparam: u32 = 154;
pub const __NR_ia32_sched_getparam: u32 = 155;
pub const __NR_ia32_sched_setscheduler: u32 = 156;
pub const __NR_ia32_sched_getscheduler: u32 = 157;
pub const __NR_ia32_sched_yield: u32 = 158;
pub const __NR_ia32_sched_get_priority_max: u32 = 159;
pub const __NR_ia32_sched_get_priority_min: u32 = 160;
pub const __NR_ia32_sched_rr_get_interval: u32 = 161;
pub const __NR_ia32_nanosleep: u32 = 162;
pub const __NR_ia32_mremap: u32 = 163;
pub const __NR_ia32_setresuid: u32 = 164;
pub const __NR_ia32_getresuid: u32 = 165;
pub const __NR_ia32_vm86: u32 = 166;
pub const __NR_ia32_query_module: u32 = 167;
pub const __NR_ia32_poll: u32 = 168;
pub const __NR_ia32_nfsservctl: u32 = 169;
pub const __NR_ia32_setresgid: u32 = 170;
pub const __NR_ia32_getresgid: u32 = 171;
pub const __NR_ia32_prctl: u32 = 172;
pub const __NR_ia32_rt_sigreturn: u32 = 173;
pub const __NR_ia32_rt_sigaction: u32 = 174;
pub const __NR_ia32_rt_sigprocmask: u32 = 175;
pub const __NR_ia32_rt_sigpending: u32 = 176;
pub const __NR_ia32_rt_sigtimedwait: u32 = 177;
pub const __NR_ia32_rt_sigqueueinfo: u32 = 178;
pub const __NR_ia32_rt_sigsuspend: u32 = 179;
pub const __NR_ia32_pread64: u32 = 180;
pub const __NR_ia32_pwrite64: u32 = 181;
pub const __NR_ia32_chown: u32 = 182;
pub const __NR_ia32_getcwd: u32 = 183;
pub const __NR_ia32_capget: u32 = 184;
pub const __NR_ia32_capset: u32 = 185;
pub const __NR_ia32_sigaltstack: u32 = 186;
pub const __NR_ia32_sendfile: u32 = 187;
pub const __NR_ia32_getpmsg: u32 = 188;
pub const __NR_ia32_putpmsg: u32 = 189;
pub const __NR_ia32_vfork: u32 = 190;
pub const __NR_ia32_ugetrlimit: u32 = 191;
pub const __NR_ia32_mmap2: u32 = 192;
pub const __NR_ia32_truncate64: u32 = 193;
pub const __NR_ia32_ftruncate64: u32 = 194;
pub const __NR_ia32_stat64: u32 = 195;
pub const __NR_ia32_lstat64: u32 = 196;
pub const __NR_ia32_fstat64: u32 = 197;
pub const __NR_ia32_lchown32: u32 = 198;
pub const __NR_ia32_getuid32: u32 = 199;
pub const __NR_ia32_getgid32: u32 = 200;
pub const __NR_ia32_geteuid32: u32 = 201;
pub const __NR_ia32_getegid32: u32 = 202;
pub const __NR_ia32_setreuid32: u32 = 203;
pub const __NR_ia32_setregid32: u32 = 204;
pub const __NR_ia32_getgroups32: u32 = 205;
pub const __NR_ia32_setgroups32: u32 = 206;
pub const __NR_ia32_fchown32: u32 = 207;
pub const __NR_ia32_setresuid32: u32 = 208;
pub const __NR_ia32_getresuid32: u32 = 209;
pub const __NR_ia32_setresgid32: u32 = 210;
pub const __NR_ia32_getresgid32: u32 = 211;
pub const __NR_ia32_chown32: u32 = 212;
pub const __NR_ia32_setuid32: u32 = 213;
pub const __NR_ia32_setgid32: u32 = 214;
pub const __NR_ia32_setfsuid32: u32 = 215;
pub const __NR_ia32_setfsgid32: u32 = 216;
pub const __NR_ia32_pivot_root: u32 = 217;
pub const __NR_ia32_mincore: u32 = 218;
pub const __NR_ia32_madvise: u32 = 219;
pub const __NR_ia32_getdents64: u32 = 220;
pub const __NR_ia32_fcntl64: u32 = 221;
pub const __NR_ia32_gettid: u32 = 224;
pub const __NR_ia32_readahead: u32 = 225;
pub const __NR_ia32_setxattr: u32 = 226;
pub const __NR_ia32_lsetxattr: u32 = 227;
pub const __NR_ia32_fsetxattr: u32 = 228;
pub const __NR_ia32_getxattr: u32 = 229;
pub const __NR_ia32_lgetxattr: u32 = 230;
pub const __NR_ia32_fgetxattr: u32 = 231;
pub const __NR_ia32_listxattr: u32 = 232;
pub const __NR_ia32_llistxattr: u32 = 233;
pub const __NR_ia32_flistxattr: u32 = 234;
pub const __NR_ia32_removexattr: u32 = 235;
pub const __NR_ia32_lremovexattr: u32 = 236;
pub const __NR_ia32_fremovexattr: u32 = 237;
pub const __NR_ia32_tkill: u32 = 238;
pub const __NR_ia32_sendfile64: u32 = 239;
pub const __NR_ia32_futex: u32 = 240;
pub const __NR_ia32_sched_setaffinity: u32 = 241;
pub const __NR_ia32_sched_getaffinity: u32 = 242;
pub const __NR_ia32_set_thread_area: u32 = 243;
pub const __NR_ia32_get_thread_area: u32 = 244;
pub const __NR_ia32_io_setup: u32 = 245;
pub const __NR_ia32_io_destroy: u32 = 246;
pub const __NR_ia32_io_getevents: u32 = 247;
pub const __NR_ia32_io_submit: u32 = 248;
pub const __NR_ia32_io_cancel: u32 = 249;
pub const __NR_ia32_fadvise64: u32 = 250;
pub const __NR_ia32_exit_group: u32 = 252;
pub const __NR_ia32_lookup_dcookie: u32 = 253;
pub const __NR_ia32_epoll_create: u32 = 254;
pub const __NR_ia32_epoll_ctl: u32 = 255;
pub const __NR_ia32_epoll_wait: u32 = 256;
pub const __NR_ia32_remap_file_pages: u32 = 257;
pub const __NR_ia32_set_tid_address: u32 = 258;
pub const __NR_ia32_timer_create: u32 = 259;
pub const __NR_ia32_timer_settime: u32 = 260;
pub const __NR_ia32_timer_gettime: u32 = 261;
pub const __NR_ia32_timer_getoverrun: u32 = 262;
pub const __NR_ia32_timer_delete: u32 = 263;
pub const __NR_ia32_clock_settime: u32 = 264;
pub const __NR_ia32_clock_gettime: u32 = 265;
pub const __NR_ia32_clock_getres: u32 = 266;
pub const __NR_ia32_clock_nanosleep: u32 = 267;
pub const __NR_ia32_statfs64: u32 = 268;
pub const __NR_ia32_fstatfs64: u32 = 269;
pub const __NR_ia32_tgkill: u32 = 270;
pub const __NR_ia32_utimes: u32 = 271;
pub const __NR_ia32_fadvise64_64: u32 = 272;
pub const __NR_ia32_vserver: u32 = 273;
pub const __NR_ia32_mbind: u32 = 274;
pub const __NR_ia32_get_mempolicy: u32 = 275;
pub const __NR_ia32_set_mempolicy: u32 = 276;
pub const __NR_ia32_mq_open: u32 = 277;
pub const __NR_ia32_mq_unlink: u32 = 278;
pub const __NR_ia32_mq_timedsend: u32 = 279;
pub const __NR_ia32_mq_timedreceive: u32 = 280;
pub const __NR_ia32_mq_notify: u32 = 281;
pub const __NR_ia32_mq_getsetattr: u32 = 282;
pub const __NR_ia32_kexec_load: u32 = 283;
pub const __NR_ia32_waitid: u32 = 284;
pub const __NR_ia32_add_key: u32 = 286;
pub const __NR_ia32_request_key: u32 = 287;
pub const __NR_ia32_keyctl: u32 = 288;
pub const __NR_ia32_ioprio_set: u32 = 289;
pub const __NR_ia32_ioprio_get: u32 = 290;
pub const __NR_ia32_inotify_init: u32 = 291;
pub const __NR_ia32_inotify_add_watch: u32 = 292;
pub const __NR_ia32_inotify_rm_watch: u32 = 293;
pub const __NR_ia32_migrate_pages: u32 = 294;
pub const __NR_ia32_openat: u32 = 295;
pub const __NR_ia32_mkdirat: u32 = 296;
pub const __NR_ia32_mknodat: u32 = 297;
pub const __NR_ia32_fchownat: u32 = 298;
pub const __NR_ia32_futimesat: u32 = 299;
pub const __NR_ia32_fstatat64: u32 = 300;
pub const __NR_ia32_unlinkat: u32 = 301;
pub const __NR_ia32_renameat: u32 = 302;
pub const __NR_ia32_linkat: u32 = 303;
pub const __NR_ia32_symlinkat: u32 = 304;
pub const __NR_ia32_readlinkat: u32 = 305;
pub const __NR_ia32_fchmodat: u32 = 306;
pub const __NR_ia32_faccessat: u32 = 307;
pub const __NR_ia32_pselect6: u32 = 308;
pub const __NR_ia32_ppoll: u32 = 309;
pub const __NR_ia32_unshare: u32 = 310;
pub const __NR_ia32_set_robust_list: u32 = 311;
pub const __NR_ia32_get_robust_list: u32 = 312;
pub const __NR_ia32_splice: u32 = 313;
pub const __NR_ia32_sync_file_range: u32 = 314;
pub const __NR_ia32_tee: u32 = 315;
pub const __NR_ia32_vmsplice: u32 = 316;
pub const __NR_ia32_move_pages: u32 = 317;
pub const __NR_ia32_getcpu: u32 = 318;
pub const __NR_ia32_epoll_pwait: u32 = 319;
pub const __NR_ia32_utimensat: u32 = 320;
pub const __NR_ia32_signalfd: u32 = 321;
pub const __NR_ia32_timerfd_create: u32 = 322;
pub const __NR_ia32_eventfd: u32 = 323;
pub const __NR_ia32_fallocate: u32 = 324;
pub const __NR_ia32_timerfd_settime: u32 = 325;
pub const __NR_ia32_timerfd_gettime: u32 = 326;
pub const __NR_ia32_signalfd4: u32 = 327;
pub const __NR_ia32_eventfd2: u32 = 328;
pub const __NR_ia32_epoll_create1: u32 = 329;
pub const __NR_ia32_dup3: u32 = 330;
pub const __NR_ia32_pipe2: u32 = 331;
pub const __NR_ia32_inotify_init1: u32 = 332;
pub const __NR_ia32_preadv: u32 = 333;
pub const __NR_ia32_pwritev: u32 = 334;
pub const __NR_ia32_rt_tgsigqueueinfo: u32 = 335;
pub const __NR_ia32_perf_event_open: u32 = 336;
pub const __NR_ia32_recvmmsg: u32 = 337;
pub const __NR_ia32_fanotify_init: u32 = 338;
pub const __NR_ia32_fanotify_mark: u32 = 339;
pub const __NR_ia32_prlimit64: u32 = 340;
pub const __NR_ia32_name_to_handle_at: u32 = 341;
pub const __NR_ia32_open_by_handle_at: u32 = 342;
pub const __NR_ia32_clock_adjtime: u32 = 343;
pub const __NR_ia32_syncfs: u32 = 344;
pub const __NR_ia32_sendmmsg: u32 = 345;
pub const __NR_ia32_setns: u32 = 346;
pub const __NR_ia32_process_vm_readv: u32 = 347;
pub const __NR_ia32_process_vm_writev: u32 = 348;
pub const __NR_ia32_kcmp: u32 = 349;
pub const __NR_ia32_finit_module: u32 = 350;
pub const __NR_ia32_sched_setattr: u32 = 351;
pub const __NR_ia32_sched_getattr: u32 = 352;
pub const __NR_ia32_renameat2: u32 = 353;
pub const __NR_ia32_seccomp: u32 = 354;
pub const __NR_ia32_getrandom: u32 = 355;
pub const __NR_ia32_memfd_create: u32 = 356;
pub const __NR_ia32_bpf: u32 = 357;
pub const __NR_ia32_execveat: u32 = 358;
pub const __NR_ia32_socket: u32 = 359;
pub const __NR_ia32_socketpair: u32 = 360;
pub const __NR_ia32_bind: u32 = 361;
pub const __NR_ia32_connect: u32 = 362;
pub const __NR_ia32_listen: u32 = 363;
pub const __NR_ia32_accept4: u32 = 364;
pub const __NR_ia32_getsockopt: u32 = 365;
pub const __NR_ia32_setsockopt: u32 = 366;
pub const __NR_ia32_getsockname: u32 = 367;
pub const __NR_ia32_getpeername: u32 = 368;
pub const __NR_ia32_sendto: u32 = 369;
pub const __NR_ia32_sendmsg: u32 = 370;
pub const __NR_ia32_recvfrom: u32 = 371;
pub const __NR_ia32_recvmsg: u32 = 372;
pub const __NR_ia32_shutdown: u32 = 373;
pub const __NR_ia32_userfaultfd: u32 = 374;
pub const __NR_ia32_membarrier: u32 = 375;
pub const __NR_ia32_mlock2: u32 = 376;
pub const __NR_ia32_copy_file_range: u32 = 377;
pub const __NR_ia32_preadv2: u32 = 378;
pub const __NR_ia32_pwritev2: u32 = 379;
pub const __NR_ia32_pkey_mprotect: u32 = 380;
pub const __NR_ia32_pkey_alloc: u32 = 381;
pub const __NR_ia32_pkey_free: u32 = 382;
pub const __NR_ia32_statx: u32 = 383;
pub const __NR_ia32_arch_prctl: u32 = 384;
pub const __NR_ia32_io_pgetevents: u32 = 385;
pub const __NR_ia32_rseq: u32 = 386;
pub const __NR_ia32_semget: u32 = 393;
pub const __NR_ia32_semctl: u32 = 394;
pub const __NR_ia32_shmget: u32 = 395;
pub const __NR_ia32_shmctl: u32 = 396;
pub const __NR_ia32_shmat: u32 = 397;
pub const __NR_ia32_shmdt: u32 = 398;
pub const __NR_ia32_msgget: u32 = 399;
pub const __NR_ia32_msgsnd: u32 = 400;
pub const __NR_ia32_msgrcv: u32 = 401;
pub const __NR_ia32_msgctl: u32 = 402;
pub const __NR_ia32_clock_gettime64: u32 = 403;
pub const __NR_ia32_clock_settime64: u32 = 404;
pub const __NR_ia32_clock_adjtime64: u32 = 405;
pub const __NR_ia32_clock_getres_time64: u32 = 406;
pub const __NR_ia32_clock_nanosleep_time64: u32 = 407;
pub const __NR_ia32_timer_gettime64: u32 = 408;
pub const __NR_ia32_timer_settime64: u32 = 409;
pub const __NR_ia32_timerfd_gettime64: u32 = 410;
pub const __NR_ia32_timerfd_settime64: u32 = 411;
pub const __NR_ia32_utimensat_time64: u32 = 412;
pub const __NR_ia32_pselect6_time64: u32 = 413;
pub const __NR_ia32_ppoll_time64: u32 = 414;
pub const __NR_ia32_io_pgetevents_time64: u32 = 416;
pub const __NR_ia32_recvmmsg_time64: u32 = 417;
pub const __NR_ia32_mq_timedsend_time64: u32 = 418;
pub const __NR_ia32_mq_timedreceive_time64: u32 = 419;
pub const __NR_ia32_semtimedop_time64: u32 = 420;
pub const __NR_ia32_rt_sigtimedwait_time64: u32 = 421;
pub const __NR_ia32_futex_time64: u32 = 422;
pub const __NR_ia32_sched_rr_get_interval_time64: u32 = 423;
pub const __NR_ia32_pidfd_send_signal: u32 = 424;
pub const __NR_ia32_io_uring_setup: u32 = 425;
pub const __NR_ia32_io_uring_enter: u32 = 426;
pub const __NR_ia32_io_uring_register: u32 = 427;
pub const __NR_ia32_open_tree: u32 = 428;
pub const __NR_ia32_move_mount: u32 = 429;
pub const __NR_ia32_fsopen: u32 = 430;
pub const __NR_ia32_fsconfig: u32 = 431;
pub const __NR_ia32_fsmount: u32 = 432;
pub const __NR_ia32_fspick: u32 = 433;
pub const __NR_ia32_pidfd_open: u32 = 434;
pub const __NR_ia32_clone3: u32 = 435;
pub const __NR_ia32_close_range: u32 = 436;
pub const __NR_ia32_openat2: u32 = 437;
pub const __NR_ia32_pidfd_getfd: u32 = 438;
pub const __NR_ia32_faccessat2: u32 = 439;
pub const __NR_ia32_process_madvise: u32 = 440;
pub const __NR_ia32_epoll_pwait2: u32 = 441;
pub const __NR_ia32_mount_setattr: u32 = 442;
pub const __NR_ia32_quotactl_fd: u32 = 443;
pub const __NR_ia32_landlock_create_ruleset: u32 = 444;
pub const __NR_ia32_landlock_add_rule: u32 = 445;
pub const __NR_ia32_landlock_restrict_self: u32 = 446;
pub const __NR_ia32_memfd_secret: u32 = 447;
pub const __NR_ia32_process_mrelease: u32 = 448;
pub const __NR_ia32_futex_waitv: u32 = 449;
pub const __NR_ia32_set_mempolicy_home_node: u32 = 450;
pub const __NR_ia32_cachestat: u32 = 451;
pub const __NR_ia32_fchmodat2: u32 = 452;
pub const __NR_ia32_map_shadow_stack: u32 = 453;
pub const __NR_ia32_futex_wake: u32 = 454;
pub const __NR_ia32_futex_wait: u32 = 455;
pub const __NR_ia32_futex_requeue: u32 = 456;
pub const __NR_ia32_statmount: u32 = 457;
pub const __NR_ia32_listmount: u32 = 458;
pub const __NR_ia32_lsm_get_self_attr: u32 = 459;
pub const __NR_ia32_lsm_set_self_attr: u32 = 460;
pub const __NR_ia32_lsm_list_modules: u32 = 461;
pub const __NR_ia32_syscalls: u32 = 462;
pub const X32_NR_syscalls: u32 = 548;
pub const IA32_NR_syscalls: u32 = 462;
pub const NR_syscalls: u32 = 462;
pub const ADFS_SUPER_MAGIC: u32 = 44533;
pub const AFFS_SUPER_MAGIC: u32 = 44543;
pub const AFS_SUPER_MAGIC: u32 = 1397113167;
pub const AUTOFS_SUPER_MAGIC: u32 = 391;
pub const CEPH_SUPER_MAGIC: u32 = 12805120;
pub const CODA_SUPER_MAGIC: u32 = 1937076805;
pub const CRAMFS_MAGIC: u32 = 684539205;
pub const CRAMFS_MAGIC_WEND: u32 = 1161678120;
pub const DEBUGFS_MAGIC: u32 = 1684170528;
pub const SECURITYFS_MAGIC: u32 = 1935894131;
pub const SELINUX_MAGIC: u32 = 4185718668;
pub const SMACK_MAGIC: u32 = 1128357203;
pub const RAMFS_MAGIC: u32 = 2240043254;
pub const TMPFS_MAGIC: u32 = 16914836;
pub const HUGETLBFS_MAGIC: u32 = 2508478710;
pub const SQUASHFS_MAGIC: u32 = 1936814952;
pub const ECRYPTFS_SUPER_MAGIC: u32 = 61791;
pub const EFS_SUPER_MAGIC: u32 = 4278867;
pub const EROFS_SUPER_MAGIC_V1: u32 = 3774210530;
pub const EXT2_SUPER_MAGIC: u32 = 61267;
pub const EXT3_SUPER_MAGIC: u32 = 61267;
pub const XENFS_SUPER_MAGIC: u32 = 2881100148;
pub const EXT4_SUPER_MAGIC: u32 = 61267;
pub const BTRFS_SUPER_MAGIC: u32 = 2435016766;
pub const NILFS_SUPER_MAGIC: u32 = 13364;
pub const F2FS_SUPER_MAGIC: u32 = 4076150800;
pub const HPFS_SUPER_MAGIC: u32 = 4187351113;
pub const ISOFS_SUPER_MAGIC: u32 = 38496;
pub const JFFS2_SUPER_MAGIC: u32 = 29366;
pub const XFS_SUPER_MAGIC: u32 = 1481003842;
pub const PSTOREFS_MAGIC: u32 = 1634035564;
pub const EFIVARFS_MAGIC: u32 = 3730735588;
pub const HOSTFS_SUPER_MAGIC: u32 = 12648430;
pub const OVERLAYFS_SUPER_MAGIC: u32 = 2035054128;
pub const FUSE_SUPER_MAGIC: u32 = 1702057286;
pub const MINIX_SUPER_MAGIC: u32 = 4991;
pub const MINIX_SUPER_MAGIC2: u32 = 5007;
pub const MINIX2_SUPER_MAGIC: u32 = 9320;
pub const MINIX2_SUPER_MAGIC2: u32 = 9336;
pub const MINIX3_SUPER_MAGIC: u32 = 19802;
pub const MSDOS_SUPER_MAGIC: u32 = 19780;
pub const EXFAT_SUPER_MAGIC: u32 = 538032816;
pub const NCP_SUPER_MAGIC: u32 = 22092;
pub const NFS_SUPER_MAGIC: u32 = 26985;
pub const OCFS2_SUPER_MAGIC: u32 = 1952539503;
pub const OPENPROM_SUPER_MAGIC: u32 = 40865;
pub const QNX4_SUPER_MAGIC: u32 = 47;
pub const QNX6_SUPER_MAGIC: u32 = 1746473250;
pub const AFS_FS_MAGIC: u32 = 1799439955;
pub const REISERFS_SUPER_MAGIC: u32 = 1382369651;
pub const REISERFS_SUPER_MAGIC_STRING: &[u8; 9usize] = b"ReIsErFs\0";
pub const REISER2FS_SUPER_MAGIC_STRING: &[u8; 10usize] = b"ReIsEr2Fs\0";
pub const REISER2FS_JR_SUPER_MAGIC_STRING: &[u8; 10usize] = b"ReIsEr3Fs\0";
pub const SMB_SUPER_MAGIC: u32 = 20859;
pub const CIFS_SUPER_MAGIC: u32 = 4283649346;
pub const SMB2_SUPER_MAGIC: u32 = 4266872130;
pub const CGROUP_SUPER_MAGIC: u32 = 2613483;
pub const CGROUP2_SUPER_MAGIC: u32 = 1667723888;
pub const RDTGROUP_SUPER_MAGIC: u32 = 124082209;
pub const STACK_END_MAGIC: u32 = 1470918301;
pub const TRACEFS_MAGIC: u32 = 1953653091;
pub const V9FS_MAGIC: u32 = 16914839;
pub const BDEVFS_MAGIC: u32 = 1650746742;
pub const DAXFS_MAGIC: u32 = 1684300152;
pub const BINFMTFS_MAGIC: u32 = 1112100429;
pub const DEVPTS_SUPER_MAGIC: u32 = 7377;
pub const BINDERFS_SUPER_MAGIC: u32 = 1819242352;
pub const FUTEXFS_SUPER_MAGIC: u32 = 195894762;
pub const PIPEFS_MAGIC: u32 = 1346981957;
pub const PROC_SUPER_MAGIC: u32 = 40864;
pub const SOCKFS_MAGIC: u32 = 1397703499;
pub const SYSFS_MAGIC: u32 = 1650812274;
pub const USBDEVICE_SUPER_MAGIC: u32 = 40866;
pub const MTD_INODE_FS_MAGIC: u32 = 288389204;
pub const ANON_INODE_FS_MAGIC: u32 = 151263540;
pub const BTRFS_TEST_MAGIC: u32 = 1936880249;
pub const NSFS_MAGIC: u32 = 1853056627;
pub const BPF_FS_MAGIC: u32 = 3405662737;
pub const AAFS_MAGIC: u32 = 1513908720;
pub const ZONEFS_MAGIC: u32 = 1515144787;
pub const UDF_SUPER_MAGIC: u32 = 352400198;
pub const DMA_BUF_MAGIC: u32 = 1145913666;
pub const DEVMEM_MAGIC: u32 = 1162691661;
pub const SECRETMEM_MAGIC: u32 = 1397048141;
pub const COMPAT_USER_HZ: u32 = 100;
pub const COMPAT_RLIM_INFINITY: u32 = 4294967295;
pub const COMPAT_OFF_T_MAX: u32 = 2147483647;
pub const _COMPAT_NSIG: u32 = 64;
pub const _COMPAT_NSIG_BPW: u32 = 32;
pub const COMPAT_UTS_MACHINE: &[u8; 7usize] = b"i686\0\0\0";
pub const COMPAT_USE_64BIT_TIME: u32 = 0;
pub const COMPAT_MINSIGSTKSZ: u32 = 2048;
pub const _COMPAT_NSIG_WORDS: u32 = 2;
pub const STAT64_HAS_BROKEN_ST_INO: u32 = 1;
pub const USER_XSTATE_FX_SW_WORDS: u32 = 6;
pub const USER_XSTATE_XCR0_WORD: u32 = 0;
pub const R_X86_64_NONE: u32 = 0;
pub const R_X86_64_64: u32 = 1;
pub const R_X86_64_PC32: u32 = 2;
pub const R_X86_64_GOT32: u32 = 3;
pub const R_X86_64_PLT32: u32 = 4;
pub const R_X86_64_COPY: u32 = 5;
pub const R_X86_64_GLOB_DAT: u32 = 6;
pub const R_X86_64_JUMP_SLOT: u32 = 7;
pub const R_X86_64_RELATIVE: u32 = 8;
pub const R_X86_64_GOTPCREL: u32 = 9;
pub const R_X86_64_32: u32 = 10;
pub const R_X86_64_32S: u32 = 11;
pub const R_X86_64_16: u32 = 12;
pub const R_X86_64_PC16: u32 = 13;
pub const R_X86_64_8: u32 = 14;
pub const R_X86_64_PC8: u32 = 15;
pub const R_X86_64_PC64: u32 = 24;
pub const COMPAT_ELF_PLATFORM: &[u8; 5usize] = b"i686\0";
pub const ELF_PLATFORM: &[u8; 7usize] = b"x86_64\0";
pub const ELF_EXEC_PAGESIZE: u32 = 4096;
pub const AT_SYSINFO: u32 = 32;
pub const ARCH_HAS_SETUP_ADDITIONAL_PAGES: u32 = 1;
pub const EM_NONE: u32 = 0;
pub const EM_M32: u32 = 1;
pub const EM_SPARC: u32 = 2;
pub const EM_386: u32 = 3;
pub const EM_68K: u32 = 4;
pub const EM_88K: u32 = 5;
pub const EM_486: u32 = 6;
pub const EM_860: u32 = 7;
pub const EM_MIPS: u32 = 8;
pub const EM_MIPS_RS3_LE: u32 = 10;
pub const EM_MIPS_RS4_BE: u32 = 10;
pub const EM_PARISC: u32 = 15;
pub const EM_SPARC32PLUS: u32 = 18;
pub const EM_PPC: u32 = 20;
pub const EM_PPC64: u32 = 21;
pub const EM_SPU: u32 = 23;
pub const EM_ARM: u32 = 40;
pub const EM_SH: u32 = 42;
pub const EM_SPARCV9: u32 = 43;
pub const EM_H8_300: u32 = 46;
pub const EM_IA_64: u32 = 50;
pub const EM_X86_64: u32 = 62;
pub const EM_S390: u32 = 22;
pub const EM_CRIS: u32 = 76;
pub const EM_M32R: u32 = 88;
pub const EM_MN10300: u32 = 89;
pub const EM_OPENRISC: u32 = 92;
pub const EM_ARCOMPACT: u32 = 93;
pub const EM_XTENSA: u32 = 94;
pub const EM_BLACKFIN: u32 = 106;
pub const EM_UNICORE: u32 = 110;
pub const EM_ALTERA_NIOS2: u32 = 113;
pub const EM_TI_C6000: u32 = 140;
pub const EM_HEXAGON: u32 = 164;
pub const EM_NDS32: u32 = 167;
pub const EM_AARCH64: u32 = 183;
pub const EM_TILEPRO: u32 = 188;
pub const EM_MICROBLAZE: u32 = 189;
pub const EM_TILEGX: u32 = 191;
pub const EM_ARCV2: u32 = 195;
pub const EM_RISCV: u32 = 243;
pub const EM_BPF: u32 = 247;
pub const EM_CSKY: u32 = 252;
pub const EM_LOONGARCH: u32 = 258;
pub const EM_FRV: u32 = 21569;
pub const EM_ALPHA: u32 = 36902;
pub const EM_CYGNUS_M32R: u32 = 36929;
pub const EM_S390_OLD: u32 = 41872;
pub const EM_CYGNUS_MN10300: u32 = 48879;
pub const PT_NULL: u32 = 0;
pub const PT_LOAD: u32 = 1;
pub const PT_DYNAMIC: u32 = 2;
pub const PT_INTERP: u32 = 3;
pub const PT_NOTE: u32 = 4;
pub const PT_SHLIB: u32 = 5;
pub const PT_PHDR: u32 = 6;
pub const PT_TLS: u32 = 7;
pub const PT_LOOS: u32 = 1610612736;
pub const PT_HIOS: u32 = 1879048191;
pub const PT_LOPROC: u32 = 1879048192;
pub const PT_HIPROC: u32 = 2147483647;
pub const PT_GNU_EH_FRAME: u32 = 1685382480;
pub const PT_GNU_STACK: u32 = 1685382481;
pub const PT_GNU_RELRO: u32 = 1685382482;
pub const PT_GNU_PROPERTY: u32 = 1685382483;
pub const PT_AARCH64_MEMTAG_MTE: u32 = 1879048194;
pub const PN_XNUM: u32 = 65535;
pub const ET_NONE: u32 = 0;
pub const ET_REL: u32 = 1;
pub const ET_EXEC: u32 = 2;
pub const ET_DYN: u32 = 3;
pub const ET_CORE: u32 = 4;
pub const ET_LOPROC: u32 = 65280;
pub const ET_HIPROC: u32 = 65535;
pub const DT_NULL: u32 = 0;
pub const DT_NEEDED: u32 = 1;
pub const DT_PLTRELSZ: u32 = 2;
pub const DT_PLTGOT: u32 = 3;
pub const DT_HASH: u32 = 4;
pub const DT_STRTAB: u32 = 5;
pub const DT_SYMTAB: u32 = 6;
pub const DT_RELA: u32 = 7;
pub const DT_RELASZ: u32 = 8;
pub const DT_RELAENT: u32 = 9;
pub const DT_STRSZ: u32 = 10;
pub const DT_SYMENT: u32 = 11;
pub const DT_INIT: u32 = 12;
pub const DT_FINI: u32 = 13;
pub const DT_SONAME: u32 = 14;
pub const DT_RPATH: u32 = 15;
pub const DT_SYMBOLIC: u32 = 16;
pub const DT_REL: u32 = 17;
pub const DT_RELSZ: u32 = 18;
pub const DT_RELENT: u32 = 19;
pub const DT_PLTREL: u32 = 20;
pub const DT_DEBUG: u32 = 21;
pub const DT_TEXTREL: u32 = 22;
pub const DT_JMPREL: u32 = 23;
pub const DT_ENCODING: u32 = 32;
pub const OLD_DT_LOOS: u32 = 1610612736;
pub const DT_LOOS: u32 = 1610612749;
pub const DT_HIOS: u32 = 1879044096;
pub const DT_VALRNGLO: u32 = 1879047424;
pub const DT_VALRNGHI: u32 = 1879047679;
pub const DT_ADDRRNGLO: u32 = 1879047680;
pub const DT_ADDRRNGHI: u32 = 1879047935;
pub const DT_VERSYM: u32 = 1879048176;
pub const DT_RELACOUNT: u32 = 1879048185;
pub const DT_RELCOUNT: u32 = 1879048186;
pub const DT_FLAGS_1: u32 = 1879048187;
pub const DT_VERDEF: u32 = 1879048188;
pub const DT_VERDEFNUM: u32 = 1879048189;
pub const DT_VERNEED: u32 = 1879048190;
pub const DT_VERNEEDNUM: u32 = 1879048191;
pub const OLD_DT_HIOS: u32 = 1879048191;
pub const DT_LOPROC: u32 = 1879048192;
pub const DT_HIPROC: u32 = 2147483647;
pub const STB_LOCAL: u32 = 0;
pub const STB_GLOBAL: u32 = 1;
pub const STB_WEAK: u32 = 2;
pub const STT_NOTYPE: u32 = 0;
pub const STT_OBJECT: u32 = 1;
pub const STT_FUNC: u32 = 2;
pub const STT_SECTION: u32 = 3;
pub const STT_FILE: u32 = 4;
pub const STT_COMMON: u32 = 5;
pub const STT_TLS: u32 = 6;
pub const EI_NIDENT: u32 = 16;
pub const PF_R: u32 = 4;
pub const PF_W: u32 = 2;
pub const PF_X: u32 = 1;
pub const SHT_NULL: u32 = 0;
pub const SHT_PROGBITS: u32 = 1;
pub const SHT_SYMTAB: u32 = 2;
pub const SHT_STRTAB: u32 = 3;
pub const SHT_RELA: u32 = 4;
pub const SHT_HASH: u32 = 5;
pub const SHT_DYNAMIC: u32 = 6;
pub const SHT_NOTE: u32 = 7;
pub const SHT_NOBITS: u32 = 8;
pub const SHT_REL: u32 = 9;
pub const SHT_SHLIB: u32 = 10;
pub const SHT_DYNSYM: u32 = 11;
pub const SHT_NUM: u32 = 12;
pub const SHT_LOPROC: u32 = 1879048192;
pub const SHT_HIPROC: u32 = 2147483647;
pub const SHT_LOUSER: u32 = 2147483648;
pub const SHT_HIUSER: u32 = 4294967295;
pub const SHF_WRITE: u32 = 1;
pub const SHF_ALLOC: u32 = 2;
pub const SHF_EXECINSTR: u32 = 4;
pub const SHF_RELA_LIVEPATCH: u32 = 1048576;
pub const SHF_RO_AFTER_INIT: u32 = 2097152;
pub const SHF_MASKPROC: u32 = 4026531840;
pub const SHN_UNDEF: u32 = 0;
pub const SHN_LORESERVE: u32 = 65280;
pub const SHN_LOPROC: u32 = 65280;
pub const SHN_HIPROC: u32 = 65311;
pub const SHN_LIVEPATCH: u32 = 65312;
pub const SHN_ABS: u32 = 65521;
pub const SHN_COMMON: u32 = 65522;
pub const SHN_HIRESERVE: u32 = 65535;
pub const EI_MAG0: u32 = 0;
pub const EI_MAG1: u32 = 1;
pub const EI_MAG2: u32 = 2;
pub const EI_MAG3: u32 = 3;
pub const EI_CLASS: u32 = 4;
pub const EI_DATA: u32 = 5;
pub const EI_VERSION: u32 = 6;
pub const EI_OSABI: u32 = 7;
pub const EI_PAD: u32 = 8;
pub const ELFMAG0: u32 = 127;
pub const ELFMAG1: u8 = 69u8;
pub const ELFMAG2: u8 = 76u8;
pub const ELFMAG3: u8 = 70u8;
pub const ELFMAG: &[u8; 5usize] = b"\x7FELF\0";
pub const SELFMAG: u32 = 4;
pub const ELFCLASSNONE: u32 = 0;
pub const ELFCLASS32: u32 = 1;
pub const ELFCLASS64: u32 = 2;
pub const ELFCLASSNUM: u32 = 3;
pub const ELFDATANONE: u32 = 0;
pub const ELFDATA2LSB: u32 = 1;
pub const ELFDATA2MSB: u32 = 2;
pub const EV_NONE: u32 = 0;
pub const EV_CURRENT: u32 = 1;
pub const EV_NUM: u32 = 2;
pub const ELFOSABI_NONE: u32 = 0;
pub const ELFOSABI_LINUX: u32 = 3;
pub const ELF_OSABI: u32 = 0;
pub const NT_PRSTATUS: u32 = 1;
pub const NT_PRFPREG: u32 = 2;
pub const NT_PRPSINFO: u32 = 3;
pub const NT_TASKSTRUCT: u32 = 4;
pub const NT_AUXV: u32 = 6;
pub const NT_SIGINFO: u32 = 1397311305;
pub const NT_FILE: u32 = 1179208773;
pub const NT_PRXFPREG: u32 = 1189489535;
pub const NT_PPC_VMX: u32 = 256;
pub const NT_PPC_SPE: u32 = 257;
pub const NT_PPC_VSX: u32 = 258;
pub const NT_PPC_TAR: u32 = 259;
pub const NT_PPC_PPR: u32 = 260;
pub const NT_PPC_DSCR: u32 = 261;
pub const NT_PPC_EBB: u32 = 262;
pub const NT_PPC_PMU: u32 = 263;
pub const NT_PPC_TM_CGPR: u32 = 264;
pub const NT_PPC_TM_CFPR: u32 = 265;
pub const NT_PPC_TM_CVMX: u32 = 266;
pub const NT_PPC_TM_CVSX: u32 = 267;
pub const NT_PPC_TM_SPR: u32 = 268;
pub const NT_PPC_TM_CTAR: u32 = 269;
pub const NT_PPC_TM_CPPR: u32 = 270;
pub const NT_PPC_TM_CDSCR: u32 = 271;
pub const NT_PPC_PKEY: u32 = 272;
pub const NT_PPC_DEXCR: u32 = 273;
pub const NT_PPC_HASHKEYR: u32 = 274;
pub const NT_386_TLS: u32 = 512;
pub const NT_386_IOPERM: u32 = 513;
pub const NT_X86_XSTATE: u32 = 514;
pub const NT_X86_SHSTK: u32 = 516;
pub const NT_S390_HIGH_GPRS: u32 = 768;
pub const NT_S390_TIMER: u32 = 769;
pub const NT_S390_TODCMP: u32 = 770;
pub const NT_S390_TODPREG: u32 = 771;
pub const NT_S390_CTRS: u32 = 772;
pub const NT_S390_PREFIX: u32 = 773;
pub const NT_S390_LAST_BREAK: u32 = 774;
pub const NT_S390_SYSTEM_CALL: u32 = 775;
pub const NT_S390_TDB: u32 = 776;
pub const NT_S390_VXRS_LOW: u32 = 777;
pub const NT_S390_VXRS_HIGH: u32 = 778;
pub const NT_S390_GS_CB: u32 = 779;
pub const NT_S390_GS_BC: u32 = 780;
pub const NT_S390_RI_CB: u32 = 781;
pub const NT_S390_PV_CPU_DATA: u32 = 782;
pub const NT_ARM_VFP: u32 = 1024;
pub const NT_ARM_TLS: u32 = 1025;
pub const NT_ARM_HW_BREAK: u32 = 1026;
pub const NT_ARM_HW_WATCH: u32 = 1027;
pub const NT_ARM_SYSTEM_CALL: u32 = 1028;
pub const NT_ARM_SVE: u32 = 1029;
pub const NT_ARM_PAC_MASK: u32 = 1030;
pub const NT_ARM_PACA_KEYS: u32 = 1031;
pub const NT_ARM_PACG_KEYS: u32 = 1032;
pub const NT_ARM_TAGGED_ADDR_CTRL: u32 = 1033;
pub const NT_ARM_PAC_ENABLED_KEYS: u32 = 1034;
pub const NT_ARM_SSVE: u32 = 1035;
pub const NT_ARM_ZA: u32 = 1036;
pub const NT_ARM_ZT: u32 = 1037;
pub const NT_ARC_V2: u32 = 1536;
pub const NT_VMCOREDD: u32 = 1792;
pub const NT_MIPS_DSP: u32 = 2048;
pub const NT_MIPS_FP_MODE: u32 = 2049;
pub const NT_MIPS_MSA: u32 = 2050;
pub const NT_RISCV_CSR: u32 = 2304;
pub const NT_RISCV_VECTOR: u32 = 2305;
pub const NT_LOONGARCH_CPUCFG: u32 = 2560;
pub const NT_LOONGARCH_CSR: u32 = 2561;
pub const NT_LOONGARCH_LSX: u32 = 2562;
pub const NT_LOONGARCH_LASX: u32 = 2563;
pub const NT_LOONGARCH_LBT: u32 = 2564;
pub const NT_LOONGARCH_HW_BREAK: u32 = 2565;
pub const NT_LOONGARCH_HW_WATCH: u32 = 2566;
pub const NT_GNU_PROPERTY_TYPE_0: u32 = 5;
pub const GNU_PROPERTY_AARCH64_FEATURE_1_AND: u32 = 3221225472;
pub const GNU_PROPERTY_AARCH64_FEATURE_1_BTI: u32 = 1;
pub const ELF32_GNU_PROPERTY_ALIGN: u32 = 4;
pub const ELF64_GNU_PROPERTY_ALIGN: u32 = 8;
pub const ELF_GNU_PROPERTY_ALIGN: u32 = 8;
pub const IDR_FREE: u32 = 0;
pub const IDA_CHUNK_SIZE: u32 = 128;
pub const KERNFS_TYPE_MASK: u32 = 15;
pub const KERNFS_FLAG_MASK: i32 = -16;
pub const KERNFS_MAX_USER_XATTRS: u32 = 128;
pub const KERNFS_USER_XATTR_SIZE_LIMIT: u32 = 131072;
pub const SYSFS_PREALLOC: u32 = 4096;
pub const UEVENT_HELPER_PATH_LEN: u32 = 256;
pub const UEVENT_NUM_ENVP: u32 = 64;
pub const UEVENT_BUFFER_SIZE: u32 = 2048;
pub const KUNIT_PARAM_DESC_SIZE: u32 = 128;
pub const KUNIT_STATUS_COMMENT_SIZE: u32 = 256;
pub const KUNIT_INDENT_LEN: u32 = 4;
pub const KUNIT_SUBTEST_INDENT: &[u8; 5usize] = b"    \0";
pub const KUNIT_SUBSUBTEST_INDENT: &[u8; 9usize] = b"        \0";
pub const STACK_DEPOT_EXTRA_BITS: u32 = 5;
pub const DEPOT_POOL_ORDER: u32 = 2;
pub const DEPOT_POOL_SIZE: u32 = 16384;
pub const DEPOT_STACK_ALIGN: u32 = 4;
pub const DEPOT_OFFSET_BITS: u32 = 10;
pub const STACK_DEPOT_FLAGS_NUM: u32 = 2;
pub const SZ_1: u32 = 1;
pub const SZ_2: u32 = 2;
pub const SZ_4: u32 = 4;
pub const SZ_8: u32 = 8;
pub const SZ_16: u32 = 16;
pub const SZ_32: u32 = 32;
pub const SZ_64: u32 = 64;
pub const SZ_128: u32 = 128;
pub const SZ_256: u32 = 256;
pub const SZ_512: u32 = 512;
pub const SZ_1K: u32 = 1024;
pub const SZ_2K: u32 = 2048;
pub const SZ_4K: u32 = 4096;
pub const SZ_8K: u32 = 8192;
pub const SZ_16K: u32 = 16384;
pub const SZ_32K: u32 = 32768;
pub const SZ_64K: u32 = 65536;
pub const SZ_128K: u32 = 131072;
pub const SZ_256K: u32 = 262144;
pub const SZ_512K: u32 = 524288;
pub const SZ_1M: u32 = 1048576;
pub const SZ_2M: u32 = 2097152;
pub const SZ_4M: u32 = 4194304;
pub const SZ_8M: u32 = 8388608;
pub const SZ_16M: u32 = 16777216;
pub const SZ_32M: u32 = 33554432;
pub const SZ_64M: u32 = 67108864;
pub const SZ_128M: u32 = 134217728;
pub const SZ_256M: u32 = 268435456;
pub const SZ_512M: u32 = 536870912;
pub const SZ_1G: u32 = 1073741824;
pub const SZ_2G: u32 = 2147483648;
pub const PMD_ORDER: u32 = 9;
pub const PUD_ORDER: u32 = 18;
pub const USER_PGTABLES_CEILING: u32 = 0;
pub const FIRST_USER_ADDRESS: u32 = 0;
pub const __PGTBL_PGD_MODIFIED: u32 = 0;
pub const __PGTBL_P4D_MODIFIED: u32 = 1;
pub const __PGTBL_PUD_MODIFIED: u32 = 2;
pub const __PGTBL_PMD_MODIFIED: u32 = 3;
pub const __PGTBL_PTE_MODIFIED: u32 = 4;
pub const MAX_PTRS_PER_PTE: u32 = 512;
pub const MAX_PTRS_PER_PMD: u32 = 512;
pub const MAX_PTRS_PER_PUD: u32 = 512;
pub const IORESOURCE_BITS: u32 = 255;
pub const IORESOURCE_TYPE_BITS: u32 = 7936;
pub const IORESOURCE_IO: u32 = 256;
pub const IORESOURCE_MEM: u32 = 512;
pub const IORESOURCE_REG: u32 = 768;
pub const IORESOURCE_IRQ: u32 = 1024;
pub const IORESOURCE_DMA: u32 = 2048;
pub const IORESOURCE_BUS: u32 = 4096;
pub const IORESOURCE_PREFETCH: u32 = 8192;
pub const IORESOURCE_READONLY: u32 = 16384;
pub const IORESOURCE_CACHEABLE: u32 = 32768;
pub const IORESOURCE_RANGELENGTH: u32 = 65536;
pub const IORESOURCE_SHADOWABLE: u32 = 131072;
pub const IORESOURCE_SIZEALIGN: u32 = 262144;
pub const IORESOURCE_STARTALIGN: u32 = 524288;
pub const IORESOURCE_MEM_64: u32 = 1048576;
pub const IORESOURCE_WINDOW: u32 = 2097152;
pub const IORESOURCE_MUXED: u32 = 4194304;
pub const IORESOURCE_EXT_TYPE_BITS: u32 = 16777216;
pub const IORESOURCE_SYSRAM: u32 = 16777216;
pub const IORESOURCE_SYSRAM_DRIVER_MANAGED: u32 = 33554432;
pub const IORESOURCE_SYSRAM_MERGEABLE: u32 = 67108864;
pub const IORESOURCE_EXCLUSIVE: u32 = 134217728;
pub const IORESOURCE_DISABLED: u32 = 268435456;
pub const IORESOURCE_UNSET: u32 = 536870912;
pub const IORESOURCE_AUTO: u32 = 1073741824;
pub const IORESOURCE_BUSY: u32 = 2147483648;
pub const IORESOURCE_SYSTEM_RAM: u32 = 16777728;
pub const IORESOURCE_IRQ_HIGHEDGE: u32 = 1;
pub const IORESOURCE_IRQ_LOWEDGE: u32 = 2;
pub const IORESOURCE_IRQ_HIGHLEVEL: u32 = 4;
pub const IORESOURCE_IRQ_LOWLEVEL: u32 = 8;
pub const IORESOURCE_IRQ_SHAREABLE: u32 = 16;
pub const IORESOURCE_IRQ_OPTIONAL: u32 = 32;
pub const IORESOURCE_IRQ_WAKECAPABLE: u32 = 64;
pub const IORESOURCE_DMA_TYPE_MASK: u32 = 3;
pub const IORESOURCE_DMA_8BIT: u32 = 0;
pub const IORESOURCE_DMA_8AND16BIT: u32 = 1;
pub const IORESOURCE_DMA_16BIT: u32 = 2;
pub const IORESOURCE_DMA_MASTER: u32 = 4;
pub const IORESOURCE_DMA_BYTE: u32 = 8;
pub const IORESOURCE_DMA_WORD: u32 = 16;
pub const IORESOURCE_DMA_SPEED_MASK: u32 = 192;
pub const IORESOURCE_DMA_COMPATIBLE: u32 = 0;
pub const IORESOURCE_DMA_TYPEA: u32 = 64;
pub const IORESOURCE_DMA_TYPEB: u32 = 128;
pub const IORESOURCE_DMA_TYPEF: u32 = 192;
pub const IORESOURCE_MEM_WRITEABLE: u32 = 1;
pub const IORESOURCE_MEM_CACHEABLE: u32 = 2;
pub const IORESOURCE_MEM_RANGELENGTH: u32 = 4;
pub const IORESOURCE_MEM_TYPE_MASK: u32 = 24;
pub const IORESOURCE_MEM_8BIT: u32 = 0;
pub const IORESOURCE_MEM_16BIT: u32 = 8;
pub const IORESOURCE_MEM_8AND16BIT: u32 = 16;
pub const IORESOURCE_MEM_32BIT: u32 = 24;
pub const IORESOURCE_MEM_SHADOWABLE: u32 = 32;
pub const IORESOURCE_MEM_EXPANSIONROM: u32 = 64;
pub const IORESOURCE_MEM_NONPOSTED: u32 = 128;
pub const IORESOURCE_IO_16BIT_ADDR: u32 = 1;
pub const IORESOURCE_IO_FIXED: u32 = 2;
pub const IORESOURCE_IO_SPARSE: u32 = 4;
pub const IORESOURCE_ROM_ENABLE: u32 = 1;
pub const IORESOURCE_ROM_SHADOW: u32 = 2;
pub const IORESOURCE_PCI_FIXED: u32 = 16;
pub const IORESOURCE_PCI_EA_BEI: u32 = 32;
pub const PGMAP_ALTMAP_VALID: u32 = 1;
pub const MAPCOUNT_ELF_CORE_MARGIN: u32 = 5;
pub const VM_NONE: u32 = 0;
pub const VM_READ: u32 = 1;
pub const VM_WRITE: u32 = 2;
pub const VM_EXEC: u32 = 4;
pub const VM_SHARED: u32 = 8;
pub const VM_MAYREAD: u32 = 16;
pub const VM_MAYWRITE: u32 = 32;
pub const VM_MAYEXEC: u32 = 64;
pub const VM_MAYSHARE: u32 = 128;
pub const VM_GROWSDOWN: u32 = 256;
pub const VM_UFFD_MISSING: u32 = 512;
pub const VM_PFNMAP: u32 = 1024;
pub const VM_UFFD_WP: u32 = 4096;
pub const VM_LOCKED: u32 = 8192;
pub const VM_IO: u32 = 16384;
pub const VM_SEQ_READ: u32 = 32768;
pub const VM_RAND_READ: u32 = 65536;
pub const VM_DONTCOPY: u32 = 131072;
pub const VM_DONTEXPAND: u32 = 262144;
pub const VM_LOCKONFAULT: u32 = 524288;
pub const VM_ACCOUNT: u32 = 1048576;
pub const VM_NORESERVE: u32 = 2097152;
pub const VM_HUGETLB: u32 = 4194304;
pub const VM_SYNC: u32 = 8388608;
pub const VM_ARCH_1: u32 = 16777216;
pub const VM_WIPEONFORK: u32 = 33554432;
pub const VM_DONTDUMP: u32 = 67108864;
pub const VM_SOFTDIRTY: u32 = 134217728;
pub const VM_MIXEDMAP: u32 = 268435456;
pub const VM_HUGEPAGE: u32 = 536870912;
pub const VM_NOHUGEPAGE: u32 = 1073741824;
pub const VM_MERGEABLE: u32 = 2147483648;
pub const VM_HIGH_ARCH_BIT_0: u32 = 32;
pub const VM_HIGH_ARCH_BIT_1: u32 = 33;
pub const VM_HIGH_ARCH_BIT_2: u32 = 34;
pub const VM_HIGH_ARCH_BIT_3: u32 = 35;
pub const VM_HIGH_ARCH_BIT_4: u32 = 36;
pub const VM_HIGH_ARCH_BIT_5: u32 = 37;
pub const VM_PKEY_SHIFT: u32 = 32;
pub const VM_PKEY_BIT4: u32 = 0;
pub const VM_PAT: u32 = 16777216;
pub const VM_MTE: u32 = 0;
pub const VM_MTE_ALLOWED: u32 = 0;
pub const VM_GROWSUP: u32 = 0;
pub const VM_UFFD_MINOR_BIT: u32 = 38;
pub const VM_DATA_FLAGS_NON_EXEC: u32 = 115;
pub const VM_DATA_FLAGS_EXEC: u32 = 119;
pub const VM_STACK: u32 = 256;
pub const VM_STACK_EARLY: u32 = 0;
pub const VM_ACCESS_FLAGS: u32 = 7;
pub const VM_SPECIAL: u32 = 268715008;
pub const VM_NO_KHUGEPAGED: u32 = 272909312;
pub const VM_INIT_DEF_MASK: u32 = 1073741824;
pub const VM_LOCKED_MASK: u32 = 532480;
pub const VM_ARCH_CLEAR: u32 = 0;
pub const SUID_DUMP_DISABLE: u32 = 0;
pub const SUID_DUMP_USER: u32 = 1;
pub const SUID_DUMP_ROOT: u32 = 2;
pub const MMF_DUMPABLE_BITS: u32 = 2;
pub const MMF_DUMPABLE_MASK: u32 = 3;
pub const MMF_DUMP_ANON_PRIVATE: u32 = 2;
pub const MMF_DUMP_ANON_SHARED: u32 = 3;
pub const MMF_DUMP_MAPPED_PRIVATE: u32 = 4;
pub const MMF_DUMP_MAPPED_SHARED: u32 = 5;
pub const MMF_DUMP_ELF_HEADERS: u32 = 6;
pub const MMF_DUMP_HUGETLB_PRIVATE: u32 = 7;
pub const MMF_DUMP_HUGETLB_SHARED: u32 = 8;
pub const MMF_DUMP_DAX_PRIVATE: u32 = 9;
pub const MMF_DUMP_DAX_SHARED: u32 = 10;
pub const MMF_DUMP_FILTER_SHIFT: u32 = 2;
pub const MMF_DUMP_FILTER_BITS: u32 = 9;
pub const MMF_DUMP_FILTER_MASK: u32 = 2044;
pub const MMF_DUMP_MASK_DEFAULT_ELF: u32 = 64;
pub const MMF_VM_MERGEABLE: u32 = 16;
pub const MMF_VM_HUGEPAGE: u32 = 17;
pub const MMF_HAS_UPROBES: u32 = 19;
pub const MMF_RECALC_UPROBES: u32 = 20;
pub const MMF_OOM_SKIP: u32 = 21;
pub const MMF_UNSTABLE: u32 = 22;
pub const MMF_HUGE_ZERO_PAGE: u32 = 23;
pub const MMF_DISABLE_THP: u32 = 24;
pub const MMF_DISABLE_THP_MASK: u32 = 16777216;
pub const MMF_OOM_REAP_QUEUED: u32 = 25;
pub const MMF_MULTIPROCESS: u32 = 26;
pub const MMF_HAS_PINNED: u32 = 27;
pub const MMF_HAS_MDWE: u32 = 28;
pub const MMF_HAS_MDWE_MASK: u32 = 268435456;
pub const MMF_HAS_MDWE_NO_INHERIT: u32 = 29;
pub const MMF_VM_MERGE_ANY: u32 = 30;
pub const MMF_VM_MERGE_ANY_MASK: u32 = 1073741824;
pub const MMF_INIT_MASK: u32 = 1358956543;
pub const HPAGE_PMD_SHIFT: u32 = 21;
pub const HPAGE_PMD_SIZE: u32 = 2097152;
pub const HPAGE_PMD_MASK: i32 = -2097152;
pub const HPAGE_PUD_SHIFT: u32 = 30;
pub const HPAGE_PUD_SIZE: u32 = 1073741824;
pub const HPAGE_PUD_MASK: i32 = -1073741824;
pub const GUP_PIN_COUNTING_BIAS: u32 = 1024;
pub const PAGE_ACCESS_TIME_MIN_BITS: u32 = 12;
pub const PAGE_ACCESS_TIME_BUCKETS: u32 = 0;
pub const PAGE_ACCESS_TIME_MASK: u32 = 2097151;
pub const ENABLE_NUMA_STAT: u32 = 1;
pub const DISABLE_NUMA_STAT: u32 = 0;
pub const MM_CP_TRY_CHANGE_WRITABLE: u32 = 1;
pub const MM_CP_PROT_NUMA: u32 = 2;
pub const MM_CP_UFFD_WP: u32 = 4;
pub const MM_CP_UFFD_WP_RESOLVE: u32 = 8;
pub const MM_CP_UFFD_WP_ALL: u32 = 12;
pub const VM_UNMAPPED_AREA_TOPDOWN: u32 = 1;
pub const VMEMMAP_RESERVE_NR: u32 = 2;
pub const ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE: u32 = 0;
pub const _HAVE_ARCH_COPY_AND_CSUM_FROM_USER: u32 = 1;
pub const _HAVE_ARCH_IPV6_CSUM: u32 = 1;
pub const PRINTK_INFO_SUBSYSTEM_LEN: u32 = 16;
pub const PRINTK_INFO_DEVICE_LEN: u32 = 48;
pub const SCHED_CPUFREQ_IOWAIT: u32 = 1;
pub const SDF_SHARED_CHILD: u32 = 1;
pub const SDF_SHARED_PARENT: u32 = 2;
pub const SDF_NEEDS_GROUPS: u32 = 4;
pub const SDTL_OVERLAP: u32 = 1;
pub const EM_MAX_POWER: u32 = 64000000;
pub const EM_MAX_NUM_CPUS: u32 = 4096;
pub const PM_EVENT_INVALID: i32 = -1;
pub const PM_EVENT_ON: u32 = 0;
pub const PM_EVENT_FREEZE: u32 = 1;
pub const PM_EVENT_SUSPEND: u32 = 2;
pub const PM_EVENT_HIBERNATE: u32 = 4;
pub const PM_EVENT_QUIESCE: u32 = 8;
pub const PM_EVENT_RESUME: u32 = 16;
pub const PM_EVENT_THAW: u32 = 32;
pub const PM_EVENT_RESTORE: u32 = 64;
pub const PM_EVENT_RECOVER: u32 = 128;
pub const PM_EVENT_USER: u32 = 256;
pub const PM_EVENT_REMOTE: u32 = 512;
pub const PM_EVENT_AUTO: u32 = 1024;
pub const PM_EVENT_SLEEP: u32 = 6;
pub const PM_EVENT_USER_SUSPEND: u32 = 258;
pub const PM_EVENT_USER_RESUME: u32 = 272;
pub const PM_EVENT_REMOTE_RESUME: u32 = 528;
pub const PM_EVENT_AUTO_SUSPEND: u32 = 1026;
pub const PM_EVENT_AUTO_RESUME: u32 = 1040;
pub const PM_EVENT_PRETHAW: u32 = 8;
pub const IO_SPACE_LIMIT: u32 = 65535;
pub const SWNODE_GRAPH_PORT_NAME_FMT: &[u8; 8usize] = b"port@%u\0";
pub const SWNODE_GRAPH_ENDPOINT_NAME_FMT: &[u8; 12usize] = b"endpoint@%u\0";
pub const NR_FWNODE_REFERENCE_ARGS: u32 = 8;
pub const PIO_INDIRECT_SIZE: u32 = 0;
pub const MMIO_UPPER_LIMIT: u32 = 65535;
pub const VM_IOREMAP: u32 = 1;
pub const VM_ALLOC: u32 = 2;
pub const VM_MAP: u32 = 4;
pub const VM_USERMAP: u32 = 8;
pub const VM_DMA_COHERENT: u32 = 16;
pub const VM_UNINITIALIZED: u32 = 32;
pub const VM_NO_GUARD: u32 = 64;
pub const VM_KASAN: u32 = 128;
pub const VM_FLUSH_RESET_PERMS: u32 = 256;
pub const VM_MAP_PUT_PAGES: u32 = 512;
pub const VM_ALLOW_HUGE_VMAP: u32 = 1024;
pub const VM_DEFER_KMEMLEAK: u32 = 0;
pub const ARCH_PAGE_TABLE_SYNC_MASK: u32 = 0;
pub const SG_CHAIN: u32 = 1;
pub const SG_END: u32 = 2;
pub const SG_PAGE_LINK_MASK: u32 = 3;
pub const SG_DMA_BUS_ADDRESS: u32 = 1;
pub const SG_DMA_SWIOTLB: u32 = 2;
pub const SG_CHUNK_SIZE: u32 = 128;
pub const SG_MAX_SEGMENTS: u32 = 2048;
pub const SG_MITER_ATOMIC: u32 = 1;
pub const SG_MITER_TO_SG: u32 = 2;
pub const SG_MITER_FROM_SG: u32 = 4;
pub const DMA_ATTR_WEAK_ORDERING: u32 = 2;
pub const DMA_ATTR_WRITE_COMBINE: u32 = 4;
pub const DMA_ATTR_NO_KERNEL_MAPPING: u32 = 16;
pub const DMA_ATTR_SKIP_CPU_SYNC: u32 = 32;
pub const DMA_ATTR_FORCE_CONTIGUOUS: u32 = 64;
pub const DMA_ATTR_ALLOC_SINGLE_PAGES: u32 = 128;
pub const DMA_ATTR_NO_WARN: u32 = 256;
pub const DMA_ATTR_PRIVILEGED: u32 = 512;
pub const IPV6_FL_A_GET: u32 = 0;
pub const IPV6_FL_A_PUT: u32 = 1;
pub const IPV6_FL_A_RENEW: u32 = 2;
pub const IPV6_FL_F_CREATE: u32 = 1;
pub const IPV6_FL_F_EXCL: u32 = 2;
pub const IPV6_FL_F_REFLECT: u32 = 4;
pub const IPV6_FL_F_REMOTE: u32 = 8;
pub const IPV6_FL_S_NONE: u32 = 0;
pub const IPV6_FL_S_EXCL: u32 = 1;
pub const IPV6_FL_S_PROCESS: u32 = 2;
pub const IPV6_FL_S_USER: u32 = 3;
pub const IPV6_FL_S_ANY: u32 = 255;
pub const IPV6_FLOWINFO_FLOWLABEL: u32 = 1048575;
pub const IPV6_FLOWINFO_PRIORITY: u32 = 267386880;
pub const IPV6_PRIORITY_UNCHARACTERIZED: u32 = 0;
pub const IPV6_PRIORITY_FILLER: u32 = 256;
pub const IPV6_PRIORITY_UNATTENDED: u32 = 512;
pub const IPV6_PRIORITY_RESERVED1: u32 = 768;
pub const IPV6_PRIORITY_BULK: u32 = 1024;
pub const IPV6_PRIORITY_RESERVED2: u32 = 1280;
pub const IPV6_PRIORITY_INTERACTIVE: u32 = 1536;
pub const IPV6_PRIORITY_CONTROL: u32 = 1792;
pub const IPV6_PRIORITY_8: u32 = 2048;
pub const IPV6_PRIORITY_9: u32 = 2304;
pub const IPV6_PRIORITY_10: u32 = 2560;
pub const IPV6_PRIORITY_11: u32 = 2816;
pub const IPV6_PRIORITY_12: u32 = 3072;
pub const IPV6_PRIORITY_13: u32 = 3328;
pub const IPV6_PRIORITY_14: u32 = 3584;
pub const IPV6_PRIORITY_15: u32 = 3840;
pub const IPPROTO_HOPOPTS: u32 = 0;
pub const IPPROTO_ROUTING: u32 = 43;
pub const IPPROTO_FRAGMENT: u32 = 44;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_NONE: u32 = 59;
pub const IPPROTO_DSTOPTS: u32 = 60;
pub const IPPROTO_MH: u32 = 135;
pub const IPV6_TLV_PAD1: u32 = 0;
pub const IPV6_TLV_PADN: u32 = 1;
pub const IPV6_TLV_ROUTERALERT: u32 = 5;
pub const IPV6_TLV_CALIPSO: u32 = 7;
pub const IPV6_TLV_IOAM: u32 = 49;
pub const IPV6_TLV_JUMBO: u32 = 194;
pub const IPV6_TLV_HAO: u32 = 201;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_FLOWINFO: u32 = 11;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_RECVERR_RFC4884: u32 = 31;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const IPV6_FLOWLABEL_MGR: u32 = 32;
pub const IPV6_FLOWINFO_SEND: u32 = 33;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_PREFER_SRC_TMP: u32 = 1;
pub const IPV6_PREFER_SRC_PUBLIC: u32 = 2;
pub const IPV6_PREFER_SRC_PUBTMP_DEFAULT: u32 = 256;
pub const IPV6_PREFER_SRC_COA: u32 = 4;
pub const IPV6_PREFER_SRC_HOME: u32 = 1024;
pub const IPV6_PREFER_SRC_CGA: u32 = 8;
pub const IPV6_PREFER_SRC_NONCGA: u32 = 2048;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const SIPHASH_CONST_0: u64 = 8317987319222330741;
pub const SIPHASH_CONST_1: u64 = 7237128888997146477;
pub const SIPHASH_CONST_2: u64 = 7816392313619706465;
pub const SIPHASH_CONST_3: u64 = 8387220255154660723;
pub const HSIPHASH_CONST_0: u32 = 0;
pub const HSIPHASH_CONST_1: u32 = 0;
pub const HSIPHASH_CONST_2: u32 = 1819895653;
pub const HSIPHASH_CONST_3: u32 = 1952801890;
pub const ETH_ALEN: u32 = 6;
pub const ETH_TLEN: u32 = 2;
pub const ETH_HLEN: u32 = 14;
pub const ETH_ZLEN: u32 = 60;
pub const ETH_DATA_LEN: u32 = 1500;
pub const ETH_FRAME_LEN: u32 = 1514;
pub const ETH_FCS_LEN: u32 = 4;
pub const ETH_MIN_MTU: u32 = 68;
pub const ETH_MAX_MTU: u32 = 65535;
pub const ETH_P_LOOP: u32 = 96;
pub const ETH_P_PUP: u32 = 512;
pub const ETH_P_PUPAT: u32 = 513;
pub const ETH_P_TSN: u32 = 8944;
pub const ETH_P_ERSPAN2: u32 = 8939;
pub const ETH_P_IP: u32 = 2048;
pub const ETH_P_X25: u32 = 2053;
pub const ETH_P_ARP: u32 = 2054;
pub const ETH_P_BPQ: u32 = 2303;
pub const ETH_P_IEEEPUP: u32 = 2560;
pub const ETH_P_IEEEPUPAT: u32 = 2561;
pub const ETH_P_BATMAN: u32 = 17157;
pub const ETH_P_DEC: u32 = 24576;
pub const ETH_P_DNA_DL: u32 = 24577;
pub const ETH_P_DNA_RC: u32 = 24578;
pub const ETH_P_DNA_RT: u32 = 24579;
pub const ETH_P_LAT: u32 = 24580;
pub const ETH_P_DIAG: u32 = 24581;
pub const ETH_P_CUST: u32 = 24582;
pub const ETH_P_SCA: u32 = 24583;
pub const ETH_P_TEB: u32 = 25944;
pub const ETH_P_RARP: u32 = 32821;
pub const ETH_P_ATALK: u32 = 32923;
pub const ETH_P_AARP: u32 = 33011;
pub const ETH_P_8021Q: u32 = 33024;
pub const ETH_P_ERSPAN: u32 = 35006;
pub const ETH_P_IPX: u32 = 33079;
pub const ETH_P_IPV6: u32 = 34525;
pub const ETH_P_PAUSE: u32 = 34824;
pub const ETH_P_SLOW: u32 = 34825;
pub const ETH_P_WCCP: u32 = 34878;
pub const ETH_P_MPLS_UC: u32 = 34887;
pub const ETH_P_MPLS_MC: u32 = 34888;
pub const ETH_P_ATMMPOA: u32 = 34892;
pub const ETH_P_PPP_DISC: u32 = 34915;
pub const ETH_P_PPP_SES: u32 = 34916;
pub const ETH_P_LINK_CTL: u32 = 34924;
pub const ETH_P_ATMFATE: u32 = 34948;
pub const ETH_P_PAE: u32 = 34958;
pub const ETH_P_PROFINET: u32 = 34962;
pub const ETH_P_REALTEK: u32 = 34969;
pub const ETH_P_AOE: u32 = 34978;
pub const ETH_P_ETHERCAT: u32 = 34980;
pub const ETH_P_8021AD: u32 = 34984;
pub const ETH_P_802_EX1: u32 = 34997;
pub const ETH_P_PREAUTH: u32 = 35015;
pub const ETH_P_TIPC: u32 = 35018;
pub const ETH_P_LLDP: u32 = 35020;
pub const ETH_P_MRP: u32 = 35043;
pub const ETH_P_MACSEC: u32 = 35045;
pub const ETH_P_8021AH: u32 = 35047;
pub const ETH_P_MVRP: u32 = 35061;
pub const ETH_P_1588: u32 = 35063;
pub const ETH_P_NCSI: u32 = 35064;
pub const ETH_P_PRP: u32 = 35067;
pub const ETH_P_CFM: u32 = 35074;
pub const ETH_P_FCOE: u32 = 35078;
pub const ETH_P_IBOE: u32 = 35093;
pub const ETH_P_TDLS: u32 = 35085;
pub const ETH_P_FIP: u32 = 35092;
pub const ETH_P_80221: u32 = 35095;
pub const ETH_P_HSR: u32 = 35119;
pub const ETH_P_NSH: u32 = 35151;
pub const ETH_P_LOOPBACK: u32 = 36864;
pub const ETH_P_QINQ1: u32 = 37120;
pub const ETH_P_QINQ2: u32 = 37376;
pub const ETH_P_QINQ3: u32 = 37632;
pub const ETH_P_EDSA: u32 = 56026;
pub const ETH_P_DSA_8021Q: u32 = 56027;
pub const ETH_P_DSA_A5PSW: u32 = 57345;
pub const ETH_P_IFE: u32 = 60734;
pub const ETH_P_AF_IUCV: u32 = 64507;
pub const ETH_P_802_3_MIN: u32 = 1536;
pub const ETH_P_802_3: u32 = 1;
pub const ETH_P_AX25: u32 = 2;
pub const ETH_P_ALL: u32 = 3;
pub const ETH_P_802_2: u32 = 4;
pub const ETH_P_SNAP: u32 = 5;
pub const ETH_P_DDCMP: u32 = 6;
pub const ETH_P_WAN_PPP: u32 = 7;
pub const ETH_P_PPP_MP: u32 = 8;
pub const ETH_P_LOCALTALK: u32 = 9;
pub const ETH_P_CAN: u32 = 12;
pub const ETH_P_CANFD: u32 = 13;
pub const ETH_P_CANXL: u32 = 14;
pub const ETH_P_PPPTALK: u32 = 16;
pub const ETH_P_TR_802_2: u32 = 17;
pub const ETH_P_MOBITEX: u32 = 21;
pub const ETH_P_CONTROL: u32 = 22;
pub const ETH_P_IRDA: u32 = 23;
pub const ETH_P_ECONET: u32 = 24;
pub const ETH_P_HDLC: u32 = 25;
pub const ETH_P_ARCNET: u32 = 26;
pub const ETH_P_DSA: u32 = 27;
pub const ETH_P_TRAILER: u32 = 28;
pub const ETH_P_PHONET: u32 = 245;
pub const ETH_P_IEEE802154: u32 = 246;
pub const ETH_P_CAIF: u32 = 247;
pub const ETH_P_XDSA: u32 = 248;
pub const ETH_P_MAP: u32 = 249;
pub const ETH_P_MCTP: u32 = 250;
pub const __UAPI_DEF_ETHHDR: u32 = 1;
pub const FLOW_DIS_MPLS_MAX: u32 = 7;
pub const FLOW_DIS_TUN_OPTS_MAX: u32 = 255;
pub const FLOW_DIS_CFM_MDL_MAX: u32 = 7;
pub const FLOW_KEYS_DIGEST_LEN: u32 = 16;
pub const PACKET_HOST: u32 = 0;
pub const PACKET_BROADCAST: u32 = 1;
pub const PACKET_MULTICAST: u32 = 2;
pub const PACKET_OTHERHOST: u32 = 3;
pub const PACKET_OUTGOING: u32 = 4;
pub const PACKET_LOOPBACK: u32 = 5;
pub const PACKET_USER: u32 = 6;
pub const PACKET_KERNEL: u32 = 7;
pub const PACKET_FASTROUTE: u32 = 6;
pub const PACKET_ADD_MEMBERSHIP: u32 = 1;
pub const PACKET_DROP_MEMBERSHIP: u32 = 2;
pub const PACKET_RECV_OUTPUT: u32 = 3;
pub const PACKET_RX_RING: u32 = 5;
pub const PACKET_STATISTICS: u32 = 6;
pub const PACKET_COPY_THRESH: u32 = 7;
pub const PACKET_AUXDATA: u32 = 8;
pub const PACKET_ORIGDEV: u32 = 9;
pub const PACKET_VERSION: u32 = 10;
pub const PACKET_HDRLEN: u32 = 11;
pub const PACKET_RESERVE: u32 = 12;
pub const PACKET_TX_RING: u32 = 13;
pub const PACKET_LOSS: u32 = 14;
pub const PACKET_VNET_HDR: u32 = 15;
pub const PACKET_TX_TIMESTAMP: u32 = 16;
pub const PACKET_TIMESTAMP: u32 = 17;
pub const PACKET_FANOUT: u32 = 18;
pub const PACKET_TX_HAS_OFF: u32 = 19;
pub const PACKET_QDISC_BYPASS: u32 = 20;
pub const PACKET_ROLLOVER_STATS: u32 = 21;
pub const PACKET_FANOUT_DATA: u32 = 22;
pub const PACKET_IGNORE_OUTGOING: u32 = 23;
pub const PACKET_VNET_HDR_SZ: u32 = 24;
pub const PACKET_FANOUT_HASH: u32 = 0;
pub const PACKET_FANOUT_LB: u32 = 1;
pub const PACKET_FANOUT_CPU: u32 = 2;
pub const PACKET_FANOUT_ROLLOVER: u32 = 3;
pub const PACKET_FANOUT_RND: u32 = 4;
pub const PACKET_FANOUT_QM: u32 = 5;
pub const PACKET_FANOUT_CBPF: u32 = 6;
pub const PACKET_FANOUT_EBPF: u32 = 7;
pub const PACKET_FANOUT_FLAG_ROLLOVER: u32 = 4096;
pub const PACKET_FANOUT_FLAG_UNIQUEID: u32 = 8192;
pub const PACKET_FANOUT_FLAG_IGNORE_OUTGOING: u32 = 16384;
pub const PACKET_FANOUT_FLAG_DEFRAG: u32 = 32768;
pub const TP_STATUS_KERNEL: u32 = 0;
pub const TP_STATUS_USER: u32 = 1;
pub const TP_STATUS_COPY: u32 = 2;
pub const TP_STATUS_LOSING: u32 = 4;
pub const TP_STATUS_CSUMNOTREADY: u32 = 8;
pub const TP_STATUS_VLAN_VALID: u32 = 16;
pub const TP_STATUS_BLK_TMO: u32 = 32;
pub const TP_STATUS_VLAN_TPID_VALID: u32 = 64;
pub const TP_STATUS_CSUM_VALID: u32 = 128;
pub const TP_STATUS_GSO_TCP: u32 = 256;
pub const TP_STATUS_AVAILABLE: u32 = 0;
pub const TP_STATUS_SEND_REQUEST: u32 = 1;
pub const TP_STATUS_SENDING: u32 = 2;
pub const TP_STATUS_WRONG_FORMAT: u32 = 4;
pub const TP_STATUS_TS_SOFTWARE: u32 = 536870912;
pub const TP_STATUS_TS_SYS_HARDWARE: u32 = 1073741824;
pub const TP_STATUS_TS_RAW_HARDWARE: u32 = 2147483648;
pub const TP_FT_REQ_FILL_RXHASH: u32 = 1;
pub const TPACKET_ALIGNMENT: u32 = 16;
pub const PACKET_MR_MULTICAST: u32 = 0;
pub const PACKET_MR_PROMISC: u32 = 1;
pub const PACKET_MR_ALLMULTI: u32 = 2;
pub const PACKET_MR_UNICAST: u32 = 3;
pub const LOOPBACK_IFINDEX: u32 = 1;
pub const FLOWI_FLAG_ANYSRC: u32 = 1;
pub const FLOWI_FLAG_KNOWN_NH: u32 = 2;
pub const NF_CT_STATE_INVALID_BIT: u32 = 1;
pub const NF_CT_STATE_UNTRACKED_BIT: u32 = 64;
pub const NF_CT_EXPECT_PERMANENT: u32 = 1;
pub const NF_CT_EXPECT_INACTIVE: u32 = 2;
pub const NF_CT_EXPECT_USERSPACE: u32 = 4;
pub const NFCT_INFOMASK: u32 = 7;
pub const NFCT_PTRMASK: i32 = -8;
pub const SKB_DROP_REASON_SUBSYS_SHIFT: u32 = 16;
pub const CHECKSUM_NONE: u32 = 0;
pub const CHECKSUM_UNNECESSARY: u32 = 1;
pub const CHECKSUM_COMPLETE: u32 = 2;
pub const CHECKSUM_PARTIAL: u32 = 3;
pub const SKB_MAX_CSUM_LEVEL: u32 = 3;
pub const MAX_SKB_FRAGS: u32 = 17;
pub const GSO_BY_FRAGS: u32 = 65535;
pub const SKB_DATAREF_SHIFT: u32 = 16;
pub const SKB_DATAREF_MASK: u32 = 65535;
pub const NET_SKBUFF_DATA_USES_OFFSET: u32 = 1;
pub const CLONED_MASK: u32 = 1;
pub const PKT_TYPE_MAX: u32 = 7;
pub const SKB_MONO_DELIVERY_TIME_MASK: u32 = 1;
pub const TC_AT_INGRESS_MASK: u32 = 2;
pub const SKB_ALLOC_FCLONE: u32 = 1;
pub const SKB_ALLOC_RX: u32 = 2;
pub const SKB_ALLOC_NAPI: u32 = 4;
pub const SKB_DST_NOREF: u32 = 1;
pub const SKB_DST_PTRMASK: i32 = -2;
pub const ENCAP_TYPE_ETHER: u32 = 0;
pub const ENCAP_TYPE_IPPROTO: u32 = 1;
pub const CHECKSUM_BREAK: u32 = 76;
pub const NPROTO: u32 = 46;
pub const SYS_SOCKET: u32 = 1;
pub const SYS_BIND: u32 = 2;
pub const SYS_CONNECT: u32 = 3;
pub const SYS_LISTEN: u32 = 4;
pub const SYS_ACCEPT: u32 = 5;
pub const SYS_GETSOCKNAME: u32 = 6;
pub const SYS_GETPEERNAME: u32 = 7;
pub const SYS_SOCKETPAIR: u32 = 8;
pub const SYS_SEND: u32 = 9;
pub const SYS_RECV: u32 = 10;
pub const SYS_SENDTO: u32 = 11;
pub const SYS_RECVFROM: u32 = 12;
pub const SYS_SHUTDOWN: u32 = 13;
pub const SYS_SETSOCKOPT: u32 = 14;
pub const SYS_GETSOCKOPT: u32 = 15;
pub const SYS_SENDMSG: u32 = 16;
pub const SYS_RECVMSG: u32 = 17;
pub const SYS_ACCEPT4: u32 = 18;
pub const SYS_RECVMMSG: u32 = 19;
pub const SYS_SENDMMSG: u32 = 20;
pub const __SO_ACCEPTCON: u32 = 65536;
pub const SOCKWQ_ASYNC_NOSPACE: u32 = 0;
pub const SOCKWQ_ASYNC_WAITDATA: u32 = 1;
pub const SOCK_NOSPACE: u32 = 2;
pub const SOCK_PASSCRED: u32 = 3;
pub const SOCK_PASSSEC: u32 = 4;
pub const SOCK_SUPPORT_ZC: u32 = 5;
pub const SOCK_CUSTOM_SOCKOPT: u32 = 6;
pub const SOCK_PASSPIDFD: u32 = 7;
pub const SOCK_TYPE_MASK: u32 = 15;
pub const SOCK_CLOEXEC: u32 = 524288;
pub const SOCK_NONBLOCK: u32 = 2048;
pub const FDPUT_FPUT: u32 = 1;
pub const FDPUT_POS_UNLOCK: u32 = 2;
pub const LSM_ID_UNDEF: u32 = 0;
pub const LSM_ID_CAPABILITY: u32 = 100;
pub const LSM_ID_SELINUX: u32 = 101;
pub const LSM_ID_SMACK: u32 = 102;
pub const LSM_ID_TOMOYO: u32 = 103;
pub const LSM_ID_APPARMOR: u32 = 104;
pub const LSM_ID_YAMA: u32 = 105;
pub const LSM_ID_LOADPIN: u32 = 106;
pub const LSM_ID_SAFESETID: u32 = 107;
pub const LSM_ID_LOCKDOWN: u32 = 108;
pub const LSM_ID_BPF: u32 = 109;
pub const LSM_ID_LANDLOCK: u32 = 110;
pub const LSM_ATTR_UNDEF: u32 = 0;
pub const LSM_ATTR_CURRENT: u32 = 100;
pub const LSM_ATTR_EXEC: u32 = 101;
pub const LSM_ATTR_FSCREATE: u32 = 102;
pub const LSM_ATTR_KEYCREATE: u32 = 103;
pub const LSM_ATTR_PREV: u32 = 104;
pub const LSM_ATTR_SOCKCREATE: u32 = 105;
pub const LSM_FLAG_SINGLE: u32 = 1;
pub const CAP_OPT_NONE: u32 = 0;
pub const SECURITY_LSM_NATIVE_LABELS: u32 = 1;
pub const LSM_SETID_ID: u32 = 1;
pub const LSM_SETID_RE: u32 = 2;
pub const LSM_SETID_RES: u32 = 4;
pub const LSM_SETID_FS: u32 = 8;
pub const LSM_PRLIMIT_READ: u32 = 1;
pub const LSM_PRLIMIT_WRITE: u32 = 2;
pub const LSM_UNSAFE_SHARE: u32 = 1;
pub const LSM_UNSAFE_PTRACE: u32 = 2;
pub const LSM_UNSAFE_NO_NEW_PRIVS: u32 = 4;
pub const SCM_MAX_FD: u32 = 253;
pub const NETLINK_ROUTE: u32 = 0;
pub const NETLINK_UNUSED: u32 = 1;
pub const NETLINK_USERSOCK: u32 = 2;
pub const NETLINK_FIREWALL: u32 = 3;
pub const NETLINK_SOCK_DIAG: u32 = 4;
pub const NETLINK_NFLOG: u32 = 5;
pub const NETLINK_XFRM: u32 = 6;
pub const NETLINK_SELINUX: u32 = 7;
pub const NETLINK_ISCSI: u32 = 8;
pub const NETLINK_AUDIT: u32 = 9;
pub const NETLINK_FIB_LOOKUP: u32 = 10;
pub const NETLINK_CONNECTOR: u32 = 11;
pub const NETLINK_NETFILTER: u32 = 12;
pub const NETLINK_IP6_FW: u32 = 13;
pub const NETLINK_DNRTMSG: u32 = 14;
pub const NETLINK_KOBJECT_UEVENT: u32 = 15;
pub const NETLINK_GENERIC: u32 = 16;
pub const NETLINK_SCSITRANSPORT: u32 = 18;
pub const NETLINK_ECRYPTFS: u32 = 19;
pub const NETLINK_RDMA: u32 = 20;
pub const NETLINK_CRYPTO: u32 = 21;
pub const NETLINK_SMC: u32 = 22;
pub const NETLINK_INET_DIAG: u32 = 4;
pub const MAX_LINKS: u32 = 32;
pub const NLM_F_REQUEST: u32 = 1;
pub const NLM_F_MULTI: u32 = 2;
pub const NLM_F_ACK: u32 = 4;
pub const NLM_F_ECHO: u32 = 8;
pub const NLM_F_DUMP_INTR: u32 = 16;
pub const NLM_F_DUMP_FILTERED: u32 = 32;
pub const NLM_F_ROOT: u32 = 256;
pub const NLM_F_MATCH: u32 = 512;
pub const NLM_F_ATOMIC: u32 = 1024;
pub const NLM_F_DUMP: u32 = 768;
pub const NLM_F_REPLACE: u32 = 256;
pub const NLM_F_EXCL: u32 = 512;
pub const NLM_F_CREATE: u32 = 1024;
pub const NLM_F_APPEND: u32 = 2048;
pub const NLM_F_NONREC: u32 = 256;
pub const NLM_F_BULK: u32 = 512;
pub const NLM_F_CAPPED: u32 = 256;
pub const NLM_F_ACK_TLVS: u32 = 512;
pub const NLMSG_ALIGNTO: u32 = 4;
pub const NLMSG_NOOP: u32 = 1;
pub const NLMSG_ERROR: u32 = 2;
pub const NLMSG_DONE: u32 = 3;
pub const NLMSG_OVERRUN: u32 = 4;
pub const NLMSG_MIN_TYPE: u32 = 16;
pub const NETLINK_ADD_MEMBERSHIP: u32 = 1;
pub const NETLINK_DROP_MEMBERSHIP: u32 = 2;
pub const NETLINK_PKTINFO: u32 = 3;
pub const NETLINK_BROADCAST_ERROR: u32 = 4;
pub const NETLINK_NO_ENOBUFS: u32 = 5;
pub const NETLINK_LISTEN_ALL_NSID: u32 = 8;
pub const NETLINK_LIST_MEMBERSHIPS: u32 = 9;
pub const NETLINK_CAP_ACK: u32 = 10;
pub const NETLINK_EXT_ACK: u32 = 11;
pub const NETLINK_GET_STRICT_CHK: u32 = 12;
pub const NET_MAJOR: u32 = 36;
pub const NLA_F_NESTED: u32 = 32768;
pub const NLA_F_NET_BYTEORDER: u32 = 16384;
pub const NLA_TYPE_MASK: i32 = -49153;
pub const NLA_ALIGNTO: u32 = 4;
pub const NL_CFG_F_NONROOT_RECV: u32 = 1;
pub const NL_CFG_F_NONROOT_SEND: u32 = 2;
pub const NETLINK_MAX_COOKIE_LEN: u32 = 20;
pub const NETLINK_MAX_FMTMSG_LEN: u32 = 80;
pub const ETH_MDIO_SUPPORTS_C22: u32 = 1;
pub const ETH_MDIO_SUPPORTS_C45: u32 = 2;
pub const ETHTOOL_FWVERS_LEN: u32 = 32;
pub const ETHTOOL_BUSINFO_LEN: u32 = 32;
pub const ETHTOOL_EROMVERS_LEN: u32 = 32;
pub const SOPASS_MAX: u32 = 6;
pub const PFC_STORM_PREVENTION_AUTO: u32 = 65535;
pub const PFC_STORM_PREVENTION_DISABLE: u32 = 0;
pub const DOWNSHIFT_DEV_DEFAULT_COUNT: u32 = 255;
pub const DOWNSHIFT_DEV_DISABLE: u32 = 0;
pub const ETHTOOL_PHY_FAST_LINK_DOWN_ON: u32 = 0;
pub const ETHTOOL_PHY_FAST_LINK_DOWN_OFF: u32 = 255;
pub const ETHTOOL_PHY_EDPD_DFLT_TX_MSECS: u32 = 65535;
pub const ETHTOOL_PHY_EDPD_NO_TX: u32 = 65534;
pub const ETHTOOL_PHY_EDPD_DISABLE: u32 = 0;
pub const ETH_GSTRING_LEN: u32 = 32;
pub const ETH_RX_NFC_IP4: u32 = 1;
pub const ETHTOOL_RX_FLOW_SPEC_RING: u32 = 4294967295;
pub const ETHTOOL_RX_FLOW_SPEC_RING_VF: u64 = 1095216660480;
pub const ETHTOOL_RX_FLOW_SPEC_RING_VF_OFF: u32 = 32;
pub const ETH_RXFH_CONTEXT_ALLOC: u32 = 4294967295;
pub const ETH_RXFH_INDIR_NO_CHANGE: u32 = 4294967295;
pub const ETHTOOL_RXNTUPLE_ACTION_DROP: i32 = -1;
pub const ETHTOOL_RXNTUPLE_ACTION_CLEAR: i32 = -2;
pub const ETHTOOL_FLASH_MAX_FILENAME: u32 = 128;
pub const ETH_FW_DUMP_DISABLE: u32 = 0;
pub const MAX_NUM_QUEUE: u32 = 4096;
pub const ETHTOOL_GSET: u32 = 1;
pub const ETHTOOL_SSET: u32 = 2;
pub const ETHTOOL_GDRVINFO: u32 = 3;
pub const ETHTOOL_GREGS: u32 = 4;
pub const ETHTOOL_GWOL: u32 = 5;
pub const ETHTOOL_SWOL: u32 = 6;
pub const ETHTOOL_GMSGLVL: u32 = 7;
pub const ETHTOOL_SMSGLVL: u32 = 8;
pub const ETHTOOL_NWAY_RST: u32 = 9;
pub const ETHTOOL_GLINK: u32 = 10;
pub const ETHTOOL_GEEPROM: u32 = 11;
pub const ETHTOOL_SEEPROM: u32 = 12;
pub const ETHTOOL_GCOALESCE: u32 = 14;
pub const ETHTOOL_SCOALESCE: u32 = 15;
pub const ETHTOOL_GRINGPARAM: u32 = 16;
pub const ETHTOOL_SRINGPARAM: u32 = 17;
pub const ETHTOOL_GPAUSEPARAM: u32 = 18;
pub const ETHTOOL_SPAUSEPARAM: u32 = 19;
pub const ETHTOOL_GRXCSUM: u32 = 20;
pub const ETHTOOL_SRXCSUM: u32 = 21;
pub const ETHTOOL_GTXCSUM: u32 = 22;
pub const ETHTOOL_STXCSUM: u32 = 23;
pub const ETHTOOL_GSG: u32 = 24;
pub const ETHTOOL_SSG: u32 = 25;
pub const ETHTOOL_TEST: u32 = 26;
pub const ETHTOOL_GSTRINGS: u32 = 27;
pub const ETHTOOL_PHYS_ID: u32 = 28;
pub const ETHTOOL_GSTATS: u32 = 29;
pub const ETHTOOL_GTSO: u32 = 30;
pub const ETHTOOL_STSO: u32 = 31;
pub const ETHTOOL_GPERMADDR: u32 = 32;
pub const ETHTOOL_GUFO: u32 = 33;
pub const ETHTOOL_SUFO: u32 = 34;
pub const ETHTOOL_GGSO: u32 = 35;
pub const ETHTOOL_SGSO: u32 = 36;
pub const ETHTOOL_GFLAGS: u32 = 37;
pub const ETHTOOL_SFLAGS: u32 = 38;
pub const ETHTOOL_GPFLAGS: u32 = 39;
pub const ETHTOOL_SPFLAGS: u32 = 40;
pub const ETHTOOL_GRXFH: u32 = 41;
pub const ETHTOOL_SRXFH: u32 = 42;
pub const ETHTOOL_GGRO: u32 = 43;
pub const ETHTOOL_SGRO: u32 = 44;
pub const ETHTOOL_GRXRINGS: u32 = 45;
pub const ETHTOOL_GRXCLSRLCNT: u32 = 46;
pub const ETHTOOL_GRXCLSRULE: u32 = 47;
pub const ETHTOOL_GRXCLSRLALL: u32 = 48;
pub const ETHTOOL_SRXCLSRLDEL: u32 = 49;
pub const ETHTOOL_SRXCLSRLINS: u32 = 50;
pub const ETHTOOL_FLASHDEV: u32 = 51;
pub const ETHTOOL_RESET: u32 = 52;
pub const ETHTOOL_SRXNTUPLE: u32 = 53;
pub const ETHTOOL_GRXNTUPLE: u32 = 54;
pub const ETHTOOL_GSSET_INFO: u32 = 55;
pub const ETHTOOL_GRXFHINDIR: u32 = 56;
pub const ETHTOOL_SRXFHINDIR: u32 = 57;
pub const ETHTOOL_GFEATURES: u32 = 58;
pub const ETHTOOL_SFEATURES: u32 = 59;
pub const ETHTOOL_GCHANNELS: u32 = 60;
pub const ETHTOOL_SCHANNELS: u32 = 61;
pub const ETHTOOL_SET_DUMP: u32 = 62;
pub const ETHTOOL_GET_DUMP_FLAG: u32 = 63;
pub const ETHTOOL_GET_DUMP_DATA: u32 = 64;
pub const ETHTOOL_GET_TS_INFO: u32 = 65;
pub const ETHTOOL_GMODULEINFO: u32 = 66;
pub const ETHTOOL_GMODULEEEPROM: u32 = 67;
pub const ETHTOOL_GEEE: u32 = 68;
pub const ETHTOOL_SEEE: u32 = 69;
pub const ETHTOOL_GRSSH: u32 = 70;
pub const ETHTOOL_SRSSH: u32 = 71;
pub const ETHTOOL_GTUNABLE: u32 = 72;
pub const ETHTOOL_STUNABLE: u32 = 73;
pub const ETHTOOL_GPHYSTATS: u32 = 74;
pub const ETHTOOL_PERQUEUE: u32 = 75;
pub const ETHTOOL_GLINKSETTINGS: u32 = 76;
pub const ETHTOOL_SLINKSETTINGS: u32 = 77;
pub const ETHTOOL_PHY_GTUNABLE: u32 = 78;
pub const ETHTOOL_PHY_STUNABLE: u32 = 79;
pub const ETHTOOL_GFECPARAM: u32 = 80;
pub const ETHTOOL_SFECPARAM: u32 = 81;
pub const SPARC_ETH_GSET: u32 = 1;
pub const SPARC_ETH_SSET: u32 = 2;
pub const SPEED_10: u32 = 10;
pub const SPEED_100: u32 = 100;
pub const SPEED_1000: u32 = 1000;
pub const SPEED_2500: u32 = 2500;
pub const SPEED_5000: u32 = 5000;
pub const SPEED_10000: u32 = 10000;
pub const SPEED_14000: u32 = 14000;
pub const SPEED_20000: u32 = 20000;
pub const SPEED_25000: u32 = 25000;
pub const SPEED_40000: u32 = 40000;
pub const SPEED_50000: u32 = 50000;
pub const SPEED_56000: u32 = 56000;
pub const SPEED_100000: u32 = 100000;
pub const SPEED_200000: u32 = 200000;
pub const SPEED_400000: u32 = 400000;
pub const SPEED_800000: u32 = 800000;
pub const SPEED_UNKNOWN: i32 = -1;
pub const DUPLEX_HALF: u32 = 0;
pub const DUPLEX_FULL: u32 = 1;
pub const DUPLEX_UNKNOWN: u32 = 255;
pub const MASTER_SLAVE_CFG_UNSUPPORTED: u32 = 0;
pub const MASTER_SLAVE_CFG_UNKNOWN: u32 = 1;
pub const MASTER_SLAVE_CFG_MASTER_PREFERRED: u32 = 2;
pub const MASTER_SLAVE_CFG_SLAVE_PREFERRED: u32 = 3;
pub const MASTER_SLAVE_CFG_MASTER_FORCE: u32 = 4;
pub const MASTER_SLAVE_CFG_SLAVE_FORCE: u32 = 5;
pub const MASTER_SLAVE_STATE_UNSUPPORTED: u32 = 0;
pub const MASTER_SLAVE_STATE_UNKNOWN: u32 = 1;
pub const MASTER_SLAVE_STATE_MASTER: u32 = 2;
pub const MASTER_SLAVE_STATE_SLAVE: u32 = 3;
pub const MASTER_SLAVE_STATE_ERR: u32 = 4;
pub const RATE_MATCH_NONE: u32 = 0;
pub const RATE_MATCH_PAUSE: u32 = 1;
pub const RATE_MATCH_CRS: u32 = 2;
pub const RATE_MATCH_OPEN_LOOP: u32 = 3;
pub const PORT_TP: u32 = 0;
pub const PORT_AUI: u32 = 1;
pub const PORT_MII: u32 = 2;
pub const PORT_FIBRE: u32 = 3;
pub const PORT_BNC: u32 = 4;
pub const PORT_DA: u32 = 5;
pub const PORT_NONE: u32 = 239;
pub const PORT_OTHER: u32 = 255;
pub const XCVR_INTERNAL: u32 = 0;
pub const XCVR_EXTERNAL: u32 = 1;
pub const XCVR_DUMMY1: u32 = 2;
pub const XCVR_DUMMY2: u32 = 3;
pub const XCVR_DUMMY3: u32 = 4;
pub const AUTONEG_DISABLE: u32 = 0;
pub const AUTONEG_ENABLE: u32 = 1;
pub const ETH_TP_MDI_INVALID: u32 = 0;
pub const ETH_TP_MDI: u32 = 1;
pub const ETH_TP_MDI_X: u32 = 2;
pub const ETH_TP_MDI_AUTO: u32 = 3;
pub const WAKE_PHY: u32 = 1;
pub const WAKE_UCAST: u32 = 2;
pub const WAKE_MCAST: u32 = 4;
pub const WAKE_BCAST: u32 = 8;
pub const WAKE_ARP: u32 = 16;
pub const WAKE_MAGIC: u32 = 32;
pub const WAKE_MAGICSECURE: u32 = 64;
pub const WAKE_FILTER: u32 = 128;
pub const WOL_MODE_COUNT: u32 = 8;
pub const RXH_XFRM_SYM_XOR: u32 = 1;
pub const RXH_XFRM_NO_CHANGE: u32 = 255;
pub const TCP_V4_FLOW: u32 = 1;
pub const UDP_V4_FLOW: u32 = 2;
pub const SCTP_V4_FLOW: u32 = 3;
pub const AH_ESP_V4_FLOW: u32 = 4;
pub const TCP_V6_FLOW: u32 = 5;
pub const UDP_V6_FLOW: u32 = 6;
pub const SCTP_V6_FLOW: u32 = 7;
pub const AH_ESP_V6_FLOW: u32 = 8;
pub const AH_V4_FLOW: u32 = 9;
pub const ESP_V4_FLOW: u32 = 10;
pub const AH_V6_FLOW: u32 = 11;
pub const ESP_V6_FLOW: u32 = 12;
pub const IPV4_USER_FLOW: u32 = 13;
pub const IP_USER_FLOW: u32 = 13;
pub const IPV6_USER_FLOW: u32 = 14;
pub const IPV4_FLOW: u32 = 16;
pub const IPV6_FLOW: u32 = 17;
pub const ETHER_FLOW: u32 = 18;
pub const FLOW_EXT: u32 = 2147483648;
pub const FLOW_MAC_EXT: u32 = 1073741824;
pub const FLOW_RSS: u32 = 536870912;
pub const RXH_L2DA: u32 = 2;
pub const RXH_VLAN: u32 = 4;
pub const RXH_L3_PROTO: u32 = 8;
pub const RXH_IP_SRC: u32 = 16;
pub const RXH_IP_DST: u32 = 32;
pub const RXH_L4_B_0_1: u32 = 64;
pub const RXH_L4_B_2_3: u32 = 128;
pub const RXH_DISCARD: u32 = 2147483648;
pub const RX_CLS_FLOW_DISC: i32 = -1;
pub const RX_CLS_FLOW_WAKE: i32 = -2;
pub const RX_CLS_LOC_SPECIAL: u32 = 2147483648;
pub const RX_CLS_LOC_ANY: u32 = 4294967295;
pub const RX_CLS_LOC_FIRST: u32 = 4294967294;
pub const RX_CLS_LOC_LAST: u32 = 4294967293;
pub const ETH_MODULE_SFF_8079: u32 = 1;
pub const ETH_MODULE_SFF_8079_LEN: u32 = 256;
pub const ETH_MODULE_SFF_8472: u32 = 2;
pub const ETH_MODULE_SFF_8472_LEN: u32 = 512;
pub const ETH_MODULE_SFF_8636: u32 = 3;
pub const ETH_MODULE_SFF_8636_LEN: u32 = 256;
pub const ETH_MODULE_SFF_8436: u32 = 4;
pub const ETH_MODULE_SFF_8436_LEN: u32 = 256;
pub const ETH_MODULE_SFF_8636_MAX_LEN: u32 = 640;
pub const ETH_MODULE_SFF_8436_MAX_LEN: u32 = 640;
pub const ETH_RESET_SHARED_SHIFT: u32 = 16;
pub const ETH_RSS_HASH_UNKNOWN: u32 = 0;
pub const ETH_RSS_HASH_NO_CHANGE: u32 = 0;
pub const ETHTOOL_STAT_NOT_SET: i32 = -1;
pub const ETHTOOL_MAX_LANES: u32 = 8;
pub const ETHTOOL_RMON_HIST_MAX: u32 = 10;
pub const ETH_MODULE_EEPROM_PAGE_LEN: u32 = 128;
pub const ETH_MODULE_MAX_I2C_ADDRESS: u32 = 127;
pub const MII_BMCR: u32 = 0;
pub const MII_BMSR: u32 = 1;
pub const MII_PHYSID1: u32 = 2;
pub const MII_PHYSID2: u32 = 3;
pub const MII_ADVERTISE: u32 = 4;
pub const MII_LPA: u32 = 5;
pub const MII_EXPANSION: u32 = 6;
pub const MII_CTRL1000: u32 = 9;
pub const MII_STAT1000: u32 = 10;
pub const MII_MMD_CTRL: u32 = 13;
pub const MII_MMD_DATA: u32 = 14;
pub const MII_ESTATUS: u32 = 15;
pub const MII_DCOUNTER: u32 = 18;
pub const MII_FCSCOUNTER: u32 = 19;
pub const MII_NWAYTEST: u32 = 20;
pub const MII_RERRCOUNTER: u32 = 21;
pub const MII_SREVISION: u32 = 22;
pub const MII_RESV1: u32 = 23;
pub const MII_LBRERROR: u32 = 24;
pub const MII_PHYADDR: u32 = 25;
pub const MII_RESV2: u32 = 26;
pub const MII_TPISTATUS: u32 = 27;
pub const MII_NCONFIG: u32 = 28;
pub const BMCR_RESV: u32 = 63;
pub const BMCR_SPEED1000: u32 = 64;
pub const BMCR_CTST: u32 = 128;
pub const BMCR_FULLDPLX: u32 = 256;
pub const BMCR_ANRESTART: u32 = 512;
pub const BMCR_ISOLATE: u32 = 1024;
pub const BMCR_PDOWN: u32 = 2048;
pub const BMCR_ANENABLE: u32 = 4096;
pub const BMCR_SPEED100: u32 = 8192;
pub const BMCR_LOOPBACK: u32 = 16384;
pub const BMCR_RESET: u32 = 32768;
pub const BMCR_SPEED10: u32 = 0;
pub const BMSR_ERCAP: u32 = 1;
pub const BMSR_JCD: u32 = 2;
pub const BMSR_LSTATUS: u32 = 4;
pub const BMSR_ANEGCAPABLE: u32 = 8;
pub const BMSR_RFAULT: u32 = 16;
pub const BMSR_ANEGCOMPLETE: u32 = 32;
pub const BMSR_RESV: u32 = 192;
pub const BMSR_ESTATEN: u32 = 256;
pub const BMSR_100HALF2: u32 = 512;
pub const BMSR_100FULL2: u32 = 1024;
pub const BMSR_10HALF: u32 = 2048;
pub const BMSR_10FULL: u32 = 4096;
pub const BMSR_100HALF: u32 = 8192;
pub const BMSR_100FULL: u32 = 16384;
pub const BMSR_100BASE4: u32 = 32768;
pub const ADVERTISE_SLCT: u32 = 31;
pub const ADVERTISE_CSMA: u32 = 1;
pub const ADVERTISE_10HALF: u32 = 32;
pub const ADVERTISE_1000XFULL: u32 = 32;
pub const ADVERTISE_10FULL: u32 = 64;
pub const ADVERTISE_1000XHALF: u32 = 64;
pub const ADVERTISE_100HALF: u32 = 128;
pub const ADVERTISE_1000XPAUSE: u32 = 128;
pub const ADVERTISE_100FULL: u32 = 256;
pub const ADVERTISE_1000XPSE_ASYM: u32 = 256;
pub const ADVERTISE_100BASE4: u32 = 512;
pub const ADVERTISE_PAUSE_CAP: u32 = 1024;
pub const ADVERTISE_PAUSE_ASYM: u32 = 2048;
pub const ADVERTISE_RESV: u32 = 4096;
pub const ADVERTISE_RFAULT: u32 = 8192;
pub const ADVERTISE_LPACK: u32 = 16384;
pub const ADVERTISE_NPAGE: u32 = 32768;
pub const ADVERTISE_FULL: u32 = 321;
pub const ADVERTISE_ALL: u32 = 480;
pub const LPA_SLCT: u32 = 31;
pub const LPA_10HALF: u32 = 32;
pub const LPA_1000XFULL: u32 = 32;
pub const LPA_10FULL: u32 = 64;
pub const LPA_1000XHALF: u32 = 64;
pub const LPA_100HALF: u32 = 128;
pub const LPA_1000XPAUSE: u32 = 128;
pub const LPA_100FULL: u32 = 256;
pub const LPA_1000XPAUSE_ASYM: u32 = 256;
pub const LPA_100BASE4: u32 = 512;
pub const LPA_PAUSE_CAP: u32 = 1024;
pub const LPA_PAUSE_ASYM: u32 = 2048;
pub const LPA_RESV: u32 = 4096;
pub const LPA_RFAULT: u32 = 8192;
pub const LPA_LPACK: u32 = 16384;
pub const LPA_NPAGE: u32 = 32768;
pub const LPA_DUPLEX: u32 = 320;
pub const LPA_100: u32 = 896;
pub const EXPANSION_NWAY: u32 = 1;
pub const EXPANSION_LCWP: u32 = 2;
pub const EXPANSION_ENABLENPAGE: u32 = 4;
pub const EXPANSION_NPCAPABLE: u32 = 8;
pub const EXPANSION_MFAULTS: u32 = 16;
pub const EXPANSION_RESV: u32 = 65504;
pub const ESTATUS_1000_XFULL: u32 = 32768;
pub const ESTATUS_1000_XHALF: u32 = 16384;
pub const ESTATUS_1000_TFULL: u32 = 8192;
pub const ESTATUS_1000_THALF: u32 = 4096;
pub const NWAYTEST_RESV1: u32 = 255;
pub const NWAYTEST_LOOPBACK: u32 = 256;
pub const NWAYTEST_RESV2: u32 = 65024;
pub const ADVERTISE_SGMII: u32 = 1;
pub const LPA_SGMII: u32 = 1;
pub const LPA_SGMII_SPD_MASK: u32 = 3072;
pub const LPA_SGMII_FULL_DUPLEX: u32 = 4096;
pub const LPA_SGMII_DPX_SPD_MASK: u32 = 7168;
pub const LPA_SGMII_10: u32 = 0;
pub const LPA_SGMII_10HALF: u32 = 0;
pub const LPA_SGMII_10FULL: u32 = 4096;
pub const LPA_SGMII_100: u32 = 1024;
pub const LPA_SGMII_100HALF: u32 = 1024;
pub const LPA_SGMII_100FULL: u32 = 5120;
pub const LPA_SGMII_1000: u32 = 2048;
pub const LPA_SGMII_1000HALF: u32 = 2048;
pub const LPA_SGMII_1000FULL: u32 = 6144;
pub const LPA_SGMII_LINK: u32 = 32768;
pub const ADVERTISE_1000FULL: u32 = 512;
pub const ADVERTISE_1000HALF: u32 = 256;
pub const CTL1000_PREFER_MASTER: u32 = 1024;
pub const CTL1000_AS_MASTER: u32 = 2048;
pub const CTL1000_ENABLE_MASTER: u32 = 4096;
pub const LPA_1000MSFAIL: u32 = 32768;
pub const LPA_1000MSRES: u32 = 16384;
pub const LPA_1000LOCALRXOK: u32 = 8192;
pub const LPA_1000REMRXOK: u32 = 4096;
pub const LPA_1000FULL: u32 = 2048;
pub const LPA_1000HALF: u32 = 1024;
pub const FLOW_CTRL_TX: u32 = 1;
pub const FLOW_CTRL_RX: u32 = 2;
pub const MII_MMD_CTRL_DEVAD_MASK: u32 = 31;
pub const MII_MMD_CTRL_ADDR: u32 = 0;
pub const MII_MMD_CTRL_NOINCR: u32 = 16384;
pub const MII_MMD_CTRL_INCR_RDWT: u32 = 32768;
pub const MII_MMD_CTRL_INCR_ON_WT: u32 = 49152;
pub const MDIO_MMD_PMAPMD: u32 = 1;
pub const MDIO_MMD_WIS: u32 = 2;
pub const MDIO_MMD_PCS: u32 = 3;
pub const MDIO_MMD_PHYXS: u32 = 4;
pub const MDIO_MMD_DTEXS: u32 = 5;
pub const MDIO_MMD_TC: u32 = 6;
pub const MDIO_MMD_AN: u32 = 7;
pub const MDIO_MMD_C22EXT: u32 = 29;
pub const MDIO_MMD_VEND1: u32 = 30;
pub const MDIO_MMD_VEND2: u32 = 31;
pub const MDIO_CTRL1: u32 = 0;
pub const MDIO_STAT1: u32 = 1;
pub const MDIO_DEVID1: u32 = 2;
pub const MDIO_DEVID2: u32 = 3;
pub const MDIO_SPEED: u32 = 4;
pub const MDIO_DEVS1: u32 = 5;
pub const MDIO_DEVS2: u32 = 6;
pub const MDIO_CTRL2: u32 = 7;
pub const MDIO_STAT2: u32 = 8;
pub const MDIO_PMA_TXDIS: u32 = 9;
pub const MDIO_PMA_RXDET: u32 = 10;
pub const MDIO_PMA_EXTABLE: u32 = 11;
pub const MDIO_PKGID1: u32 = 14;
pub const MDIO_PKGID2: u32 = 15;
pub const MDIO_AN_ADVERTISE: u32 = 16;
pub const MDIO_AN_LPA: u32 = 19;
pub const MDIO_PCS_EEE_ABLE: u32 = 20;
pub const MDIO_PCS_EEE_ABLE2: u32 = 21;
pub const MDIO_PMA_NG_EXTABLE: u32 = 21;
pub const MDIO_PCS_EEE_WK_ERR: u32 = 22;
pub const MDIO_PHYXS_LNSTAT: u32 = 24;
pub const MDIO_AN_EEE_ADV: u32 = 60;
pub const MDIO_AN_EEE_LPABLE: u32 = 61;
pub const MDIO_AN_EEE_ADV2: u32 = 62;
pub const MDIO_AN_EEE_LPABLE2: u32 = 63;
pub const MDIO_AN_CTRL2: u32 = 64;
pub const MDIO_PMA_10GBT_SWAPPOL: u32 = 130;
pub const MDIO_PMA_10GBT_TXPWR: u32 = 131;
pub const MDIO_PMA_10GBT_SNR: u32 = 133;
pub const MDIO_PMA_10GBR_FSRT_CSR: u32 = 147;
pub const MDIO_PMA_10GBR_FECABLE: u32 = 170;
pub const MDIO_PCS_10GBX_STAT1: u32 = 24;
pub const MDIO_PCS_10GBRT_STAT1: u32 = 32;
pub const MDIO_PCS_10GBRT_STAT2: u32 = 33;
pub const MDIO_AN_10GBT_CTRL: u32 = 32;
pub const MDIO_AN_10GBT_STAT: u32 = 33;
pub const MDIO_B10L_PMA_CTRL: u32 = 2294;
pub const MDIO_PMA_10T1L_STAT: u32 = 2295;
pub const MDIO_PCS_10T1L_CTRL: u32 = 2278;
pub const MDIO_PMA_PMD_BT1: u32 = 18;
pub const MDIO_AN_T1_CTRL: u32 = 512;
pub const MDIO_AN_T1_STAT: u32 = 513;
pub const MDIO_AN_T1_ADV_L: u32 = 514;
pub const MDIO_AN_T1_ADV_M: u32 = 515;
pub const MDIO_AN_T1_ADV_H: u32 = 516;
pub const MDIO_AN_T1_LP_L: u32 = 517;
pub const MDIO_AN_T1_LP_M: u32 = 518;
pub const MDIO_AN_T1_LP_H: u32 = 519;
pub const MDIO_AN_10BT1_AN_CTRL: u32 = 526;
pub const MDIO_AN_10BT1_AN_STAT: u32 = 527;
pub const MDIO_PMA_PMD_BT1_CTRL: u32 = 2100;
pub const MDIO_PCS_1000BT1_CTRL: u32 = 2304;
pub const MDIO_PCS_1000BT1_STAT: u32 = 2305;
pub const MDIO_PMA_LASI_RXCTRL: u32 = 36864;
pub const MDIO_PMA_LASI_TXCTRL: u32 = 36865;
pub const MDIO_PMA_LASI_CTRL: u32 = 36866;
pub const MDIO_PMA_LASI_RXSTAT: u32 = 36867;
pub const MDIO_PMA_LASI_TXSTAT: u32 = 36868;
pub const MDIO_PMA_LASI_STAT: u32 = 36869;
pub const MDIO_CTRL1_SPEEDSELEXT: u32 = 8256;
pub const MDIO_CTRL1_SPEEDSEL: u32 = 8316;
pub const MDIO_CTRL1_FULLDPLX: u32 = 256;
pub const MDIO_CTRL1_LPOWER: u32 = 2048;
pub const MDIO_CTRL1_RESET: u32 = 32768;
pub const MDIO_PMA_CTRL1_LOOPBACK: u32 = 1;
pub const MDIO_PMA_CTRL1_SPEED1000: u32 = 64;
pub const MDIO_PMA_CTRL1_SPEED100: u32 = 8192;
pub const MDIO_PCS_CTRL1_LOOPBACK: u32 = 16384;
pub const MDIO_PHYXS_CTRL1_LOOPBACK: u32 = 16384;
pub const MDIO_AN_CTRL1_RESTART: u32 = 512;
pub const MDIO_AN_CTRL1_ENABLE: u32 = 4096;
pub const MDIO_AN_CTRL1_XNP: u32 = 8192;
pub const MDIO_PCS_CTRL1_CLKSTOP_EN: u32 = 1024;
pub const MDIO_CTRL1_SPEED10G: u32 = 8256;
pub const MDIO_CTRL1_SPEED10P2B: u32 = 8260;
pub const MDIO_CTRL1_SPEED2_5G: u32 = 8280;
pub const MDIO_CTRL1_SPEED5G: u32 = 8284;
pub const MDIO_STAT1_LPOWERABLE: u32 = 2;
pub const MDIO_STAT1_LSTATUS: u32 = 4;
pub const MDIO_STAT1_FAULT: u32 = 128;
pub const MDIO_AN_STAT1_LPABLE: u32 = 1;
pub const MDIO_AN_STAT1_ABLE: u32 = 8;
pub const MDIO_AN_STAT1_RFAULT: u32 = 16;
pub const MDIO_AN_STAT1_COMPLETE: u32 = 32;
pub const MDIO_AN_STAT1_PAGE: u32 = 64;
pub const MDIO_AN_STAT1_XNP: u32 = 128;
pub const MDIO_SPEED_10G: u32 = 1;
pub const MDIO_PMA_SPEED_2B: u32 = 2;
pub const MDIO_PMA_SPEED_10P: u32 = 4;
pub const MDIO_PMA_SPEED_1000: u32 = 16;
pub const MDIO_PMA_SPEED_100: u32 = 32;
pub const MDIO_PMA_SPEED_10: u32 = 64;
pub const MDIO_PCS_SPEED_10P2B: u32 = 2;
pub const MDIO_PCS_SPEED_2_5G: u32 = 64;
pub const MDIO_PCS_SPEED_5G: u32 = 128;
pub const MDIO_PMA_CTRL2_TYPE: u32 = 15;
pub const MDIO_PMA_CTRL2_10GBCX4: u32 = 0;
pub const MDIO_PMA_CTRL2_10GBEW: u32 = 1;
pub const MDIO_PMA_CTRL2_10GBLW: u32 = 2;
pub const MDIO_PMA_CTRL2_10GBSW: u32 = 3;
pub const MDIO_PMA_CTRL2_10GBLX4: u32 = 4;
pub const MDIO_PMA_CTRL2_10GBER: u32 = 5;
pub const MDIO_PMA_CTRL2_10GBLR: u32 = 6;
pub const MDIO_PMA_CTRL2_10GBSR: u32 = 7;
pub const MDIO_PMA_CTRL2_10GBLRM: u32 = 8;
pub const MDIO_PMA_CTRL2_10GBT: u32 = 9;
pub const MDIO_PMA_CTRL2_10GBKX4: u32 = 10;
pub const MDIO_PMA_CTRL2_10GBKR: u32 = 11;
pub const MDIO_PMA_CTRL2_1000BT: u32 = 12;
pub const MDIO_PMA_CTRL2_1000BKX: u32 = 13;
pub const MDIO_PMA_CTRL2_100BTX: u32 = 14;
pub const MDIO_PMA_CTRL2_10BT: u32 = 15;
pub const MDIO_PMA_CTRL2_2_5GBT: u32 = 48;
pub const MDIO_PMA_CTRL2_5GBT: u32 = 49;
pub const MDIO_PMA_CTRL2_BASET1: u32 = 61;
pub const MDIO_PCS_CTRL2_TYPE: u32 = 3;
pub const MDIO_PCS_CTRL2_10GBR: u32 = 0;
pub const MDIO_PCS_CTRL2_10GBX: u32 = 1;
pub const MDIO_PCS_CTRL2_10GBW: u32 = 2;
pub const MDIO_PCS_CTRL2_10GBT: u32 = 3;
pub const MDIO_STAT2_RXFAULT: u32 = 1024;
pub const MDIO_STAT2_TXFAULT: u32 = 2048;
pub const MDIO_STAT2_DEVPRST: u32 = 49152;
pub const MDIO_STAT2_DEVPRST_VAL: u32 = 32768;
pub const MDIO_PMA_STAT2_LBABLE: u32 = 1;
pub const MDIO_PMA_STAT2_10GBEW: u32 = 2;
pub const MDIO_PMA_STAT2_10GBLW: u32 = 4;
pub const MDIO_PMA_STAT2_10GBSW: u32 = 8;
pub const MDIO_PMA_STAT2_10GBLX4: u32 = 16;
pub const MDIO_PMA_STAT2_10GBER: u32 = 32;
pub const MDIO_PMA_STAT2_10GBLR: u32 = 64;
pub const MDIO_PMA_STAT2_10GBSR: u32 = 128;
pub const MDIO_PMD_STAT2_TXDISAB: u32 = 256;
pub const MDIO_PMA_STAT2_EXTABLE: u32 = 512;
pub const MDIO_PMA_STAT2_RXFLTABLE: u32 = 4096;
pub const MDIO_PMA_STAT2_TXFLTABLE: u32 = 8192;
pub const MDIO_PCS_STAT2_10GBR: u32 = 1;
pub const MDIO_PCS_STAT2_10GBX: u32 = 2;
pub const MDIO_PCS_STAT2_10GBW: u32 = 4;
pub const MDIO_PCS_STAT2_RXFLTABLE: u32 = 4096;
pub const MDIO_PCS_STAT2_TXFLTABLE: u32 = 8192;
pub const MDIO_PMD_TXDIS_GLOBAL: u32 = 1;
pub const MDIO_PMD_TXDIS_0: u32 = 2;
pub const MDIO_PMD_TXDIS_1: u32 = 4;
pub const MDIO_PMD_TXDIS_2: u32 = 8;
pub const MDIO_PMD_TXDIS_3: u32 = 16;
pub const MDIO_PMD_RXDET_GLOBAL: u32 = 1;
pub const MDIO_PMD_RXDET_0: u32 = 2;
pub const MDIO_PMD_RXDET_1: u32 = 4;
pub const MDIO_PMD_RXDET_2: u32 = 8;
pub const MDIO_PMD_RXDET_3: u32 = 16;
pub const MDIO_PMA_EXTABLE_10GCX4: u32 = 1;
pub const MDIO_PMA_EXTABLE_10GBLRM: u32 = 2;
pub const MDIO_PMA_EXTABLE_10GBT: u32 = 4;
pub const MDIO_PMA_EXTABLE_10GBKX4: u32 = 8;
pub const MDIO_PMA_EXTABLE_10GBKR: u32 = 16;
pub const MDIO_PMA_EXTABLE_1000BT: u32 = 32;
pub const MDIO_PMA_EXTABLE_1000BKX: u32 = 64;
pub const MDIO_PMA_EXTABLE_100BTX: u32 = 128;
pub const MDIO_PMA_EXTABLE_10BT: u32 = 256;
pub const MDIO_PMA_EXTABLE_BT1: u32 = 2048;
pub const MDIO_PMA_EXTABLE_NBT: u32 = 16384;
pub const MDIO_PHYXS_LNSTAT_SYNC0: u32 = 1;
pub const MDIO_PHYXS_LNSTAT_SYNC1: u32 = 2;
pub const MDIO_PHYXS_LNSTAT_SYNC2: u32 = 4;
pub const MDIO_PHYXS_LNSTAT_SYNC3: u32 = 8;
pub const MDIO_PHYXS_LNSTAT_ALIGN: u32 = 4096;
pub const MDIO_PMA_10GBT_SWAPPOL_ABNX: u32 = 1;
pub const MDIO_PMA_10GBT_SWAPPOL_CDNX: u32 = 2;
pub const MDIO_PMA_10GBT_SWAPPOL_AREV: u32 = 256;
pub const MDIO_PMA_10GBT_SWAPPOL_BREV: u32 = 512;
pub const MDIO_PMA_10GBT_SWAPPOL_CREV: u32 = 1024;
pub const MDIO_PMA_10GBT_SWAPPOL_DREV: u32 = 2048;
pub const MDIO_PMA_10GBT_TXPWR_SHORT: u32 = 1;
pub const MDIO_PMA_10GBT_SNR_BIAS: u32 = 32768;
pub const MDIO_PMA_10GBT_SNR_MAX: u32 = 127;
pub const MDIO_PMA_10GBR_FECABLE_ABLE: u32 = 1;
pub const MDIO_PMA_10GBR_FECABLE_ERRABLE: u32 = 2;
pub const MDIO_PMA_10GBR_FSRT_ENABLE: u32 = 1;
pub const MDIO_PCS_10GBRT_STAT1_BLKLK: u32 = 1;
pub const MDIO_PCS_10GBRT_STAT2_ERR: u32 = 255;
pub const MDIO_PCS_10GBRT_STAT2_BER: u32 = 16128;
pub const MDIO_AN_10GBT_CTRL_ADVFSRT2_5G: u32 = 32;
pub const MDIO_AN_10GBT_CTRL_ADV2_5G: u32 = 128;
pub const MDIO_AN_10GBT_CTRL_ADV5G: u32 = 256;
pub const MDIO_AN_10GBT_CTRL_ADV10G: u32 = 4096;
pub const MDIO_AN_10GBT_STAT_LP2_5G: u32 = 32;
pub const MDIO_AN_10GBT_STAT_LP5G: u32 = 64;
pub const MDIO_AN_10GBT_STAT_LPTRR: u32 = 512;
pub const MDIO_AN_10GBT_STAT_LPLTABLE: u32 = 1024;
pub const MDIO_AN_10GBT_STAT_LP10G: u32 = 2048;
pub const MDIO_AN_10GBT_STAT_REMOK: u32 = 4096;
pub const MDIO_AN_10GBT_STAT_LOCOK: u32 = 8192;
pub const MDIO_AN_10GBT_STAT_MS: u32 = 16384;
pub const MDIO_AN_10GBT_STAT_MSFLT: u32 = 32768;
pub const MDIO_PMA_10T1L_CTRL_LB_EN: u32 = 1;
pub const MDIO_PMA_10T1L_CTRL_EEE_EN: u32 = 1024;
pub const MDIO_PMA_10T1L_CTRL_LOW_POWER: u32 = 2048;
pub const MDIO_PMA_10T1L_CTRL_2V4_EN: u32 = 4096;
pub const MDIO_PMA_10T1L_CTRL_TX_DIS: u32 = 16384;
pub const MDIO_PMA_10T1L_CTRL_PMA_RST: u32 = 32768;
pub const MDIO_PMA_10T1L_STAT_LINK: u32 = 1;
pub const MDIO_PMA_10T1L_STAT_FAULT: u32 = 2;
pub const MDIO_PMA_10T1L_STAT_POLARITY: u32 = 4;
pub const MDIO_PMA_10T1L_STAT_RECV_FAULT: u32 = 512;
pub const MDIO_PMA_10T1L_STAT_EEE: u32 = 1024;
pub const MDIO_PMA_10T1L_STAT_LOW_POWER: u32 = 2048;
pub const MDIO_PMA_10T1L_STAT_2V4_ABLE: u32 = 4096;
pub const MDIO_PMA_10T1L_STAT_LB_ABLE: u32 = 8192;
pub const MDIO_PCS_10T1L_CTRL_LB: u32 = 16384;
pub const MDIO_PCS_10T1L_CTRL_RESET: u32 = 32768;
pub const MDIO_PMA_PMD_BT1_B100_ABLE: u32 = 1;
pub const MDIO_PMA_PMD_BT1_B1000_ABLE: u32 = 2;
pub const MDIO_PMA_PMD_BT1_B10L_ABLE: u32 = 4;
pub const MDIO_AN_T1_ADV_L_PAUSE_CAP: u32 = 1024;
pub const MDIO_AN_T1_ADV_L_PAUSE_ASYM: u32 = 2048;
pub const MDIO_AN_T1_ADV_L_FORCE_MS: u32 = 4096;
pub const MDIO_AN_T1_ADV_L_REMOTE_FAULT: u32 = 8192;
pub const MDIO_AN_T1_ADV_L_ACK: u32 = 16384;
pub const MDIO_AN_T1_ADV_L_NEXT_PAGE_REQ: u32 = 32768;
pub const MDIO_AN_T1_ADV_M_B10L: u32 = 16384;
pub const MDIO_AN_T1_ADV_M_MST: u32 = 16;
pub const MDIO_AN_T1_ADV_H_10L_TX_HI_REQ: u32 = 4096;
pub const MDIO_AN_T1_ADV_H_10L_TX_HI: u32 = 8192;
pub const MDIO_AN_T1_LP_L_PAUSE_CAP: u32 = 1024;
pub const MDIO_AN_T1_LP_L_PAUSE_ASYM: u32 = 2048;
pub const MDIO_AN_T1_LP_L_FORCE_MS: u32 = 4096;
pub const MDIO_AN_T1_LP_L_REMOTE_FAULT: u32 = 8192;
pub const MDIO_AN_T1_LP_L_ACK: u32 = 16384;
pub const MDIO_AN_T1_LP_L_NEXT_PAGE_REQ: u32 = 32768;
pub const MDIO_AN_T1_LP_M_MST: u32 = 16;
pub const MDIO_AN_T1_LP_M_B10L: u32 = 16384;
pub const MDIO_AN_T1_LP_H_10L_TX_HI_REQ: u32 = 4096;
pub const MDIO_AN_T1_LP_H_10L_TX_HI: u32 = 8192;
pub const MDIO_AN_10BT1_AN_CTRL_ADV_EEE_T1L: u32 = 16384;
pub const MDIO_AN_10BT1_AN_STAT_LPA_EEE_T1L: u32 = 16384;
pub const MDIO_PMA_PMD_BT1_CTRL_STRAP: u32 = 15;
pub const MDIO_PMA_PMD_BT1_CTRL_STRAP_B1000: u32 = 1;
pub const MDIO_PMA_PMD_BT1_CTRL_CFG_MST: u32 = 16384;
pub const MDIO_PCS_1000BT1_CTRL_LOW_POWER: u32 = 2048;
pub const MDIO_PCS_1000BT1_CTRL_DISABLE_TX: u32 = 16384;
pub const MDIO_PCS_1000BT1_CTRL_RESET: u32 = 32768;
pub const MDIO_PCS_1000BT1_STAT_LINK: u32 = 4;
pub const MDIO_PCS_1000BT1_STAT_FAULT: u32 = 128;
pub const MDIO_AN_EEE_ADV_100TX: u32 = 2;
pub const MDIO_AN_EEE_ADV_1000T: u32 = 4;
pub const MDIO_EEE_100TX: u32 = 2;
pub const MDIO_EEE_1000T: u32 = 4;
pub const MDIO_EEE_10GT: u32 = 8;
pub const MDIO_EEE_1000KX: u32 = 16;
pub const MDIO_EEE_10GKX4: u32 = 32;
pub const MDIO_EEE_10GKR: u32 = 64;
pub const MDIO_EEE_40GR_FW: u32 = 256;
pub const MDIO_EEE_40GR_DS: u32 = 512;
pub const MDIO_EEE_100GR_FW: u32 = 4096;
pub const MDIO_EEE_100GR_DS: u32 = 8192;
pub const MDIO_EEE_2_5GT: u32 = 1;
pub const MDIO_EEE_5GT: u32 = 2;
pub const MDIO_AN_THP_BP2_5GT: u32 = 8;
pub const MDIO_PMA_NG_EXTABLE_2_5GBT: u32 = 1;
pub const MDIO_PMA_NG_EXTABLE_5GBT: u32 = 2;
pub const MDIO_PMA_LASI_RX_PHYXSLFLT: u32 = 1;
pub const MDIO_PMA_LASI_RX_PCSLFLT: u32 = 8;
pub const MDIO_PMA_LASI_RX_PMALFLT: u32 = 16;
pub const MDIO_PMA_LASI_RX_OPTICPOWERFLT: u32 = 32;
pub const MDIO_PMA_LASI_RX_WISLFLT: u32 = 512;
pub const MDIO_PMA_LASI_TX_PHYXSLFLT: u32 = 1;
pub const MDIO_PMA_LASI_TX_PCSLFLT: u32 = 8;
pub const MDIO_PMA_LASI_TX_PMALFLT: u32 = 16;
pub const MDIO_PMA_LASI_TX_LASERPOWERFLT: u32 = 128;
pub const MDIO_PMA_LASI_TX_LASERTEMPFLT: u32 = 256;
pub const MDIO_PMA_LASI_TX_LASERBICURRFLT: u32 = 512;
pub const MDIO_PMA_LASI_LSALARM: u32 = 1;
pub const MDIO_PMA_LASI_TXALARM: u32 = 2;
pub const MDIO_PMA_LASI_RXALARM: u32 = 4;
pub const MDIO_PHY_ID_C45: u32 = 32768;
pub const MDIO_PHY_ID_PRTAD: u32 = 992;
pub const MDIO_PHY_ID_DEVAD: u32 = 31;
pub const MDIO_PHY_ID_C45_MASK: u32 = 33791;
pub const MDIO_USXGMII_EEE_CLK_STP: u32 = 128;
pub const MDIO_USXGMII_EEE: u32 = 256;
pub const MDIO_USXGMII_SPD_MASK: u32 = 3584;
pub const MDIO_USXGMII_FULL_DUPLEX: u32 = 4096;
pub const MDIO_USXGMII_DPX_SPD_MASK: u32 = 7680;
pub const MDIO_USXGMII_10: u32 = 0;
pub const MDIO_USXGMII_10HALF: u32 = 0;
pub const MDIO_USXGMII_10FULL: u32 = 4096;
pub const MDIO_USXGMII_100: u32 = 512;
pub const MDIO_USXGMII_100HALF: u32 = 512;
pub const MDIO_USXGMII_100FULL: u32 = 4608;
pub const MDIO_USXGMII_1000: u32 = 1024;
pub const MDIO_USXGMII_1000HALF: u32 = 1024;
pub const MDIO_USXGMII_1000FULL: u32 = 5120;
pub const MDIO_USXGMII_10G: u32 = 1536;
pub const MDIO_USXGMII_10GHALF: u32 = 1536;
pub const MDIO_USXGMII_10GFULL: u32 = 5632;
pub const MDIO_USXGMII_2500: u32 = 2048;
pub const MDIO_USXGMII_2500HALF: u32 = 2048;
pub const MDIO_USXGMII_2500FULL: u32 = 6144;
pub const MDIO_USXGMII_5000: u32 = 2560;
pub const MDIO_USXGMII_5000HALF: u32 = 2560;
pub const MDIO_USXGMII_5000FULL: u32 = 6656;
pub const MDIO_USXGMII_LINK: u32 = 32768;
pub const PCI_ANY_ID: i32 = -1;
pub const IEEE1394_MATCH_VENDOR_ID: u32 = 1;
pub const IEEE1394_MATCH_MODEL_ID: u32 = 2;
pub const IEEE1394_MATCH_SPECIFIER_ID: u32 = 4;
pub const IEEE1394_MATCH_VERSION: u32 = 8;
pub const USB_DEVICE_ID_MATCH_VENDOR: u32 = 1;
pub const USB_DEVICE_ID_MATCH_PRODUCT: u32 = 2;
pub const USB_DEVICE_ID_MATCH_DEV_LO: u32 = 4;
pub const USB_DEVICE_ID_MATCH_DEV_HI: u32 = 8;
pub const USB_DEVICE_ID_MATCH_DEV_CLASS: u32 = 16;
pub const USB_DEVICE_ID_MATCH_DEV_SUBCLASS: u32 = 32;
pub const USB_DEVICE_ID_MATCH_DEV_PROTOCOL: u32 = 64;
pub const USB_DEVICE_ID_MATCH_INT_CLASS: u32 = 128;
pub const USB_DEVICE_ID_MATCH_INT_SUBCLASS: u32 = 256;
pub const USB_DEVICE_ID_MATCH_INT_PROTOCOL: u32 = 512;
pub const USB_DEVICE_ID_MATCH_INT_NUMBER: u32 = 1024;
pub const HID_ANY_ID: i32 = -1;
pub const HID_BUS_ANY: u32 = 65535;
pub const HID_GROUP_ANY: u32 = 0;
pub const CCW_DEVICE_ID_MATCH_CU_TYPE: u32 = 1;
pub const CCW_DEVICE_ID_MATCH_CU_MODEL: u32 = 2;
pub const CCW_DEVICE_ID_MATCH_DEVICE_TYPE: u32 = 4;
pub const CCW_DEVICE_ID_MATCH_DEVICE_MODEL: u32 = 8;
pub const AP_DEVICE_ID_MATCH_CARD_TYPE: u32 = 1;
pub const AP_DEVICE_ID_MATCH_QUEUE_TYPE: u32 = 2;
pub const ACPI_ID_LEN: u32 = 16;
pub const PNP_ID_LEN: u32 = 8;
pub const PNP_MAX_DEVICES: u32 = 8;
pub const SERIO_ANY: u32 = 255;
pub const PCMCIA_DEV_ID_MATCH_MANF_ID: u32 = 1;
pub const PCMCIA_DEV_ID_MATCH_CARD_ID: u32 = 2;
pub const PCMCIA_DEV_ID_MATCH_FUNC_ID: u32 = 4;
pub const PCMCIA_DEV_ID_MATCH_FUNCTION: u32 = 8;
pub const PCMCIA_DEV_ID_MATCH_PROD_ID1: u32 = 16;
pub const PCMCIA_DEV_ID_MATCH_PROD_ID2: u32 = 32;
pub const PCMCIA_DEV_ID_MATCH_PROD_ID3: u32 = 64;
pub const PCMCIA_DEV_ID_MATCH_PROD_ID4: u32 = 128;
pub const PCMCIA_DEV_ID_MATCH_DEVICE_NO: u32 = 256;
pub const PCMCIA_DEV_ID_MATCH_FAKE_CIS: u32 = 512;
pub const PCMCIA_DEV_ID_MATCH_ANONYMOUS: u32 = 1024;
pub const INPUT_DEVICE_ID_EV_MAX: u32 = 31;
pub const INPUT_DEVICE_ID_KEY_MIN_INTERESTING: u32 = 113;
pub const INPUT_DEVICE_ID_KEY_MAX: u32 = 767;
pub const INPUT_DEVICE_ID_REL_MAX: u32 = 15;
pub const INPUT_DEVICE_ID_ABS_MAX: u32 = 63;
pub const INPUT_DEVICE_ID_MSC_MAX: u32 = 7;
pub const INPUT_DEVICE_ID_LED_MAX: u32 = 15;
pub const INPUT_DEVICE_ID_SND_MAX: u32 = 7;
pub const INPUT_DEVICE_ID_FF_MAX: u32 = 127;
pub const INPUT_DEVICE_ID_SW_MAX: u32 = 16;
pub const INPUT_DEVICE_ID_PROP_MAX: u32 = 31;
pub const INPUT_DEVICE_ID_MATCH_BUS: u32 = 1;
pub const INPUT_DEVICE_ID_MATCH_VENDOR: u32 = 2;
pub const INPUT_DEVICE_ID_MATCH_PRODUCT: u32 = 4;
pub const INPUT_DEVICE_ID_MATCH_VERSION: u32 = 8;
pub const INPUT_DEVICE_ID_MATCH_EVBIT: u32 = 16;
pub const INPUT_DEVICE_ID_MATCH_KEYBIT: u32 = 32;
pub const INPUT_DEVICE_ID_MATCH_RELBIT: u32 = 64;
pub const INPUT_DEVICE_ID_MATCH_ABSBIT: u32 = 128;
pub const INPUT_DEVICE_ID_MATCH_MSCIT: u32 = 256;
pub const INPUT_DEVICE_ID_MATCH_LEDBIT: u32 = 512;
pub const INPUT_DEVICE_ID_MATCH_SNDBIT: u32 = 1024;
pub const INPUT_DEVICE_ID_MATCH_FFBIT: u32 = 2048;
pub const INPUT_DEVICE_ID_MATCH_SWBIT: u32 = 4096;
pub const INPUT_DEVICE_ID_MATCH_PROPBIT: u32 = 8192;
pub const EISA_SIG_LEN: u32 = 8;
pub const EISA_DEVICE_MODALIAS_FMT: &[u8; 9usize] = b"eisa:s%s\0";
pub const PA_HWTYPE_ANY_ID: u32 = 255;
pub const PA_HVERSION_REV_ANY_ID: u32 = 255;
pub const PA_HVERSION_ANY_ID: u32 = 65535;
pub const PA_SVERSION_ANY_ID: u32 = 4294967295;
pub const SDIO_ANY_ID: i32 = -1;
pub const SSB_ANY_VENDOR: u32 = 65535;
pub const SSB_ANY_ID: u32 = 65535;
pub const SSB_ANY_REV: u32 = 255;
pub const BCMA_ANY_MANUF: u32 = 65535;
pub const BCMA_ANY_ID: u32 = 65535;
pub const BCMA_ANY_REV: u32 = 255;
pub const BCMA_ANY_CLASS: u32 = 255;
pub const VIRTIO_DEV_ANY_ID: u32 = 4294967295;
pub const RPMSG_NAME_SIZE: u32 = 32;
pub const RPMSG_DEVICE_MODALIAS_FMT: &[u8; 9usize] = b"rpmsg:%s\0";
pub const I2C_NAME_SIZE: u32 = 20;
pub const I2C_MODULE_PREFIX: &[u8; 5usize] = b"i2c:\0";
pub const PCI_EPF_NAME_SIZE: u32 = 20;
pub const PCI_EPF_MODULE_PREFIX: &[u8; 9usize] = b"pci_epf:\0";
pub const I3C_MATCH_DCR: u32 = 1;
pub const I3C_MATCH_MANUF: u32 = 2;
pub const I3C_MATCH_PART: u32 = 4;
pub const I3C_MATCH_EXTRA_INFO: u32 = 8;
pub const SPI_NAME_SIZE: u32 = 32;
pub const SPI_MODULE_PREFIX: &[u8; 5usize] = b"spi:\0";
pub const SLIMBUS_NAME_SIZE: u32 = 32;
pub const SLIMBUS_MODULE_PREFIX: &[u8; 6usize] = b"slim:\0";
pub const APR_NAME_SIZE: u32 = 32;
pub const APR_MODULE_PREFIX: &[u8; 5usize] = b"apr:\0";
pub const SPMI_NAME_SIZE: u32 = 32;
pub const SPMI_MODULE_PREFIX: &[u8; 6usize] = b"spmi:\0";
pub const PLATFORM_NAME_SIZE: u32 = 20;
pub const PLATFORM_MODULE_PREFIX: &[u8; 10usize] = b"platform:\0";
pub const MDIO_NAME_SIZE: u32 = 32;
pub const MDIO_MODULE_PREFIX: &[u8; 6usize] = b"mdio:\0";
pub const MDIO_ID_FMT: &[u8; 65usize] =
    b"%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u\0";
pub const ZORRO_WILDCARD: u32 = 4294967295;
pub const ZORRO_DEVICE_MODALIAS_FMT: &[u8; 12usize] = b"zorro:i%08X\0";
pub const ISAPNP_ANY_ID: u32 = 65535;
pub const X86_VENDOR_ANY: u32 = 65535;
pub const X86_FAMILY_ANY: u32 = 0;
pub const X86_MODEL_ANY: u32 = 0;
pub const X86_STEPPING_ANY: u32 = 0;
pub const X86_FEATURE_ANY: u32 = 0;
pub const IPACK_ANY_FORMAT: u32 = 255;
pub const IPACK_ANY_ID: i32 = -1;
pub const MEI_CL_MODULE_PREFIX: &[u8; 5usize] = b"mei:\0";
pub const MEI_CL_NAME_SIZE: u32 = 32;
pub const MEI_CL_VERSION_ANY: u32 = 255;
pub const RIO_ANY_ID: u32 = 65535;
pub const TBSVC_MATCH_PROTOCOL_KEY: u32 = 1;
pub const TBSVC_MATCH_PROTOCOL_ID: u32 = 2;
pub const TBSVC_MATCH_PROTOCOL_VERSION: u32 = 4;
pub const TBSVC_MATCH_PROTOCOL_REVISION: u32 = 8;
pub const TYPEC_ANY_MODE: u32 = 7;
pub const WMI_MODULE_PREFIX: &[u8; 5usize] = b"wmi:\0";
pub const MHI_DEVICE_MODALIAS_FMT: &[u8; 7usize] = b"mhi:%s\0";
pub const MHI_NAME_SIZE: u32 = 32;
pub const MHI_EP_DEVICE_MODALIAS_FMT: &[u8; 10usize] = b"mhi_ep:%s\0";
pub const AUXILIARY_NAME_SIZE: u32 = 32;
pub const AUXILIARY_MODULE_PREFIX: &[u8; 11usize] = b"auxiliary:\0";
pub const SSAM_MATCH_TARGET: u32 = 1;
pub const SSAM_MATCH_INSTANCE: u32 = 2;
pub const SSAM_MATCH_FUNCTION: u32 = 4;
pub const ISHTP_MODULE_PREFIX: &[u8; 7usize] = b"ishtp:\0";
pub const CDX_ANY_ID: u32 = 65535;
pub const MDIO_DEVICE_FLAG_PHY: u32 = 1;
pub const MDIO_PRTAD_NONE: i32 = -1;
pub const MDIO_DEVAD_NONE: i32 = -1;
pub const MDIO_SUPPORTS_C22: u32 = 1;
pub const MDIO_SUPPORTS_C45: u32 = 2;
pub const MDIO_EMULATE_C22: u32 = 4;
pub const LEDS_TRIG_TYPE_EDGE: u32 = 0;
pub const LEDS_TRIG_TYPE_LEVEL: u32 = 1;
pub const LEDS_BOOST_OFF: u32 = 0;
pub const LEDS_BOOST_ADAPTIVE: u32 = 1;
pub const LEDS_BOOST_FIXED: u32 = 2;
pub const LED_COLOR_ID_WHITE: u32 = 0;
pub const LED_COLOR_ID_RED: u32 = 1;
pub const LED_COLOR_ID_GREEN: u32 = 2;
pub const LED_COLOR_ID_BLUE: u32 = 3;
pub const LED_COLOR_ID_AMBER: u32 = 4;
pub const LED_COLOR_ID_VIOLET: u32 = 5;
pub const LED_COLOR_ID_YELLOW: u32 = 6;
pub const LED_COLOR_ID_IR: u32 = 7;
pub const LED_COLOR_ID_MULTI: u32 = 8;
pub const LED_COLOR_ID_RGB: u32 = 9;
pub const LED_COLOR_ID_PURPLE: u32 = 10;
pub const LED_COLOR_ID_ORANGE: u32 = 11;
pub const LED_COLOR_ID_PINK: u32 = 12;
pub const LED_COLOR_ID_CYAN: u32 = 13;
pub const LED_COLOR_ID_LIME: u32 = 14;
pub const LED_COLOR_ID_MAX: u32 = 15;
pub const LED_FUNCTION_CAPSLOCK: &[u8; 9usize] = b"capslock\0";
pub const LED_FUNCTION_SCROLLLOCK: &[u8; 11usize] = b"scrolllock\0";
pub const LED_FUNCTION_NUMLOCK: &[u8; 8usize] = b"numlock\0";
pub const LED_FUNCTION_KBD_BACKLIGHT: &[u8; 14usize] = b"kbd_backlight\0";
pub const LED_FUNCTION_POWER: &[u8; 6usize] = b"power\0";
pub const LED_FUNCTION_DISK: &[u8; 5usize] = b"disk\0";
pub const LED_FUNCTION_CHARGING: &[u8; 9usize] = b"charging\0";
pub const LED_FUNCTION_STATUS: &[u8; 7usize] = b"status\0";
pub const LED_FUNCTION_MICMUTE: &[u8; 8usize] = b"micmute\0";
pub const LED_FUNCTION_MUTE: &[u8; 5usize] = b"mute\0";
pub const LED_FUNCTION_PLAYER1: &[u8; 9usize] = b"player-1\0";
pub const LED_FUNCTION_PLAYER2: &[u8; 9usize] = b"player-2\0";
pub const LED_FUNCTION_PLAYER3: &[u8; 9usize] = b"player-3\0";
pub const LED_FUNCTION_PLAYER4: &[u8; 9usize] = b"player-4\0";
pub const LED_FUNCTION_PLAYER5: &[u8; 9usize] = b"player-5\0";
pub const LED_FUNCTION_ACTIVITY: &[u8; 9usize] = b"activity\0";
pub const LED_FUNCTION_ALARM: &[u8; 6usize] = b"alarm\0";
pub const LED_FUNCTION_BACKLIGHT: &[u8; 10usize] = b"backlight\0";
pub const LED_FUNCTION_BLUETOOTH: &[u8; 10usize] = b"bluetooth\0";
pub const LED_FUNCTION_BOOT: &[u8; 5usize] = b"boot\0";
pub const LED_FUNCTION_CPU: &[u8; 4usize] = b"cpu\0";
pub const LED_FUNCTION_DEBUG: &[u8; 6usize] = b"debug\0";
pub const LED_FUNCTION_DISK_ACTIVITY: &[u8; 14usize] = b"disk-activity\0";
pub const LED_FUNCTION_DISK_ERR: &[u8; 9usize] = b"disk-err\0";
pub const LED_FUNCTION_DISK_READ: &[u8; 10usize] = b"disk-read\0";
pub const LED_FUNCTION_DISK_WRITE: &[u8; 11usize] = b"disk-write\0";
pub const LED_FUNCTION_FAULT: &[u8; 6usize] = b"fault\0";
pub const LED_FUNCTION_FLASH: &[u8; 6usize] = b"flash\0";
pub const LED_FUNCTION_HEARTBEAT: &[u8; 10usize] = b"heartbeat\0";
pub const LED_FUNCTION_INDICATOR: &[u8; 10usize] = b"indicator\0";
pub const LED_FUNCTION_LAN: &[u8; 4usize] = b"lan\0";
pub const LED_FUNCTION_MAIL: &[u8; 5usize] = b"mail\0";
pub const LED_FUNCTION_MTD: &[u8; 4usize] = b"mtd\0";
pub const LED_FUNCTION_PANIC: &[u8; 6usize] = b"panic\0";
pub const LED_FUNCTION_PROGRAMMING: &[u8; 12usize] = b"programming\0";
pub const LED_FUNCTION_RX: &[u8; 3usize] = b"rx\0";
pub const LED_FUNCTION_SD: &[u8; 3usize] = b"sd\0";
pub const LED_FUNCTION_STANDBY: &[u8; 8usize] = b"standby\0";
pub const LED_FUNCTION_TORCH: &[u8; 6usize] = b"torch\0";
pub const LED_FUNCTION_TX: &[u8; 3usize] = b"tx\0";
pub const LED_FUNCTION_USB: &[u8; 4usize] = b"usb\0";
pub const LED_FUNCTION_WAN: &[u8; 4usize] = b"wan\0";
pub const LED_FUNCTION_WLAN: &[u8; 5usize] = b"wlan\0";
pub const LED_FUNCTION_WPS: &[u8; 4usize] = b"wps\0";
pub const LED_BLINK_SW: u32 = 0;
pub const LED_BLINK_ONESHOT: u32 = 1;
pub const LED_BLINK_ONESHOT_STOP: u32 = 2;
pub const LED_BLINK_INVERT: u32 = 3;
pub const LED_BLINK_BRIGHTNESS_CHANGE: u32 = 4;
pub const LED_BLINK_DISABLE: u32 = 5;
pub const LED_SET_BRIGHTNESS_OFF: u32 = 6;
pub const LED_SET_BRIGHTNESS: u32 = 7;
pub const LED_SET_BLINK: u32 = 8;
pub const TRIG_NAME_MAX: u32 = 50;
pub const GPIO_LED_NO_BLINK_LOW: u32 = 0;
pub const GPIO_LED_NO_BLINK_HIGH: u32 = 1;
pub const GPIO_LED_BLINK: u32 = 2;
pub const MAX_UDELAY_MS: u32 = 5;
pub const PHY_POLL: i32 = -1;
pub const PHY_MAC_INTERRUPT: i32 = -2;
pub const PHY_IS_INTERNAL: u32 = 1;
pub const PHY_RST_AFTER_CLK_EN: u32 = 2;
pub const PHY_POLL_CABLE_TEST: u32 = 4;
pub const PHY_ALWAYS_CALL_SUSPEND: u32 = 8;
pub const MDIO_DEVICE_IS_PHY: u32 = 2147483648;
pub const PHY_INIT_TIMEOUT: u32 = 100000;
pub const PHY_FORCE_TIMEOUT: u32 = 10;
pub const PHY_MAX_ADDR: u32 = 32;
pub const PHY_ID_FMT: &[u8; 8usize] = b"%s:%02x\0";
pub const MII_BUS_ID_SIZE: u32 = 61;
pub const PHY_SHARED_F_INIT_DONE: u32 = 0;
pub const PHY_SHARED_F_PROBE_DONE: u32 = 1;
pub const MDIO_MMD_NUM: u32 = 32;
pub const PHY_F_NO_IRQ: u32 = 2147483648;
pub const PHY_PAIR_ALL: i32 = -1;
pub const PHY_ANY_ID: &[u8; 14usize] = b"MATCH ANY PHY\0";
pub const PHY_ANY_UID: u32 = 4294967295;
pub const INAT_OPCODE_TABLE_SIZE: u32 = 256;
pub const INAT_GROUP_TABLE_SIZE: u32 = 8;
pub const INAT_PFX_OPNDSZ: u32 = 1;
pub const INAT_PFX_REPE: u32 = 2;
pub const INAT_PFX_REPNE: u32 = 3;
pub const INAT_PFX_LOCK: u32 = 4;
pub const INAT_PFX_CS: u32 = 5;
pub const INAT_PFX_DS: u32 = 6;
pub const INAT_PFX_ES: u32 = 7;
pub const INAT_PFX_FS: u32 = 8;
pub const INAT_PFX_GS: u32 = 9;
pub const INAT_PFX_SS: u32 = 10;
pub const INAT_PFX_ADDRSZ: u32 = 11;
pub const INAT_PFX_REX: u32 = 12;
pub const INAT_PFX_VEX2: u32 = 13;
pub const INAT_PFX_VEX3: u32 = 14;
pub const INAT_PFX_EVEX: u32 = 15;
pub const INAT_LSTPFX_MAX: u32 = 3;
pub const INAT_LGCPFX_MAX: u32 = 11;
pub const INAT_IMM_BYTE: u32 = 1;
pub const INAT_IMM_WORD: u32 = 2;
pub const INAT_IMM_DWORD: u32 = 3;
pub const INAT_IMM_QWORD: u32 = 4;
pub const INAT_IMM_PTR: u32 = 5;
pub const INAT_IMM_VWORD32: u32 = 6;
pub const INAT_IMM_VWORD: u32 = 7;
pub const INAT_PFX_OFFS: u32 = 0;
pub const INAT_PFX_BITS: u32 = 4;
pub const INAT_PFX_MAX: u32 = 15;
pub const INAT_PFX_MASK: u32 = 15;
pub const INAT_ESC_OFFS: u32 = 4;
pub const INAT_ESC_BITS: u32 = 2;
pub const INAT_ESC_MAX: u32 = 3;
pub const INAT_ESC_MASK: u32 = 48;
pub const INAT_GRP_OFFS: u32 = 6;
pub const INAT_GRP_BITS: u32 = 5;
pub const INAT_GRP_MAX: u32 = 31;
pub const INAT_GRP_MASK: u32 = 1984;
pub const INAT_IMM_OFFS: u32 = 11;
pub const INAT_IMM_BITS: u32 = 3;
pub const INAT_IMM_MASK: u32 = 14336;
pub const INAT_FLAG_OFFS: u32 = 14;
pub const INAT_MODRM: u32 = 16384;
pub const INAT_FORCE64: u32 = 32768;
pub const INAT_SCNDIMM: u32 = 65536;
pub const INAT_MOFFSET: u32 = 131072;
pub const INAT_VARIANT: u32 = 262144;
pub const INAT_VEXOK: u32 = 524288;
pub const INAT_VEXONLY: u32 = 1048576;
pub const INAT_EVEXONLY: u32 = 2097152;
pub const INAT_SEG_REG_IGNORE: u32 = 0;
pub const INAT_SEG_REG_DEFAULT: u32 = 1;
pub const INAT_SEG_REG_CS: u32 = 2;
pub const INAT_SEG_REG_SS: u32 = 3;
pub const INAT_SEG_REG_DS: u32 = 4;
pub const INAT_SEG_REG_ES: u32 = 5;
pub const INAT_SEG_REG_FS: u32 = 6;
pub const INAT_SEG_REG_GS: u32 = 7;
pub const MAX_INSN_SIZE: u32 = 15;
pub const X86_VEX2_M: u32 = 1;
pub const X86_VEX_M_MAX: u32 = 31;
pub const POP_SS_OPCODE: u32 = 31;
pub const MOV_SREG_OPCODE: u32 = 142;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_branch_data {
    pub func: *const core::ffi::c_char,
    pub file: *const core::ffi::c_char,
    pub line: core::ffi::c_uint,
    pub __bindgen_anon_1: ftrace_branch_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ftrace_branch_data__bindgen_ty_1 {
    pub __bindgen_anon_1: ftrace_branch_data__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: ftrace_branch_data__bindgen_ty_1__bindgen_ty_2,
    pub miss_hit: [core::ffi::c_ulong; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ftrace_branch_data__bindgen_ty_1__bindgen_ty_1 {
    pub correct: core::ffi::c_ulong,
    pub incorrect: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ftrace_branch_data__bindgen_ty_1__bindgen_ty_2 {
    pub miss: core::ffi::c_ulong,
    pub hit: core::ffi::c_ulong,
}
impl Default for ftrace_branch_data__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ftrace_branch_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_likely_data {
    pub data: ftrace_branch_data,
    pub constant: core::ffi::c_ulong,
}
impl Default for ftrace_likely_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn ftrace_likely_update(
        f: *mut ftrace_likely_data,
        val: core::ffi::c_int,
        expect: core::ffi::c_int,
        is_constant: core::ffi::c_int,
    );
}
pub type __s8 = core::ffi::c_schar;
pub type __u8 = core::ffi::c_uchar;
pub type __s16 = core::ffi::c_short;
pub type __u16 = core::ffi::c_ushort;
pub type __s32 = core::ffi::c_int;
pub type __u32 = core::ffi::c_uint;
pub type __s64 = core::ffi::c_longlong;
pub type __u64 = core::ffi::c_ulonglong;
pub type s8 = __s8;
pub type u8_ = __u8;
pub type s16 = __s16;
pub type u16_ = __u16;
pub type s32 = __s32;
pub type u32_ = __u32;
pub type s64 = __s64;
pub type u64_ = __u64;
pub const false_: _bindgen_ty_1 = 0;
pub const true_: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [core::ffi::c_ulong; 16usize],
}
pub type __kernel_sighandler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int)>;
pub type __kernel_key_t = core::ffi::c_int;
pub type __kernel_mqd_t = core::ffi::c_int;
pub type __kernel_old_uid_t = core::ffi::c_ushort;
pub type __kernel_old_gid_t = core::ffi::c_ushort;
pub type __kernel_old_dev_t = core::ffi::c_ulong;
pub type __kernel_long_t = core::ffi::c_long;
pub type __kernel_ulong_t = core::ffi::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = core::ffi::c_uint;
pub type __kernel_pid_t = core::ffi::c_int;
pub type __kernel_ipc_pid_t = core::ffi::c_int;
pub type __kernel_uid_t = core::ffi::c_uint;
pub type __kernel_gid_t = core::ffi::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = core::ffi::c_int;
pub type __kernel_uid32_t = core::ffi::c_uint;
pub type __kernel_gid32_t = core::ffi::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [core::ffi::c_int; 2usize],
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = core::ffi::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time64_t = core::ffi::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = core::ffi::c_int;
pub type __kernel_clockid_t = core::ffi::c_int;
pub type __kernel_caddr_t = *mut core::ffi::c_char;
pub type __kernel_uid16_t = core::ffi::c_ushort;
pub type __kernel_gid16_t = core::ffi::c_ushort;
pub type __s128 = i128;
pub type __u128 = u128;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = core::ffi::c_uint;
pub type s128 = __s128;
pub type u128_ = __u128;
pub type __kernel_dev_t = u32_;
pub type fd_set = __kernel_fd_set;
pub type dev_t = __kernel_dev_t;
pub type ino_t = __kernel_ulong_t;
pub type mode_t = __kernel_mode_t;
pub type umode_t = core::ffi::c_ushort;
pub type nlink_t = u32_;
pub type off_t = __kernel_off_t;
pub type pid_t = __kernel_pid_t;
pub type daddr_t = __kernel_daddr_t;
pub type key_t = __kernel_key_t;
pub type suseconds_t = __kernel_suseconds_t;
pub type timer_t = __kernel_timer_t;
pub type clockid_t = __kernel_clockid_t;
pub type mqd_t = __kernel_mqd_t;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type uid16_t = __kernel_uid16_t;
pub type gid16_t = __kernel_gid16_t;
pub type old_uid_t = __kernel_old_uid_t;
pub type old_gid_t = __kernel_old_gid_t;
pub type loff_t = __kernel_loff_t;
pub type clock_t = __kernel_clock_t;
pub type caddr_t = __kernel_caddr_t;
pub type u_char = core::ffi::c_uchar;
pub type u_short = core::ffi::c_ushort;
pub type u_int = core::ffi::c_uint;
pub type u_long = core::ffi::c_ulong;
pub type unchar = core::ffi::c_uchar;
pub type ushort = core::ffi::c_ushort;
pub type uint = core::ffi::c_uint;
pub type ulong = core::ffi::c_ulong;
pub type u_int8_t = u8_;
pub type u_int16_t = u16_;
pub type u_int32_t = u32_;
pub type u_int64_t = u64_;
pub type ktime_t = s64;
pub type sector_t = u64_;
pub type blkcnt_t = u64_;
pub type dma_addr_t = u64_;
pub type gfp_t = core::ffi::c_uint;
pub type slab_flags_t = core::ffi::c_uint;
pub type fmode_t = core::ffi::c_uint;
pub type phys_addr_t = u64_;
pub type resource_size_t = phys_addr_t;
pub type irq_hw_number_t = core::ffi::c_ulong;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct atomic_t {
    pub counter: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct atomic64_t {
    pub counter: s64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rcuref_t {
    pub refcnt: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
impl Default for list_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
impl Default for hlist_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
impl Default for hlist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ustat {
    pub f_tfree: __kernel_daddr_t,
    pub f_tinode: core::ffi::c_ulong,
    pub f_fname: [core::ffi::c_char; 6usize],
    pub f_fpack: [core::ffi::c_char; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct callback_head {
    pub next: *mut callback_head,
    pub func: ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
}
impl Default for callback_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type rcu_callback_t = ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head)>;
pub type call_rcu_func_t =
    ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head, func: rcu_callback_t)>;
pub type swap_r_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        a: *mut core::ffi::c_void,
        b: *mut core::ffi::c_void,
        size: core::ffi::c_int,
        priv_: *const core::ffi::c_void,
    ),
>;
pub type swap_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        a: *mut core::ffi::c_void,
        b: *mut core::ffi::c_void,
        size: core::ffi::c_int,
    ),
>;
pub type cmp_r_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const core::ffi::c_void,
        b: *const core::ffi::c_void,
        priv_: *const core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
pub type cmp_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const core::ffi::c_void,
        b: *const core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kcsan_scoped_access {}
pub type va_list = __builtin_va_list;
pub type initcall_t = ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>;
pub type exitcall_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type initcall_entry_t = core::ffi::c_int;
extern "C" {
    pub static mut __con_initcall_start: [initcall_entry_t; 0usize];
}
extern "C" {
    pub static mut __con_initcall_end: [initcall_entry_t; 0usize];
}
pub type ctor_fn_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn do_one_initcall(fn_: initcall_t) -> core::ffi::c_int;
}
extern "C" {
    pub static mut boot_command_line: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut saved_command_line: *mut core::ffi::c_char;
}
extern "C" {
    pub static mut saved_command_line_len: core::ffi::c_uint;
}
extern "C" {
    pub static mut reset_devices: core::ffi::c_uint;
}
extern "C" {
    pub fn setup_arch(arg1: *mut *mut core::ffi::c_char);
}
extern "C" {
    pub fn prepare_namespace();
}
extern "C" {
    pub fn init_rootfs();
}
extern "C" {
    pub fn init_IRQ();
}
extern "C" {
    pub fn time_init();
}
extern "C" {
    pub fn poking_init();
}
extern "C" {
    pub fn pgtable_cache_init();
}
extern "C" {
    pub static mut __initcall_start: [initcall_entry_t; 0usize];
}
extern "C" {
    pub static mut __initcall0_start: [initcall_entry_t; 0usize];
}
extern "C" {
    pub static mut __initcall1_start: [initcall_entry_t; 0usize];
}
extern "C" {
    pub static mut __initcall2_start: [initcall_entry_t; 0usize];
}
extern "C" {
    pub static mut __initcall3_start: [initcall_entry_t; 0usize];
}
extern "C" {
    pub static mut __initcall4_start: [initcall_entry_t; 0usize];
}
extern "C" {
    pub static mut __initcall5_start: [initcall_entry_t; 0usize];
}
extern "C" {
    pub static mut __initcall6_start: [initcall_entry_t; 0usize];
}
extern "C" {
    pub static mut __initcall7_start: [initcall_entry_t; 0usize];
}
extern "C" {
    pub static mut __initcall_end: [initcall_entry_t; 0usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_system_type {
    pub name: *const core::ffi::c_char,
    pub fs_flags: core::ffi::c_int,
    pub init_fs_context:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context) -> core::ffi::c_int>,
    pub parameters: *const fs_parameter_spec,
    pub mount: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_system_type,
            arg2: core::ffi::c_int,
            arg3: *const core::ffi::c_char,
            arg4: *mut core::ffi::c_void,
        ) -> *mut dentry,
    >,
    pub kill_sb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub owner: *mut module,
    pub next: *mut file_system_type,
    pub fs_supers: hlist_head,
    pub s_lock_key: lock_class_key,
    pub s_umount_key: lock_class_key,
    pub s_vfs_rename_key: lock_class_key,
    pub s_writers_key: [lock_class_key; 3usize],
    pub i_lock_key: lock_class_key,
    pub i_mutex_key: lock_class_key,
    pub invalidate_lock_key: lock_class_key,
    pub i_mutex_dir_key: lock_class_key,
}
impl Default for file_system_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut rootfs_fs_type: file_system_type;
}
extern "C" {
    pub static mut rodata_enabled: bool_;
}
extern "C" {
    pub fn mark_rodata_ro();
}
extern "C" {
    pub static mut late_time_init: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub static mut initcall_debug: bool_;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct module {
    pub state: module_state,
    pub list: list_head,
    pub name: [core::ffi::c_char; 56usize],
    pub mkobj: module_kobject,
    pub modinfo_attrs: *mut module_attribute,
    pub version: *const core::ffi::c_char,
    pub srcversion: *const core::ffi::c_char,
    pub holders_dir: *mut kobject,
    pub syms: *mut kernel_symbol,
    pub crcs: *const s32,
    pub num_syms: core::ffi::c_uint,
    pub param_lock: mutex,
    pub kp: *mut kernel_param,
    pub num_kp: core::ffi::c_uint,
    pub num_gpl_syms: core::ffi::c_uint,
    pub gpl_syms: *const kernel_symbol,
    pub gpl_crcs: *const s32,
    pub using_gplonly_symbols: bool_,
    pub sig_ok: bool_,
    pub async_probe_requested: bool_,
    pub num_exentries: core::ffi::c_uint,
    pub extable: *mut exception_table_entry,
    pub init: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub mem: [module_memory; 7usize],
    pub arch: mod_arch_specific,
    pub taints: core::ffi::c_ulong,
    pub num_bugs: core::ffi::c_uint,
    pub bug_list: list_head,
    pub bug_table: *mut bug_entry,
    pub kallsyms: *mut mod_kallsyms,
    pub core_kallsyms: mod_kallsyms,
    pub sect_attrs: *mut module_sect_attrs,
    pub notes_attrs: *mut module_notes_attrs,
    pub args: *mut core::ffi::c_char,
    pub percpu: *mut core::ffi::c_void,
    pub percpu_size: core::ffi::c_uint,
    pub noinstr_text_start: *mut core::ffi::c_void,
    pub noinstr_text_size: core::ffi::c_uint,
    pub num_tracepoints: core::ffi::c_uint,
    pub tracepoints_ptrs: *const core::ffi::c_int,
    pub num_srcu_structs: core::ffi::c_uint,
    pub srcu_struct_ptrs: *mut *mut srcu_struct,
    pub num_bpf_raw_events: core::ffi::c_uint,
    pub bpf_raw_events: *mut bpf_raw_event_map,
    pub btf_data_size: core::ffi::c_uint,
    pub btf_data: *mut core::ffi::c_void,
    pub jump_entries: *mut jump_entry,
    pub num_jump_entries: core::ffi::c_uint,
    pub num_trace_bprintk_fmt: core::ffi::c_uint,
    pub trace_bprintk_fmt_start: *mut *const core::ffi::c_char,
    pub trace_events: *mut *mut trace_event_call,
    pub num_trace_events: core::ffi::c_uint,
    pub trace_evals: *mut *mut trace_eval_map,
    pub num_trace_evals: core::ffi::c_uint,
    pub num_ftrace_callsites: core::ffi::c_uint,
    pub ftrace_callsites: *mut core::ffi::c_ulong,
    pub kprobes_text_start: *mut core::ffi::c_void,
    pub kprobes_text_size: core::ffi::c_uint,
    pub kprobe_blacklist: *mut core::ffi::c_ulong,
    pub num_kprobe_blacklist: core::ffi::c_uint,
    pub num_static_call_sites: core::ffi::c_int,
    pub static_call_sites: *mut static_call_site,
    pub klp: bool_,
    pub klp_alive: bool_,
    pub klp_info: *mut klp_modinfo,
    pub source_list: list_head,
    pub target_list: list_head,
    pub exit: ::core::option::Option<unsafe extern "C" fn()>,
    pub refcnt: atomic_t,
    pub ei_funcs: *mut error_injection_entry,
    pub num_ei_funcs: core::ffi::c_uint,
    pub dyndbg_info: _ddebug_info,
}
impl Default for module {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut __this_module: module;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qspinlock {
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qspinlock__bindgen_ty_1 {
    pub val: atomic_t,
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: qspinlock__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_1 {
    pub locked: u8_,
    pub pending: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_2 {
    pub locked_pending: u16_,
    pub tail: u16_,
}
impl Default for qspinlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for qspinlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arch_spinlock_t = qspinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qrwlock {
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1,
    pub wait_lock: arch_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qrwlock__bindgen_ty_1 {
    pub cnts: atomic_t,
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qrwlock__bindgen_ty_1__bindgen_ty_1 {
    pub wlocked: u8_,
    pub __lstate: [u8_; 3usize],
}
impl Default for qrwlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for qrwlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arch_rwlock_t = qrwlock;
pub const lockdep_wait_type_LD_WAIT_INV: lockdep_wait_type = 0;
pub const lockdep_wait_type_LD_WAIT_FREE: lockdep_wait_type = 1;
pub const lockdep_wait_type_LD_WAIT_SPIN: lockdep_wait_type = 2;
pub const lockdep_wait_type_LD_WAIT_CONFIG: lockdep_wait_type = 2;
pub const lockdep_wait_type_LD_WAIT_SLEEP: lockdep_wait_type = 3;
pub const lockdep_wait_type_LD_WAIT_MAX: lockdep_wait_type = 4;
pub type lockdep_wait_type = core::ffi::c_uint;
pub const lockdep_lock_type_LD_LOCK_NORMAL: lockdep_lock_type = 0;
pub const lockdep_lock_type_LD_LOCK_PERCPU: lockdep_lock_type = 1;
pub const lockdep_lock_type_LD_LOCK_WAIT_OVERRIDE: lockdep_lock_type = 2;
pub const lockdep_lock_type_LD_LOCK_MAX: lockdep_lock_type = 3;
pub type lockdep_lock_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lock_class_key {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lockdep_map {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pin_cookie {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_spinlock {
    pub raw_lock: arch_spinlock_t,
}
impl Default for raw_spinlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type raw_spinlock_t = raw_spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ratelimit_state {
    pub lock: raw_spinlock_t,
    pub interval: core::ffi::c_int,
    pub burst: core::ffi::c_int,
    pub printed: core::ffi::c_int,
    pub missed: core::ffi::c_int,
    pub begin: core::ffi::c_ulong,
    pub flags: core::ffi::c_ulong,
}
impl Default for ratelimit_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn ___ratelimit(
        rs: *mut ratelimit_state,
        func: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static linux_banner: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static linux_proc_banner: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut oops_in_progress: core::ffi::c_int;
}
extern "C" {
    pub static mut console_printk: [core::ffi::c_int; 0usize];
}
extern "C" {
    pub fn console_verbose();
}
extern "C" {
    pub static mut devkmsg_log_str: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut suppress_printk: core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct va_format {
    pub fmt: *const core::ffi::c_char,
    pub va: *mut va_list,
}
impl Default for va_format {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn early_printk(fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn vprintk_emit(
        facility: core::ffi::c_int,
        level: core::ffi::c_int,
        dev_info: *const dev_printk_info,
        fmt: *const core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vprintk(fmt: *const core::ffi::c_char, args: *mut __va_list_tag) -> core::ffi::c_int;
}
extern "C" {
    pub fn _printk(fmt: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
    pub fn _printk_deferred(fmt: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
    pub fn __printk_safe_enter();
}
extern "C" {
    pub fn __printk_safe_exit();
}
extern "C" {
    pub fn __printk_ratelimit(func: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn printk_timed_ratelimit(
        caller_jiffies: *mut core::ffi::c_ulong,
        interval_msec: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub static mut printk_delay_msec: core::ffi::c_int;
}
extern "C" {
    pub static mut dmesg_restrict: core::ffi::c_int;
}
extern "C" {
    pub fn wake_up_klogd();
}
extern "C" {
    pub fn log_buf_addr_get() -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn log_buf_len_get() -> u32_;
}
extern "C" {
    pub fn log_buf_vmcoreinfo_setup();
}
extern "C" {
    pub fn setup_log_buf(early: core::ffi::c_int);
}
extern "C" {
    pub fn dump_stack_set_arch_desc(fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn dump_stack_print_info(log_lvl: *const core::ffi::c_char);
}
extern "C" {
    pub fn show_regs_print_info(log_lvl: *const core::ffi::c_char);
}
extern "C" {
    pub fn dump_stack_lvl(log_lvl: *const core::ffi::c_char);
}
extern "C" {
    pub fn dump_stack();
}
extern "C" {
    pub fn printk_trigger_flush();
}
extern "C" {
    pub fn this_cpu_in_panic() -> bool_;
}
extern "C" {
    pub fn __printk_cpu_sync_try_get() -> core::ffi::c_int;
}
extern "C" {
    pub fn __printk_cpu_sync_wait();
}
extern "C" {
    pub fn __printk_cpu_sync_put();
}
extern "C" {
    pub static mut kptr_restrict: core::ffi::c_int;
}
extern "C" {
    pub static mut static_key_initialized: bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key {
    pub enabled: atomic_t,
    pub __bindgen_anon_1: static_key__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union static_key__bindgen_ty_1 {
    pub type_: core::ffi::c_ulong,
    pub entries: *mut jump_entry,
    pub next: *mut static_key_mod,
}
impl Default for static_key__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for static_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}rsp"]
    pub static mut current_stack_pointer: core::ffi::c_ulong;
}
extern "C" {
    pub static x86_nops: [*const core::ffi::c_uchar; 0usize];
}
extern "C" {
    pub fn arch_jump_entry_size(entry: *mut jump_entry) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct jump_entry {
    pub code: s32,
    pub target: s32,
    pub key: core::ffi::c_long,
}
pub const jump_label_type_JUMP_LABEL_NOP: jump_label_type = 0;
pub const jump_label_type_JUMP_LABEL_JMP: jump_label_type = 1;
pub type jump_label_type = core::ffi::c_uint;
extern "C" {
    pub static mut __start___jump_table: [jump_entry; 0usize];
}
extern "C" {
    pub static mut __stop___jump_table: [jump_entry; 0usize];
}
extern "C" {
    pub fn jump_label_init();
}
extern "C" {
    pub fn jump_label_lock();
}
extern "C" {
    pub fn jump_label_unlock();
}
extern "C" {
    pub fn arch_jump_label_transform(entry: *mut jump_entry, type_: jump_label_type);
}
extern "C" {
    pub fn arch_jump_label_transform_queue(entry: *mut jump_entry, type_: jump_label_type)
        -> bool_;
}
extern "C" {
    pub fn arch_jump_label_transform_apply();
}
extern "C" {
    pub fn jump_label_text_reserved(
        start: *mut core::ffi::c_void,
        end: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn static_key_slow_inc(key: *mut static_key) -> bool_;
}
extern "C" {
    pub fn static_key_fast_inc_not_disabled(key: *mut static_key) -> bool_;
}
extern "C" {
    pub fn static_key_slow_dec(key: *mut static_key);
}
extern "C" {
    pub fn static_key_slow_inc_cpuslocked(key: *mut static_key) -> bool_;
}
extern "C" {
    pub fn static_key_slow_dec_cpuslocked(key: *mut static_key);
}
extern "C" {
    pub fn static_key_count(key: *mut static_key) -> core::ffi::c_int;
}
extern "C" {
    pub fn static_key_enable(key: *mut static_key);
}
extern "C" {
    pub fn static_key_disable(key: *mut static_key);
}
extern "C" {
    pub fn static_key_enable_cpuslocked(key: *mut static_key);
}
extern "C" {
    pub fn static_key_disable_cpuslocked(key: *mut static_key);
}
extern "C" {
    pub fn jump_label_init_type(entry: *mut jump_entry) -> jump_label_type;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_true {
    pub key: static_key,
}
impl Default for static_key_true {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_false {
    pub key: static_key,
}
impl Default for static_key_false {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn ____wrong_branch_error() -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ddebug {
    pub modname: *const core::ffi::c_char,
    pub function: *const core::ffi::c_char,
    pub filename: *const core::ffi::c_char,
    pub format: *const core::ffi::c_char,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub key: _ddebug__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ddebug__bindgen_ty_1 {
    pub dd_key_true: static_key_true,
    pub dd_key_false: static_key_false,
}
impl Default for _ddebug__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ddebug {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _ddebug {
    #[inline]
    pub fn lineno(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_lineno(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn class_id(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_class_id(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lineno: core::ffi::c_uint,
        class_id: core::ffi::c_uint,
        flags: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let lineno: u32 = unsafe { ::core::mem::transmute(lineno) };
            lineno as u64
        });
        __bindgen_bitfield_unit.set(18usize, 6u8, {
            let class_id: u32 = unsafe { ::core::mem::transmute(class_id) };
            class_id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let flags: u32 = unsafe { ::core::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const class_map_type_DD_CLASS_TYPE_DISJOINT_BITS: class_map_type = 0;
pub const class_map_type_DD_CLASS_TYPE_LEVEL_NUM: class_map_type = 1;
pub const class_map_type_DD_CLASS_TYPE_DISJOINT_NAMES: class_map_type = 2;
pub const class_map_type_DD_CLASS_TYPE_LEVEL_NAMES: class_map_type = 3;
pub type class_map_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ddebug_class_map {
    pub link: list_head,
    pub mod_: *mut module,
    pub mod_name: *const core::ffi::c_char,
    pub class_names: *mut *const core::ffi::c_char,
    pub length: core::ffi::c_int,
    pub base: core::ffi::c_int,
    pub map_type: class_map_type,
}
impl Default for ddebug_class_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ddebug_info {
    pub descs: *mut _ddebug,
    pub classes: *mut ddebug_class_map,
    pub num_descs: core::ffi::c_uint,
    pub num_classes: core::ffi::c_uint,
}
impl Default for _ddebug_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ddebug_class_param {
    pub __bindgen_anon_1: ddebug_class_param__bindgen_ty_1,
    pub flags: [core::ffi::c_char; 8usize],
    pub map: *const ddebug_class_map,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ddebug_class_param__bindgen_ty_1 {
    pub bits: *mut core::ffi::c_ulong,
    pub lvl: *mut core::ffi::c_uint,
}
impl Default for ddebug_class_param__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ddebug_class_param {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __dynamic_pr_debug(descriptor: *mut _ddebug, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn __dynamic_dev_dbg(
        descriptor: *mut _ddebug,
        dev: *const device,
        fmt: *const core::ffi::c_char,
        ...
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __dynamic_netdev_dbg(
        descriptor: *mut _ddebug,
        dev: *const net_device,
        fmt: *const core::ffi::c_char,
        ...
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __dynamic_ibdev_dbg(
        descriptor: *mut _ddebug,
        ibdev: *const ib_device,
        fmt: *const core::ffi::c_char,
        ...
    );
}
extern "C" {
    pub fn ddebug_dyndbg_module_param_cb(
        param: *mut core::ffi::c_char,
        val: *mut core::ffi::c_char,
        modname: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_set_dyndbg_classes(
        instr: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_dyndbg_classes(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_param_ops {
    pub flags: core::ffi::c_uint,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            val: *const core::ffi::c_char,
            kp: *const kernel_param,
        ) -> core::ffi::c_int,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(
            buffer: *mut core::ffi::c_char,
            kp: *const kernel_param,
        ) -> core::ffi::c_int,
    >,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg: *mut core::ffi::c_void)>,
}
extern "C" {
    pub static param_ops_dyndbg_classes: kernel_param_ops;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_operations {
    pub owner: *mut module,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: loff_t, arg3: core::ffi::c_int) -> loff_t,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut core::ffi::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *const core::ffi::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub read_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub write_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub iopoll: ::core::option::Option<
        unsafe extern "C" fn(
            kiocb: *mut kiocb,
            arg1: *mut io_comp_batch,
            flags: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub iterate_shared: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> core::ffi::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut poll_table_struct) -> __poll_t,
    >,
    pub unlocked_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_uint,
            arg3: core::ffi::c_ulong,
        ) -> core::ffi::c_long,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_uint,
            arg3: core::ffi::c_ulong,
        ) -> core::ffi::c_long,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut vm_area_struct) -> core::ffi::c_int,
    >,
    pub mmap_supported_flags: core::ffi::c_ulong,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> core::ffi::c_int,
    >,
    pub flush: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, id: fl_owner_t) -> core::ffi::c_int,
    >,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> core::ffi::c_int,
    >,
    pub fsync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            datasync: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub fasync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: core::ffi::c_int,
            arg2: *mut file,
            arg3: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub lock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_int,
            arg3: *mut file_lock,
        ) -> core::ffi::c_int,
    >,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_ulong,
            arg3: core::ffi::c_ulong,
            arg4: core::ffi::c_ulong,
            arg5: core::ffi::c_ulong,
        ) -> core::ffi::c_ulong,
    >,
    pub check_flags:
        ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int) -> core::ffi::c_int>,
    pub flock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_int,
            arg3: *mut file_lock,
        ) -> core::ffi::c_int,
    >,
    pub splice_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pipe_inode_info,
            arg2: *mut file,
            arg3: *mut loff_t,
            arg4: usize,
            arg5: core::ffi::c_uint,
        ) -> isize,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut loff_t,
            arg3: *mut pipe_inode_info,
            arg4: usize,
            arg5: core::ffi::c_uint,
        ) -> isize,
    >,
    pub splice_eof: ::core::option::Option<unsafe extern "C" fn(file: *mut file)>,
    pub setlease: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_int,
            arg3: *mut *mut file_lock,
            arg4: *mut *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub fallocate: ::core::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            mode: core::ffi::c_int,
            offset: loff_t,
            len: loff_t,
        ) -> core::ffi::c_long,
    >,
    pub show_fdinfo: ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, f: *mut file)>,
    pub copy_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: *mut file,
            arg4: loff_t,
            arg5: usize,
            arg6: core::ffi::c_uint,
        ) -> isize,
    >,
    pub remap_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            file_in: *mut file,
            pos_in: loff_t,
            file_out: *mut file,
            pos_out: loff_t,
            len: loff_t,
            remap_flags: core::ffi::c_uint,
        ) -> loff_t,
    >,
    pub fadvise: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            arg4: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub uring_cmd: ::core::option::Option<
        unsafe extern "C" fn(
            ioucmd: *mut io_uring_cmd,
            issue_flags: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub uring_cmd_iopoll: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut io_uring_cmd,
            arg2: *mut io_comp_batch,
            poll_flags: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
}
impl Default for file_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static kmsg_fops: file_operations;
}
pub const DUMP_PREFIX_NONE: _bindgen_ty_2 = 0;
pub const DUMP_PREFIX_ADDRESS: _bindgen_ty_2 = 1;
pub const DUMP_PREFIX_OFFSET: _bindgen_ty_2 = 2;
pub type _bindgen_ty_2 = core::ffi::c_uint;
extern "C" {
    pub fn hex_dump_to_buffer(
        buf: *const core::ffi::c_void,
        len: usize,
        rowsize: core::ffi::c_int,
        groupsize: core::ffi::c_int,
        linebuf: *mut core::ffi::c_char,
        linebuflen: usize,
        ascii: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn print_hex_dump(
        level: *const core::ffi::c_char,
        prefix_str: *const core::ffi::c_char,
        prefix_type: core::ffi::c_int,
        rowsize: core::ffi::c_int,
        groupsize: core::ffi::c_int,
        buf: *const core::ffi::c_void,
        len: usize,
        ascii: bool_,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct string_stream {
    _unused: [u8; 0],
}
pub const kunit_assert_type_KUNIT_ASSERTION: kunit_assert_type = 0;
pub const kunit_assert_type_KUNIT_EXPECTATION: kunit_assert_type = 1;
pub type kunit_assert_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_loc {
    pub line: core::ffi::c_int,
    pub file: *const core::ffi::c_char,
}
impl Default for kunit_loc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kunit_assert {}
pub type assert_format_t = ::core::option::Option<
    unsafe extern "C" fn(
        assert: *const kunit_assert,
        message: *const va_format,
        stream: *mut string_stream,
    ),
>;
extern "C" {
    pub fn kunit_assert_prologue(
        loc: *const kunit_loc,
        type_: kunit_assert_type,
        stream: *mut string_stream,
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kunit_fail_assert {
    pub assert: kunit_assert,
}
extern "C" {
    pub fn kunit_fail_assert_format(
        assert: *const kunit_assert,
        message: *const va_format,
        stream: *mut string_stream,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_unary_assert {
    pub assert: kunit_assert,
    pub condition: *const core::ffi::c_char,
    pub expected_true: bool_,
}
impl Default for kunit_unary_assert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn kunit_unary_assert_format(
        assert: *const kunit_assert,
        message: *const va_format,
        stream: *mut string_stream,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_ptr_not_err_assert {
    pub assert: kunit_assert,
    pub text: *const core::ffi::c_char,
    pub value: *const core::ffi::c_void,
}
impl Default for kunit_ptr_not_err_assert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn kunit_ptr_not_err_assert_format(
        assert: *const kunit_assert,
        message: *const va_format,
        stream: *mut string_stream,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_binary_assert_text {
    pub operation: *const core::ffi::c_char,
    pub left_text: *const core::ffi::c_char,
    pub right_text: *const core::ffi::c_char,
}
impl Default for kunit_binary_assert_text {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_binary_assert {
    pub assert: kunit_assert,
    pub text: *const kunit_binary_assert_text,
    pub left_value: core::ffi::c_longlong,
    pub right_value: core::ffi::c_longlong,
}
impl Default for kunit_binary_assert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn kunit_binary_assert_format(
        assert: *const kunit_assert,
        message: *const va_format,
        stream: *mut string_stream,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_binary_ptr_assert {
    pub assert: kunit_assert,
    pub text: *const kunit_binary_assert_text,
    pub left_value: *const core::ffi::c_void,
    pub right_value: *const core::ffi::c_void,
}
impl Default for kunit_binary_ptr_assert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn kunit_binary_ptr_assert_format(
        assert: *const kunit_assert,
        message: *const va_format,
        stream: *mut string_stream,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_binary_str_assert {
    pub assert: kunit_assert,
    pub text: *const kunit_binary_assert_text,
    pub left_value: *const core::ffi::c_char,
    pub right_value: *const core::ffi::c_char,
}
impl Default for kunit_binary_str_assert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn kunit_binary_str_assert_format(
        assert: *const kunit_assert,
        message: *const va_format,
        stream: *mut string_stream,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_mem_assert {
    pub assert: kunit_assert,
    pub text: *const kunit_binary_assert_text,
    pub left_value: *const core::ffi::c_void,
    pub right_value: *const core::ffi::c_void,
    pub size: usize,
}
impl Default for kunit_mem_assert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn kunit_mem_assert_format(
        assert: *const kunit_assert,
        message: *const va_format,
        stream: *mut string_stream,
    );
}
pub type kunit_try_catch_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>;
#[repr(C)]
#[repr(align(8))]
#[derive(Default, Copy, Clone)]
pub struct kunit_try_catch {
    pub _bindgen_opaque_blob: [u64; 6usize],
}
extern "C" {
    pub fn kunit_try_catch_run(try_catch: *mut kunit_try_catch, context: *mut core::ffi::c_void);
}
extern "C" {
    pub fn kunit_try_catch_throw(try_catch: *mut kunit_try_catch) -> !;
}
extern "C" {
    pub fn __bad_size_call_parameter();
}
extern "C" {
    pub static mut __per_cpu_offset: [core::ffi::c_ulong; 8192usize];
}
extern "C" {
    pub fn setup_per_cpu_areas();
}
extern "C" {
    pub static mut this_cpu_off: core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Default)]
pub struct sysinfo {
    pub uptime: __kernel_long_t,
    pub loads: [__kernel_ulong_t; 3usize],
    pub totalram: __kernel_ulong_t,
    pub freeram: __kernel_ulong_t,
    pub sharedram: __kernel_ulong_t,
    pub bufferram: __kernel_ulong_t,
    pub totalswap: __kernel_ulong_t,
    pub freeswap: __kernel_ulong_t,
    pub procs: __u16,
    pub pad: __u16,
    pub totalhigh: __kernel_ulong_t,
    pub freehigh: __kernel_ulong_t,
    pub mem_unit: __u32,
    pub _f: __IncompleteArrayField<core::ffi::c_char>,
}
#[repr(C)]
#[repr(align(64))]
pub struct cacheline_padding {
    pub x: __IncompleteArrayField<core::ffi::c_char>,
}
impl Default for cacheline_padding {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pcpu_hot {
    pub __bindgen_anon_1: pcpu_hot__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pcpu_hot__bindgen_ty_1 {
    pub __bindgen_anon_1: pcpu_hot__bindgen_ty_1__bindgen_ty_1,
    pub pad: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pcpu_hot__bindgen_ty_1__bindgen_ty_1 {
    pub current_task: *mut task_struct,
    pub preempt_count: core::ffi::c_int,
    pub cpu_number: core::ffi::c_int,
    pub call_depth: u64_,
    pub top_of_stack: core::ffi::c_ulong,
    pub hardirq_stack_ptr: *mut core::ffi::c_void,
    pub softirq_pending: u16_,
    pub hardirq_stack_inuse: bool_,
}
impl Default for pcpu_hot__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pcpu_hot__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pcpu_hot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut pcpu_hot: pcpu_hot;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct static_call_site {
    pub addr: s32,
    pub key: s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_call_key {
    pub func: *mut core::ffi::c_void,
    pub __bindgen_anon_1: static_call_key__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union static_call_key__bindgen_ty_1 {
    pub type_: core::ffi::c_ulong,
    pub mods: *mut static_call_mod,
    pub sites: *mut static_call_site,
}
impl Default for static_call_key__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for static_call_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn preempt_schedule();
}
extern "C" {
    pub fn preempt_schedule_thunk();
}
extern "C" {
    pub fn preempt_schedule_notrace();
}
extern "C" {
    pub fn preempt_schedule_notrace_thunk();
}
extern "C" {
    pub static mut __SCK__preempt_schedule: static_call_key;
}
extern "C" {
    pub fn __SCT__preempt_schedule();
}
extern "C" {
    pub static mut __SCK__preempt_schedule_notrace: static_call_key;
}
extern "C" {
    pub fn __SCT__preempt_schedule_notrace();
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct preempt_ops {
    pub sched_in: ::core::option::Option<
        unsafe extern "C" fn(notifier: *mut preempt_notifier, cpu: core::ffi::c_int),
    >,
    pub sched_out: ::core::option::Option<
        unsafe extern "C" fn(notifier: *mut preempt_notifier, next: *mut task_struct),
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct preempt_notifier {
    pub link: hlist_node,
    pub ops: *mut preempt_ops,
}
impl Default for preempt_notifier {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn preempt_notifier_inc();
}
extern "C" {
    pub fn preempt_notifier_dec();
}
extern "C" {
    pub fn preempt_notifier_register(notifier: *mut preempt_notifier);
}
extern "C" {
    pub fn preempt_notifier_unregister(notifier: *mut preempt_notifier);
}
extern "C" {
    pub fn migrate_disable();
}
extern "C" {
    pub fn migrate_enable();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_preempt_t {
    pub lock: *mut core::ffi::c_void,
}
impl Default for class_preempt_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_preempt_notrace_t {
    pub lock: *mut core::ffi::c_void,
}
impl Default for class_preempt_notrace_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_migrate_t {
    pub lock: *mut core::ffi::c_void,
}
impl Default for class_migrate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const cc_attr_CC_ATTR_MEM_ENCRYPT: cc_attr = 0;
pub const cc_attr_CC_ATTR_HOST_MEM_ENCRYPT: cc_attr = 1;
pub const cc_attr_CC_ATTR_GUEST_MEM_ENCRYPT: cc_attr = 2;
pub const cc_attr_CC_ATTR_GUEST_STATE_ENCRYPT: cc_attr = 3;
pub const cc_attr_CC_ATTR_GUEST_UNROLL_STRING_IO: cc_attr = 4;
pub const cc_attr_CC_ATTR_GUEST_SEV_SNP: cc_attr = 5;
pub const cc_attr_CC_ATTR_HOTPLUG_DISABLED: cc_attr = 6;
pub type cc_attr = core::ffi::c_uint;
extern "C" {
    pub fn cc_platform_has(attr: cc_attr) -> bool_;
}
extern "C" {
    pub fn mem_encrypt_init();
}
extern "C" {
    pub fn mem_encrypt_setup_arch();
}
extern "C" {
    pub static mut sme_me_mask: u64_;
}
extern "C" {
    pub static mut sev_status: u64_;
}
extern "C" {
    pub fn sme_encrypt_execute(
        encrypted_kernel_vaddr: core::ffi::c_ulong,
        decrypted_kernel_vaddr: core::ffi::c_ulong,
        kernel_len: core::ffi::c_ulong,
        encryption_wa: core::ffi::c_ulong,
        encryption_pgd: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn sme_early_encrypt(paddr: resource_size_t, size: core::ffi::c_ulong);
}
extern "C" {
    pub fn sme_early_decrypt(paddr: resource_size_t, size: core::ffi::c_ulong);
}
extern "C" {
    pub fn sme_map_bootdata(real_mode_data: *mut core::ffi::c_char);
}
extern "C" {
    pub fn sme_unmap_bootdata(real_mode_data: *mut core::ffi::c_char);
}
extern "C" {
    pub fn sme_early_init();
}
extern "C" {
    pub fn sme_encrypt_kernel(bp: *mut boot_params);
}
extern "C" {
    pub fn sme_enable(bp: *mut boot_params);
}
extern "C" {
    pub fn early_set_memory_decrypted(
        vaddr: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn early_set_memory_encrypted(
        vaddr: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn early_set_mem_enc_dec_hypercall(
        vaddr: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        enc: bool_,
    );
}
extern "C" {
    pub fn mem_encrypt_free_decrypted_mem();
}
extern "C" {
    pub fn sev_es_init_vc_handling();
}
extern "C" {
    pub fn add_encrypt_protection_map();
}
extern "C" {
    pub static mut __start_bss_decrypted: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __end_bss_decrypted: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __start_bss_decrypted_unused: [core::ffi::c_char; 0usize];
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct unwind_hint {
    pub ip: u32_,
    pub sp_offset: s16,
    pub sp_reg: u8_,
    pub type_: u8_,
    pub signal: u8_,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Default, Copy, Clone)]
pub struct alt_instr {
    pub _bindgen_opaque_blob: [u8; 14usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union alt_instr__bindgen_ty_1 {
    pub __bindgen_anon_1: alt_instr__bindgen_ty_1__bindgen_ty_1,
    pub ft_flags: u32_,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Default, Copy, Clone)]
pub struct alt_instr__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl alt_instr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn cpuid(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_cpuid(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(cpuid: u32_, flags: u32_) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let cpuid: u32 = unsafe { ::core::mem::transmute(cpuid) };
            cpuid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let flags: u32 = unsafe { ::core::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for alt_instr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut __alt_instructions: [alt_instr; 0usize];
}
extern "C" {
    pub static mut __alt_instructions_end: [alt_instr; 0usize];
}
extern "C" {
    pub static mut alternatives_patched: core::ffi::c_int;
}
extern "C" {
    pub fn alternative_instructions();
}
extern "C" {
    pub fn apply_alternatives(start: *mut alt_instr, end: *mut alt_instr);
}
extern "C" {
    pub fn apply_retpolines(start: *mut s32, end: *mut s32);
}
extern "C" {
    pub fn apply_returns(start: *mut s32, end: *mut s32);
}
extern "C" {
    pub fn apply_seal_endbr(start: *mut s32, end: *mut s32);
}
extern "C" {
    pub fn apply_fineibt(
        start_retpoline: *mut s32,
        end_retpoine: *mut s32,
        start_cfi: *mut s32,
        end_cfi: *mut s32,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct callthunk_sites {
    pub call_start: *mut s32,
    pub call_end: *mut s32,
    pub alt_start: *mut alt_instr,
    pub alt_end: *mut alt_instr,
}
impl Default for callthunk_sites {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn callthunks_patch_builtin_calls();
}
extern "C" {
    pub fn callthunks_patch_module_calls(sites: *mut callthunk_sites, mod_: *mut module);
}
extern "C" {
    pub fn callthunks_translate_call_dest(dest: *mut core::ffi::c_void) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn x86_call_depth_emit_accounting(
        pprog: *mut *mut u8_,
        func: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn alternatives_smp_module_add(
        mod_: *mut module,
        name: *mut core::ffi::c_char,
        locks: *mut core::ffi::c_void,
        locks_end: *mut core::ffi::c_void,
        text: *mut core::ffi::c_void,
        text_end: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn alternatives_smp_module_del(mod_: *mut module);
}
extern "C" {
    pub fn alternatives_enable_smp();
}
extern "C" {
    pub fn alternatives_text_reserved(
        start: *mut core::ffi::c_void,
        end: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut skip_smp_alternatives: bool_;
}
extern "C" {
    pub fn BUG_func();
}
extern "C" {
    pub fn nop_func();
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct orc_entry {
    pub sp_offset: s16,
    pub bp_offset: s16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl orc_entry {
    #[inline]
    pub fn sp_reg(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sp_reg(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn bp_reg(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_bp_reg(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn signal(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_signal(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sp_reg: core::ffi::c_uint,
        bp_reg: core::ffi::c_uint,
        type_: core::ffi::c_uint,
        signal: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sp_reg: u32 = unsafe { ::core::mem::transmute(sp_reg) };
            sp_reg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let bp_reg: u32 = unsafe { ::core::mem::transmute(bp_reg) };
            bp_reg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let signal: u32 = unsafe { ::core::mem::transmute(signal) };
            signal as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type retpoline_thunk_t = [u8_; 32usize];
extern "C" {
    pub static mut __x86_indirect_thunk_array: [retpoline_thunk_t; 0usize];
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_array: [retpoline_thunk_t; 0usize];
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_array: [retpoline_thunk_t; 0usize];
}
extern "C" {
    pub fn __x86_return_thunk();
}
extern "C" {
    pub fn retbleed_return_thunk();
}
extern "C" {
    pub fn srso_alias_untrain_ret();
}
extern "C" {
    pub fn srso_return_thunk();
}
extern "C" {
    pub fn srso_alias_return_thunk();
}
extern "C" {
    pub fn entry_untrain_ret();
}
extern "C" {
    pub fn entry_ibpb();
}
extern "C" {
    pub fn clear_bhb_loop();
}
extern "C" {
    pub static mut x86_return_thunk: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn call_depth_return_thunk();
}
extern "C" {
    pub static mut __x86_indirect_thunk_rax: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rcx: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rdx: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rbx: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rsp: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rbp: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rsi: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rdi: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r8: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r9: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r10: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r11: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r12: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r13: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r14: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r15: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_rax: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_rcx: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_rdx: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_rbx: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_rsp: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_rbp: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_rsi: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_rdi: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_r8: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_r9: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_r10: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_r11: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_r12: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_r13: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_r14: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_call_thunk_r15: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_rax: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_rcx: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_rdx: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_rbx: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_rsp: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_rbp: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_rsi: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_rdi: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_r8: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_r9: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_r10: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_r11: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_r12: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_r13: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_r14: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_jump_thunk_r15: retpoline_thunk_t;
}
pub const spectre_v2_mitigation_SPECTRE_V2_NONE: spectre_v2_mitigation = 0;
pub const spectre_v2_mitigation_SPECTRE_V2_RETPOLINE: spectre_v2_mitigation = 1;
pub const spectre_v2_mitigation_SPECTRE_V2_LFENCE: spectre_v2_mitigation = 2;
pub const spectre_v2_mitigation_SPECTRE_V2_EIBRS: spectre_v2_mitigation = 3;
pub const spectre_v2_mitigation_SPECTRE_V2_EIBRS_RETPOLINE: spectre_v2_mitigation = 4;
pub const spectre_v2_mitigation_SPECTRE_V2_EIBRS_LFENCE: spectre_v2_mitigation = 5;
pub const spectre_v2_mitigation_SPECTRE_V2_IBRS: spectre_v2_mitigation = 6;
pub type spectre_v2_mitigation = core::ffi::c_uint;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_NONE: spectre_v2_user_mitigation = 0;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_STRICT: spectre_v2_user_mitigation = 1;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_STRICT_PREFERRED: spectre_v2_user_mitigation =
    2;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_PRCTL: spectre_v2_user_mitigation = 3;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_SECCOMP: spectre_v2_user_mitigation = 4;
pub type spectre_v2_user_mitigation = core::ffi::c_uint;
pub const ssb_mitigation_SPEC_STORE_BYPASS_NONE: ssb_mitigation = 0;
pub const ssb_mitigation_SPEC_STORE_BYPASS_DISABLE: ssb_mitigation = 1;
pub const ssb_mitigation_SPEC_STORE_BYPASS_PRCTL: ssb_mitigation = 2;
pub const ssb_mitigation_SPEC_STORE_BYPASS_SECCOMP: ssb_mitigation = 3;
pub type ssb_mitigation = core::ffi::c_uint;
extern "C" {
    pub static mut x86_pred_cmd: u64_;
}
extern "C" {
    pub static mut x86_spec_ctrl_base: u64_;
}
extern "C" {
    pub static mut x86_spec_ctrl_current: core::ffi::c_ulonglong;
}
extern "C" {
    pub fn update_spec_ctrl_cond(val: u64_);
}
extern "C" {
    pub fn spec_ctrl_current() -> u64_;
}
extern "C" {
    pub static mut switch_to_cond_stibp: static_key_false;
}
extern "C" {
    pub static mut switch_mm_cond_ibpb: static_key_false;
}
extern "C" {
    pub static mut switch_mm_always_ibpb: static_key_false;
}
extern "C" {
    pub static mut mds_idle_clear: static_key_false;
}
extern "C" {
    pub static mut switch_mm_cond_l1d_flush: static_key_false;
}
extern "C" {
    pub static mut mmio_stale_data_clear: static_key_false;
}
extern "C" {
    pub static mut mds_verw_sel: u16_;
}
extern "C" {
    pub static mut early_idt_handler_array: [[core::ffi::c_char; 9usize]; 32usize];
}
extern "C" {
    pub fn early_ignore_irq();
}
extern "C" {
    pub static mut xen_early_idt_handler_array: [[core::ffi::c_char; 8usize]; 32usize];
}
#[repr(C)]
#[repr(align(1))]
#[derive(Default, Copy, Clone)]
pub struct desc_struct {
    pub _bindgen_opaque_blob: [u8; 8usize],
}
pub const GATE_INTERRUPT: _bindgen_ty_3 = 14;
pub const GATE_TRAP: _bindgen_ty_3 = 15;
pub const GATE_CALL: _bindgen_ty_3 = 12;
pub const GATE_TASK: _bindgen_ty_3 = 5;
pub type _bindgen_ty_3 = core::ffi::c_uint;
pub const DESC_TSS: _bindgen_ty_4 = 9;
pub const DESC_LDT: _bindgen_ty_4 = 2;
pub const DESCTYPE_S: _bindgen_ty_4 = 16;
pub type _bindgen_ty_4 = core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct ldttss_desc {
    pub limit0: u16_,
    pub base0: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub base3: u32_,
    pub zero1: u32_,
}
impl ldttss_desc {
    #[inline]
    pub fn base1(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit1(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_limit1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn zero0(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_zero0(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn g(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_g(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn base2(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base2(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        base1: u16_,
        type_: u16_,
        dpl: u16_,
        p: u16_,
        limit1: u16_,
        zero0: u16_,
        g: u16_,
        base2: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let base1: u16 = unsafe { ::core::mem::transmute(base1) };
            base1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let type_: u16 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u16 = unsafe { ::core::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u16 = unsafe { ::core::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let limit1: u16 = unsafe { ::core::mem::transmute(limit1) };
            limit1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let zero0: u16 = unsafe { ::core::mem::transmute(zero0) };
            zero0 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let g: u16 = unsafe { ::core::mem::transmute(g) };
            g as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let base2: u16 = unsafe { ::core::mem::transmute(base2) };
            base2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ldt_desc = ldttss_desc;
pub type tss_desc = ldttss_desc;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct idt_bits {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl idt_bits {
    #[inline]
    pub fn ist(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_ist(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn zero(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_zero(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ist: u16_,
        zero: u16_,
        type_: u16_,
        dpl: u16_,
        p: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let ist: u16 = unsafe { ::core::mem::transmute(ist) };
            ist as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let zero: u16 = unsafe { ::core::mem::transmute(zero) };
            zero as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let type_: u16 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u16 = unsafe { ::core::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u16 = unsafe { ::core::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct idt_data {
    pub vector: core::ffi::c_uint,
    pub segment: core::ffi::c_uint,
    pub bits: idt_bits,
    pub addr: *const core::ffi::c_void,
}
impl Default for idt_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct gate_struct {
    pub offset_low: u16_,
    pub segment: u16_,
    pub bits: idt_bits,
    pub offset_middle: u16_,
    pub offset_high: u32_,
    pub reserved: u32_,
}
pub type gate_desc = gate_struct;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct desc_ptr {
    pub size: core::ffi::c_ushort,
    pub address: core::ffi::c_ulong,
}
extern "C" {
    pub fn kaslr_get_random_long(purpose: *const core::ffi::c_char) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn kernel_randomize_memory();
}
extern "C" {
    pub fn init_trampoline_kaslr();
}
extern "C" {
    pub static mut physical_mask: phys_addr_t;
}
extern "C" {
    pub fn devmem_is_allowed(pagenr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub static mut max_low_pfn_mapped: core::ffi::c_ulong;
}
extern "C" {
    pub static mut max_pfn_mapped: core::ffi::c_ulong;
}
extern "C" {
    pub fn pfn_range_is_mapped(start_pfn: core::ffi::c_ulong, end_pfn: core::ffi::c_ulong)
        -> bool_;
}
extern "C" {
    pub fn initmem_init();
}
pub const page_cache_mode__PAGE_CACHE_MODE_WB: page_cache_mode = 0;
pub const page_cache_mode__PAGE_CACHE_MODE_WC: page_cache_mode = 1;
pub const page_cache_mode__PAGE_CACHE_MODE_UC_MINUS: page_cache_mode = 2;
pub const page_cache_mode__PAGE_CACHE_MODE_UC: page_cache_mode = 3;
pub const page_cache_mode__PAGE_CACHE_MODE_WT: page_cache_mode = 4;
pub const page_cache_mode__PAGE_CACHE_MODE_WP: page_cache_mode = 5;
pub const page_cache_mode__PAGE_CACHE_MODE_NUM: page_cache_mode = 8;
pub type page_cache_mode = core::ffi::c_uint;
extern "C" {
    pub fn phys_to_target_node(start: phys_addr_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn memory_add_physaddr_to_nid(start: u64_) -> core::ffi::c_int;
}
pub type pteval_t = core::ffi::c_ulong;
pub type pmdval_t = core::ffi::c_ulong;
pub type pudval_t = core::ffi::c_ulong;
pub type p4dval_t = core::ffi::c_ulong;
pub type pgdval_t = core::ffi::c_ulong;
pub type pgprotval_t = core::ffi::c_ulong;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pte_t {
    pub pte: pteval_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pmd_t {
    pub pmd: pmdval_t,
}
extern "C" {
    pub static mut __pgtable_l5_enabled: core::ffi::c_uint;
}
extern "C" {
    pub static mut pgdir_shift: core::ffi::c_uint;
}
extern "C" {
    pub static mut ptrs_per_p4d: core::ffi::c_uint;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pgprot {
    pub pgprot: pgprotval_t,
}
pub type pgprot_t = pgprot;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pgd_t {
    pub pgd: pgdval_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct p4d_t {
    pub p4d: p4dval_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pud_t {
    pub pud: pudval_t,
}
extern "C" {
    pub fn cachemode2protval(pcm: page_cache_mode) -> core::ffi::c_ulong;
}
pub type pgtable_t = *mut page;
extern "C" {
    pub static mut __supported_pte_mask: pteval_t;
}
extern "C" {
    pub static mut __default_kernel_pte_mask: pteval_t;
}
extern "C" {
    pub fn set_nx();
}
extern "C" {
    pub static mut nx_enabled: core::ffi::c_int;
}
extern "C" {
    pub fn pgprot_writecombine(prot: pgprot_t) -> pgprot_t;
}
extern "C" {
    pub fn pgprot_writethrough(prot: pgprot_t) -> pgprot_t;
}
extern "C" {
    pub fn phys_mem_access_prot(
        file: *mut file,
        pfn: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        vma_prot: pgprot_t,
    ) -> pgprot_t;
}
extern "C" {
    pub fn set_pte_vaddr(vaddr: core::ffi::c_ulong, pte: pte_t);
}
pub const pg_level_PG_LEVEL_NONE: pg_level = 0;
pub const pg_level_PG_LEVEL_4K: pg_level = 1;
pub const pg_level_PG_LEVEL_2M: pg_level = 2;
pub const pg_level_PG_LEVEL_1G: pg_level = 3;
pub const pg_level_PG_LEVEL_512G: pg_level = 4;
pub const pg_level_PG_LEVEL_NUM: pg_level = 5;
pub type pg_level = core::ffi::c_uint;
extern "C" {
    pub fn update_page_count(level: core::ffi::c_int, pages: core::ffi::c_ulong);
}
extern "C" {
    pub fn lookup_address(address: core::ffi::c_ulong, level: *mut core::ffi::c_uint)
        -> *mut pte_t;
}
extern "C" {
    pub fn lookup_address_in_pgd(
        pgd: *mut pgd_t,
        address: core::ffi::c_ulong,
        level: *mut core::ffi::c_uint,
    ) -> *mut pte_t;
}
extern "C" {
    pub fn lookup_address_in_pgd_attr(
        pgd: *mut pgd_t,
        address: core::ffi::c_ulong,
        level: *mut core::ffi::c_uint,
        nx: *mut bool_,
        rw: *mut bool_,
    ) -> *mut pte_t;
}
extern "C" {
    pub fn lookup_pmd_address(address: core::ffi::c_ulong) -> *mut pmd_t;
}
extern "C" {
    pub fn slow_virt_to_phys(__address: *mut core::ffi::c_void) -> phys_addr_t;
}
extern "C" {
    pub fn kernel_map_pages_in_pgd(
        pgd: *mut pgd_t,
        pfn: u64_,
        address: core::ffi::c_ulong,
        numpages: core::ffi::c_uint,
        page_flags: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_unmap_pages_in_pgd(
        pgd: *mut pgd_t,
        address: core::ffi::c_ulong,
        numpages: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flush_tlb_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmu_gather {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct paravirt_callee_save {
    pub func: *mut core::ffi::c_void,
}
impl Default for paravirt_callee_save {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pv_info {
    pub extra_user_64bit_cs: u16_,
    pub name: *const core::ffi::c_char,
}
impl Default for pv_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pv_lazy_ops {
    pub enter: ::core::option::Option<unsafe extern "C" fn()>,
    pub leave: ::core::option::Option<unsafe extern "C" fn()>,
    pub flush: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pv_cpu_ops {
    pub io_delay: ::core::option::Option<unsafe extern "C" fn()>,
    pub get_debugreg:
        ::core::option::Option<unsafe extern "C" fn(regno: core::ffi::c_int) -> core::ffi::c_ulong>,
    pub set_debugreg: ::core::option::Option<
        unsafe extern "C" fn(regno: core::ffi::c_int, value: core::ffi::c_ulong),
    >,
    pub read_cr0: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_ulong>,
    pub write_cr0: ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_ulong)>,
    pub write_cr4: ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_ulong)>,
    pub load_tr_desc: ::core::option::Option<unsafe extern "C" fn()>,
    pub load_gdt: ::core::option::Option<unsafe extern "C" fn(arg1: *const desc_ptr)>,
    pub load_idt: ::core::option::Option<unsafe extern "C" fn(arg1: *const desc_ptr)>,
    pub set_ldt: ::core::option::Option<
        unsafe extern "C" fn(desc: *const core::ffi::c_void, entries: core::ffi::c_uint),
    >,
    pub store_tr: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_ulong>,
    pub load_tls:
        ::core::option::Option<unsafe extern "C" fn(t: *mut thread_struct, cpu: core::ffi::c_uint)>,
    pub load_gs_index: ::core::option::Option<unsafe extern "C" fn(idx: core::ffi::c_uint)>,
    pub write_ldt_entry: ::core::option::Option<
        unsafe extern "C" fn(
            ldt: *mut desc_struct,
            entrynum: core::ffi::c_int,
            desc: *const core::ffi::c_void,
        ),
    >,
    pub write_gdt_entry: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut desc_struct,
            entrynum: core::ffi::c_int,
            desc: *const core::ffi::c_void,
            size: core::ffi::c_int,
        ),
    >,
    pub write_idt_entry: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gate_desc,
            entrynum: core::ffi::c_int,
            gate: *const gate_desc,
        ),
    >,
    pub alloc_ldt: ::core::option::Option<
        unsafe extern "C" fn(ldt: *mut desc_struct, entries: core::ffi::c_uint),
    >,
    pub free_ldt: ::core::option::Option<
        unsafe extern "C" fn(ldt: *mut desc_struct, entries: core::ffi::c_uint),
    >,
    pub load_sp0: ::core::option::Option<unsafe extern "C" fn(sp0: core::ffi::c_ulong)>,
    pub invalidate_io_bitmap: ::core::option::Option<unsafe extern "C" fn()>,
    pub update_io_bitmap: ::core::option::Option<unsafe extern "C" fn()>,
    pub wbinvd: ::core::option::Option<unsafe extern "C" fn()>,
    pub cpuid: ::core::option::Option<
        unsafe extern "C" fn(
            eax: *mut core::ffi::c_uint,
            ebx: *mut core::ffi::c_uint,
            ecx: *mut core::ffi::c_uint,
            edx: *mut core::ffi::c_uint,
        ),
    >,
    pub read_msr: ::core::option::Option<unsafe extern "C" fn(msr: core::ffi::c_uint) -> u64_>,
    pub write_msr: ::core::option::Option<
        unsafe extern "C" fn(
            msr: core::ffi::c_uint,
            low: core::ffi::c_uint,
            high: core::ffi::c_uint,
        ),
    >,
    pub read_msr_safe: ::core::option::Option<
        unsafe extern "C" fn(msr: core::ffi::c_uint, err: *mut core::ffi::c_int) -> u64_,
    >,
    pub write_msr_safe: ::core::option::Option<
        unsafe extern "C" fn(
            msr: core::ffi::c_uint,
            low: core::ffi::c_uint,
            high: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub read_pmc: ::core::option::Option<unsafe extern "C" fn(counter: core::ffi::c_int) -> u64_>,
    pub start_context_switch: ::core::option::Option<unsafe extern "C" fn(prev: *mut task_struct)>,
    pub end_context_switch: ::core::option::Option<unsafe extern "C" fn(next: *mut task_struct)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pv_irq_ops {
    pub save_fl: paravirt_callee_save,
    pub irq_disable: paravirt_callee_save,
    pub irq_enable: paravirt_callee_save,
    pub safe_halt: ::core::option::Option<unsafe extern "C" fn()>,
    pub halt: ::core::option::Option<unsafe extern "C" fn()>,
}
impl Default for pv_irq_ops {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pv_mmu_ops {
    pub flush_tlb_user: ::core::option::Option<unsafe extern "C" fn()>,
    pub flush_tlb_kernel: ::core::option::Option<unsafe extern "C" fn()>,
    pub flush_tlb_one_user: ::core::option::Option<unsafe extern "C" fn(addr: core::ffi::c_ulong)>,
    pub flush_tlb_multi: ::core::option::Option<
        unsafe extern "C" fn(cpus: *const cpumask, info: *const flush_tlb_info),
    >,
    pub tlb_remove_table: ::core::option::Option<
        unsafe extern "C" fn(tlb: *mut mmu_gather, table: *mut core::ffi::c_void),
    >,
    pub exit_mmap: ::core::option::Option<unsafe extern "C" fn(mm: *mut mm_struct)>,
    pub notify_page_enc_status_changed: ::core::option::Option<
        unsafe extern "C" fn(pfn: core::ffi::c_ulong, npages: core::ffi::c_int, enc: bool_),
    >,
    pub read_cr2: paravirt_callee_save,
    pub write_cr2: ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_ulong)>,
    pub read_cr3: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_ulong>,
    pub write_cr3: ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_ulong)>,
    pub enter_mmap: ::core::option::Option<unsafe extern "C" fn(mm: *mut mm_struct)>,
    pub pgd_alloc:
        ::core::option::Option<unsafe extern "C" fn(mm: *mut mm_struct) -> core::ffi::c_int>,
    pub pgd_free: ::core::option::Option<unsafe extern "C" fn(mm: *mut mm_struct, pgd: *mut pgd_t)>,
    pub alloc_pte:
        ::core::option::Option<unsafe extern "C" fn(mm: *mut mm_struct, pfn: core::ffi::c_ulong)>,
    pub alloc_pmd:
        ::core::option::Option<unsafe extern "C" fn(mm: *mut mm_struct, pfn: core::ffi::c_ulong)>,
    pub alloc_pud:
        ::core::option::Option<unsafe extern "C" fn(mm: *mut mm_struct, pfn: core::ffi::c_ulong)>,
    pub alloc_p4d:
        ::core::option::Option<unsafe extern "C" fn(mm: *mut mm_struct, pfn: core::ffi::c_ulong)>,
    pub release_pte: ::core::option::Option<unsafe extern "C" fn(pfn: core::ffi::c_ulong)>,
    pub release_pmd: ::core::option::Option<unsafe extern "C" fn(pfn: core::ffi::c_ulong)>,
    pub release_pud: ::core::option::Option<unsafe extern "C" fn(pfn: core::ffi::c_ulong)>,
    pub release_p4d: ::core::option::Option<unsafe extern "C" fn(pfn: core::ffi::c_ulong)>,
    pub set_pte: ::core::option::Option<unsafe extern "C" fn(ptep: *mut pte_t, pteval: pte_t)>,
    pub set_pmd: ::core::option::Option<unsafe extern "C" fn(pmdp: *mut pmd_t, pmdval: pmd_t)>,
    pub ptep_modify_prot_start: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            addr: core::ffi::c_ulong,
            ptep: *mut pte_t,
        ) -> pte_t,
    >,
    pub ptep_modify_prot_commit: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            addr: core::ffi::c_ulong,
            ptep: *mut pte_t,
            pte: pte_t,
        ),
    >,
    pub pte_val: paravirt_callee_save,
    pub make_pte: paravirt_callee_save,
    pub pgd_val: paravirt_callee_save,
    pub make_pgd: paravirt_callee_save,
    pub set_pud: ::core::option::Option<unsafe extern "C" fn(pudp: *mut pud_t, pudval: pud_t)>,
    pub pmd_val: paravirt_callee_save,
    pub make_pmd: paravirt_callee_save,
    pub pud_val: paravirt_callee_save,
    pub make_pud: paravirt_callee_save,
    pub set_p4d: ::core::option::Option<unsafe extern "C" fn(p4dp: *mut p4d_t, p4dval: p4d_t)>,
    pub p4d_val: paravirt_callee_save,
    pub make_p4d: paravirt_callee_save,
    pub set_pgd: ::core::option::Option<unsafe extern "C" fn(pgdp: *mut pgd_t, pgdval: pgd_t)>,
    pub lazy_mode: pv_lazy_ops,
    pub set_fixmap: ::core::option::Option<
        unsafe extern "C" fn(idx: core::ffi::c_uint, phys: phys_addr_t, flags: pgprot_t),
    >,
}
impl Default for pv_mmu_ops {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_spinlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pv_lock_ops {
    pub queued_spin_lock_slowpath:
        ::core::option::Option<unsafe extern "C" fn(lock: *mut qspinlock, val: u32_)>,
    pub queued_spin_unlock: paravirt_callee_save,
    pub wait: ::core::option::Option<unsafe extern "C" fn(ptr: *mut u8_, val: u8_)>,
    pub kick: ::core::option::Option<unsafe extern "C" fn(cpu: core::ffi::c_int)>,
    pub vcpu_is_preempted: paravirt_callee_save,
}
impl Default for pv_lock_ops {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct paravirt_patch_template {
    pub cpu: pv_cpu_ops,
    pub irq: pv_irq_ops,
    pub mmu: pv_mmu_ops,
    pub lock: pv_lock_ops,
}
impl Default for paravirt_patch_template {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut pv_info: pv_info;
}
extern "C" {
    pub static mut pv_ops: paravirt_patch_template;
}
extern "C" {
    pub fn paravirt_disable_iospace() -> core::ffi::c_int;
}
extern "C" {
    pub fn paravirt_ret0() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _paravirt_ident_64(arg1: u64_) -> u64_;
}
extern "C" {
    pub fn pv_native_save_fl() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn pv_native_irq_disable();
}
extern "C" {
    pub fn pv_native_irq_enable();
}
extern "C" {
    pub fn pv_native_read_cr2() -> core::ffi::c_ulong;
}
extern "C" {
    pub static mut panic_blink:
        ::core::option::Option<unsafe extern "C" fn(state: core::ffi::c_int) -> core::ffi::c_long>;
}
extern "C" {
    pub fn panic(fmt: *const core::ffi::c_char, ...) -> !;
}
extern "C" {
    pub fn nmi_panic(regs: *mut pt_regs, msg: *const core::ffi::c_char);
}
extern "C" {
    pub fn check_panic_on_warn(origin: *const core::ffi::c_char);
}
extern "C" {
    pub fn oops_enter();
}
extern "C" {
    pub fn oops_exit();
}
extern "C" {
    pub fn oops_may_print() -> bool_;
}
extern "C" {
    pub static mut panic_timeout: core::ffi::c_int;
}
extern "C" {
    pub static mut panic_print: core::ffi::c_ulong;
}
extern "C" {
    pub static mut panic_on_oops: core::ffi::c_int;
}
extern "C" {
    pub static mut panic_on_unrecovered_nmi: core::ffi::c_int;
}
extern "C" {
    pub static mut panic_on_io_nmi: core::ffi::c_int;
}
extern "C" {
    pub static mut panic_on_warn: core::ffi::c_int;
}
extern "C" {
    pub static mut panic_on_taint: core::ffi::c_ulong;
}
extern "C" {
    pub static mut panic_on_taint_nousertaint: bool_;
}
extern "C" {
    pub static mut sysctl_panic_on_rcu_stall: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_max_rcu_stall_to_panic: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_panic_on_stackoverflow: core::ffi::c_int;
}
extern "C" {
    pub static mut crash_kexec_post_notifiers: bool_;
}
extern "C" {
    pub fn __stack_chk_fail();
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub static mut panic_cpu: atomic_t;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct taint_flag {
    pub c_true: core::ffi::c_char,
    pub c_false: core::ffi::c_char,
    pub module: bool_,
}
extern "C" {
    pub static taint_flags: [taint_flag; 19usize];
}
pub const lockdep_ok_LOCKDEP_STILL_OK: lockdep_ok = 0;
pub const lockdep_ok_LOCKDEP_NOW_UNRELIABLE: lockdep_ok = 1;
pub type lockdep_ok = core::ffi::c_uint;
extern "C" {
    pub fn print_tainted() -> *const core::ffi::c_char;
}
extern "C" {
    pub fn add_taint(flag: core::ffi::c_uint, arg1: lockdep_ok);
}
extern "C" {
    pub fn test_taint(flag: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_taint() -> core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct warn_args {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __warn(
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        caller: *mut core::ffi::c_void,
        taint: core::ffi::c_uint,
        regs: *mut pt_regs,
        args: *mut warn_args,
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bug_entry {
    pub bug_addr_disp: core::ffi::c_int,
    pub file_disp: core::ffi::c_int,
    pub line: core::ffi::c_ushort,
    pub flags: core::ffi::c_ushort,
}
extern "C" {
    pub fn warn_slowpath_fmt(
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        taint: core::ffi::c_uint,
        fmt: *const core::ffi::c_char,
        ...
    );
}
extern "C" {
    pub fn __warn_printk(fmt: *const core::ffi::c_char, ...);
}
pub const bug_trap_type_BUG_TRAP_TYPE_NONE: bug_trap_type = 0;
pub const bug_trap_type_BUG_TRAP_TYPE_WARN: bug_trap_type = 1;
pub const bug_trap_type_BUG_TRAP_TYPE_BUG: bug_trap_type = 2;
pub type bug_trap_type = core::ffi::c_uint;
extern "C" {
    pub fn bug_get_file_line(
        bug: *mut bug_entry,
        file: *mut *const core::ffi::c_char,
        line: *mut core::ffi::c_uint,
    );
}
extern "C" {
    pub fn find_bug(bugaddr: core::ffi::c_ulong) -> *mut bug_entry;
}
extern "C" {
    pub fn report_bug(bug_addr: core::ffi::c_ulong, regs: *mut pt_regs) -> bug_trap_type;
}
extern "C" {
    pub fn is_valid_bugaddr(addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_bug_clear_once();
}
extern "C" {
    pub fn __sw_hweight8(w: core::ffi::c_uint) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __sw_hweight16(w: core::ffi::c_uint) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __sw_hweight32(w: core::ffi::c_uint) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __sw_hweight64(w: __u64) -> core::ffi::c_ulong;
}
extern "C" {
    pub static hex_asc: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static hex_asc_upper: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub fn hex_to_bin(ch: core::ffi::c_uchar) -> core::ffi::c_int;
}
extern "C" {
    pub fn hex2bin(dst: *mut u8_, src: *const core::ffi::c_char, count: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn bin2hex(
        dst: *mut core::ffi::c_char,
        src: *const core::ffi::c_void,
        count: usize,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn mac_pton(s: *const core::ffi::c_char, mac: *mut u8_) -> bool_;
}
extern "C" {
    pub fn _kstrtoul(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn _kstrtol(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_long,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtoull(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_ulonglong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtoll(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_longlong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtouint(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtoint(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtou16(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtos16(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut s16,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtou8(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut u8_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtos8(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut s8,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtobool(s: *const core::ffi::c_char, res: *mut bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtoull_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_ulonglong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtoll_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_longlong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtoul_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtol_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_long,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtouint_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtoint_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtou16_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtos16_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut s16,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtou8_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut u8_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtos8_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut s8,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtobool_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        res: *mut bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_strtoul(
        arg1: *const core::ffi::c_char,
        arg2: *mut *mut core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn simple_strtol(
        arg1: *const core::ffi::c_char,
        arg2: *mut *mut core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn simple_strtoull(
        arg1: *const core::ffi::c_char,
        arg2: *mut *mut core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_ulonglong;
}
extern "C" {
    pub fn simple_strtoll(
        arg1: *const core::ffi::c_char,
        arg2: *mut *mut core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_longlong;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct s16_fract {
    pub numerator: __s16,
    pub denominator: __s16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct u16_fract {
    pub numerator: __u16,
    pub denominator: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct s32_fract {
    pub numerator: __s32,
    pub denominator: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct u32_fract {
    pub numerator: __u32,
    pub denominator: __u32,
}
extern "C" {
    pub fn int_pow(base: u64_, exp: core::ffi::c_uint) -> u64_;
}
extern "C" {
    pub fn int_sqrt(arg1: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn num_to_str(
        buf: *mut core::ffi::c_char,
        size: core::ffi::c_int,
        num: core::ffi::c_ulonglong,
        width: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sprintf(
        buf: *mut core::ffi::c_char,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vsprintf(
        buf: *mut core::ffi::c_char,
        arg1: *const core::ffi::c_char,
        arg2: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn snprintf(
        buf: *mut core::ffi::c_char,
        size: core::ffi::c_ulong,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vsnprintf(
        buf: *mut core::ffi::c_char,
        size: core::ffi::c_ulong,
        fmt: *const core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn scnprintf(
        buf: *mut core::ffi::c_char,
        size: usize,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vscnprintf(
        buf: *mut core::ffi::c_char,
        size: usize,
        fmt: *const core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kasprintf(gfp: gfp_t, fmt: *const core::ffi::c_char, ...) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn kvasprintf(
        gfp: gfp_t,
        fmt: *const core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn kvasprintf_const(
        gfp: gfp_t,
        fmt: *const core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn sscanf(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut no_hash_pointers: bool_;
}
extern "C" {
    pub fn no_hash_pointers_enable(str_: *mut core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cond_resched() -> core::ffi::c_int;
}
extern "C" {
    pub static mut __SCK__might_resched: static_call_key;
}
extern "C" {
    pub fn __SCT__might_resched() -> core::ffi::c_int;
}
extern "C" {
    pub fn do_exit(error_code: core::ffi::c_long) -> !;
}
extern "C" {
    pub fn get_option(
        str_: *mut *mut core::ffi::c_char,
        pint: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_options(
        str_: *const core::ffi::c_char,
        nints: core::ffi::c_int,
        ints: *mut core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn memparse(
        ptr: *const core::ffi::c_char,
        retptr: *mut *mut core::ffi::c_char,
    ) -> core::ffi::c_ulonglong;
}
extern "C" {
    pub fn parse_option_str(
        str_: *const core::ffi::c_char,
        option: *const core::ffi::c_char,
    ) -> bool_;
}
extern "C" {
    pub fn next_arg(
        args: *mut core::ffi::c_char,
        param: *mut *mut core::ffi::c_char,
        val: *mut *mut core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn core_kernel_text(addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn __kernel_text_address(addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_text_address(addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn func_ptr_is_kernel_text(ptr: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn bust_spinlocks(yes: core::ffi::c_int);
}
extern "C" {
    pub static mut root_mountflags: core::ffi::c_int;
}
extern "C" {
    pub static mut early_boot_irqs_disabled: bool_;
}
pub const system_states_SYSTEM_BOOTING: system_states = 0;
pub const system_states_SYSTEM_SCHEDULING: system_states = 1;
pub const system_states_SYSTEM_FREEING_INITMEM: system_states = 2;
pub const system_states_SYSTEM_RUNNING: system_states = 3;
pub const system_states_SYSTEM_HALT: system_states = 4;
pub const system_states_SYSTEM_POWER_OFF: system_states = 5;
pub const system_states_SYSTEM_RESTART: system_states = 6;
pub const system_states_SYSTEM_SUSPEND: system_states = 7;
pub type system_states = core::ffi::c_uint;
extern "C" {
    pub static mut system_state: system_states;
}
pub const ftrace_dump_mode_DUMP_NONE: ftrace_dump_mode = 0;
pub const ftrace_dump_mode_DUMP_ALL: ftrace_dump_mode = 1;
pub const ftrace_dump_mode_DUMP_ORIG: ftrace_dump_mode = 2;
pub type ftrace_dump_mode = core::ffi::c_uint;
extern "C" {
    pub fn tracing_on();
}
extern "C" {
    pub fn tracing_off();
}
extern "C" {
    pub fn tracing_is_on() -> core::ffi::c_int;
}
extern "C" {
    pub fn tracing_snapshot();
}
extern "C" {
    pub fn tracing_snapshot_alloc();
}
extern "C" {
    pub fn tracing_start();
}
extern "C" {
    pub fn tracing_stop();
}
extern "C" {
    pub fn __trace_bprintk(
        ip: core::ffi::c_ulong,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __trace_printk(
        ip: core::ffi::c_ulong,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __trace_bputs(
        ip: core::ffi::c_ulong,
        str_: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __trace_puts(
        ip: core::ffi::c_ulong,
        str_: *const core::ffi::c_char,
        size: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn trace_dump_stack(skip: core::ffi::c_int);
}
extern "C" {
    pub fn __ftrace_vbprintk(
        ip: core::ffi::c_ulong,
        fmt: *const core::ffi::c_char,
        ap: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __ftrace_vprintk(
        ip: core::ffi::c_ulong,
        fmt: *const core::ffi::c_char,
        ap: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ftrace_dump(oops_dump_mode: ftrace_dump_mode);
}
extern "C" {
    pub fn _find_next_bit(
        addr1: *const core::ffi::c_ulong,
        nbits: core::ffi::c_ulong,
        start: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _find_next_and_bit(
        addr1: *const core::ffi::c_ulong,
        addr2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_ulong,
        start: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _find_next_andnot_bit(
        addr1: *const core::ffi::c_ulong,
        addr2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_ulong,
        start: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _find_next_or_bit(
        addr1: *const core::ffi::c_ulong,
        addr2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_ulong,
        start: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _find_next_zero_bit(
        addr: *const core::ffi::c_ulong,
        nbits: core::ffi::c_ulong,
        start: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _find_first_bit(
        addr: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __find_nth_bit(
        addr: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        n: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __find_nth_and_bit(
        addr1: *const core::ffi::c_ulong,
        addr2: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        n: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __find_nth_andnot_bit(
        addr1: *const core::ffi::c_ulong,
        addr2: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        n: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __find_nth_and_andnot_bit(
        addr1: *const core::ffi::c_ulong,
        addr2: *const core::ffi::c_ulong,
        addr3: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        n: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _find_first_and_bit(
        addr1: *const core::ffi::c_ulong,
        addr2: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _find_first_zero_bit(
        addr: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _find_last_bit(
        addr: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn find_next_clump8(
        clump: *mut core::ffi::c_ulong,
        addr: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        offset: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn strndup_user(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_long,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn memdup_user(arg1: *const core::ffi::c_void, arg2: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmemdup_user(arg1: *const core::ffi::c_void, arg2: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memdup_user_nul(arg1: *const core::ffi::c_void, arg2: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memcpy(
        to: *mut core::ffi::c_void,
        from: *const core::ffi::c_void,
        len: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __memcpy(
        to: *mut core::ffi::c_void,
        from: *const core::ffi::c_void,
        len: usize,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        s: *mut core::ffi::c_void,
        c: core::ffi::c_int,
        n: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __memset(
        s: *mut core::ffi::c_void,
        c: core::ffi::c_int,
        n: usize,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        dest: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        count: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __memmove(
        dest: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        count: usize,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        cs: *const core::ffi::c_void,
        ct: *const core::ffi::c_void,
        count: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strlen(s: *const core::ffi::c_char) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn strcpy(
        dest: *mut core::ffi::c_char,
        src: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strcat(
        dest: *mut core::ffi::c_char,
        src: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strcmp(cs: *const core::ffi::c_char, ct: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn __memcpy_flushcache(
        dst: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        cnt: usize,
    );
}
extern "C" {
    pub fn strncpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strscpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: usize,
    ) -> isize;
}
extern "C" {
    pub fn strscpy_pad(
        dest: *mut core::ffi::c_char,
        src: *const core::ffi::c_char,
        count: usize,
    ) -> isize;
}
extern "C" {
    pub fn strncat(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn strncmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp(
        s1: *const core::ffi::c_char,
        s2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp(
        s1: *const core::ffi::c_char,
        s2: *const core::ffi::c_char,
        n: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strchr(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int)
        -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strchrnul(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strnchrnul(
        arg1: *const core::ffi::c_char,
        arg2: usize,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strnchr(
        arg1: *const core::ffi::c_char,
        arg2: usize,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn skip_spaces(arg1: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strim(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strstr(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: usize,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const core::ffi::c_char, arg2: __kernel_size_t) -> __kernel_size_t;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn strcspn(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __memcat_p(
        a: *mut *mut core::ffi::c_void,
        b: *mut *mut core::ffi::c_void,
    ) -> *mut *mut core::ffi::c_void;
}
extern "C" {
    pub fn memscan(
        arg1: *mut core::ffi::c_void,
        arg2: core::ffi::c_int,
        arg3: __kernel_size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn bcmp(
        arg1: *const core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const core::ffi::c_void,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memchr_inv(
        s: *const core::ffi::c_void,
        c: core::ffi::c_int,
        n: usize,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn strreplace(
        str_: *mut core::ffi::c_char,
        old: core::ffi::c_char,
        new: core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn kfree_const(x: *const core::ffi::c_void);
}
extern "C" {
    pub fn kstrdup(s: *const core::ffi::c_char, gfp: gfp_t) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn kstrdup_const(s: *const core::ffi::c_char, gfp: gfp_t) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn kstrndup(s: *const core::ffi::c_char, len: usize, gfp: gfp_t) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn kmemdup(src: *const core::ffi::c_void, len: usize, gfp: gfp_t)
        -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kvmemdup(
        src: *const core::ffi::c_void,
        len: usize,
        gfp: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kmemdup_nul(
        s: *const core::ffi::c_char,
        len: usize,
        gfp: gfp_t,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn argv_split(
        gfp: gfp_t,
        str_: *const core::ffi::c_char,
        argcp: *mut core::ffi::c_int,
    ) -> *mut *mut core::ffi::c_char;
}
extern "C" {
    pub fn argv_free(argv: *mut *mut core::ffi::c_char);
}
extern "C" {
    pub fn sysfs_streq(s1: *const core::ffi::c_char, s2: *const core::ffi::c_char) -> bool_;
}
extern "C" {
    pub fn match_string(
        array: *const *const core::ffi::c_char,
        n: usize,
        string: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sysfs_match_string(
        array: *const *const core::ffi::c_char,
        n: usize,
        s: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vbin_printf(
        bin_buf: *mut u32_,
        size: usize,
        fmt: *const core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bstr_printf(
        buf: *mut core::ffi::c_char,
        size: usize,
        fmt: *const core::ffi::c_char,
        bin_buf: *const u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bprintf(
        bin_buf: *mut u32_,
        size: usize,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memory_read_from_buffer(
        to: *mut core::ffi::c_void,
        count: usize,
        ppos: *mut loff_t,
        from: *const core::ffi::c_void,
        available: usize,
    ) -> isize;
}
extern "C" {
    pub fn ptr_to_hashval(
        ptr: *const core::ffi::c_void,
        hashval_out: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memweight(ptr: *const core::ffi::c_void, bytes: usize) -> usize;
}
extern "C" {
    pub fn fortify_panic(name: *const core::ffi::c_char) -> !;
}
extern "C" {
    pub fn __read_overflow();
}
extern "C" {
    pub fn __read_overflow2();
}
extern "C" {
    pub fn __read_overflow2_field(avail: usize, wanted: usize);
}
extern "C" {
    pub fn __write_overflow();
}
extern "C" {
    pub fn __write_overflow_field(avail: usize, wanted: usize);
}
extern "C" {
    pub fn memcpy_and_pad(
        dest: *mut core::ffi::c_void,
        dest_len: usize,
        src: *const core::ffi::c_void,
        count: usize,
        pad: core::ffi::c_int,
    );
}
extern "C" {
    pub fn bitmap_parse_user(
        ubuf: *const core::ffi::c_char,
        ulen: core::ffi::c_uint,
        dst: *mut core::ffi::c_ulong,
        nbits: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_print_to_pagebuf(
        list: bool_,
        buf: *mut core::ffi::c_char,
        maskp: *const core::ffi::c_ulong,
        nmaskbits: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_print_bitmask_to_buf(
        buf: *mut core::ffi::c_char,
        maskp: *const core::ffi::c_ulong,
        nmaskbits: core::ffi::c_int,
        off: loff_t,
        count: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_print_list_to_buf(
        buf: *mut core::ffi::c_char,
        maskp: *const core::ffi::c_ulong,
        nmaskbits: core::ffi::c_int,
        off: loff_t,
        count: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_parse(
        buf: *const core::ffi::c_char,
        buflen: core::ffi::c_uint,
        dst: *mut core::ffi::c_ulong,
        nbits: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_parselist(
        buf: *const core::ffi::c_char,
        maskp: *mut core::ffi::c_ulong,
        nmaskbits: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_parselist_user(
        ubuf: *const core::ffi::c_char,
        ulen: core::ffi::c_uint,
        dst: *mut core::ffi::c_ulong,
        nbits: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_alloc(nbits: core::ffi::c_uint, flags: gfp_t) -> *mut core::ffi::c_ulong;
}
extern "C" {
    pub fn bitmap_zalloc(nbits: core::ffi::c_uint, flags: gfp_t) -> *mut core::ffi::c_ulong;
}
extern "C" {
    pub fn bitmap_alloc_node(
        nbits: core::ffi::c_uint,
        flags: gfp_t,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_ulong;
}
extern "C" {
    pub fn bitmap_zalloc_node(
        nbits: core::ffi::c_uint,
        flags: gfp_t,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_ulong;
}
extern "C" {
    pub fn bitmap_free(bitmap: *const core::ffi::c_ulong);
}
extern "C" {
    pub fn devm_bitmap_alloc(
        dev: *mut device,
        nbits: core::ffi::c_uint,
        flags: gfp_t,
    ) -> *mut core::ffi::c_ulong;
}
extern "C" {
    pub fn devm_bitmap_zalloc(
        dev: *mut device,
        nbits: core::ffi::c_uint,
        flags: gfp_t,
    ) -> *mut core::ffi::c_ulong;
}
extern "C" {
    pub fn __bitmap_equal(
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_or_equal(
        src1: *const core::ffi::c_ulong,
        src2: *const core::ffi::c_ulong,
        src3: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_complement(
        dst: *mut core::ffi::c_ulong,
        src: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_shift_right(
        dst: *mut core::ffi::c_ulong,
        src: *const core::ffi::c_ulong,
        shift: core::ffi::c_uint,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_shift_left(
        dst: *mut core::ffi::c_ulong,
        src: *const core::ffi::c_ulong,
        shift: core::ffi::c_uint,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bitmap_cut(
        dst: *mut core::ffi::c_ulong,
        src: *const core::ffi::c_ulong,
        first: core::ffi::c_uint,
        cut: core::ffi::c_uint,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_and(
        dst: *mut core::ffi::c_ulong,
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_or(
        dst: *mut core::ffi::c_ulong,
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_xor(
        dst: *mut core::ffi::c_ulong,
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_andnot(
        dst: *mut core::ffi::c_ulong,
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_replace(
        dst: *mut core::ffi::c_ulong,
        old: *const core::ffi::c_ulong,
        new: *const core::ffi::c_ulong,
        mask: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_intersects(
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_subset(
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_weight(
        bitmap: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __bitmap_weight_and(
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __bitmap_set(
        map: *mut core::ffi::c_ulong,
        start: core::ffi::c_uint,
        len: core::ffi::c_int,
    );
}
extern "C" {
    pub fn __bitmap_clear(
        map: *mut core::ffi::c_ulong,
        start: core::ffi::c_uint,
        len: core::ffi::c_int,
    );
}
extern "C" {
    pub fn bitmap_find_next_zero_area_off(
        map: *mut core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        start: core::ffi::c_ulong,
        nr: core::ffi::c_uint,
        align_mask: core::ffi::c_ulong,
        align_offset: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn bitmap_remap(
        dst: *mut core::ffi::c_ulong,
        src: *const core::ffi::c_ulong,
        old: *const core::ffi::c_ulong,
        new: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bitmap_bitremap(
        oldbit: core::ffi::c_int,
        old: *const core::ffi::c_ulong,
        new: *const core::ffi::c_ulong,
        bits: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_onto(
        dst: *mut core::ffi::c_ulong,
        orig: *const core::ffi::c_ulong,
        relmap: *const core::ffi::c_ulong,
        bits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bitmap_fold(
        dst: *mut core::ffi::c_ulong,
        orig: *const core::ffi::c_ulong,
        sz: core::ffi::c_uint,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bitmap_from_arr32(
        bitmap: *mut core::ffi::c_ulong,
        buf: *const u32_,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bitmap_to_arr32(
        buf: *mut u32_,
        bitmap: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn __xchg_wrong_size();
}
extern "C" {
    pub fn __cmpxchg_wrong_size();
}
extern "C" {
    pub fn __xadd_wrong_size();
}
extern "C" {
    pub fn __add_wrong_size();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union __u128_halves {
    pub full: u128_,
    pub __bindgen_anon_1: __u128_halves__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __u128_halves__bindgen_ty_1 {
    pub low: u64_,
    pub high: u64_,
}
impl Default for __u128_halves {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type atomic_long_t = atomic64_t;
extern "C" {
    pub fn numa_nearest_node(node: core::ffi::c_int, state: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn numa_fill_memblks(start: u64_, end: u64_) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct attribute_group {
    pub name: *const core::ffi::c_char,
    pub is_visible: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: core::ffi::c_int,
        ) -> umode_t,
    >,
    pub is_bin_visible: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut bin_attribute,
            arg3: core::ffi::c_int,
        ) -> umode_t,
    >,
    pub attrs: *mut *mut attribute,
    pub bin_attrs: *mut *mut bin_attribute,
}
impl Default for attribute_group {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static arch_node_dev_group: attribute_group;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpumask {
    pub bits: [core::ffi::c_ulong; 128usize],
}
impl Default for cpumask {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cpumask_t = cpumask;
extern "C" {
    pub static mut nr_cpu_ids: core::ffi::c_uint;
}
extern "C" {
    pub static mut __cpu_possible_mask: cpumask;
}
extern "C" {
    pub static mut __cpu_online_mask: cpumask;
}
extern "C" {
    pub static mut __cpu_present_mask: cpumask;
}
extern "C" {
    pub static mut __cpu_active_mask: cpumask;
}
extern "C" {
    pub static mut __cpu_dying_mask: cpumask;
}
extern "C" {
    pub static mut __num_online_cpus: atomic_t;
}
extern "C" {
    pub static mut cpus_booted_once_mask: cpumask_t;
}
extern "C" {
    pub fn cpumask_local_spread(i: core::ffi::c_uint, node: core::ffi::c_int) -> core::ffi::c_uint;
}
extern "C" {
    pub fn cpumask_any_and_distribute(
        src1p: *const cpumask,
        src2p: *const cpumask,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn cpumask_any_distribute(srcp: *const cpumask) -> core::ffi::c_uint;
}
extern "C" {
    pub fn cpumask_next_wrap(
        n: core::ffi::c_int,
        mask: *const cpumask,
        start: core::ffi::c_int,
        wrap: bool_,
    ) -> core::ffi::c_uint;
}
pub type cpumask_var_t = *mut cpumask;
extern "C" {
    pub fn alloc_cpumask_var_node(
        mask: *mut cpumask_var_t,
        flags: gfp_t,
        node: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn alloc_bootmem_cpumask_var(mask: *mut cpumask_var_t);
}
extern "C" {
    pub fn free_cpumask_var(mask: cpumask_var_t);
}
extern "C" {
    pub fn free_bootmem_cpumask_var(mask: cpumask_var_t);
}
extern "C" {
    pub static cpu_all_bits: [core::ffi::c_ulong; 128usize];
}
extern "C" {
    pub fn init_cpu_present(src: *const cpumask);
}
extern "C" {
    pub fn init_cpu_possible(src: *const cpumask);
}
extern "C" {
    pub fn init_cpu_online(src: *const cpumask);
}
extern "C" {
    pub fn set_cpu_online(cpu: core::ffi::c_uint, online: bool_);
}
extern "C" {
    pub static mut cpu_bit_bitmap: [[core::ffi::c_ulong; 128usize]; 65usize];
}
extern "C" {
    pub fn dummy_steal_clock(cpu: core::ffi::c_int) -> u64_;
}
extern "C" {
    pub fn dummy_sched_clock() -> u64_;
}
extern "C" {
    pub static mut __SCK__pv_steal_clock: static_call_key;
}
extern "C" {
    pub fn __SCT__pv_steal_clock(arg1: core::ffi::c_int) -> u64_;
}
extern "C" {
    pub static mut __SCK__pv_sched_clock: static_call_key;
}
extern "C" {
    pub fn __SCT__pv_sched_clock() -> u64_;
}
extern "C" {
    pub fn paravirt_set_sched_clock(func: ::core::option::Option<unsafe extern "C" fn() -> u64_>);
}
extern "C" {
    pub static mut paravirt_steal_enabled: static_key;
}
extern "C" {
    pub static mut paravirt_steal_rq_enabled: static_key;
}
extern "C" {
    pub fn __native_queued_spin_unlock(lock: *mut qspinlock);
}
extern "C" {
    pub fn pv_is_native_spin_unlock() -> bool_;
}
extern "C" {
    pub fn __native_vcpu_is_preempted(cpu: core::ffi::c_long) -> bool_;
}
extern "C" {
    pub fn pv_is_native_vcpu_is_preempted() -> bool_;
}
extern "C" {
    pub fn paravirt_set_cap();
}
extern "C" {
    pub fn native_flush_tlb_local();
}
extern "C" {
    pub fn native_flush_tlb_global();
}
extern "C" {
    pub fn native_flush_tlb_one_user(addr: core::ffi::c_ulong);
}
extern "C" {
    pub fn native_flush_tlb_multi(cpumask: *const cpumask, info: *const flush_tlb_info);
}
extern "C" {
    pub fn pv_native_wbinvd();
}
extern "C" {
    pub fn __raw_callee_save___native_queued_spin_unlock(lock: *mut qspinlock);
}
extern "C" {
    pub fn __raw_callee_save___native_vcpu_is_preempted(cpu: core::ffi::c_long) -> bool_;
}
extern "C" {
    pub fn default_banner();
}
extern "C" {
    pub fn native_pv_lock_init();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_irq_t {
    pub lock: *mut core::ffi::c_void,
}
impl Default for class_irq_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_irqsave_t {
    pub lock: *mut core::ffi::c_void,
    pub flags: core::ffi::c_ulong,
}
impl Default for class_irqsave_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pollfd {
    _unused: [u8; 0],
}
pub const timespec_type_TT_NONE: timespec_type = 0;
pub const timespec_type_TT_NATIVE: timespec_type = 1;
pub const timespec_type_TT_COMPAT: timespec_type = 2;
pub type timespec_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block {
    pub arch_data: core::ffi::c_ulong,
    pub fn_:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut restart_block) -> core::ffi::c_long>,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1 {
    pub futex: restart_block__bindgen_ty_1__bindgen_ty_1,
    pub nanosleep: restart_block__bindgen_ty_1__bindgen_ty_2,
    pub poll: restart_block__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_1 {
    pub uaddr: *mut u32_,
    pub val: u32_,
    pub flags: u32_,
    pub bitset: u32_,
    pub time: u64_,
    pub uaddr2: *mut u32_,
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_2 {
    pub clockid: clockid_t,
    pub type_: timespec_type,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub expires: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub rmtp: *mut __kernel_timespec,
    pub compat_rmtp: *mut old_timespec32,
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_3 {
    pub ufds: *mut pollfd,
    pub nfds: core::ffi::c_int,
    pub has_timeout: core::ffi::c_int,
    pub tv_sec: core::ffi::c_ulong,
    pub tv_nsec: core::ffi::c_ulong,
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for restart_block__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for restart_block {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn do_no_restart_syscall(parm: *mut restart_block) -> core::ffi::c_long;
}
pub const BAD_STACK: _bindgen_ty_5 = -1;
pub const NOT_STACK: _bindgen_ty_5 = 0;
pub const GOOD_FRAME: _bindgen_ty_5 = 1;
pub const GOOD_STACK: _bindgen_ty_5 = 2;
pub type _bindgen_ty_5 = core::ffi::c_int;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SECCOMP: syscall_work_bit = 0;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_TRACEPOINT: syscall_work_bit = 1;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_TRACE: syscall_work_bit = 2;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_EMU: syscall_work_bit = 3;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_AUDIT: syscall_work_bit = 4;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_USER_DISPATCH: syscall_work_bit = 5;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_EXIT_TRAP: syscall_work_bit = 6;
pub type syscall_work_bit = core::ffi::c_uint;
extern "C" {
    pub static mut max_pfn: core::ffi::c_ulong;
}
extern "C" {
    pub static mut phys_base: core::ffi::c_ulong;
}
extern "C" {
    pub static mut page_offset_base: core::ffi::c_ulong;
}
extern "C" {
    pub static mut vmalloc_base: core::ffi::c_ulong;
}
extern "C" {
    pub static mut vmemmap_base: core::ffi::c_ulong;
}
extern "C" {
    pub fn clear_page_orig(page: *mut core::ffi::c_void);
}
extern "C" {
    pub fn clear_page_rep(page: *mut core::ffi::c_void);
}
extern "C" {
    pub fn clear_page_erms(page: *mut core::ffi::c_void);
}
extern "C" {
    pub fn copy_page(to: *mut core::ffi::c_void, from: *mut core::ffi::c_void);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct range {
    pub start: u64_,
    pub end: u64_,
}
extern "C" {
    pub fn add_range(
        range: *mut range,
        az: core::ffi::c_int,
        nr_range: core::ffi::c_int,
        start: u64_,
        end: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn add_range_with_merge(
        range: *mut range,
        az: core::ffi::c_int,
        nr_range: core::ffi::c_int,
        start: u64_,
        end: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn subtract_range(range: *mut range, az: core::ffi::c_int, start: u64_, end: u64_);
}
extern "C" {
    pub fn clean_sort_range(range: *mut range, az: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn sort_range(range: *mut range, nr_range: core::ffi::c_int);
}
extern "C" {
    pub static mut pfn_mapped: [range; 0usize];
}
extern "C" {
    pub static mut nr_pfn_mapped: core::ffi::c_int;
}
extern "C" {
    pub fn __virt_addr_valid(kaddr: core::ffi::c_ulong) -> bool_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pfn_t {
    pub val: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_bitmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm86 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pt_regs {
    pub r15: core::ffi::c_ulong,
    pub r14: core::ffi::c_ulong,
    pub r13: core::ffi::c_ulong,
    pub r12: core::ffi::c_ulong,
    pub bp: core::ffi::c_ulong,
    pub bx: core::ffi::c_ulong,
    pub r11: core::ffi::c_ulong,
    pub r10: core::ffi::c_ulong,
    pub r9: core::ffi::c_ulong,
    pub r8: core::ffi::c_ulong,
    pub ax: core::ffi::c_ulong,
    pub cx: core::ffi::c_ulong,
    pub dx: core::ffi::c_ulong,
    pub si: core::ffi::c_ulong,
    pub di: core::ffi::c_ulong,
    pub orig_ax: core::ffi::c_ulong,
    pub ip: core::ffi::c_ulong,
    pub cs: core::ffi::c_ulong,
    pub flags: core::ffi::c_ulong,
    pub sp: core::ffi::c_ulong,
    pub ss: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct user_desc {
    pub entry_number: core::ffi::c_uint,
    pub base_addr: core::ffi::c_uint,
    pub limit: core::ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl user_desc {
    #[inline]
    pub fn seg_32bit(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_seg_32bit(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn contents(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_contents(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn read_exec_only(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_read_exec_only(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit_in_pages(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_limit_in_pages(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn seg_not_present(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_seg_not_present(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn useable(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useable(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lm(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lm(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        seg_32bit: core::ffi::c_uint,
        contents: core::ffi::c_uint,
        read_exec_only: core::ffi::c_uint,
        limit_in_pages: core::ffi::c_uint,
        seg_not_present: core::ffi::c_uint,
        useable: core::ffi::c_uint,
        lm: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let seg_32bit: u32 = unsafe { ::core::mem::transmute(seg_32bit) };
            seg_32bit as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let contents: u32 = unsafe { ::core::mem::transmute(contents) };
            contents as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let read_exec_only: u32 = unsafe { ::core::mem::transmute(read_exec_only) };
            read_exec_only as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let limit_in_pages: u32 = unsafe { ::core::mem::transmute(limit_in_pages) };
            limit_in_pages as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let seg_not_present: u32 = unsafe { ::core::mem::transmute(seg_not_present) };
            seg_not_present as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let useable: u32 = unsafe { ::core::mem::transmute(useable) };
            useable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let lm: u32 = unsafe { ::core::mem::transmute(lm) };
            lm as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn syscall_init();
}
extern "C" {
    pub fn entry_SYSCALL_64();
}
extern "C" {
    pub fn entry_SYSCALL_64_safe_stack();
}
extern "C" {
    pub fn entry_SYSRETQ_unsafe_stack();
}
extern "C" {
    pub fn entry_SYSRETQ_end();
}
extern "C" {
    pub fn do_arch_prctl_64(
        task: *mut task_struct,
        option: core::ffi::c_int,
        arg2: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn entry_SYSENTER_compat();
}
extern "C" {
    pub fn __end_entry_SYSENTER_compat();
}
extern "C" {
    pub fn entry_SYSCALL_compat();
}
extern "C" {
    pub fn entry_SYSCALL_compat_safe_stack();
}
extern "C" {
    pub fn entry_SYSRETL_compat_unsafe_stack();
}
extern "C" {
    pub fn entry_SYSRETL_compat_end();
}
extern "C" {
    pub fn x86_configure_nx();
}
extern "C" {
    pub static mut reboot_force: core::ffi::c_int;
}
extern "C" {
    pub fn do_arch_prctl_common(
        option: core::ffi::c_int,
        arg2: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn profile_pc(regs: *mut pt_regs) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn convert_ip_to_linear(child: *mut task_struct, regs: *mut pt_regs) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn send_sigtrap(
        regs: *mut pt_regs,
        error_code: core::ffi::c_int,
        si_code: core::ffi::c_int,
    );
}
extern "C" {
    pub fn regs_query_register_offset(name: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn regs_query_register_name(offset: core::ffi::c_uint) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn copy_from_kernel_nofault(
        dst: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn do_get_thread_area(
        p: *mut task_struct,
        idx: core::ffi::c_int,
        info: *mut user_desc,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_set_thread_area(
        p: *mut task_struct,
        idx: core::ffi::c_int,
        info: *mut user_desc,
        can_allocate: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct math_emu_info {
    pub ___orig_eip: core::ffi::c_long,
    pub regs: *mut pt_regs,
}
impl Default for math_emu_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __u32,
    pub extended_size: __u32,
    pub xfeatures: __u64,
    pub xstate_size: __u32,
    pub padding: [__u32; 7usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct _fpreg {
    pub significand: [__u16; 4usize],
    pub exponent: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [__u16; 4usize],
    pub exponent: __u16,
    pub padding: [__u16; 3usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _fpstate_32 {
    pub cw: __u32,
    pub sw: __u32,
    pub tag: __u32,
    pub ipoff: __u32,
    pub cssel: __u32,
    pub dataoff: __u32,
    pub datasel: __u32,
    pub _st: [_fpreg; 8usize],
    pub status: __u16,
    pub magic: __u16,
    pub _fxsr_env: [__u32; 6usize],
    pub mxcsr: __u32,
    pub reserved: __u32,
    pub _fxsr_st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 8usize],
    pub __bindgen_anon_1: _fpstate_32__bindgen_ty_1,
    pub __bindgen_anon_2: _fpstate_32__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _fpstate_32__bindgen_ty_1 {
    pub padding1: [__u32; 44usize],
    pub padding: [__u32; 44usize],
}
impl Default for _fpstate_32__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _fpstate_32__bindgen_ty_2 {
    pub padding2: [__u32; 12usize],
    pub sw_reserved: _fpx_sw_bytes,
}
impl Default for _fpstate_32__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _fpstate_32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _fpstate_64 {
    pub cwd: __u16,
    pub swd: __u16,
    pub twd: __u16,
    pub fop: __u16,
    pub rip: __u64,
    pub rdp: __u64,
    pub mxcsr: __u32,
    pub mxcsr_mask: __u32,
    pub st_space: [__u32; 32usize],
    pub xmm_space: [__u32; 64usize],
    pub reserved2: [__u32; 12usize],
    pub __bindgen_anon_1: _fpstate_64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _fpstate_64__bindgen_ty_1 {
    pub reserved3: [__u32; 12usize],
    pub sw_reserved: _fpx_sw_bytes,
}
impl Default for _fpstate_64__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _fpstate_64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct _header {
    pub xfeatures: __u64,
    pub reserved1: [__u64; 2usize],
    pub reserved2: [__u64; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__u32; 64usize],
}
impl Default for _ymmh_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate_64,
    pub xstate_hdr: _header,
    pub ymmh: _ymmh_state,
}
impl Default for _xstate {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sigcontext_32 {
    pub gs: __u16,
    pub __gsh: __u16,
    pub fs: __u16,
    pub __fsh: __u16,
    pub es: __u16,
    pub __esh: __u16,
    pub ds: __u16,
    pub __dsh: __u16,
    pub di: __u32,
    pub si: __u32,
    pub bp: __u32,
    pub sp: __u32,
    pub bx: __u32,
    pub dx: __u32,
    pub cx: __u32,
    pub ax: __u32,
    pub trapno: __u32,
    pub err: __u32,
    pub ip: __u32,
    pub cs: __u16,
    pub __csh: __u16,
    pub flags: __u32,
    pub sp_at_signal: __u32,
    pub ss: __u16,
    pub __ssh: __u16,
    pub fpstate: __u32,
    pub oldmask: __u32,
    pub cr2: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sigcontext_64 {
    pub r8: __u64,
    pub r9: __u64,
    pub r10: __u64,
    pub r11: __u64,
    pub r12: __u64,
    pub r13: __u64,
    pub r14: __u64,
    pub r15: __u64,
    pub di: __u64,
    pub si: __u64,
    pub bp: __u64,
    pub bx: __u64,
    pub dx: __u64,
    pub ax: __u64,
    pub cx: __u64,
    pub sp: __u64,
    pub ip: __u64,
    pub flags: __u64,
    pub cs: __u16,
    pub gs: __u16,
    pub fs: __u16,
    pub ss: __u16,
    pub err: __u64,
    pub trapno: __u64,
    pub oldmask: __u64,
    pub cr2: __u64,
    pub fpstate: __u64,
    pub reserved1: [__u64; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpuid_regs {
    pub eax: u32_,
    pub ebx: u32_,
    pub ecx: u32_,
    pub edx: u32_,
}
pub const cpuid_regs_idx_CPUID_EAX: cpuid_regs_idx = 0;
pub const cpuid_regs_idx_CPUID_EBX: cpuid_regs_idx = 1;
pub const cpuid_regs_idx_CPUID_ECX: cpuid_regs_idx = 2;
pub const cpuid_regs_idx_CPUID_EDX: cpuid_regs_idx = 3;
pub type cpuid_regs_idx = core::ffi::c_uint;
extern "C" {
    pub fn setup_cpu_local_masks();
}
extern "C" {
    pub static mut __invalid_size_argument_for_IOC: core::ffi::c_uint;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msr {
    pub __bindgen_anon_1: msr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msr__bindgen_ty_1 {
    pub __bindgen_anon_1: msr__bindgen_ty_1__bindgen_ty_1,
    pub q: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct msr__bindgen_ty_1__bindgen_ty_1 {
    pub l: u32_,
    pub h: u32_,
}
impl Default for msr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for msr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msr_info {
    pub msr_no: u32_,
    pub reg: msr,
    pub msrs: *mut msr,
    pub err: core::ffi::c_int,
}
impl Default for msr_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msr_regs_info {
    pub regs: *mut u32_,
    pub err: core::ffi::c_int,
}
impl Default for msr_regs_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct saved_msr {
    pub valid: bool_,
    pub info: msr_info,
}
impl Default for saved_msr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct saved_msrs {
    pub num: core::ffi::c_uint,
    pub array: *mut saved_msr,
}
impl Default for saved_msrs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_print_flags {
    pub mask: core::ffi::c_ulong,
    pub name: *const core::ffi::c_char,
}
impl Default for trace_print_flags {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_print_flags_u64 {
    pub mask: core::ffi::c_ulonglong,
    pub name: *const core::ffi::c_char,
}
impl Default for trace_print_flags_u64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tracepoint_func {
    pub func: *mut core::ffi::c_void,
    pub data: *mut core::ffi::c_void,
    pub prio: core::ffi::c_int,
}
impl Default for tracepoint_func {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tracepoint {
    pub name: *const core::ffi::c_char,
    pub key: static_key,
    pub static_call_key: *mut static_call_key,
    pub static_call_tramp: *mut core::ffi::c_void,
    pub iterator: *mut core::ffi::c_void,
    pub probestub: *mut core::ffi::c_void,
    pub regfunc: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub unregfunc: ::core::option::Option<unsafe extern "C" fn()>,
    pub funcs: *mut tracepoint_func,
}
impl Default for tracepoint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type tracepoint_ptr_t = core::ffi::c_int;
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct bpf_raw_event_map {
    pub tp: *mut tracepoint,
    pub bpf_func: *mut core::ffi::c_void,
    pub num_args: u32_,
    pub writable_size: u32_,
}
impl Default for bpf_raw_event_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut __tracepoint_read_msr: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_write_msr: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_rdpmc: tracepoint;
}
extern "C" {
    pub fn do_trace_write_msr(msr: core::ffi::c_uint, val: u64_, failed: core::ffi::c_int);
}
extern "C" {
    pub fn do_trace_read_msr(msr: core::ffi::c_uint, val: u64_, failed: core::ffi::c_int);
}
extern "C" {
    pub fn do_trace_rdpmc(msr: core::ffi::c_uint, val: u64_, failed: core::ffi::c_int);
}
extern "C" {
    pub fn rdmsr_safe_regs(regs: *mut u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn wrmsr_safe_regs(regs: *mut u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn msrs_alloc() -> *mut msr;
}
extern "C" {
    pub fn msrs_free(msrs: *mut msr);
}
extern "C" {
    pub fn msr_set_bit(msr: u32_, bit: u8_) -> core::ffi::c_int;
}
extern "C" {
    pub fn msr_clear_bit(msr: u32_, bit: u8_) -> core::ffi::c_int;
}
extern "C" {
    pub fn rdmsr_on_cpu(
        cpu: core::ffi::c_uint,
        msr_no: u32_,
        l: *mut u32_,
        h: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn wrmsr_on_cpu(cpu: core::ffi::c_uint, msr_no: u32_, l: u32_, h: u32_)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn rdmsrl_on_cpu(cpu: core::ffi::c_uint, msr_no: u32_, q: *mut u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn wrmsrl_on_cpu(cpu: core::ffi::c_uint, msr_no: u32_, q: u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn rdmsr_on_cpus(mask: *const cpumask, msr_no: u32_, msrs: *mut msr);
}
extern "C" {
    pub fn wrmsr_on_cpus(mask: *const cpumask, msr_no: u32_, msrs: *mut msr);
}
extern "C" {
    pub fn rdmsr_safe_on_cpu(
        cpu: core::ffi::c_uint,
        msr_no: u32_,
        l: *mut u32_,
        h: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn wrmsr_safe_on_cpu(
        cpu: core::ffi::c_uint,
        msr_no: u32_,
        l: u32_,
        h: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rdmsrl_safe_on_cpu(
        cpu: core::ffi::c_uint,
        msr_no: u32_,
        q: *mut u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn wrmsrl_safe_on_cpu(cpu: core::ffi::c_uint, msr_no: u32_, q: u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn rdmsr_safe_regs_on_cpu(cpu: core::ffi::c_uint, regs: *mut u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn wrmsr_safe_regs_on_cpu(cpu: core::ffi::c_uint, regs: *mut u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn native_write_cr0(val: core::ffi::c_ulong);
}
extern "C" {
    pub fn native_write_cr4(val: core::ffi::c_ulong);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fregs_state {
    pub cwd: u32_,
    pub swd: u32_,
    pub twd: u32_,
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
    pub st_space: [u32_; 20usize],
    pub status: u32_,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct fxregs_state {
    pub cwd: u16_,
    pub swd: u16_,
    pub twd: u16_,
    pub fop: u16_,
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1,
    pub mxcsr: u32_,
    pub mxcsr_mask: u32_,
    pub st_space: [u32_; 32usize],
    pub xmm_space: [u32_; 64usize],
    pub padding: [u32_; 12usize],
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_1 {
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_1 {
    pub rip: u64_,
    pub rdp: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_2 {
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
}
impl Default for fxregs_state__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_2 {
    pub padding1: [u32_; 12usize],
    pub sw_reserved: [u32_; 12usize],
}
impl Default for fxregs_state__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for fxregs_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swregs_state {
    pub cwd: u32_,
    pub swd: u32_,
    pub twd: u32_,
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
    pub st_space: [u32_; 20usize],
    pub ftop: u8_,
    pub changed: u8_,
    pub lookahead: u8_,
    pub no_update: u8_,
    pub rm: u8_,
    pub alimit: u8_,
    pub info: *mut math_emu_info,
    pub entry_eip: u32_,
}
impl Default for swregs_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const xfeature_XFEATURE_FP: xfeature = 0;
pub const xfeature_XFEATURE_SSE: xfeature = 1;
pub const xfeature_XFEATURE_YMM: xfeature = 2;
pub const xfeature_XFEATURE_BNDREGS: xfeature = 3;
pub const xfeature_XFEATURE_BNDCSR: xfeature = 4;
pub const xfeature_XFEATURE_OPMASK: xfeature = 5;
pub const xfeature_XFEATURE_ZMM_Hi256: xfeature = 6;
pub const xfeature_XFEATURE_Hi16_ZMM: xfeature = 7;
pub const xfeature_XFEATURE_PT_UNIMPLEMENTED_SO_FAR: xfeature = 8;
pub const xfeature_XFEATURE_PKRU: xfeature = 9;
pub const xfeature_XFEATURE_PASID: xfeature = 10;
pub const xfeature_XFEATURE_CET_USER: xfeature = 11;
pub const xfeature_XFEATURE_CET_KERNEL_UNUSED: xfeature = 12;
pub const xfeature_XFEATURE_RSRVD_COMP_13: xfeature = 13;
pub const xfeature_XFEATURE_RSRVD_COMP_14: xfeature = 14;
pub const xfeature_XFEATURE_LBR: xfeature = 15;
pub const xfeature_XFEATURE_RSRVD_COMP_16: xfeature = 16;
pub const xfeature_XFEATURE_XTILE_CFG: xfeature = 17;
pub const xfeature_XFEATURE_XTILE_DATA: xfeature = 18;
pub const xfeature_XFEATURE_MAX: xfeature = 19;
pub type xfeature = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct reg_128_bit {
    pub regbytes: [u8_; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct reg_256_bit {
    pub regbytes: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct reg_512_bit {
    pub regbytes: [u8_; 64usize],
}
impl Default for reg_512_bit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct reg_1024_byte {
    pub regbytes: [u8_; 1024usize],
}
impl Default for reg_1024_byte {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct ymmh_struct {
    pub hi_ymm: [reg_128_bit; 16usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct mpx_bndreg {
    pub lower_bound: u64_,
    pub upper_bound: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct mpx_bndreg_state {
    pub bndreg: [mpx_bndreg; 4usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct mpx_bndcsr {
    pub bndcfgu: u64_,
    pub bndstatus: u64_,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mpx_bndcsr_state {
    pub __bindgen_anon_1: mpx_bndcsr_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mpx_bndcsr_state__bindgen_ty_1 {
    pub bndcsr: mpx_bndcsr,
    pub pad_to_64_bytes: [u8_; 64usize],
}
impl Default for mpx_bndcsr_state__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mpx_bndcsr_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct avx_512_opmask_state {
    pub opmask_reg: [u64_; 8usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct avx_512_zmm_uppers_state {
    pub zmm_upper: [reg_256_bit; 16usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct avx_512_hi16_state {
    pub hi16_zmm: [reg_512_bit; 16usize],
}
impl Default for avx_512_hi16_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct pkru_state {
    pub pkru: u32_,
    pub pad: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cet_user_state {
    pub user_cet: u64_,
    pub user_ssp: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lbr_entry {
    pub from: u64_,
    pub to: u64_,
    pub info: u64_,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Default, Copy, Clone)]
pub struct arch_lbr_state {
    pub _bindgen_opaque_blob: [u64; 5usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct xtile_cfg {
    pub tcfg: [u64_; 8usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct xtile_data {
    pub tmm: reg_1024_byte,
}
impl Default for xtile_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct ia32_pasid_state {
    pub pasid: u64_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct xstate_header {
    pub xfeatures: u64_,
    pub xcomp_bv: u64_,
    pub reserved: [u64_; 6usize],
}
#[repr(C)]
#[repr(align(64))]
pub struct xregs_state {
    pub _bindgen_opaque_blob: [u8; 576usize],
}
impl Default for xregs_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct fpregs_state {
    pub fsave: __BindgenUnionField<fregs_state>,
    pub fxsave: __BindgenUnionField<fxregs_state>,
    pub soft: __BindgenUnionField<swregs_state>,
    pub xsave: __BindgenUnionField<xregs_state>,
    pub __padding: __BindgenUnionField<[u8_; 4096usize]>,
    pub bindgen_union_field: [u8; 4096usize],
}
impl Default for fpregs_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct fpstate {
    pub size: core::ffi::c_uint,
    pub user_size: core::ffi::c_uint,
    pub xfeatures: u64_,
    pub user_xfeatures: u64_,
    pub xfd: u64_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u64; 3usize],
    pub regs: fpregs_state,
}
impl Default for fpstate {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl fpstate {
    #[inline]
    pub fn is_valloc(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_valloc(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_guest(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_guest(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_confidential(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_confidential(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_use(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_use(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_valloc: core::ffi::c_uint,
        is_guest: core::ffi::c_uint,
        is_confidential: core::ffi::c_uint,
        in_use: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_valloc: u32 = unsafe { ::core::mem::transmute(is_valloc) };
            is_valloc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_guest: u32 = unsafe { ::core::mem::transmute(is_guest) };
            is_guest as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_confidential: u32 = unsafe { ::core::mem::transmute(is_confidential) };
            is_confidential as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let in_use: u32 = unsafe { ::core::mem::transmute(in_use) };
            in_use as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fpu_state_perm {
    pub __state_perm: u64_,
    pub __state_size: core::ffi::c_uint,
    pub __user_state_size: core::ffi::c_uint,
}
#[repr(C)]
#[repr(align(64))]
pub struct fpu {
    pub last_cpu: core::ffi::c_uint,
    pub avx512_timestamp: core::ffi::c_ulong,
    pub fpstate: *mut fpstate,
    pub __task_fpstate: *mut fpstate,
    pub perm: fpu_state_perm,
    pub guest_perm: fpu_state_perm,
    pub __fpstate: fpstate,
}
impl Default for fpu {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fpu_guest {
    pub xfeatures: u64_,
    pub perm: u64_,
    pub xfd_err: u64_,
    pub uabi_size: core::ffi::c_uint,
    pub fpstate: *mut fpstate,
}
impl Default for fpu_guest {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fpu_state_config {
    pub max_size: core::ffi::c_uint,
    pub default_size: core::ffi::c_uint,
    pub max_features: u64_,
    pub default_features: u64_,
    pub legacy_features: u64_,
}
extern "C" {
    pub static mut fpu_kernel_cfg: fpu_state_config;
}
extern "C" {
    pub static mut fpu_user_cfg: fpu_state_config;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct getcpu_cache {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __vdso_getcpu(
        cpu: *mut core::ffi::c_uint,
        node: *mut core::ffi::c_uint,
        unused: *mut getcpu_cache,
    ) -> core::ffi::c_long;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct thread_shstk {
    pub base: u64_,
    pub size: u64_,
}
extern "C" {
    pub fn shstk_prctl(
        task: *mut task_struct,
        option: core::ffi::c_int,
        arg2: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn reset_thread_features();
}
extern "C" {
    pub fn shstk_alloc_thread_stack(
        p: *mut task_struct,
        clone_flags: core::ffi::c_ulong,
        stack_size: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn shstk_free(p: *mut task_struct);
}
extern "C" {
    pub fn setup_signal_shadow_stack(ksig: *mut ksignal) -> core::ffi::c_int;
}
extern "C" {
    pub fn restore_signal_shadow_stack() -> core::ffi::c_int;
}
pub const UNAME26: _bindgen_ty_6 = 131072;
pub const ADDR_NO_RANDOMIZE: _bindgen_ty_6 = 262144;
pub const FDPIC_FUNCPTRS: _bindgen_ty_6 = 524288;
pub const MMAP_PAGE_ZERO: _bindgen_ty_6 = 1048576;
pub const ADDR_COMPAT_LAYOUT: _bindgen_ty_6 = 2097152;
pub const READ_IMPLIES_EXEC: _bindgen_ty_6 = 4194304;
pub const ADDR_LIMIT_32BIT: _bindgen_ty_6 = 8388608;
pub const SHORT_INODE: _bindgen_ty_6 = 16777216;
pub const WHOLE_SECONDS: _bindgen_ty_6 = 33554432;
pub const STICKY_TIMEOUTS: _bindgen_ty_6 = 67108864;
pub const ADDR_LIMIT_3GB: _bindgen_ty_6 = 134217728;
pub type _bindgen_ty_6 = core::ffi::c_uint;
pub const PER_LINUX: _bindgen_ty_7 = 0;
pub const PER_LINUX_32BIT: _bindgen_ty_7 = 8388608;
pub const PER_LINUX_FDPIC: _bindgen_ty_7 = 524288;
pub const PER_SVR4: _bindgen_ty_7 = 68157441;
pub const PER_SVR3: _bindgen_ty_7 = 83886082;
pub const PER_SCOSVR3: _bindgen_ty_7 = 117440515;
pub const PER_OSR5: _bindgen_ty_7 = 100663299;
pub const PER_WYSEV386: _bindgen_ty_7 = 83886084;
pub const PER_ISCR4: _bindgen_ty_7 = 67108869;
pub const PER_BSD: _bindgen_ty_7 = 6;
pub const PER_SUNOS: _bindgen_ty_7 = 67108870;
pub const PER_XENIX: _bindgen_ty_7 = 83886087;
pub const PER_LINUX32: _bindgen_ty_7 = 8;
pub const PER_LINUX32_3GB: _bindgen_ty_7 = 134217736;
pub const PER_IRIX32: _bindgen_ty_7 = 67108873;
pub const PER_IRIXN32: _bindgen_ty_7 = 67108874;
pub const PER_IRIX64: _bindgen_ty_7 = 67108875;
pub const PER_RISCOS: _bindgen_ty_7 = 12;
pub const PER_SOLARIS: _bindgen_ty_7 = 67108877;
pub const PER_UW7: _bindgen_ty_7 = 68157454;
pub const PER_OSF4: _bindgen_ty_7 = 15;
pub const PER_HPUX: _bindgen_ty_7 = 16;
pub const PER_MASK: _bindgen_ty_7 = 255;
pub type _bindgen_ty_7 = core::ffi::c_uint;
extern "C" {
    pub fn iter_div_u64_rem(dividend: u64_, divisor: u32_, remainder: *mut u64_) -> u32_;
}
pub const tlb_infos_ENTRIES: tlb_infos = 0;
pub const tlb_infos_NR_INFO: tlb_infos = 1;
pub type tlb_infos = core::ffi::c_uint;
extern "C" {
    pub static mut tlb_lli_4k: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lli_2m: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lli_4m: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lld_4k: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lld_2m: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lld_4m: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lld_1g: [u16_; 1usize];
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpuinfo_topology {
    pub apicid: u32_,
    pub initial_apicid: u32_,
    pub pkg_id: u32_,
    pub die_id: u32_,
    pub cu_id: u32_,
    pub core_id: u32_,
    pub logical_pkg_id: u32_,
    pub logical_die_id: u32_,
    pub llc_id: u32_,
    pub l2c_id: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpuinfo_x86 {
    pub x86: __u8,
    pub x86_vendor: __u8,
    pub x86_model: __u8,
    pub x86_stepping: __u8,
    pub x86_tlbsize: core::ffi::c_int,
    pub vmx_capability: [__u32; 5usize],
    pub x86_virt_bits: __u8,
    pub x86_phys_bits: __u8,
    pub x86_coreid_bits: __u8,
    pub extended_cpuid_level: __u32,
    pub cpuid_level: core::ffi::c_int,
    pub __bindgen_anon_1: cpuinfo_x86__bindgen_ty_1,
    pub x86_vendor_id: [core::ffi::c_char; 16usize],
    pub x86_model_id: [core::ffi::c_char; 64usize],
    pub topo: cpuinfo_topology,
    pub x86_cache_size: core::ffi::c_uint,
    pub x86_cache_alignment: core::ffi::c_int,
    pub x86_cache_max_rmid: core::ffi::c_int,
    pub x86_cache_occ_scale: core::ffi::c_int,
    pub x86_cache_mbm_width_offset: core::ffi::c_int,
    pub x86_power: core::ffi::c_int,
    pub loops_per_jiffy: core::ffi::c_ulong,
    pub ppin: u64_,
    pub x86_max_cores: u16_,
    pub x86_clflush_size: u16_,
    pub booted_cores: u16_,
    pub cpu_index: u16_,
    pub smt_active: bool_,
    pub microcode: u32_,
    pub x86_cache_bits: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpuinfo_x86__bindgen_ty_1 {
    pub x86_capability: [__u32; 24usize],
    pub x86_capability_alignment: core::ffi::c_ulong,
}
impl Default for cpuinfo_x86__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cpuinfo_x86 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl cpuinfo_x86 {
    #[inline]
    pub fn initialized(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(initialized: core::ffi::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let initialized: u32 = unsafe { ::core::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static mut boot_cpu_data: cpuinfo_x86;
}
extern "C" {
    pub static mut new_cpu_data: cpuinfo_x86;
}
extern "C" {
    pub static mut cpu_caps_cleared: [__u32; 24usize];
}
extern "C" {
    pub static mut cpu_caps_set: [__u32; 24usize];
}
extern "C" {
    pub static mut cpu_info: cpuinfo_x86;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seq_operations {
    _unused: [u8; 0],
}
extern "C" {
    pub static cpuinfo_op: seq_operations;
}
extern "C" {
    pub fn cpu_detect(c: *mut cpuinfo_x86);
}
extern "C" {
    pub fn early_cpu_init();
}
extern "C" {
    pub fn identify_secondary_cpu(arg1: *mut cpuinfo_x86);
}
extern "C" {
    pub fn print_cpu_info(arg1: *mut cpuinfo_x86);
}
extern "C" {
    pub fn print_cpu_msr(arg1: *mut cpuinfo_x86);
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct x86_hw_tss {
    pub reserved1: u32_,
    pub sp0: u64_,
    pub sp1: u64_,
    pub sp2: u64_,
    pub reserved2: u64_,
    pub ist: [u64_; 7usize],
    pub reserved3: u32_,
    pub reserved4: u32_,
    pub reserved5: u16_,
    pub io_bitmap_base: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct entry_stack {
    pub stack: [core::ffi::c_char; 4096usize],
}
impl Default for entry_stack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4096))]
#[derive(Copy, Clone)]
pub struct entry_stack_page {
    pub stack: entry_stack,
}
impl Default for entry_stack_page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_io_bitmap {
    pub prev_sequence: u64_,
    pub prev_max: core::ffi::c_uint,
    pub bitmap: [core::ffi::c_ulong; 1025usize],
    pub mapall: [core::ffi::c_ulong; 1025usize],
}
impl Default for x86_io_bitmap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4096))]
#[derive(Copy, Clone)]
pub struct tss_struct {
    pub x86_tss: x86_hw_tss,
    pub io_bitmap: x86_io_bitmap,
}
impl Default for tss_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut cpu_tss_rw: tss_struct;
}
#[repr(C)]
#[repr(align(16384))]
#[derive(Copy, Clone)]
pub struct irq_stack {
    pub stack: [core::ffi::c_char; 16384usize],
}
impl Default for irq_stack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fixed_percpu_data {
    pub gs_base: [core::ffi::c_char; 40usize],
    pub stack_canary: core::ffi::c_ulong,
}
impl Default for fixed_percpu_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut fixed_percpu_data: fixed_percpu_data;
}
extern "C" {
    pub static mut init_per_cpu__fixed_percpu_data: fixed_percpu_data;
}
extern "C" {
    pub fn entry_SYSCALL32_ignore();
}
extern "C" {
    pub fn current_save_fsgs();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
pub struct thread_struct {
    pub tls_array: [desc_struct; 3usize],
    pub sp: core::ffi::c_ulong,
    pub es: core::ffi::c_ushort,
    pub ds: core::ffi::c_ushort,
    pub fsindex: core::ffi::c_ushort,
    pub gsindex: core::ffi::c_ushort,
    pub fsbase: core::ffi::c_ulong,
    pub gsbase: core::ffi::c_ulong,
    pub ptrace_bps: [*mut perf_event; 4usize],
    pub virtual_dr6: core::ffi::c_ulong,
    pub ptrace_dr7: core::ffi::c_ulong,
    pub cr2: core::ffi::c_ulong,
    pub trap_nr: core::ffi::c_ulong,
    pub error_code: core::ffi::c_ulong,
    pub io_bitmap: *mut io_bitmap,
    pub iopl_emul: core::ffi::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub pkru: u32_,
    pub features: core::ffi::c_ulong,
    pub features_locked: core::ffi::c_ulong,
    pub shstk: thread_shstk,
    pub __bindgen_padding_0: u64,
    pub fpu: fpu,
}
impl Default for thread_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl thread_struct {
    #[inline]
    pub fn iopl_warn(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_iopl_warn(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(iopl_warn: core::ffi::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let iopl_warn: u32 = unsafe { ::core::mem::transmute(iopl_warn) };
            iopl_warn as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn fpu_thread_struct_whitelist(
        offset: *mut core::ffi::c_ulong,
        size: *mut core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn __get_wchan(p: *mut task_struct) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn select_idle_routine(c: *const cpuinfo_x86);
}
extern "C" {
    pub fn amd_e400_c1e_apic_setup();
}
extern "C" {
    pub static mut boot_option_idle_override: core::ffi::c_ulong;
}
pub const idle_boot_override_IDLE_NO_OVERRIDE: idle_boot_override = 0;
pub const idle_boot_override_IDLE_HALT: idle_boot_override = 1;
pub const idle_boot_override_IDLE_NOMWAIT: idle_boot_override = 2;
pub const idle_boot_override_IDLE_POLL: idle_boot_override = 3;
pub type idle_boot_override = core::ffi::c_uint;
extern "C" {
    pub fn enable_sep_cpu();
}
extern "C" {
    pub static mut early_gdt_descr: desc_ptr;
}
extern "C" {
    pub fn switch_gdt_and_percpu_base(arg1: core::ffi::c_int);
}
extern "C" {
    pub fn load_direct_gdt(arg1: core::ffi::c_int);
}
extern "C" {
    pub fn load_fixmap_gdt(arg1: core::ffi::c_int);
}
extern "C" {
    pub fn cpu_init();
}
extern "C" {
    pub fn cpu_init_exception_handling();
}
extern "C" {
    pub fn cr4_init();
}
extern "C" {
    pub fn set_task_blockstep(task: *mut task_struct, on: bool_);
}
extern "C" {
    pub static mut bootloader_type: core::ffi::c_int;
}
extern "C" {
    pub static mut bootloader_version: core::ffi::c_int;
}
extern "C" {
    pub static mut ignore_fpu_irq: core::ffi::c_char;
}
extern "C" {
    pub static mut __end_init_task: [core::ffi::c_ulong; 0usize];
}
extern "C" {
    pub fn KSTK_ESP(task: *mut task_struct) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn start_thread(regs: *mut pt_regs, new_ip: core::ffi::c_ulong, new_sp: core::ffi::c_ulong);
}
extern "C" {
    pub fn get_tsc_mode(adr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_tsc_mode(val: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub static mut msr_misc_features_shadow: core::ffi::c_ulonglong;
}
extern "C" {
    pub fn amd_get_nodes_per_socket() -> u32_;
}
extern "C" {
    pub fn amd_get_highest_perf() -> u32_;
}
extern "C" {
    pub fn amd_clear_divider();
}
extern "C" {
    pub fn amd_check_microcode();
}
extern "C" {
    pub fn arch_align_stack(sp: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn free_init_pages(
        what: *const core::ffi::c_char,
        begin: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn free_kernel_image_pages(
        what: *const core::ffi::c_char,
        begin: *mut core::ffi::c_void,
        end: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn default_idle();
}
extern "C" {
    pub fn xen_set_default_idle() -> bool_;
}
extern "C" {
    pub fn stop_this_cpu(dummy: *mut core::ffi::c_void) -> !;
}
extern "C" {
    pub fn microcode_check(prev_info: *mut cpuinfo_x86);
}
extern "C" {
    pub fn store_cpu_caps(info: *mut cpuinfo_x86);
}
pub const l1tf_mitigations_L1TF_MITIGATION_OFF: l1tf_mitigations = 0;
pub const l1tf_mitigations_L1TF_MITIGATION_FLUSH_NOWARN: l1tf_mitigations = 1;
pub const l1tf_mitigations_L1TF_MITIGATION_FLUSH: l1tf_mitigations = 2;
pub const l1tf_mitigations_L1TF_MITIGATION_FLUSH_NOSMT: l1tf_mitigations = 3;
pub const l1tf_mitigations_L1TF_MITIGATION_FULL: l1tf_mitigations = 4;
pub const l1tf_mitigations_L1TF_MITIGATION_FULL_FORCE: l1tf_mitigations = 5;
pub type l1tf_mitigations = core::ffi::c_uint;
extern "C" {
    pub static mut l1tf_mitigation: l1tf_mitigations;
}
pub const mds_mitigations_MDS_MITIGATION_OFF: mds_mitigations = 0;
pub const mds_mitigations_MDS_MITIGATION_FULL: mds_mitigations = 1;
pub const mds_mitigations_MDS_MITIGATION_VMWERV: mds_mitigations = 2;
pub type mds_mitigations = core::ffi::c_uint;
extern "C" {
    pub fn gds_ucode_mitigated() -> bool_;
}
pub const cpuid_leafs_CPUID_1_EDX: cpuid_leafs = 0;
pub const cpuid_leafs_CPUID_8000_0001_EDX: cpuid_leafs = 1;
pub const cpuid_leafs_CPUID_8086_0001_EDX: cpuid_leafs = 2;
pub const cpuid_leafs_CPUID_LNX_1: cpuid_leafs = 3;
pub const cpuid_leafs_CPUID_1_ECX: cpuid_leafs = 4;
pub const cpuid_leafs_CPUID_C000_0001_EDX: cpuid_leafs = 5;
pub const cpuid_leafs_CPUID_8000_0001_ECX: cpuid_leafs = 6;
pub const cpuid_leafs_CPUID_LNX_2: cpuid_leafs = 7;
pub const cpuid_leafs_CPUID_LNX_3: cpuid_leafs = 8;
pub const cpuid_leafs_CPUID_7_0_EBX: cpuid_leafs = 9;
pub const cpuid_leafs_CPUID_D_1_EAX: cpuid_leafs = 10;
pub const cpuid_leafs_CPUID_LNX_4: cpuid_leafs = 11;
pub const cpuid_leafs_CPUID_7_1_EAX: cpuid_leafs = 12;
pub const cpuid_leafs_CPUID_8000_0008_EBX: cpuid_leafs = 13;
pub const cpuid_leafs_CPUID_6_EAX: cpuid_leafs = 14;
pub const cpuid_leafs_CPUID_8000_000A_EDX: cpuid_leafs = 15;
pub const cpuid_leafs_CPUID_7_ECX: cpuid_leafs = 16;
pub const cpuid_leafs_CPUID_8000_0007_EBX: cpuid_leafs = 17;
pub const cpuid_leafs_CPUID_7_EDX: cpuid_leafs = 18;
pub const cpuid_leafs_CPUID_8000_001F_EAX: cpuid_leafs = 19;
pub const cpuid_leafs_CPUID_8000_0021_EAX: cpuid_leafs = 20;
pub const cpuid_leafs_CPUID_LNX_5: cpuid_leafs = 21;
pub const cpuid_leafs_NR_CPUID_WORDS: cpuid_leafs = 22;
pub type cpuid_leafs = core::ffi::c_uint;
extern "C" {
    pub static x86_cap_flags: [*const core::ffi::c_char; 704usize];
}
extern "C" {
    pub static x86_power_flags: [*const core::ffi::c_char; 32usize];
}
extern "C" {
    pub static x86_bug_flags: [*const core::ffi::c_char; 64usize];
}
extern "C" {
    pub fn setup_clear_cpu_cap(bit: core::ffi::c_uint);
}
extern "C" {
    pub fn clear_cpu_cap(c: *mut cpuinfo_x86, bit: core::ffi::c_uint);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct thread_info {
    pub flags: core::ffi::c_ulong,
    pub syscall_work: core::ffi::c_ulong,
    pub status: u32_,
    pub cpu: u32_,
}
extern "C" {
    pub fn arch_setup_new_exec();
}
extern "C" {
    pub fn __check_object_size(
        ptr: *const core::ffi::c_void,
        n: core::ffi::c_ulong,
        to_user: bool_,
    );
}
extern "C" {
    pub fn __bad_copy_from();
}
extern "C" {
    pub fn __bad_copy_to();
}
extern "C" {
    pub fn __copy_overflow(size: core::ffi::c_int, count: core::ffi::c_ulong);
}
extern "C" {
    pub fn arch_task_cache_init();
}
extern "C" {
    pub fn arch_release_task_struct(tsk: *mut task_struct);
}
extern "C" {
    pub fn arch_dup_task_struct(dst: *mut task_struct, src: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn _local_bh_enable();
}
extern "C" {
    pub fn __local_bh_enable_ip(ip: core::ffi::c_ulong, cnt: core::ffi::c_uint);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct llist_head {
    pub first: *mut llist_node,
}
impl Default for llist_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct llist_node {
    pub next: *mut llist_node,
}
impl Default for llist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn llist_add_batch(
        new_first: *mut llist_node,
        new_last: *mut llist_node,
        head: *mut llist_head,
    ) -> bool_;
}
extern "C" {
    pub fn llist_del_first(head: *mut llist_head) -> *mut llist_node;
}
extern "C" {
    pub fn llist_del_first_this(head: *mut llist_head, this: *mut llist_node) -> bool_;
}
extern "C" {
    pub fn llist_reverse_order(head: *mut llist_node) -> *mut llist_node;
}
pub const CSD_FLAG_LOCK: _bindgen_ty_8 = 1;
pub const IRQ_WORK_PENDING: _bindgen_ty_8 = 1;
pub const IRQ_WORK_BUSY: _bindgen_ty_8 = 2;
pub const IRQ_WORK_LAZY: _bindgen_ty_8 = 4;
pub const IRQ_WORK_HARD_IRQ: _bindgen_ty_8 = 8;
pub const IRQ_WORK_CLAIMED: _bindgen_ty_8 = 3;
pub const CSD_TYPE_ASYNC: _bindgen_ty_8 = 0;
pub const CSD_TYPE_SYNC: _bindgen_ty_8 = 16;
pub const CSD_TYPE_IRQ_WORK: _bindgen_ty_8 = 32;
pub const CSD_TYPE_TTWU: _bindgen_ty_8 = 48;
pub const CSD_FLAG_TYPE_MASK: _bindgen_ty_8 = 240;
pub type _bindgen_ty_8 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_node {
    pub llist: llist_node,
    pub __bindgen_anon_1: __call_single_node__bindgen_ty_1,
    pub src: u16_,
    pub dst: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __call_single_node__bindgen_ty_1 {
    pub u_flags: core::ffi::c_uint,
    pub a_flags: atomic_t,
}
impl Default for __call_single_node__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __call_single_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type smp_call_func_t =
    ::core::option::Option<unsafe extern "C" fn(info: *mut core::ffi::c_void)>;
pub type smp_cond_func_t = ::core::option::Option<
    unsafe extern "C" fn(cpu: core::ffi::c_int, info: *mut core::ffi::c_void) -> bool_,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_data {
    pub node: __call_single_node,
    pub func: smp_call_func_t,
    pub info: *mut core::ffi::c_void,
}
impl Default for __call_single_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type call_single_data_t = __call_single_data;
extern "C" {
    pub fn __smp_call_single_queue(cpu: core::ffi::c_int, node: *mut llist_node);
}
extern "C" {
    pub static mut total_cpus: core::ffi::c_uint;
}
extern "C" {
    pub fn smp_call_function_single(
        cpuid: core::ffi::c_int,
        func: smp_call_func_t,
        info: *mut core::ffi::c_void,
        wait: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn on_each_cpu_cond_mask(
        cond_func: smp_cond_func_t,
        func: smp_call_func_t,
        info: *mut core::ffi::c_void,
        wait: bool_,
        mask: *const cpumask,
    );
}
extern "C" {
    pub fn smp_call_function_single_async(
        cpu: core::ffi::c_int,
        csd: *mut call_single_data_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn panic_smp_self_stop() -> !;
}
extern "C" {
    pub fn nmi_panic_self_stop(regs: *mut pt_regs) -> !;
}
extern "C" {
    pub fn crash_smp_send_stop();
}
extern "C" {
    pub static mut smp_num_siblings: core::ffi::c_int;
}
extern "C" {
    pub static mut num_processors: core::ffi::c_uint;
}
extern "C" {
    pub static mut cpu_sibling_map: *mut cpumask;
}
extern "C" {
    pub static mut cpu_core_map: *mut cpumask;
}
extern "C" {
    pub static mut cpu_die_map: *mut cpumask;
}
extern "C" {
    pub static mut cpu_llc_shared_map: *mut cpumask;
}
extern "C" {
    pub static mut cpu_l2c_shared_map: *mut cpumask;
}
extern "C" {
    pub static mut x86_cpu_to_apicid: core::ffi::c_uint;
}
extern "C" {
    pub static mut x86_cpu_to_apicid_early_ptr: *mut core::ffi::c_uint;
}
extern "C" {
    pub static mut x86_cpu_to_apicid_early_map: [core::ffi::c_uint; 0usize];
}
extern "C" {
    pub static mut x86_cpu_to_acpiid: core::ffi::c_uint;
}
extern "C" {
    pub static mut x86_cpu_to_acpiid_early_ptr: *mut core::ffi::c_uint;
}
extern "C" {
    pub static mut x86_cpu_to_acpiid_early_map: [core::ffi::c_uint; 0usize];
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct smp_ops {
    pub smp_prepare_boot_cpu: ::core::option::Option<unsafe extern "C" fn()>,
    pub smp_prepare_cpus: ::core::option::Option<unsafe extern "C" fn(max_cpus: core::ffi::c_uint)>,
    pub smp_cpus_done: ::core::option::Option<unsafe extern "C" fn(max_cpus: core::ffi::c_uint)>,
    pub stop_other_cpus: ::core::option::Option<unsafe extern "C" fn(wait: core::ffi::c_int)>,
    pub crash_stop_other_cpus: ::core::option::Option<unsafe extern "C" fn()>,
    pub smp_send_reschedule: ::core::option::Option<unsafe extern "C" fn(cpu: core::ffi::c_int)>,
    pub cleanup_dead_cpu: ::core::option::Option<unsafe extern "C" fn(cpu: core::ffi::c_uint)>,
    pub poll_sync_state: ::core::option::Option<unsafe extern "C" fn()>,
    pub kick_ap_alive: ::core::option::Option<
        unsafe extern "C" fn(cpu: core::ffi::c_uint, tidle: *mut task_struct) -> core::ffi::c_int,
    >,
    pub cpu_disable: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub cpu_die: ::core::option::Option<unsafe extern "C" fn(cpu: core::ffi::c_uint)>,
    pub play_dead: ::core::option::Option<unsafe extern "C" fn()>,
    pub send_call_func_ipi: ::core::option::Option<unsafe extern "C" fn(mask: *const cpumask)>,
    pub send_call_func_single_ipi:
        ::core::option::Option<unsafe extern "C" fn(cpu: core::ffi::c_int)>,
}
extern "C" {
    pub fn set_cpu_sibling_map(cpu: core::ffi::c_int);
}
extern "C" {
    pub static mut smp_ops: smp_ops;
}
extern "C" {
    pub fn cpu_disable_common();
}
extern "C" {
    pub fn native_smp_prepare_boot_cpu();
}
extern "C" {
    pub fn smp_prepare_cpus_common();
}
extern "C" {
    pub fn native_smp_prepare_cpus(max_cpus: core::ffi::c_uint);
}
extern "C" {
    pub fn calculate_max_logical_packages();
}
extern "C" {
    pub fn native_smp_cpus_done(max_cpus: core::ffi::c_uint);
}
extern "C" {
    pub fn common_cpu_up(cpunum: core::ffi::c_uint, tidle: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn native_kick_ap(cpu: core::ffi::c_uint, tidle: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn native_cpu_disable() -> core::ffi::c_int;
}
extern "C" {
    pub fn hlt_play_dead() -> !;
}
extern "C" {
    pub fn native_play_dead();
}
extern "C" {
    pub fn play_dead_common();
}
extern "C" {
    pub fn wbinvd_on_cpu(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn wbinvd_on_all_cpus() -> core::ffi::c_int;
}
extern "C" {
    pub fn smp_kick_mwait_play_dead();
}
extern "C" {
    pub fn native_smp_send_reschedule(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn native_send_call_func_ipi(mask: *const cpumask);
}
extern "C" {
    pub fn native_send_call_func_single_ipi(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn smp_store_cpu_info(id: core::ffi::c_int);
}
extern "C" {
    pub fn smp_reboot_interrupt();
}
extern "C" {
    pub fn smp_reschedule_interrupt(regs: *mut pt_regs);
}
extern "C" {
    pub fn smp_call_function_interrupt(regs: *mut pt_regs);
}
extern "C" {
    pub fn smp_call_function_single_interrupt(r: *mut pt_regs);
}
extern "C" {
    pub static mut disabled_cpus: core::ffi::c_uint;
}
extern "C" {
    pub static mut smpboot_control: core::ffi::c_uint;
}
extern "C" {
    pub static mut apic_mmio_base: core::ffi::c_ulong;
}
extern "C" {
    pub fn __cpu_up(cpunum: core::ffi::c_uint, tidle: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn smp_call_function(
        func: smp_call_func_t,
        info: *mut core::ffi::c_void,
        wait: core::ffi::c_int,
    );
}
extern "C" {
    pub fn smp_call_function_many(
        mask: *const cpumask,
        func: smp_call_func_t,
        info: *mut core::ffi::c_void,
        wait: bool_,
    );
}
extern "C" {
    pub fn smp_call_function_any(
        mask: *const cpumask,
        func: smp_call_func_t,
        info: *mut core::ffi::c_void,
        wait: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kick_all_cpus_sync();
}
extern "C" {
    pub fn wake_up_all_idle_cpus();
}
extern "C" {
    pub fn call_function_init();
}
extern "C" {
    pub fn generic_smp_call_function_single_interrupt();
}
extern "C" {
    pub static mut setup_max_cpus: core::ffi::c_uint;
}
extern "C" {
    pub fn setup_nr_cpu_ids();
}
extern "C" {
    pub fn smp_init();
}
extern "C" {
    pub static mut __boot_cpu_id: core::ffi::c_int;
}
extern "C" {
    pub fn arch_disable_smp_support();
}
extern "C" {
    pub fn arch_thaw_secondary_cpus_begin();
}
extern "C" {
    pub fn arch_thaw_secondary_cpus_end();
}
extern "C" {
    pub fn smp_setup_processor_id();
}
extern "C" {
    pub fn smp_call_on_cpu(
        cpu: core::ffi::c_uint,
        func: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> core::ffi::c_int,
        >,
        par: *mut core::ffi::c_void,
        phys: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn smpcfd_prepare_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn smpcfd_dead_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn smpcfd_dying_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn lock_is_held(arg1: *const core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn lockdep_is_held(arg1: *const core::ffi::c_void) -> core::ffi::c_int;
}
pub const xhlock_context_t_XHLOCK_HARD: xhlock_context_t = 0;
pub const xhlock_context_t_XHLOCK_SOFT: xhlock_context_t = 1;
pub const xhlock_context_t_XHLOCK_CTX_NR: xhlock_context_t = 2;
pub type xhlock_context_t = core::ffi::c_uint;
#[repr(C)]
#[repr(align(4))]
#[derive(Default, Copy, Clone)]
pub struct spinlock {
    pub _bindgen_opaque_blob: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spinlock__bindgen_ty_1 {
    pub rlock: raw_spinlock,
}
impl Default for spinlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type spinlock_t = spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rwlock_t {
    pub raw_lock: arch_rwlock_t,
}
impl Default for rwlock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn native_queued_spin_lock_slowpath(lock: *mut qspinlock, val: u32_);
}
extern "C" {
    pub fn __pv_init_lock_hash();
}
extern "C" {
    pub fn __pv_queued_spin_lock_slowpath(lock: *mut qspinlock, val: u32_);
}
extern "C" {
    pub fn __raw_callee_save___pv_queued_spin_unlock(lock: *mut qspinlock);
}
extern "C" {
    pub static mut nopvspin: bool_;
}
extern "C" {
    pub static mut virt_spin_lock_key: static_key_true;
}
extern "C" {
    pub fn queued_read_lock_slowpath(lock: *mut qrwlock);
}
extern "C" {
    pub fn queued_write_lock_slowpath(lock: *mut qrwlock);
}
extern "C" {
    pub fn in_lock_functions(addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn _raw_spin_lock(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_nested(lock: *mut raw_spinlock_t, subclass: core::ffi::c_int);
}
extern "C" {
    pub fn _raw_spin_lock_nest_lock(lock: *mut raw_spinlock_t, map: *mut lockdep_map);
}
extern "C" {
    pub fn _raw_spin_lock_bh(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_irq(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_irqsave(lock: *mut raw_spinlock_t) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _raw_spin_lock_irqsave_nested(
        lock: *mut raw_spinlock_t,
        subclass: core::ffi::c_int,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _raw_spin_trylock(lock: *mut raw_spinlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn _raw_spin_trylock_bh(lock: *mut raw_spinlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn _raw_spin_unlock(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_bh(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_irq(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_irqrestore(lock: *mut raw_spinlock_t, flags: core::ffi::c_ulong);
}
extern "C" {
    pub fn _raw_read_lock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock_nested(lock: *mut rwlock_t, subclass: core::ffi::c_int);
}
extern "C" {
    pub fn _raw_read_lock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_lock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_lock_irqsave(lock: *mut rwlock_t) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _raw_write_lock_irqsave(lock: *mut rwlock_t) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _raw_read_trylock(lock: *mut rwlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn _raw_write_trylock(lock: *mut rwlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn _raw_read_unlock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_irqrestore(lock: *mut rwlock_t, flags: core::ffi::c_ulong);
}
extern "C" {
    pub fn _raw_write_unlock_irqrestore(lock: *mut rwlock_t, flags: core::ffi::c_ulong);
}
extern "C" {
    pub fn _atomic_dec_and_lock(atomic: *mut atomic_t, lock: *mut spinlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn _atomic_dec_and_lock_irqsave(
        atomic: *mut atomic_t,
        lock: *mut spinlock_t,
        flags: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn _atomic_dec_and_raw_lock(
        atomic: *mut atomic_t,
        lock: *mut raw_spinlock_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn _atomic_dec_and_raw_lock_irqsave(
        atomic: *mut atomic_t,
        lock: *mut raw_spinlock_t,
        flags: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __alloc_bucket_spinlocks(
        locks: *mut *mut spinlock_t,
        lock_mask: *mut core::ffi::c_uint,
        max_size: usize,
        cpu_mult: core::ffi::c_uint,
        gfp: gfp_t,
        name: *const core::ffi::c_char,
        key: *mut lock_class_key,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn free_bucket_spinlocks(locks: *mut spinlock_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_raw_spinlock_t {
    pub lock: *mut raw_spinlock_t,
}
impl Default for class_raw_spinlock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type class_raw_spinlock_try_t = class_raw_spinlock_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_raw_spinlock_nested_t {
    pub lock: *mut raw_spinlock_t,
}
impl Default for class_raw_spinlock_nested_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_raw_spinlock_irq_t {
    pub lock: *mut raw_spinlock_t,
}
impl Default for class_raw_spinlock_irq_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type class_raw_spinlock_irq_try_t = class_raw_spinlock_irq_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_raw_spinlock_irqsave_t {
    pub lock: *mut raw_spinlock_t,
    pub flags: core::ffi::c_ulong,
}
impl Default for class_raw_spinlock_irqsave_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type class_raw_spinlock_irqsave_try_t = class_raw_spinlock_irqsave_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_spinlock_t {
    pub lock: *mut spinlock_t,
}
impl Default for class_spinlock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type class_spinlock_try_t = class_spinlock_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_spinlock_irq_t {
    pub lock: *mut spinlock_t,
}
impl Default for class_spinlock_irq_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type class_spinlock_irq_try_t = class_spinlock_irq_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_spinlock_irqsave_t {
    pub lock: *mut spinlock_t,
    pub flags: core::ffi::c_ulong,
}
impl Default for class_spinlock_irqsave_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type class_spinlock_irqsave_try_t = class_spinlock_irqsave_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_read_lock_t {
    pub lock: *mut rwlock_t,
}
impl Default for class_read_lock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_read_lock_irq_t {
    pub lock: *mut rwlock_t,
}
impl Default for class_read_lock_irq_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_read_lock_irqsave_t {
    pub lock: *mut rwlock_t,
    pub flags: core::ffi::c_ulong,
}
impl Default for class_read_lock_irqsave_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_write_lock_t {
    pub lock: *mut rwlock_t,
}
impl Default for class_write_lock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_write_lock_irq_t {
    pub lock: *mut rwlock_t,
}
impl Default for class_write_lock_irq_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_write_lock_irqsave_t {
    pub lock: *mut rwlock_t,
    pub flags: core::ffi::c_ulong,
}
impl Default for class_write_lock_irqsave_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct refcount_struct {
    pub refs: atomic_t,
}
pub type refcount_t = refcount_struct;
pub const refcount_saturation_type_REFCOUNT_ADD_NOT_ZERO_OVF: refcount_saturation_type = 0;
pub const refcount_saturation_type_REFCOUNT_ADD_OVF: refcount_saturation_type = 1;
pub const refcount_saturation_type_REFCOUNT_ADD_UAF: refcount_saturation_type = 2;
pub const refcount_saturation_type_REFCOUNT_SUB_UAF: refcount_saturation_type = 3;
pub const refcount_saturation_type_REFCOUNT_DEC_LEAK: refcount_saturation_type = 4;
pub type refcount_saturation_type = core::ffi::c_uint;
extern "C" {
    pub fn refcount_warn_saturate(r: *mut refcount_t, t: refcount_saturation_type);
}
extern "C" {
    pub fn refcount_dec_if_one(r: *mut refcount_t) -> bool_;
}
extern "C" {
    pub fn refcount_dec_not_one(r: *mut refcount_t) -> bool_;
}
extern "C" {
    pub fn refcount_dec_and_mutex_lock(r: *mut refcount_t, lock: *mut mutex) -> bool_;
}
extern "C" {
    pub fn refcount_dec_and_lock(r: *mut refcount_t, lock: *mut spinlock_t) -> bool_;
}
extern "C" {
    pub fn refcount_dec_and_lock_irqsave(
        r: *mut refcount_t,
        lock: *mut spinlock_t,
        flags: *mut core::ffi::c_ulong,
    ) -> bool_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kref {
    pub refcount: refcount_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct stat {
    pub st_dev: __kernel_ulong_t,
    pub st_ino: __kernel_ulong_t,
    pub st_nlink: __kernel_ulong_t,
    pub st_mode: core::ffi::c_uint,
    pub st_uid: core::ffi::c_uint,
    pub st_gid: core::ffi::c_uint,
    pub __pad0: core::ffi::c_uint,
    pub st_rdev: __kernel_ulong_t,
    pub st_size: __kernel_long_t,
    pub st_blksize: __kernel_long_t,
    pub st_blocks: __kernel_long_t,
    pub st_atime: __kernel_ulong_t,
    pub st_atime_nsec: __kernel_ulong_t,
    pub st_mtime: __kernel_ulong_t,
    pub st_mtime_nsec: __kernel_ulong_t,
    pub st_ctime: __kernel_ulong_t,
    pub st_ctime_nsec: __kernel_ulong_t,
    pub __unused: [__kernel_long_t; 3usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __old_kernel_stat {
    pub st_dev: core::ffi::c_ushort,
    pub st_ino: core::ffi::c_ushort,
    pub st_mode: core::ffi::c_ushort,
    pub st_nlink: core::ffi::c_ushort,
    pub st_uid: core::ffi::c_ushort,
    pub st_gid: core::ffi::c_ushort,
    pub st_rdev: core::ffi::c_ushort,
    pub st_size: core::ffi::c_uint,
    pub st_atime: core::ffi::c_uint,
    pub st_mtime: core::ffi::c_uint,
    pub st_ctime: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct statx_timestamp {
    pub tv_sec: __s64,
    pub tv_nsec: __u32,
    pub __reserved: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct statx {
    pub stx_mask: __u32,
    pub stx_blksize: __u32,
    pub stx_attributes: __u64,
    pub stx_nlink: __u32,
    pub stx_uid: __u32,
    pub stx_gid: __u32,
    pub stx_mode: __u16,
    pub __spare0: [__u16; 1usize],
    pub stx_ino: __u64,
    pub stx_size: __u64,
    pub stx_blocks: __u64,
    pub stx_attributes_mask: __u64,
    pub stx_atime: statx_timestamp,
    pub stx_btime: statx_timestamp,
    pub stx_ctime: statx_timestamp,
    pub stx_mtime: statx_timestamp,
    pub stx_rdev_major: __u32,
    pub stx_rdev_minor: __u32,
    pub stx_dev_major: __u32,
    pub stx_dev_minor: __u32,
    pub stx_mnt_id: __u64,
    pub stx_dio_mem_align: __u32,
    pub stx_dio_offset_align: __u32,
    pub __spare3: [__u64; 12usize],
}
pub type time64_t = __s64;
pub type timeu64_t = __u64;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_timespec {
    pub tv_sec: __kernel_time64_t,
    pub tv_nsec: core::ffi::c_longlong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_itimerspec {
    pub it_interval: __kernel_timespec,
    pub it_value: __kernel_timespec,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_old_timeval {
    pub tv_sec: __kernel_long_t,
    pub tv_usec: __kernel_long_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_old_timespec {
    pub tv_sec: __kernel_old_time_t,
    pub tv_nsec: core::ffi::c_long,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_old_itimerval {
    pub it_interval: __kernel_old_timeval,
    pub it_value: __kernel_old_timeval,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_sock_timeval {
    pub tv_sec: __s64,
    pub tv_usec: __s64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: core::ffi::c_int,
    pub tz_dsttime: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct timespec64 {
    pub tv_sec: time64_t,
    pub tv_nsec: core::ffi::c_long,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct itimerspec64 {
    pub it_interval: timespec64,
    pub it_value: timespec64,
}
extern "C" {
    pub fn set_normalized_timespec64(ts: *mut timespec64, sec: time64_t, nsec: s64);
}
extern "C" {
    pub fn ns_to_timespec64(nsec: s64) -> timespec64;
}
extern "C" {
    pub fn timespec64_add_safe(lhs: timespec64, rhs: timespec64) -> timespec64;
}
extern "C" {
    pub static mut sys_tz: timezone;
}
extern "C" {
    pub fn get_timespec64(ts: *mut timespec64, uts: *const __kernel_timespec) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_timespec64(ts: *const timespec64, uts: *mut __kernel_timespec) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_itimerspec64(
        it: *mut itimerspec64,
        uit: *const __kernel_itimerspec,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_itimerspec64(
        it: *const itimerspec64,
        uit: *mut __kernel_itimerspec,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mktime64(
        year: core::ffi::c_uint,
        mon: core::ffi::c_uint,
        day: core::ffi::c_uint,
        hour: core::ffi::c_uint,
        min: core::ffi::c_uint,
        sec: core::ffi::c_uint,
    ) -> time64_t;
}
extern "C" {
    pub fn clear_itimer();
}
extern "C" {
    pub fn do_utimes(
        dfd: core::ffi::c_int,
        filename: *const core::ffi::c_char,
        times: *mut timespec64,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm {
    pub tm_sec: core::ffi::c_int,
    pub tm_min: core::ffi::c_int,
    pub tm_hour: core::ffi::c_int,
    pub tm_mday: core::ffi::c_int,
    pub tm_mon: core::ffi::c_int,
    pub tm_year: core::ffi::c_long,
    pub tm_wday: core::ffi::c_int,
    pub tm_yday: core::ffi::c_int,
}
extern "C" {
    pub fn time64_to_tm(totalsecs: time64_t, offset: core::ffi::c_int, result: *mut tm);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_timex_timeval {
    pub tv_sec: __kernel_time64_t,
    pub tv_usec: core::ffi::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_timex {
    pub modes: core::ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub offset: core::ffi::c_longlong,
    pub freq: core::ffi::c_longlong,
    pub maxerror: core::ffi::c_longlong,
    pub esterror: core::ffi::c_longlong,
    pub status: core::ffi::c_int,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub constant: core::ffi::c_longlong,
    pub precision: core::ffi::c_longlong,
    pub tolerance: core::ffi::c_longlong,
    pub time: __kernel_timex_timeval,
    pub tick: core::ffi::c_longlong,
    pub ppsfreq: core::ffi::c_longlong,
    pub jitter: core::ffi::c_longlong,
    pub shift: core::ffi::c_int,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub stabil: core::ffi::c_longlong,
    pub jitcnt: core::ffi::c_longlong,
    pub calcnt: core::ffi::c_longlong,
    pub errcnt: core::ffi::c_longlong,
    pub stbcnt: core::ffi::c_longlong,
    pub tai: core::ffi::c_int,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 44usize]>,
}
impl Default for __kernel_timex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl __kernel_timex {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_3() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn random_get_entropy_fallback() -> core::ffi::c_ulong;
}
pub type cycles_t = core::ffi::c_ulonglong;
extern "C" {
    pub static mut cpu_khz: core::ffi::c_uint;
}
extern "C" {
    pub static mut tsc_khz: core::ffi::c_uint;
}
extern "C" {
    pub fn disable_TSC();
}
extern "C" {
    pub fn convert_art_to_tsc(art: u64_) -> system_counterval_t;
}
extern "C" {
    pub fn convert_art_ns_to_tsc(art_ns: u64_) -> system_counterval_t;
}
extern "C" {
    pub fn tsc_early_init();
}
extern "C" {
    pub fn tsc_init();
}
extern "C" {
    pub fn mark_tsc_unstable(reason: *mut core::ffi::c_char);
}
extern "C" {
    pub fn unsynchronized_tsc() -> core::ffi::c_int;
}
extern "C" {
    pub fn check_tsc_unstable() -> core::ffi::c_int;
}
extern "C" {
    pub fn mark_tsc_async_resets(reason: *mut core::ffi::c_char);
}
extern "C" {
    pub fn native_calibrate_cpu_early() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn native_calibrate_tsc() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn native_sched_clock_from_tsc(tsc: u64_) -> core::ffi::c_ulonglong;
}
extern "C" {
    pub static mut tsc_clocksource_reliable: core::ffi::c_int;
}
extern "C" {
    pub static mut tsc_async_resets: bool_;
}
extern "C" {
    pub fn tsc_store_and_check_tsc_adjust(bootcpu: bool_) -> bool_;
}
extern "C" {
    pub fn tsc_verify_tsc_adjust(resume: bool_);
}
extern "C" {
    pub fn check_tsc_sync_target();
}
extern "C" {
    pub fn notsc_setup(arg1: *mut core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn tsc_save_sched_clock_state();
}
extern "C" {
    pub fn tsc_restore_sched_clock_state();
}
extern "C" {
    pub fn cpu_khz_from_msr() -> core::ffi::c_ulong;
}
extern "C" {
    pub static mut tick_usec: core::ffi::c_ulong;
}
extern "C" {
    pub static mut tick_nsec: core::ffi::c_ulong;
}
extern "C" {
    pub fn do_adjtimex(arg1: *mut __kernel_timex) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_clock_adjtime(which_clock: clockid_t, ktx: *mut __kernel_timex) -> core::ffi::c_int;
}
extern "C" {
    pub fn hardpps(arg1: *const timespec64, arg2: *const timespec64);
}
extern "C" {
    pub fn read_current_timer(timer_val: *mut core::ffi::c_ulong) -> core::ffi::c_int;
}
pub type old_time32_t = s32;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct old_timespec32 {
    pub tv_sec: old_time32_t,
    pub tv_nsec: s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct old_timeval32 {
    pub tv_sec: old_time32_t,
    pub tv_usec: s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct old_itimerspec32 {
    pub it_interval: old_timespec32,
    pub it_value: old_timespec32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct old_utimbuf32 {
    pub actime: old_time32_t,
    pub modtime: old_time32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct old_timex32 {
    pub modes: u32_,
    pub offset: s32,
    pub freq: s32,
    pub maxerror: s32,
    pub esterror: s32,
    pub status: s32,
    pub constant: s32,
    pub precision: s32,
    pub tolerance: s32,
    pub time: old_timeval32,
    pub tick: s32,
    pub ppsfreq: s32,
    pub jitter: s32,
    pub shift: s32,
    pub stabil: s32,
    pub jitcnt: s32,
    pub calcnt: s32,
    pub errcnt: s32,
    pub stbcnt: s32,
    pub tai: s32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 44usize]>,
}
impl Default for old_timex32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn get_old_timespec32(
        arg1: *mut timespec64,
        arg2: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_old_timespec32(
        arg1: *const timespec64,
        arg2: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_old_itimerspec32(
        its: *mut itimerspec64,
        uits: *const old_itimerspec32,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_old_itimerspec32(
        its: *const itimerspec64,
        uits: *mut old_itimerspec32,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_old_timex32(arg1: *mut __kernel_timex, arg2: *const old_timex32)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn put_old_timex32(arg1: *mut old_timex32, arg2: *const __kernel_timex)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn ns_to_kernel_old_timeval(nsec: s64) -> __kernel_old_timeval;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct timens_offset {
    pub sec: s64,
    pub nsec: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kuid_t {
    pub val: uid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kgid_t {
    pub val: gid_t,
}
extern "C" {
    pub static mut overflowuid: core::ffi::c_int;
}
extern "C" {
    pub static mut overflowgid: core::ffi::c_int;
}
extern "C" {
    pub fn __bad_uid();
}
extern "C" {
    pub fn __bad_gid();
}
extern "C" {
    pub static mut fs_overflowuid: core::ffi::c_int;
}
extern "C" {
    pub static mut fs_overflowgid: core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_namespace {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut init_user_ns: user_namespace;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uid_gid_map {
    _unused: [u8; 0],
}
extern "C" {
    pub fn make_kuid(from: *mut user_namespace, uid: uid_t) -> kuid_t;
}
extern "C" {
    pub fn make_kgid(from: *mut user_namespace, gid: gid_t) -> kgid_t;
}
extern "C" {
    pub fn from_kuid(to: *mut user_namespace, uid: kuid_t) -> uid_t;
}
extern "C" {
    pub fn from_kgid(to: *mut user_namespace, gid: kgid_t) -> gid_t;
}
extern "C" {
    pub fn from_kuid_munged(to: *mut user_namespace, uid: kuid_t) -> uid_t;
}
extern "C" {
    pub fn from_kgid_munged(to: *mut user_namespace, gid: kgid_t) -> gid_t;
}
extern "C" {
    pub fn map_id_down(map: *mut uid_gid_map, id: u32_) -> u32_;
}
extern "C" {
    pub fn map_id_up(map: *mut uid_gid_map, id: u32_) -> u32_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kstat {
    pub result_mask: u32_,
    pub mode: umode_t,
    pub nlink: core::ffi::c_uint,
    pub blksize: u32,
    pub attributes: u64_,
    pub attributes_mask: u64_,
    pub ino: u64_,
    pub dev: dev_t,
    pub rdev: dev_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub size: loff_t,
    pub atime: timespec64,
    pub mtime: timespec64,
    pub ctime: timespec64,
    pub btime: timespec64,
    pub blocks: u64_,
    pub mnt_id: u64_,
    pub dio_mem_align: u32_,
    pub dio_offset_align: u32_,
    pub change_cookie: u64_,
}
extern "C" {
    pub fn build_id_parse(
        vma: *mut vm_area_struct,
        build_id: *mut core::ffi::c_uchar,
        size: *mut __u32,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn build_id_parse_buf(
        buf: *const core::ffi::c_void,
        build_id: *mut core::ffi::c_uchar,
        buf_size: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut vmlinux_build_id: [core::ffi::c_uchar; 20usize];
}
extern "C" {
    pub fn init_vmlinux_build_id();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_nulls_head {
    pub first: *mut hlist_nulls_node,
}
impl Default for hlist_nulls_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_nulls_node {
    pub next: *mut hlist_nulls_node,
    pub pprev: *mut *mut hlist_nulls_node,
}
impl Default for hlist_nulls_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type wait_queue_entry_t = wait_queue_entry;
pub type wait_queue_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        wq_entry: *mut wait_queue_entry,
        mode: core::ffi::c_uint,
        flags: core::ffi::c_int,
        key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
extern "C" {
    pub fn default_wake_function(
        wq_entry: *mut wait_queue_entry,
        mode: core::ffi::c_uint,
        flags: core::ffi::c_int,
        key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_queue_entry {
    pub flags: core::ffi::c_uint,
    pub private: *mut core::ffi::c_void,
    pub func: wait_queue_func_t,
    pub entry: list_head,
}
impl Default for wait_queue_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_queue_head {
    pub lock: spinlock_t,
    pub head: list_head,
}
impl Default for wait_queue_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type wait_queue_head_t = wait_queue_head;
extern "C" {
    pub fn __init_waitqueue_head(
        wq_head: *mut wait_queue_head,
        name: *const core::ffi::c_char,
        arg1: *mut lock_class_key,
    );
}
extern "C" {
    pub fn add_wait_queue(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn add_wait_queue_exclusive(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn add_wait_queue_priority(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn remove_wait_queue(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn __wake_up(
        wq_head: *mut wait_queue_head,
        mode: core::ffi::c_uint,
        nr: core::ffi::c_int,
        key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wake_up_on_current_cpu(
        wq_head: *mut wait_queue_head,
        mode: core::ffi::c_uint,
        key: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn __wake_up_locked_key(
        wq_head: *mut wait_queue_head,
        mode: core::ffi::c_uint,
        key: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn __wake_up_sync_key(
        wq_head: *mut wait_queue_head,
        mode: core::ffi::c_uint,
        key: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn __wake_up_locked_sync_key(
        wq_head: *mut wait_queue_head,
        mode: core::ffi::c_uint,
        key: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn __wake_up_locked(
        wq_head: *mut wait_queue_head,
        mode: core::ffi::c_uint,
        nr: core::ffi::c_int,
    );
}
extern "C" {
    pub fn __wake_up_sync(wq_head: *mut wait_queue_head, mode: core::ffi::c_uint);
}
extern "C" {
    pub fn __wake_up_pollfree(wq_head: *mut wait_queue_head);
}
extern "C" {
    pub fn init_wait_entry(wq_entry: *mut wait_queue_entry, flags: core::ffi::c_int);
}
extern "C" {
    pub fn do_wait_intr(
        arg1: *mut wait_queue_head_t,
        arg2: *mut wait_queue_entry_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_wait_intr_irq(
        arg1: *mut wait_queue_head_t,
        arg2: *mut wait_queue_entry_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn prepare_to_wait(
        wq_head: *mut wait_queue_head,
        wq_entry: *mut wait_queue_entry,
        state: core::ffi::c_int,
    );
}
extern "C" {
    pub fn prepare_to_wait_exclusive(
        wq_head: *mut wait_queue_head,
        wq_entry: *mut wait_queue_entry,
        state: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn prepare_to_wait_event(
        wq_head: *mut wait_queue_head,
        wq_entry: *mut wait_queue_entry,
        state: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn finish_wait(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn wait_woken(
        wq_entry: *mut wait_queue_entry,
        mode: core::ffi::c_uint,
        timeout: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn woken_wake_function(
        wq_entry: *mut wait_queue_entry,
        mode: core::ffi::c_uint,
        sync: core::ffi::c_int,
        key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn autoremove_wake_function(
        wq_entry: *mut wait_queue_entry,
        mode: core::ffi::c_uint,
        sync: core::ffi::c_int,
        key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
pub type task_call_f = ::core::option::Option<
    unsafe extern "C" fn(p: *mut task_struct, arg: *mut core::ffi::c_void) -> core::ffi::c_int,
>;
extern "C" {
    pub fn task_call_func(
        p: *mut task_struct,
        func: task_call_f,
        arg: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct optimistic_spin_queue {
    pub tail: atomic_t,
}
extern "C" {
    pub fn osq_lock(lock: *mut optimistic_spin_queue) -> bool_;
}
extern "C" {
    pub fn osq_unlock(lock: *mut optimistic_spin_queue);
}
extern "C" {
    pub static mut debug_locks: core::ffi::c_int;
}
extern "C" {
    pub static mut debug_locks_silent: core::ffi::c_int;
}
extern "C" {
    pub fn debug_locks_off() -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mutex {
    pub owner: atomic_long_t,
    pub wait_lock: raw_spinlock_t,
    pub osq: optimistic_spin_queue,
    pub wait_list: list_head,
}
impl Default for mutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __mutex_init(lock: *mut mutex, name: *const core::ffi::c_char, key: *mut lock_class_key);
}
extern "C" {
    pub fn mutex_is_locked(lock: *mut mutex) -> bool_;
}
extern "C" {
    pub fn mutex_lock(lock: *mut mutex);
}
extern "C" {
    pub fn mutex_lock_interruptible(lock: *mut mutex) -> core::ffi::c_int;
}
extern "C" {
    pub fn mutex_lock_killable(lock: *mut mutex) -> core::ffi::c_int;
}
extern "C" {
    pub fn mutex_lock_io(lock: *mut mutex);
}
extern "C" {
    pub fn mutex_trylock(lock: *mut mutex) -> core::ffi::c_int;
}
extern "C" {
    pub fn mutex_unlock(lock: *mut mutex);
}
extern "C" {
    pub fn atomic_dec_and_mutex_lock(cnt: *mut atomic_t, lock: *mut mutex) -> core::ffi::c_int;
}
pub type class_mutex_t = *mut mutex;
pub type class_mutex_try_t = class_mutex_t;
pub type class_mutex_intr_t = class_mutex_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount {
    pub sequence: core::ffi::c_uint,
}
pub type seqcount_t = seqcount;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_raw_spinlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_raw_spinlock_t = seqcount_raw_spinlock;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_spinlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_spinlock_t = seqcount_spinlock;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_rwlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_rwlock_t = seqcount_rwlock;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_mutex {
    pub seqcount: seqcount_t,
}
pub type seqcount_mutex_t = seqcount_mutex;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqlock_t {
    pub seqcount: seqcount_spinlock_t,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_latch_t {
    pub seqcount: seqcount_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nodemask_t {
    pub bits: [core::ffi::c_ulong; 16usize],
}
extern "C" {
    pub static mut nr_irqs: core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_desc {
    _unused: [u8; 0],
}
extern "C" {
    pub fn irq_to_desc(irq: core::ffi::c_uint) -> *mut irq_desc;
}
extern "C" {
    pub fn irq_get_next_irq(offset: core::ffi::c_uint) -> core::ffi::c_uint;
}
#[repr(C)]
#[derive(Default)]
pub struct rand_pool_info {
    pub entropy_count: core::ffi::c_int,
    pub buf_size: core::ffi::c_int,
    pub buf: __IncompleteArrayField<__u32>,
}
extern "C" {
    pub fn add_device_randomness(buf: *const core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn add_bootloader_randomness(buf: *const core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn add_input_randomness(
        type_: core::ffi::c_uint,
        code: core::ffi::c_uint,
        value: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn add_interrupt_randomness(irq: core::ffi::c_int);
}
extern "C" {
    pub fn add_hwgenerator_randomness(
        buf: *const core::ffi::c_void,
        len: usize,
        entropy: usize,
        sleep_after: bool_,
    );
}
extern "C" {
    pub fn add_vmfork_randomness(unique_vm_id: *const core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn register_random_vmfork_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_random_vmfork_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_random_bytes(buf: *mut core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn get_random_u8() -> u8_;
}
extern "C" {
    pub fn get_random_u16() -> u16_;
}
extern "C" {
    pub fn get_random_u32() -> u32_;
}
extern "C" {
    pub fn get_random_u64() -> u64_;
}
extern "C" {
    pub fn __get_random_u32_below(ceil: u32_) -> u32_;
}
extern "C" {
    pub fn random_init_early(command_line: *const core::ffi::c_char);
}
extern "C" {
    pub fn random_init();
}
extern "C" {
    pub fn rng_is_initialized() -> bool_;
}
extern "C" {
    pub fn wait_for_random_bytes() -> core::ffi::c_int;
}
extern "C" {
    pub fn execute_with_initialized_rng(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn __do_once_start(done: *mut bool_, flags: *mut core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn __do_once_done(
        done: *mut bool_,
        once_key: *mut static_key_true,
        flags: *mut core::ffi::c_ulong,
        mod_: *mut module,
    );
}
extern "C" {
    pub fn __do_once_sleepable_start(done: *mut bool_) -> bool_;
}
extern "C" {
    pub fn __do_once_sleepable_done(
        done: *mut bool_,
        once_key: *mut static_key_true,
        mod_: *mut module,
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rnd_state {
    pub s1: __u32,
    pub s2: __u32,
    pub s3: __u32,
    pub s4: __u32,
}
extern "C" {
    pub fn prandom_u32_state(state: *mut rnd_state) -> u32_;
}
extern "C" {
    pub fn prandom_bytes_state(state: *mut rnd_state, buf: *mut core::ffi::c_void, nbytes: usize);
}
extern "C" {
    pub fn prandom_seed_full_state(pcpu_state: *mut rnd_state);
}
extern "C" {
    pub fn random_prepare_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn random_online_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub static mut _unused_nodemask_arg_: nodemask_t;
}
pub const node_states_N_POSSIBLE: node_states = 0;
pub const node_states_N_ONLINE: node_states = 1;
pub const node_states_N_NORMAL_MEMORY: node_states = 2;
pub const node_states_N_HIGH_MEMORY: node_states = 2;
pub const node_states_N_MEMORY: node_states = 3;
pub const node_states_N_CPU: node_states = 4;
pub const node_states_N_GENERIC_INITIATOR: node_states = 5;
pub const node_states_NR_NODE_STATES: node_states = 6;
pub type node_states = core::ffi::c_uint;
extern "C" {
    pub static mut node_states: [nodemask_t; 6usize];
}
extern "C" {
    pub static mut nr_node_ids: core::ffi::c_uint;
}
extern "C" {
    pub static mut nr_online_nodes: core::ffi::c_uint;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nodemask_scratch {
    pub mask1: nodemask_t,
    pub mask2: nodemask_t,
}
pub const pageblock_bits_PB_migrate: pageblock_bits = 0;
pub const pageblock_bits_PB_migrate_end: pageblock_bits = 2;
pub const pageblock_bits_PB_migrate_skip: pageblock_bits = 3;
pub const pageblock_bits_NR_PAGEBLOCK_BITS: pageblock_bits = 4;
pub type pageblock_bits = core::ffi::c_uint;
extern "C" {
    pub fn get_pfnblock_flags_mask(
        page: *const page,
        pfn: core::ffi::c_ulong,
        mask: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn set_pfnblock_flags_mask(
        page: *mut page,
        flags: core::ffi::c_ulong,
        pfn: core::ffi::c_ulong,
        mask: core::ffi::c_ulong,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_tlbflush_unmap_batch {
    pub cpumask: cpumask,
}
impl Default for arch_tlbflush_unmap_batch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const MM_FILEPAGES: _bindgen_ty_9 = 0;
pub const MM_ANONPAGES: _bindgen_ty_9 = 1;
pub const MM_SWAPENTS: _bindgen_ty_9 = 2;
pub const MM_SHMEMPAGES: _bindgen_ty_9 = 3;
pub const NR_MM_COUNTERS: _bindgen_ty_9 = 4;
pub type _bindgen_ty_9 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page_frag {
    pub page: *mut page,
    pub offset: __u32,
    pub size: __u32,
}
impl Default for page_frag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tlbflush_unmap_batch {
    pub arch: arch_tlbflush_unmap_batch,
    pub flush_required: bool_,
    pub writable: bool_,
}
impl Default for tlbflush_unmap_batch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_node {
    pub __rb_parent_color: core::ffi::c_ulong,
    pub rb_right: *mut rb_node,
    pub rb_left: *mut rb_node,
}
impl Default for rb_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_root {
    pub rb_node: *mut rb_node,
}
impl Default for rb_root {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_root_cached {
    pub rb_root: rb_root,
    pub rb_leftmost: *mut rb_node,
}
impl Default for rb_root_cached {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn ct_irq_enter();
}
extern "C" {
    pub fn ct_irq_exit();
}
extern "C" {
    pub fn ct_irq_enter_irqson();
}
extern "C" {
    pub fn ct_irq_exit_irqson();
}
extern "C" {
    pub fn ct_nmi_enter();
}
extern "C" {
    pub fn ct_nmi_exit();
}
extern "C" {
    pub fn call_rcu(head: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn rcu_barrier_tasks();
}
extern "C" {
    pub fn rcu_barrier_tasks_rude();
}
extern "C" {
    pub fn synchronize_rcu();
}
extern "C" {
    pub fn get_completed_synchronize_rcu() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn get_completed_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn __rcu_read_lock();
}
extern "C" {
    pub fn __rcu_read_unlock();
}
extern "C" {
    pub fn call_rcu_hurry(head: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn rcu_init();
}
extern "C" {
    pub static mut rcu_scheduler_active: core::ffi::c_int;
}
extern "C" {
    pub fn rcu_sched_clock_irq(user: core::ffi::c_int);
}
extern "C" {
    pub fn rcu_init_tasks_generic();
}
extern "C" {
    pub fn rcu_sysrq_start();
}
extern "C" {
    pub fn rcu_sysrq_end();
}
extern "C" {
    pub fn rcu_init_nohz();
}
extern "C" {
    pub fn rcu_nocb_cpu_offload(cpu: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn rcu_nocb_cpu_deoffload(cpu: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn rcu_nocb_flush_deferred_wakeup();
}
extern "C" {
    pub fn call_rcu_tasks(head: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn synchronize_rcu_tasks();
}
extern "C" {
    pub fn rcu_trc_cmpxchg_need_qs(t: *mut task_struct, old: u8_, new: u8_) -> u8_;
}
extern "C" {
    pub fn rcu_tasks_trace_qs_blkd(t: *mut task_struct);
}
extern "C" {
    pub fn call_rcu_tasks_rude(head: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn synchronize_rcu_tasks_rude();
}
extern "C" {
    pub fn exit_tasks_rcu_start();
}
extern "C" {
    pub fn exit_tasks_rcu_stop();
}
extern "C" {
    pub fn exit_tasks_rcu_finish();
}
extern "C" {
    pub fn rcu_softirq_qs();
}
extern "C" {
    pub fn rcu_note_context_switch(preempt: bool_);
}
extern "C" {
    pub fn rcu_needs_cpu() -> core::ffi::c_int;
}
extern "C" {
    pub fn rcu_cpu_stall_reset();
}
extern "C" {
    pub fn rcu_request_urgent_qs_task(t: *mut task_struct);
}
extern "C" {
    pub fn synchronize_rcu_expedited();
}
extern "C" {
    pub fn kvfree_call_rcu(head: *mut callback_head, ptr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn rcu_barrier();
}
extern "C" {
    pub fn rcu_momentary_dyntick_idle();
}
extern "C" {
    pub fn kfree_rcu_scheduler_running();
}
extern "C" {
    pub fn rcu_gp_might_be_stalled() -> bool_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rcu_gp_oldstate {
    pub rgos_norm: core::ffi::c_ulong,
    pub rgos_exp: core::ffi::c_ulong,
}
extern "C" {
    pub fn start_poll_synchronize_rcu_expedited() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn start_poll_synchronize_rcu_expedited_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn cond_synchronize_rcu_expedited(oldstate: core::ffi::c_ulong);
}
extern "C" {
    pub fn cond_synchronize_rcu_expedited_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn get_state_synchronize_rcu() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn get_state_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn start_poll_synchronize_rcu() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn start_poll_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn poll_state_synchronize_rcu(oldstate: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn poll_state_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate) -> bool_;
}
extern "C" {
    pub fn cond_synchronize_rcu(oldstate: core::ffi::c_ulong);
}
extern "C" {
    pub fn cond_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn rcu_preempt_deferred_qs(t: *mut task_struct);
}
extern "C" {
    pub fn exit_rcu();
}
extern "C" {
    pub fn rcu_scheduler_starting();
}
extern "C" {
    pub fn rcu_end_inkernel_boot();
}
extern "C" {
    pub fn rcu_inkernel_boot_has_ended() -> bool_;
}
extern "C" {
    pub fn rcu_is_watching() -> bool_;
}
extern "C" {
    pub fn rcutree_prepare_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn rcutree_online_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn rcutree_report_cpu_starting(cpu: core::ffi::c_uint);
}
extern "C" {
    pub fn rcutree_dead_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn rcutree_dying_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn rcutree_offline_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn rcutree_migrate_callbacks(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn rcutree_report_cpu_dead();
}
extern "C" {
    pub static mut rcu_lock_map: lockdep_map;
}
extern "C" {
    pub static mut rcu_bh_lock_map: lockdep_map;
}
extern "C" {
    pub static mut rcu_sched_lock_map: lockdep_map;
}
extern "C" {
    pub static mut rcu_callback_map: lockdep_map;
}
extern "C" {
    pub static mut rcu_expedited: core::ffi::c_int;
}
extern "C" {
    pub static mut rcu_normal: core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_rcu_t {
    pub lock: *mut core::ffi::c_void,
}
impl Default for class_rcu_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn rb_insert_color(arg1: *mut rb_node, arg2: *mut rb_root);
}
extern "C" {
    pub fn rb_erase(arg1: *mut rb_node, arg2: *mut rb_root);
}
extern "C" {
    pub fn rb_next(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_prev(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_first(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_last(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_first_postorder(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_next_postorder(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_replace_node(victim: *mut rb_node, new: *mut rb_node, root: *mut rb_root);
}
extern "C" {
    pub fn rb_replace_node_rcu(victim: *mut rb_node, new: *mut rb_node, root: *mut rb_root);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct maple_metadata {
    pub end: core::ffi::c_uchar,
    pub gap: core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_range_64 {
    pub parent: *mut maple_pnode,
    pub pivot: [core::ffi::c_ulong; 15usize],
    pub __bindgen_anon_1: maple_range_64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union maple_range_64__bindgen_ty_1 {
    pub slot: [*mut core::ffi::c_void; 16usize],
    pub __bindgen_anon_1: maple_range_64__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_range_64__bindgen_ty_1__bindgen_ty_1 {
    pub pad: [*mut core::ffi::c_void; 15usize],
    pub meta: maple_metadata,
}
impl Default for maple_range_64__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for maple_range_64__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for maple_range_64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_arange_64 {
    pub parent: *mut maple_pnode,
    pub pivot: [core::ffi::c_ulong; 9usize],
    pub slot: [*mut core::ffi::c_void; 10usize],
    pub gap: [core::ffi::c_ulong; 10usize],
    pub meta: maple_metadata,
}
impl Default for maple_arange_64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_alloc {
    pub total: core::ffi::c_ulong,
    pub node_count: core::ffi::c_uchar,
    pub request_count: core::ffi::c_uint,
    pub slot: [*mut maple_alloc; 30usize],
}
impl Default for maple_alloc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_topiary {
    pub parent: *mut maple_pnode,
    pub next: *mut maple_enode,
}
impl Default for maple_topiary {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const maple_type_maple_dense: maple_type = 0;
pub const maple_type_maple_leaf_64: maple_type = 1;
pub const maple_type_maple_range_64: maple_type = 2;
pub const maple_type_maple_arange_64: maple_type = 3;
pub type maple_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lockdep_map_p {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_tree {
    pub __bindgen_anon_1: maple_tree__bindgen_ty_1,
    pub ma_flags: core::ffi::c_uint,
    pub ma_root: *mut core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union maple_tree__bindgen_ty_1 {
    pub ma_lock: spinlock_t,
    pub ma_external_lock: lockdep_map_p,
}
impl Default for maple_tree__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for maple_tree {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_node {
    pub __bindgen_anon_1: maple_node__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union maple_node__bindgen_ty_1 {
    pub __bindgen_anon_1: maple_node__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: maple_node__bindgen_ty_1__bindgen_ty_2,
    pub mr64: maple_range_64,
    pub ma64: maple_arange_64,
    pub alloc: maple_alloc,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_node__bindgen_ty_1__bindgen_ty_1 {
    pub parent: *mut maple_pnode,
    pub slot: [*mut core::ffi::c_void; 31usize],
}
impl Default for maple_node__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_node__bindgen_ty_1__bindgen_ty_2 {
    pub pad: *mut core::ffi::c_void,
    pub rcu: callback_head,
    pub piv_parent: *mut maple_enode,
    pub parent_slot: core::ffi::c_uchar,
    pub type_: maple_type,
    pub slot_len: core::ffi::c_uchar,
    pub ma_flags: core::ffi::c_uint,
}
impl Default for maple_node__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for maple_node__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for maple_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ma_topiary {
    pub head: *mut maple_enode,
    pub tail: *mut maple_enode,
    pub mtree: *mut maple_tree,
}
impl Default for ma_topiary {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn mtree_load(mt: *mut maple_tree, index: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mtree_insert(
        mt: *mut maple_tree,
        index: core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mtree_insert_range(
        mt: *mut maple_tree,
        first: core::ffi::c_ulong,
        last: core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mtree_alloc_range(
        mt: *mut maple_tree,
        startp: *mut core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        size: core::ffi::c_ulong,
        min: core::ffi::c_ulong,
        max: core::ffi::c_ulong,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mtree_alloc_cyclic(
        mt: *mut maple_tree,
        startp: *mut core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        range_lo: core::ffi::c_ulong,
        range_hi: core::ffi::c_ulong,
        next: *mut core::ffi::c_ulong,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mtree_alloc_rrange(
        mt: *mut maple_tree,
        startp: *mut core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        size: core::ffi::c_ulong,
        min: core::ffi::c_ulong,
        max: core::ffi::c_ulong,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mtree_store_range(
        mt: *mut maple_tree,
        first: core::ffi::c_ulong,
        last: core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mtree_store(
        mt: *mut maple_tree,
        index: core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mtree_erase(mt: *mut maple_tree, index: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mtree_dup(mt: *mut maple_tree, new: *mut maple_tree, gfp: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn __mt_dup(mt: *mut maple_tree, new: *mut maple_tree, gfp: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn mtree_destroy(mt: *mut maple_tree);
}
extern "C" {
    pub fn __mt_destroy(mt: *mut maple_tree);
}
pub const maple_status_ma_active: maple_status = 0;
pub const maple_status_ma_start: maple_status = 1;
pub const maple_status_ma_root: maple_status = 2;
pub const maple_status_ma_none: maple_status = 3;
pub const maple_status_ma_pause: maple_status = 4;
pub const maple_status_ma_overflow: maple_status = 5;
pub const maple_status_ma_underflow: maple_status = 6;
pub const maple_status_ma_error: maple_status = 7;
pub type maple_status = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ma_state {
    pub tree: *mut maple_tree,
    pub index: core::ffi::c_ulong,
    pub last: core::ffi::c_ulong,
    pub node: *mut maple_enode,
    pub min: core::ffi::c_ulong,
    pub max: core::ffi::c_ulong,
    pub alloc: *mut maple_alloc,
    pub status: maple_status,
    pub depth: core::ffi::c_uchar,
    pub offset: core::ffi::c_uchar,
    pub mas_flags: core::ffi::c_uchar,
    pub end: core::ffi::c_uchar,
}
impl Default for ma_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ma_wr_state {
    pub mas: *mut ma_state,
    pub node: *mut maple_node,
    pub r_min: core::ffi::c_ulong,
    pub r_max: core::ffi::c_ulong,
    pub type_: maple_type,
    pub offset_end: core::ffi::c_uchar,
    pub pivots: *mut core::ffi::c_ulong,
    pub end_piv: core::ffi::c_ulong,
    pub slots: *mut *mut core::ffi::c_void,
    pub entry: *mut core::ffi::c_void,
    pub content: *mut core::ffi::c_void,
}
impl Default for ma_wr_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn mas_walk(mas: *mut ma_state) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_store(mas: *mut ma_state, entry: *mut core::ffi::c_void) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_erase(mas: *mut ma_state) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_store_gfp(
        mas: *mut ma_state,
        entry: *mut core::ffi::c_void,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mas_store_prealloc(mas: *mut ma_state, entry: *mut core::ffi::c_void);
}
extern "C" {
    pub fn mas_find(mas: *mut ma_state, max: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_find_range(mas: *mut ma_state, max: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_find_rev(mas: *mut ma_state, min: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_find_range_rev(
        mas: *mut ma_state,
        max: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_preallocate(
        mas: *mut ma_state,
        entry: *mut core::ffi::c_void,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mas_alloc_cyclic(
        mas: *mut ma_state,
        startp: *mut core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        range_lo: core::ffi::c_ulong,
        range_hi: core::ffi::c_ulong,
        next: *mut core::ffi::c_ulong,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mas_nomem(mas: *mut ma_state, gfp: gfp_t) -> bool_;
}
extern "C" {
    pub fn mas_pause(mas: *mut ma_state);
}
extern "C" {
    pub fn maple_tree_init();
}
extern "C" {
    pub fn mas_destroy(mas: *mut ma_state);
}
extern "C" {
    pub fn mas_expected_entries(
        mas: *mut ma_state,
        nr_entries: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mas_prev(mas: *mut ma_state, min: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_prev_range(mas: *mut ma_state, max: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_next(mas: *mut ma_state, max: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_next_range(mas: *mut ma_state, max: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_empty_area(
        mas: *mut ma_state,
        min: core::ffi::c_ulong,
        max: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mas_empty_area_rev(
        mas: *mut ma_state,
        min: core::ffi::c_ulong,
        max: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mt_find(
        mt: *mut maple_tree,
        index: *mut core::ffi::c_ulong,
        max: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mt_find_after(
        mt: *mut maple_tree,
        index: *mut core::ffi::c_ulong,
        max: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mt_prev(
        mt: *mut maple_tree,
        index: core::ffi::c_ulong,
        min: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mt_next(
        mt: *mut maple_tree,
        index: core::ffi::c_ulong,
        max: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rw_semaphore {
    pub count: atomic_long_t,
    pub owner: atomic_long_t,
    pub osq: optimistic_spin_queue,
    pub wait_lock: raw_spinlock_t,
    pub wait_list: list_head,
}
impl Default for rw_semaphore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __init_rwsem(
        sem: *mut rw_semaphore,
        name: *const core::ffi::c_char,
        key: *mut lock_class_key,
    );
}
extern "C" {
    pub fn down_read(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn down_read_interruptible(sem: *mut rw_semaphore) -> core::ffi::c_int;
}
extern "C" {
    pub fn down_read_killable(sem: *mut rw_semaphore) -> core::ffi::c_int;
}
extern "C" {
    pub fn down_read_trylock(sem: *mut rw_semaphore) -> core::ffi::c_int;
}
extern "C" {
    pub fn down_write(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn down_write_killable(sem: *mut rw_semaphore) -> core::ffi::c_int;
}
extern "C" {
    pub fn down_write_trylock(sem: *mut rw_semaphore) -> core::ffi::c_int;
}
extern "C" {
    pub fn up_read(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn up_write(sem: *mut rw_semaphore);
}
pub type class_rwsem_read_t = *mut rw_semaphore;
pub type class_rwsem_read_try_t = class_rwsem_read_t;
pub type class_rwsem_read_intr_t = class_rwsem_read_t;
pub type class_rwsem_write_t = *mut rw_semaphore;
pub type class_rwsem_write_try_t = class_rwsem_write_t;
extern "C" {
    pub fn downgrade_write(sem: *mut rw_semaphore);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swait_queue_head {
    pub lock: raw_spinlock_t,
    pub task_list: list_head,
}
impl Default for swait_queue_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swait_queue {
    pub task: *mut task_struct,
    pub task_list: list_head,
}
impl Default for swait_queue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __init_swait_queue_head(
        q: *mut swait_queue_head,
        name: *const core::ffi::c_char,
        key: *mut lock_class_key,
    );
}
extern "C" {
    pub fn swake_up_one(q: *mut swait_queue_head);
}
extern "C" {
    pub fn swake_up_all(q: *mut swait_queue_head);
}
extern "C" {
    pub fn swake_up_locked(q: *mut swait_queue_head, wake_flags: core::ffi::c_int);
}
extern "C" {
    pub fn prepare_to_swait_exclusive(
        q: *mut swait_queue_head,
        wait: *mut swait_queue,
        state: core::ffi::c_int,
    );
}
extern "C" {
    pub fn prepare_to_swait_event(
        q: *mut swait_queue_head,
        wait: *mut swait_queue,
        state: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn __finish_swait(q: *mut swait_queue_head, wait: *mut swait_queue);
}
extern "C" {
    pub fn finish_swait(q: *mut swait_queue_head, wait: *mut swait_queue);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct completion {
    pub done: core::ffi::c_uint,
    pub wait: swait_queue_head,
}
impl Default for completion {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn wait_for_completion(arg1: *mut completion);
}
extern "C" {
    pub fn wait_for_completion_io(arg1: *mut completion);
}
extern "C" {
    pub fn wait_for_completion_interruptible(x: *mut completion) -> core::ffi::c_int;
}
extern "C" {
    pub fn wait_for_completion_killable(x: *mut completion) -> core::ffi::c_int;
}
extern "C" {
    pub fn wait_for_completion_state(
        x: *mut completion,
        state: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn wait_for_completion_timeout(
        x: *mut completion,
        timeout: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn wait_for_completion_io_timeout(
        x: *mut completion,
        timeout: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn wait_for_completion_interruptible_timeout(
        x: *mut completion,
        timeout: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn wait_for_completion_killable_timeout(
        x: *mut completion,
        timeout: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn try_wait_for_completion(x: *mut completion) -> bool_;
}
extern "C" {
    pub fn completion_done(x: *mut completion) -> bool_;
}
extern "C" {
    pub fn complete(arg1: *mut completion);
}
extern "C" {
    pub fn complete_on_current_cpu(x: *mut completion);
}
extern "C" {
    pub fn complete_all(arg1: *mut completion);
}
pub const uprobe_filter_ctx_UPROBE_FILTER_REGISTER: uprobe_filter_ctx = 0;
pub const uprobe_filter_ctx_UPROBE_FILTER_UNREGISTER: uprobe_filter_ctx = 1;
pub const uprobe_filter_ctx_UPROBE_FILTER_MMAP: uprobe_filter_ctx = 2;
pub type uprobe_filter_ctx = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe_consumer {
    pub handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut uprobe_consumer, regs: *mut pt_regs) -> core::ffi::c_int,
    >,
    pub ret_handler: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut uprobe_consumer,
            func: core::ffi::c_ulong,
            regs: *mut pt_regs,
        ) -> core::ffi::c_int,
    >,
    pub filter: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut uprobe_consumer,
            ctx: uprobe_filter_ctx,
            mm: *mut mm_struct,
        ) -> bool_,
    >,
    pub next: *mut uprobe_consumer,
}
impl Default for uprobe_consumer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn register_refined_jiffies(clock_tick_rate: core::ffi::c_long) -> core::ffi::c_int;
}
extern "C" {
    pub static mut jiffies_64: u64_;
}
extern "C" {
    pub static mut jiffies: core::ffi::c_ulong;
}
extern "C" {
    pub static mut preset_lpj: core::ffi::c_ulong;
}
extern "C" {
    pub fn jiffies_to_msecs(j: core::ffi::c_ulong) -> core::ffi::c_uint;
}
extern "C" {
    pub fn jiffies_to_usecs(j: core::ffi::c_ulong) -> core::ffi::c_uint;
}
extern "C" {
    pub fn jiffies64_to_nsecs(j: u64_) -> u64_;
}
extern "C" {
    pub fn jiffies64_to_msecs(j: u64_) -> u64_;
}
extern "C" {
    pub fn __msecs_to_jiffies(m: core::ffi::c_uint) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __usecs_to_jiffies(u: core::ffi::c_uint) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn timespec64_to_jiffies(value: *const timespec64) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn jiffies_to_timespec64(jiffies: core::ffi::c_ulong, value: *mut timespec64);
}
extern "C" {
    pub fn jiffies_to_clock_t(x: core::ffi::c_ulong) -> clock_t;
}
extern "C" {
    pub fn clock_t_to_jiffies(x: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn jiffies_64_to_clock_t(x: u64_) -> u64_;
}
extern "C" {
    pub fn nsec_to_clock_t(x: u64_) -> u64_;
}
extern "C" {
    pub fn nsecs_to_jiffies64(n: u64_) -> u64_;
}
extern "C" {
    pub fn nsecs_to_jiffies(n: u64_) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn ktime_add_safe(lhs: ktime_t, rhs: ktime_t) -> ktime_t;
}
pub const clocksource_ids_CSID_GENERIC: clocksource_ids = 0;
pub const clocksource_ids_CSID_ARM_ARCH_COUNTER: clocksource_ids = 1;
pub const clocksource_ids_CSID_MAX: clocksource_ids = 2;
pub type clocksource_ids = core::ffi::c_uint;
extern "C" {
    pub fn timekeeping_init();
}
extern "C" {
    pub static mut timekeeping_suspended: core::ffi::c_int;
}
extern "C" {
    pub fn legacy_timer_tick(ticks: core::ffi::c_ulong);
}
extern "C" {
    pub fn do_settimeofday64(ts: *const timespec64) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_sys_settimeofday64(tv: *const timespec64, tz: *const timezone) -> core::ffi::c_int;
}
extern "C" {
    pub fn ktime_get_raw_ts64(ts: *mut timespec64);
}
extern "C" {
    pub fn ktime_get_ts64(ts: *mut timespec64);
}
extern "C" {
    pub fn ktime_get_real_ts64(tv: *mut timespec64);
}
extern "C" {
    pub fn ktime_get_coarse_ts64(ts: *mut timespec64);
}
extern "C" {
    pub fn ktime_get_coarse_real_ts64(ts: *mut timespec64);
}
extern "C" {
    pub fn getboottime64(ts: *mut timespec64);
}
extern "C" {
    pub fn ktime_get_seconds() -> time64_t;
}
extern "C" {
    pub fn __ktime_get_real_seconds() -> time64_t;
}
extern "C" {
    pub fn ktime_get_real_seconds() -> time64_t;
}
pub const tk_offsets_TK_OFFS_REAL: tk_offsets = 0;
pub const tk_offsets_TK_OFFS_BOOT: tk_offsets = 1;
pub const tk_offsets_TK_OFFS_TAI: tk_offsets = 2;
pub const tk_offsets_TK_OFFS_MAX: tk_offsets = 3;
pub type tk_offsets = core::ffi::c_uint;
extern "C" {
    pub fn ktime_get() -> ktime_t;
}
extern "C" {
    pub fn ktime_get_with_offset(offs: tk_offsets) -> ktime_t;
}
extern "C" {
    pub fn ktime_get_coarse_with_offset(offs: tk_offsets) -> ktime_t;
}
extern "C" {
    pub fn ktime_mono_to_any(tmono: ktime_t, offs: tk_offsets) -> ktime_t;
}
extern "C" {
    pub fn ktime_get_raw() -> ktime_t;
}
extern "C" {
    pub fn ktime_get_resolution_ns() -> u32_;
}
extern "C" {
    pub fn ktime_get_mono_fast_ns() -> u64_;
}
extern "C" {
    pub fn ktime_get_raw_fast_ns() -> u64_;
}
extern "C" {
    pub fn ktime_get_boot_fast_ns() -> u64_;
}
extern "C" {
    pub fn ktime_get_tai_fast_ns() -> u64_;
}
extern "C" {
    pub fn ktime_get_real_fast_ns() -> u64_;
}
extern "C" {
    pub fn timekeeping_rtc_skipsuspend() -> bool_;
}
extern "C" {
    pub fn timekeeping_rtc_skipresume() -> bool_;
}
extern "C" {
    pub fn timekeeping_inject_sleeptime64(delta: *const timespec64);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ktime_timestamps {
    pub mono: u64_,
    pub boot: u64_,
    pub real: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct system_time_snapshot {
    pub cycles: u64_,
    pub real: ktime_t,
    pub raw: ktime_t,
    pub cs_id: clocksource_ids,
    pub clock_was_set_seq: core::ffi::c_uint,
    pub cs_was_changed_seq: u8_,
}
impl Default for system_time_snapshot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct system_device_crosststamp {
    pub device: ktime_t,
    pub sys_realtime: ktime_t,
    pub sys_monoraw: ktime_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct system_counterval_t {
    pub cycles: u64_,
    pub cs: *mut clocksource,
}
impl Default for system_counterval_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn get_device_system_crosststamp(
        get_time_fn: ::core::option::Option<
            unsafe extern "C" fn(
                device_time: *mut ktime_t,
                system_counterval: *mut system_counterval_t,
                ctx: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        ctx: *mut core::ffi::c_void,
        history: *mut system_time_snapshot,
        xtstamp: *mut system_device_crosststamp,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ktime_get_snapshot(systime_snapshot: *mut system_time_snapshot);
}
extern "C" {
    pub fn ktime_get_fast_timestamps(snap: *mut ktime_timestamps);
}
extern "C" {
    pub static mut persistent_clock_is_local: core::ffi::c_int;
}
extern "C" {
    pub fn read_persistent_clock64(ts: *mut timespec64);
}
extern "C" {
    pub fn read_persistent_wall_and_boot_offset(
        wall_clock: *mut timespec64,
        boot_offset: *mut timespec64,
    );
}
extern "C" {
    pub fn update_persistent_clock64(now: timespec64) -> core::ffi::c_int;
}
pub const debug_obj_state_ODEBUG_STATE_NONE: debug_obj_state = 0;
pub const debug_obj_state_ODEBUG_STATE_INIT: debug_obj_state = 1;
pub const debug_obj_state_ODEBUG_STATE_INACTIVE: debug_obj_state = 2;
pub const debug_obj_state_ODEBUG_STATE_ACTIVE: debug_obj_state = 3;
pub const debug_obj_state_ODEBUG_STATE_DESTROYED: debug_obj_state = 4;
pub const debug_obj_state_ODEBUG_STATE_NOTAVAILABLE: debug_obj_state = 5;
pub const debug_obj_state_ODEBUG_STATE_MAX: debug_obj_state = 6;
pub type debug_obj_state = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct debug_obj {
    pub node: hlist_node,
    pub state: debug_obj_state,
    pub astate: core::ffi::c_uint,
    pub object: *mut core::ffi::c_void,
    pub descr: *const debug_obj_descr,
}
impl Default for debug_obj {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct debug_obj_descr {
    pub name: *const core::ffi::c_char,
    pub debug_hint: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut core::ffi::c_void) -> *mut core::ffi::c_void,
    >,
    pub is_static_object:
        ::core::option::Option<unsafe extern "C" fn(addr: *mut core::ffi::c_void) -> bool_>,
    pub fixup_init: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut core::ffi::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_activate: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut core::ffi::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_destroy: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut core::ffi::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_free: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut core::ffi::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_assert_init: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut core::ffi::c_void, state: debug_obj_state) -> bool_,
    >,
}
impl Default for debug_obj_descr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timer_list {
    pub entry: hlist_node,
    pub expires: core::ffi::c_ulong,
    pub function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
    pub flags: u32_,
}
impl Default for timer_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn init_timer_key(
        timer: *mut timer_list,
        func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
        flags: core::ffi::c_uint,
        name: *const core::ffi::c_char,
        key: *mut lock_class_key,
    );
}
extern "C" {
    pub fn add_timer_on(timer: *mut timer_list, cpu: core::ffi::c_int);
}
extern "C" {
    pub fn mod_timer(timer: *mut timer_list, expires: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn mod_timer_pending(
        timer: *mut timer_list,
        expires: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn timer_reduce(timer: *mut timer_list, expires: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn add_timer(timer: *mut timer_list);
}
extern "C" {
    pub fn try_to_del_timer_sync(timer: *mut timer_list) -> core::ffi::c_int;
}
extern "C" {
    pub fn timer_delete_sync(timer: *mut timer_list) -> core::ffi::c_int;
}
extern "C" {
    pub fn timer_delete(timer: *mut timer_list) -> core::ffi::c_int;
}
extern "C" {
    pub fn timer_shutdown_sync(timer: *mut timer_list) -> core::ffi::c_int;
}
extern "C" {
    pub fn timer_shutdown(timer: *mut timer_list) -> core::ffi::c_int;
}
extern "C" {
    pub fn init_timers();
}
extern "C" {
    pub fn it_real_fn(arg1: *mut hrtimer) -> hrtimer_restart;
}
extern "C" {
    pub fn __round_jiffies(j: core::ffi::c_ulong, cpu: core::ffi::c_int) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __round_jiffies_relative(
        j: core::ffi::c_ulong,
        cpu: core::ffi::c_int,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn round_jiffies(j: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn round_jiffies_relative(j: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __round_jiffies_up(j: core::ffi::c_ulong, cpu: core::ffi::c_int) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __round_jiffies_up_relative(
        j: core::ffi::c_ulong,
        cpu: core::ffi::c_int,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn round_jiffies_up(j: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn round_jiffies_up_relative(j: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn timers_prepare_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn timers_dead_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct workqueue_struct {
    _unused: [u8; 0],
}
pub type work_func_t = ::core::option::Option<unsafe extern "C" fn(work: *mut work_struct)>;
extern "C" {
    pub fn delayed_work_timer_fn(t: *mut timer_list);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct work_struct {
    pub data: atomic_long_t,
    pub entry: list_head,
    pub func: work_func_t,
}
impl Default for work_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const WORK_STRUCT_PENDING_BIT: _bindgen_ty_10 = 0;
pub const WORK_STRUCT_INACTIVE_BIT: _bindgen_ty_10 = 1;
pub const WORK_STRUCT_PWQ_BIT: _bindgen_ty_10 = 2;
pub const WORK_STRUCT_LINKED_BIT: _bindgen_ty_10 = 3;
pub const WORK_STRUCT_COLOR_SHIFT: _bindgen_ty_10 = 4;
pub const WORK_STRUCT_COLOR_BITS: _bindgen_ty_10 = 4;
pub const WORK_STRUCT_PENDING: _bindgen_ty_10 = 1;
pub const WORK_STRUCT_INACTIVE: _bindgen_ty_10 = 2;
pub const WORK_STRUCT_PWQ: _bindgen_ty_10 = 4;
pub const WORK_STRUCT_LINKED: _bindgen_ty_10 = 8;
pub const WORK_STRUCT_STATIC: _bindgen_ty_10 = 0;
pub const WORK_NR_COLORS: _bindgen_ty_10 = 16;
pub const WORK_CPU_UNBOUND: _bindgen_ty_10 = 8192;
pub const WORK_STRUCT_FLAG_BITS: _bindgen_ty_10 = 8;
pub const WORK_OFFQ_FLAG_BASE: _bindgen_ty_10 = 4;
pub const __WORK_OFFQ_CANCELING: _bindgen_ty_10 = 4;
pub const WORK_OFFQ_FLAG_BITS: _bindgen_ty_10 = 1;
pub const WORK_OFFQ_POOL_SHIFT: _bindgen_ty_10 = 5;
pub const WORK_OFFQ_LEFT: _bindgen_ty_10 = 59;
pub const WORK_OFFQ_POOL_BITS: _bindgen_ty_10 = 31;
pub const WORK_BUSY_PENDING: _bindgen_ty_10 = 1;
pub const WORK_BUSY_RUNNING: _bindgen_ty_10 = 2;
pub const WORKER_DESC_LEN: _bindgen_ty_10 = 24;
pub type _bindgen_ty_10 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct delayed_work {
    pub work: work_struct,
    pub timer: timer_list,
    pub wq: *mut workqueue_struct,
    pub cpu: core::ffi::c_int,
}
impl Default for delayed_work {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_work {
    pub work: work_struct,
    pub rcu: callback_head,
    pub wq: *mut workqueue_struct,
}
impl Default for rcu_work {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const wq_affn_scope_WQ_AFFN_DFL: wq_affn_scope = 0;
pub const wq_affn_scope_WQ_AFFN_CPU: wq_affn_scope = 1;
pub const wq_affn_scope_WQ_AFFN_SMT: wq_affn_scope = 2;
pub const wq_affn_scope_WQ_AFFN_CACHE: wq_affn_scope = 3;
pub const wq_affn_scope_WQ_AFFN_NUMA: wq_affn_scope = 4;
pub const wq_affn_scope_WQ_AFFN_SYSTEM: wq_affn_scope = 5;
pub const wq_affn_scope_WQ_AFFN_NR_TYPES: wq_affn_scope = 6;
pub type wq_affn_scope = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct workqueue_attrs {
    pub nice: core::ffi::c_int,
    pub cpumask: cpumask_var_t,
    pub __pod_cpumask: cpumask_var_t,
    pub affn_strict: bool_,
    pub affn_scope: wq_affn_scope,
    pub ordered: bool_,
}
impl Default for workqueue_attrs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct execute_work {
    pub work: work_struct,
}
impl Default for execute_work {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const WQ_UNBOUND: _bindgen_ty_11 = 2;
pub const WQ_FREEZABLE: _bindgen_ty_11 = 4;
pub const WQ_MEM_RECLAIM: _bindgen_ty_11 = 8;
pub const WQ_HIGHPRI: _bindgen_ty_11 = 16;
pub const WQ_CPU_INTENSIVE: _bindgen_ty_11 = 32;
pub const WQ_SYSFS: _bindgen_ty_11 = 64;
pub const WQ_POWER_EFFICIENT: _bindgen_ty_11 = 128;
pub const __WQ_DESTROYING: _bindgen_ty_11 = 32768;
pub const __WQ_DRAINING: _bindgen_ty_11 = 65536;
pub const __WQ_ORDERED: _bindgen_ty_11 = 131072;
pub const __WQ_LEGACY: _bindgen_ty_11 = 262144;
pub const __WQ_ORDERED_EXPLICIT: _bindgen_ty_11 = 524288;
pub const WQ_MAX_ACTIVE: _bindgen_ty_11 = 512;
pub const WQ_UNBOUND_MAX_ACTIVE: _bindgen_ty_11 = 512;
pub const WQ_DFL_ACTIVE: _bindgen_ty_11 = 256;
pub type _bindgen_ty_11 = core::ffi::c_uint;
extern "C" {
    pub static mut system_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_highpri_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_long_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_unbound_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_freezable_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_power_efficient_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_freezable_power_efficient_wq: *mut workqueue_struct;
}
extern "C" {
    pub fn alloc_workqueue(
        fmt: *const core::ffi::c_char,
        flags: core::ffi::c_uint,
        max_active: core::ffi::c_int,
        ...
    ) -> *mut workqueue_struct;
}
extern "C" {
    pub fn destroy_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn alloc_workqueue_attrs() -> *mut workqueue_attrs;
}
extern "C" {
    pub fn free_workqueue_attrs(attrs: *mut workqueue_attrs);
}
extern "C" {
    pub fn apply_workqueue_attrs(
        wq: *mut workqueue_struct,
        attrs: *const workqueue_attrs,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn workqueue_unbound_exclude_cpumask(cpumask: cpumask_var_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn queue_work_on(
        cpu: core::ffi::c_int,
        wq: *mut workqueue_struct,
        work: *mut work_struct,
    ) -> bool_;
}
extern "C" {
    pub fn queue_work_node(
        node: core::ffi::c_int,
        wq: *mut workqueue_struct,
        work: *mut work_struct,
    ) -> bool_;
}
extern "C" {
    pub fn queue_delayed_work_on(
        cpu: core::ffi::c_int,
        wq: *mut workqueue_struct,
        work: *mut delayed_work,
        delay: core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn mod_delayed_work_on(
        cpu: core::ffi::c_int,
        wq: *mut workqueue_struct,
        dwork: *mut delayed_work,
        delay: core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn queue_rcu_work(wq: *mut workqueue_struct, rwork: *mut rcu_work) -> bool_;
}
extern "C" {
    pub fn __flush_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn drain_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn schedule_on_each_cpu(func: work_func_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn execute_in_process_context(
        fn_: work_func_t,
        arg1: *mut execute_work,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn flush_work(work: *mut work_struct) -> bool_;
}
extern "C" {
    pub fn cancel_work(work: *mut work_struct) -> bool_;
}
extern "C" {
    pub fn cancel_work_sync(work: *mut work_struct) -> bool_;
}
extern "C" {
    pub fn flush_delayed_work(dwork: *mut delayed_work) -> bool_;
}
extern "C" {
    pub fn cancel_delayed_work(dwork: *mut delayed_work) -> bool_;
}
extern "C" {
    pub fn cancel_delayed_work_sync(dwork: *mut delayed_work) -> bool_;
}
extern "C" {
    pub fn flush_rcu_work(rwork: *mut rcu_work) -> bool_;
}
extern "C" {
    pub fn workqueue_set_max_active(wq: *mut workqueue_struct, max_active: core::ffi::c_int);
}
extern "C" {
    pub fn current_work() -> *mut work_struct;
}
extern "C" {
    pub fn current_is_workqueue_rescuer() -> bool_;
}
extern "C" {
    pub fn workqueue_congested(cpu: core::ffi::c_int, wq: *mut workqueue_struct) -> bool_;
}
extern "C" {
    pub fn work_busy(work: *mut work_struct) -> core::ffi::c_uint;
}
extern "C" {
    pub fn set_worker_desc(fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn print_worker_info(log_lvl: *const core::ffi::c_char, task: *mut task_struct);
}
extern "C" {
    pub fn show_all_workqueues();
}
extern "C" {
    pub fn show_freezable_workqueues();
}
extern "C" {
    pub fn show_one_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn wq_worker_comm(buf: *mut core::ffi::c_char, size: usize, task: *mut task_struct);
}
extern "C" {
    pub fn __warn_flushing_systemwide_wq();
}
extern "C" {
    pub fn work_on_cpu_key(
        cpu: core::ffi::c_int,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> core::ffi::c_long,
        >,
        arg: *mut core::ffi::c_void,
        key: *mut lock_class_key,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn work_on_cpu_safe_key(
        cpu: core::ffi::c_int,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> core::ffi::c_long,
        >,
        arg: *mut core::ffi::c_void,
        key: *mut lock_class_key,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn freeze_workqueues_begin();
}
extern "C" {
    pub fn freeze_workqueues_busy() -> bool_;
}
extern "C" {
    pub fn thaw_workqueues();
}
extern "C" {
    pub fn workqueue_sysfs_register(wq: *mut workqueue_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn workqueue_prepare_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn workqueue_online_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn workqueue_offline_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn workqueue_init_early();
}
extern "C" {
    pub fn workqueue_init();
}
extern "C" {
    pub fn workqueue_init_topology();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_cblist {
    pub head: *mut callback_head,
    pub tail: *mut *mut callback_head,
    pub len: core::ffi::c_long,
}
impl Default for rcu_cblist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_segcblist {
    pub head: *mut callback_head,
    pub tails: [*mut *mut callback_head; 4usize],
    pub gp_seq: [core::ffi::c_ulong; 4usize],
    pub len: atomic_long_t,
    pub seglen: [core::ffi::c_long; 4usize],
    pub flags: u8_,
}
impl Default for rcu_segcblist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn init_srcu_struct(ssp: *mut srcu_struct) -> core::ffi::c_int;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct srcu_data {
    pub srcu_lock_count: [atomic_long_t; 2usize],
    pub srcu_unlock_count: [atomic_long_t; 2usize],
    pub srcu_nmi_safety: core::ffi::c_int,
    pub __bindgen_padding_0: [u32; 7usize],
    pub lock: spinlock_t,
    pub srcu_cblist: rcu_segcblist,
    pub srcu_gp_seq_needed: core::ffi::c_ulong,
    pub srcu_gp_seq_needed_exp: core::ffi::c_ulong,
    pub srcu_cblist_invoking: bool_,
    pub delay_work: timer_list,
    pub work: work_struct,
    pub srcu_barrier_head: callback_head,
    pub mynode: *mut srcu_node,
    pub grpmask: core::ffi::c_ulong,
    pub cpu: core::ffi::c_int,
    pub ssp: *mut srcu_struct,
}
impl Default for srcu_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_node {
    pub lock: spinlock_t,
    pub srcu_have_cbs: [core::ffi::c_ulong; 4usize],
    pub srcu_data_have_cbs: [core::ffi::c_ulong; 4usize],
    pub srcu_gp_seq_needed_exp: core::ffi::c_ulong,
    pub srcu_parent: *mut srcu_node,
    pub grplo: core::ffi::c_int,
    pub grphi: core::ffi::c_int,
}
impl Default for srcu_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_usage {
    pub node: *mut srcu_node,
    pub level: [*mut srcu_node; 4usize],
    pub srcu_size_state: core::ffi::c_int,
    pub srcu_cb_mutex: mutex,
    pub lock: spinlock_t,
    pub srcu_gp_mutex: mutex,
    pub srcu_gp_seq: core::ffi::c_ulong,
    pub srcu_gp_seq_needed: core::ffi::c_ulong,
    pub srcu_gp_seq_needed_exp: core::ffi::c_ulong,
    pub srcu_gp_start: core::ffi::c_ulong,
    pub srcu_last_gp_end: core::ffi::c_ulong,
    pub srcu_size_jiffies: core::ffi::c_ulong,
    pub srcu_n_lock_retries: core::ffi::c_ulong,
    pub srcu_n_exp_nodelay: core::ffi::c_ulong,
    pub sda_is_static: bool_,
    pub srcu_barrier_seq: core::ffi::c_ulong,
    pub srcu_barrier_mutex: mutex,
    pub srcu_barrier_completion: completion,
    pub srcu_barrier_cpu_cnt: atomic_t,
    pub reschedule_jiffies: core::ffi::c_ulong,
    pub reschedule_count: core::ffi::c_ulong,
    pub work: delayed_work,
    pub srcu_ssp: *mut srcu_struct,
}
impl Default for srcu_usage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_struct {
    pub srcu_idx: core::ffi::c_uint,
    pub sda: *mut srcu_data,
    pub dep_map: lockdep_map,
    pub srcu_sup: *mut srcu_usage,
}
impl Default for srcu_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn synchronize_srcu_expedited(ssp: *mut srcu_struct);
}
extern "C" {
    pub fn srcu_barrier(ssp: *mut srcu_struct);
}
extern "C" {
    pub fn srcu_torture_stats_print(
        ssp: *mut srcu_struct,
        tt: *mut core::ffi::c_char,
        tf: *mut core::ffi::c_char,
    );
}
extern "C" {
    pub fn call_srcu(
        ssp: *mut srcu_struct,
        head: *mut callback_head,
        func: ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
    );
}
extern "C" {
    pub fn cleanup_srcu_struct(ssp: *mut srcu_struct);
}
extern "C" {
    pub fn __srcu_read_lock(ssp: *mut srcu_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn __srcu_read_unlock(ssp: *mut srcu_struct, idx: core::ffi::c_int);
}
extern "C" {
    pub fn synchronize_srcu(ssp: *mut srcu_struct);
}
extern "C" {
    pub fn get_state_synchronize_srcu(ssp: *mut srcu_struct) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn start_poll_synchronize_srcu(ssp: *mut srcu_struct) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn poll_state_synchronize_srcu(ssp: *mut srcu_struct, cookie: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn srcu_init();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_srcu_t {
    pub lock: *mut srcu_struct,
    pub idx: core::ffi::c_int,
}
impl Default for class_srcu_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type notifier_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        nb: *mut notifier_block,
        action: core::ffi::c_ulong,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct notifier_block {
    pub notifier_call: notifier_fn_t,
    pub next: *mut notifier_block,
    pub priority: core::ffi::c_int,
}
impl Default for notifier_block {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct atomic_notifier_head {
    pub lock: spinlock_t,
    pub head: *mut notifier_block,
}
impl Default for atomic_notifier_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blocking_notifier_head {
    pub rwsem: rw_semaphore,
    pub head: *mut notifier_block,
}
impl Default for blocking_notifier_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_notifier_head {
    pub head: *mut notifier_block,
}
impl Default for raw_notifier_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_notifier_head {
    pub mutex: mutex,
    pub srcuu: srcu_usage,
    pub srcu: srcu_struct,
    pub head: *mut notifier_block,
}
impl Default for srcu_notifier_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn srcu_init_notifier_head(nh: *mut srcu_notifier_head);
}
extern "C" {
    pub fn atomic_notifier_chain_register(
        nh: *mut atomic_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn blocking_notifier_chain_register(
        nh: *mut blocking_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn raw_notifier_chain_register(
        nh: *mut raw_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn srcu_notifier_chain_register(
        nh: *mut srcu_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn atomic_notifier_chain_register_unique_prio(
        nh: *mut atomic_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn blocking_notifier_chain_register_unique_prio(
        nh: *mut blocking_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn atomic_notifier_chain_unregister(
        nh: *mut atomic_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn blocking_notifier_chain_unregister(
        nh: *mut blocking_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn raw_notifier_chain_unregister(
        nh: *mut raw_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn srcu_notifier_chain_unregister(
        nh: *mut srcu_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn atomic_notifier_call_chain(
        nh: *mut atomic_notifier_head,
        val: core::ffi::c_ulong,
        v: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn blocking_notifier_call_chain(
        nh: *mut blocking_notifier_head,
        val: core::ffi::c_ulong,
        v: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn raw_notifier_call_chain(
        nh: *mut raw_notifier_head,
        val: core::ffi::c_ulong,
        v: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn srcu_notifier_call_chain(
        nh: *mut srcu_notifier_head,
        val: core::ffi::c_ulong,
        v: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn blocking_notifier_call_chain_robust(
        nh: *mut blocking_notifier_head,
        val_up: core::ffi::c_ulong,
        val_down: core::ffi::c_ulong,
        v: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn raw_notifier_call_chain_robust(
        nh: *mut raw_notifier_head,
        val_up: core::ffi::c_ulong,
        val_down: core::ffi::c_ulong,
        v: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn atomic_notifier_call_chain_is_empty(nh: *mut atomic_notifier_head) -> bool_;
}
extern "C" {
    pub static mut reboot_notifier_list: blocking_notifier_head;
}
pub type uprobe_opcode_t = u8_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe_xol_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_uprobe {
    pub __bindgen_anon_1: arch_uprobe__bindgen_ty_1,
    pub ops: *const uprobe_xol_ops,
    pub __bindgen_anon_2: arch_uprobe__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union arch_uprobe__bindgen_ty_1 {
    pub insn: [u8_; 16usize],
    pub ixol: [u8_; 16usize],
}
impl Default for arch_uprobe__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union arch_uprobe__bindgen_ty_2 {
    pub branch: arch_uprobe__bindgen_ty_2__bindgen_ty_1,
    pub defparam: arch_uprobe__bindgen_ty_2__bindgen_ty_2,
    pub push: arch_uprobe__bindgen_ty_2__bindgen_ty_3,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct arch_uprobe__bindgen_ty_2__bindgen_ty_1 {
    pub offs: s32,
    pub ilen: u8_,
    pub opc1: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct arch_uprobe__bindgen_ty_2__bindgen_ty_2 {
    pub fixups: u8_,
    pub ilen: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct arch_uprobe__bindgen_ty_2__bindgen_ty_3 {
    pub reg_offset: u8_,
    pub ilen: u8_,
}
impl Default for arch_uprobe__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for arch_uprobe {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct arch_uprobe_task {
    pub saved_scratch_register: core::ffi::c_ulong,
    pub saved_trap_nr: core::ffi::c_uint,
    pub saved_tf: core::ffi::c_uint,
}
pub const uprobe_task_state_UTASK_RUNNING: uprobe_task_state = 0;
pub const uprobe_task_state_UTASK_SSTEP: uprobe_task_state = 1;
pub const uprobe_task_state_UTASK_SSTEP_ACK: uprobe_task_state = 2;
pub const uprobe_task_state_UTASK_SSTEP_TRAPPED: uprobe_task_state = 3;
pub type uprobe_task_state = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe_task {
    pub state: uprobe_task_state,
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1,
    pub active_uprobe: *mut uprobe,
    pub xol_vaddr: core::ffi::c_ulong,
    pub return_instances: *mut return_instance,
    pub depth: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uprobe_task__bindgen_ty_1 {
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: uprobe_task__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_1 {
    pub autask: arch_uprobe_task,
    pub vaddr: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_2 {
    pub dup_xol_work: callback_head,
    pub dup_xol_addr: core::ffi::c_ulong,
}
impl Default for uprobe_task__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for uprobe_task__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for uprobe_task {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct return_instance {
    pub uprobe: *mut uprobe,
    pub func: core::ffi::c_ulong,
    pub stack: core::ffi::c_ulong,
    pub orig_ret_vaddr: core::ffi::c_ulong,
    pub chained: bool_,
    pub next: *mut return_instance,
}
impl Default for return_instance {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const rp_check_RP_CHECK_CALL: rp_check = 0;
pub const rp_check_RP_CHECK_CHAIN_CALL: rp_check = 1;
pub const rp_check_RP_CHECK_RET: rp_check = 2;
pub type rp_check = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xol_area {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobes_state {
    pub xol_area: *mut xol_area,
}
impl Default for uprobes_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn uprobes_init();
}
extern "C" {
    pub fn set_swbp(
        aup: *mut arch_uprobe,
        mm: *mut mm_struct,
        vaddr: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_orig_insn(
        aup: *mut arch_uprobe,
        mm: *mut mm_struct,
        vaddr: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn is_swbp_insn(insn: *mut uprobe_opcode_t) -> bool_;
}
extern "C" {
    pub fn is_trap_insn(insn: *mut uprobe_opcode_t) -> bool_;
}
extern "C" {
    pub fn uprobe_get_swbp_addr(regs: *mut pt_regs) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn uprobe_get_trap_addr(regs: *mut pt_regs) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn uprobe_write_opcode(
        auprobe: *mut arch_uprobe,
        mm: *mut mm_struct,
        vaddr: core::ffi::c_ulong,
        arg1: uprobe_opcode_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn uprobe_register(
        inode: *mut inode,
        offset: loff_t,
        uc: *mut uprobe_consumer,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn uprobe_register_refctr(
        inode: *mut inode,
        offset: loff_t,
        ref_ctr_offset: loff_t,
        uc: *mut uprobe_consumer,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn uprobe_apply(
        inode: *mut inode,
        offset: loff_t,
        uc: *mut uprobe_consumer,
        arg1: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn uprobe_unregister(inode: *mut inode, offset: loff_t, uc: *mut uprobe_consumer);
}
extern "C" {
    pub fn uprobe_mmap(vma: *mut vm_area_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn uprobe_munmap(
        vma: *mut vm_area_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn uprobe_start_dup_mmap();
}
extern "C" {
    pub fn uprobe_end_dup_mmap();
}
extern "C" {
    pub fn uprobe_dup_mmap(oldmm: *mut mm_struct, newmm: *mut mm_struct);
}
extern "C" {
    pub fn uprobe_free_utask(t: *mut task_struct);
}
extern "C" {
    pub fn uprobe_copy_process(t: *mut task_struct, flags: core::ffi::c_ulong);
}
extern "C" {
    pub fn uprobe_post_sstep_notifier(regs: *mut pt_regs) -> core::ffi::c_int;
}
extern "C" {
    pub fn uprobe_pre_sstep_notifier(regs: *mut pt_regs) -> core::ffi::c_int;
}
extern "C" {
    pub fn uprobe_notify_resume(regs: *mut pt_regs);
}
extern "C" {
    pub fn uprobe_deny_signal() -> bool_;
}
extern "C" {
    pub fn arch_uprobe_skip_sstep(aup: *mut arch_uprobe, regs: *mut pt_regs) -> bool_;
}
extern "C" {
    pub fn uprobe_clear_state(mm: *mut mm_struct);
}
extern "C" {
    pub fn arch_uprobe_analyze_insn(
        aup: *mut arch_uprobe,
        mm: *mut mm_struct,
        addr: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_uprobe_pre_xol(aup: *mut arch_uprobe, regs: *mut pt_regs) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_uprobe_post_xol(aup: *mut arch_uprobe, regs: *mut pt_regs) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_uprobe_xol_was_trapped(tsk: *mut task_struct) -> bool_;
}
extern "C" {
    pub fn arch_uprobe_exception_notify(
        self_: *mut notifier_block,
        val: core::ffi::c_ulong,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_uprobe_abort_xol(aup: *mut arch_uprobe, regs: *mut pt_regs);
}
extern "C" {
    pub fn arch_uretprobe_hijack_return_addr(
        trampoline_vaddr: core::ffi::c_ulong,
        regs: *mut pt_regs,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn arch_uretprobe_is_alive(
        ret: *mut return_instance,
        ctx: rp_check,
        regs: *mut pt_regs,
    ) -> bool_;
}
extern "C" {
    pub fn arch_uprobe_ignore(aup: *mut arch_uprobe, regs: *mut pt_regs) -> bool_;
}
extern "C" {
    pub fn arch_uprobe_copy_ixol(
        page: *mut page,
        vaddr: core::ffi::c_ulong,
        src: *mut core::ffi::c_void,
        len: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn dump_page(page: *mut page, reason: *const core::ffi::c_char);
}
extern "C" {
    pub fn dump_vma(vma: *const vm_area_struct);
}
extern "C" {
    pub fn dump_mm(mm: *const mm_struct);
}
extern "C" {
    pub fn vma_iter_dump_tree(vmi: *const vma_iterator);
}
extern "C" {
    pub static mut pcpu_base_addr: *mut core::ffi::c_void;
}
extern "C" {
    pub static mut pcpu_unit_offsets: *const core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pcpu_group_info {
    pub nr_units: core::ffi::c_int,
    pub base_offset: core::ffi::c_ulong,
    pub cpu_map: *mut core::ffi::c_uint,
}
impl Default for pcpu_group_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct pcpu_alloc_info {
    pub static_size: usize,
    pub reserved_size: usize,
    pub dyn_size: usize,
    pub unit_size: usize,
    pub atom_size: usize,
    pub alloc_size: usize,
    pub __ai_size: usize,
    pub nr_groups: core::ffi::c_int,
    pub groups: __IncompleteArrayField<pcpu_group_info>,
}
impl Default for pcpu_alloc_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const pcpu_fc_PCPU_FC_AUTO: pcpu_fc = 0;
pub const pcpu_fc_PCPU_FC_EMBED: pcpu_fc = 1;
pub const pcpu_fc_PCPU_FC_PAGE: pcpu_fc = 2;
pub const pcpu_fc_PCPU_FC_NR: pcpu_fc = 3;
pub type pcpu_fc = core::ffi::c_uint;
extern "C" {
    pub static pcpu_fc_names: [*const core::ffi::c_char; 3usize];
}
extern "C" {
    pub static mut pcpu_chosen_fc: pcpu_fc;
}
pub type pcpu_fc_cpu_to_node_fn_t =
    ::core::option::Option<unsafe extern "C" fn(cpu: core::ffi::c_int) -> core::ffi::c_int>;
pub type pcpu_fc_cpu_distance_fn_t = ::core::option::Option<
    unsafe extern "C" fn(from: core::ffi::c_uint, to: core::ffi::c_uint) -> core::ffi::c_int,
>;
extern "C" {
    pub fn pcpu_alloc_alloc_info(
        nr_groups: core::ffi::c_int,
        nr_units: core::ffi::c_int,
    ) -> *mut pcpu_alloc_info;
}
extern "C" {
    pub fn pcpu_free_alloc_info(ai: *mut pcpu_alloc_info);
}
extern "C" {
    pub fn pcpu_setup_first_chunk(ai: *const pcpu_alloc_info, base_addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn pcpu_embed_first_chunk(
        reserved_size: usize,
        dyn_size: usize,
        atom_size: usize,
        cpu_distance_fn: pcpu_fc_cpu_distance_fn_t,
        cpu_to_nd_fn: pcpu_fc_cpu_to_node_fn_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pcpu_populate_pte(addr: core::ffi::c_ulong);
}
extern "C" {
    pub fn pcpu_page_first_chunk(
        reserved_size: usize,
        cpu_to_nd_fn: pcpu_fc_cpu_to_node_fn_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __alloc_reserved_percpu(size: usize, align: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __is_kernel_percpu_address(
        addr: core::ffi::c_ulong,
        can_addr: *mut core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn is_kernel_percpu_address(addr: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn __alloc_percpu_gfp(size: usize, align: usize, gfp: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __alloc_percpu(size: usize, align: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn free_percpu(__pdata: *mut core::ffi::c_void);
}
extern "C" {
    pub fn pcpu_alloc_size(__pdata: *mut core::ffi::c_void) -> usize;
}
extern "C" {
    pub fn per_cpu_ptr_to_phys(addr: *mut core::ffi::c_void) -> phys_addr_t;
}
extern "C" {
    pub fn pcpu_nr_pages() -> core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_counter {
    pub lock: raw_spinlock_t,
    pub count: s64,
    pub list: list_head,
    pub counters: *mut s32,
}
impl Default for percpu_counter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut percpu_counter_batch: core::ffi::c_int;
}
extern "C" {
    pub fn __percpu_counter_init_many(
        fbc: *mut percpu_counter,
        amount: s64,
        gfp: gfp_t,
        nr_counters: u32_,
        key: *mut lock_class_key,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn percpu_counter_destroy_many(fbc: *mut percpu_counter, nr_counters: u32_);
}
extern "C" {
    pub fn percpu_counter_set(fbc: *mut percpu_counter, amount: s64);
}
extern "C" {
    pub fn percpu_counter_add_batch(fbc: *mut percpu_counter, amount: s64, batch: s32);
}
extern "C" {
    pub fn __percpu_counter_sum(fbc: *mut percpu_counter) -> s64;
}
extern "C" {
    pub fn __percpu_counter_compare(
        fbc: *mut percpu_counter,
        rhs: s64,
        batch: s32,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __percpu_counter_limited_add(
        fbc: *mut percpu_counter,
        limit: s64,
        amount: s64,
        batch: s32,
    ) -> bool_;
}
extern "C" {
    pub fn percpu_counter_sync(fbc: *mut percpu_counter);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_context_t {
    pub ctx_id: u64_,
    pub tlb_gen: atomic64_t,
    pub ldt_usr_sem: rw_semaphore,
    pub ldt: *mut ldt_struct,
    pub flags: core::ffi::c_ulong,
    pub lam_cr3_mask: core::ffi::c_ulong,
    pub untag_mask: u64_,
    pub lock: mutex,
    pub vdso: *mut core::ffi::c_void,
    pub vdso_image: *const vdso_image,
    pub perf_rdpmc_allowed: atomic_t,
    pub pkey_allocation_map: u16_,
    pub execute_only_pkey: s16,
}
impl Default for mm_context_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn leave_mm(cpu: core::ffi::c_int);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_cgroup {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct page {
    pub flags: core::ffi::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_2,
    pub _refcount: atomic_t,
    pub memcg_data: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: page__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: page__bindgen_ty_1__bindgen_ty_4,
    pub callback_head: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub mapping: *mut address_space,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub private: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub lru: list_head,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub buddy_list: list_head,
    pub pcp_list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __filler: *mut core::ffi::c_void,
    pub mlock_count: core::ffi::c_uint,
}
impl Default for page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub index: core::ffi::c_ulong,
    pub share: core::ffi::c_ulong,
}
impl Default for page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for page__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_2 {
    pub pp_magic: core::ffi::c_ulong,
    pub pp: *mut page_pool,
    pub _pp_mapping_pad: core::ffi::c_ulong,
    pub dma_addr: core::ffi::c_ulong,
    pub pp_ref_count: atomic_long_t,
}
impl Default for page__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_3 {
    pub compound_head: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_4 {
    pub pgmap: *mut dev_pagemap,
    pub zone_device_data: *mut core::ffi::c_void,
}
impl Default for page__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for page__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_2 {
    pub _mapcount: atomic_t,
    pub page_type: core::ffi::c_uint,
}
impl Default for page__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct encoded_page {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct swp_entry_t {
    pub val: core::ffi::c_ulong,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct folio {
    pub __bindgen_anon_1: folio__bindgen_ty_1,
    pub __bindgen_anon_2: folio__bindgen_ty_2,
    pub __bindgen_anon_3: folio__bindgen_ty_3,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1 {
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1,
    pub page: page,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_1__bindgen_ty_1 {
    pub flags: core::ffi::c_ulong,
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub mapping: *mut address_space,
    pub index: core::ffi::c_ulong,
    pub __bindgen_anon_2: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub _mapcount: atomic_t,
    pub _refcount: atomic_t,
    pub memcg_data: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub lru: list_head,
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __filler: *mut core::ffi::c_void,
    pub mlock_count: core::ffi::c_uint,
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub private: *mut core::ffi::c_void,
    pub swap: swp_entry_t,
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_2 {
    pub __bindgen_anon_1: folio__bindgen_ty_2__bindgen_ty_1,
    pub __page_1: page,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct folio__bindgen_ty_2__bindgen_ty_1 {
    pub _flags_1: core::ffi::c_ulong,
    pub _head_1: core::ffi::c_ulong,
    pub _folio_avail: core::ffi::c_ulong,
    pub _entire_mapcount: atomic_t,
    pub _nr_pages_mapped: atomic_t,
    pub _pincount: atomic_t,
    pub _folio_nr_pages: core::ffi::c_uint,
}
impl Default for folio__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_3 {
    pub __bindgen_anon_1: folio__bindgen_ty_3__bindgen_ty_1,
    pub __bindgen_anon_2: folio__bindgen_ty_3__bindgen_ty_2,
    pub __page_2: page,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_3__bindgen_ty_1 {
    pub _flags_2: core::ffi::c_ulong,
    pub _head_2: core::ffi::c_ulong,
    pub _hugetlb_subpool: *mut core::ffi::c_void,
    pub _hugetlb_cgroup: *mut core::ffi::c_void,
    pub _hugetlb_cgroup_rsvd: *mut core::ffi::c_void,
    pub _hugetlb_hwpoison: *mut core::ffi::c_void,
}
impl Default for folio__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_3__bindgen_ty_2 {
    pub _flags_2a: core::ffi::c_ulong,
    pub _head_2a: core::ffi::c_ulong,
    pub _deferred_list: list_head,
}
impl Default for folio__bindgen_ty_3__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ptdesc {
    pub __page_flags: core::ffi::c_ulong,
    pub __bindgen_anon_1: ptdesc__bindgen_ty_1,
    pub __page_mapping: core::ffi::c_ulong,
    pub __bindgen_anon_2: ptdesc__bindgen_ty_2,
    pub __bindgen_anon_3: ptdesc__bindgen_ty_3,
    pub __page_type: core::ffi::c_uint,
    pub __page_refcount: atomic_t,
    pub pt_memcg_data: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ptdesc__bindgen_ty_1 {
    pub pt_rcu_head: callback_head,
    pub pt_list: list_head,
    pub __bindgen_anon_1: ptdesc__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ptdesc__bindgen_ty_1__bindgen_ty_1 {
    pub _pt_pad_1: core::ffi::c_ulong,
    pub pmd_huge_pte: pgtable_t,
}
impl Default for ptdesc__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ptdesc__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ptdesc__bindgen_ty_2 {
    pub pt_mm: *mut mm_struct,
    pub pt_frag_refcount: atomic_t,
}
impl Default for ptdesc__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ptdesc__bindgen_ty_3 {
    pub _pt_pad_2: core::ffi::c_ulong,
    pub ptl: spinlock_t,
}
impl Default for ptdesc__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ptdesc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page_frag_cache {
    pub va: *mut core::ffi::c_void,
    pub offset: __u16,
    pub size: __u16,
    pub pagecnt_bias: core::ffi::c_uint,
    pub pfmemalloc: bool_,
}
impl Default for page_frag_cache {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vm_flags_t = core::ffi::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_region {
    pub vm_rb: rb_node,
    pub vm_flags: vm_flags_t,
    pub vm_start: core::ffi::c_ulong,
    pub vm_end: core::ffi::c_ulong,
    pub vm_top: core::ffi::c_ulong,
    pub vm_pgoff: core::ffi::c_ulong,
    pub vm_file: *mut file,
    pub vm_usage: core::ffi::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for vm_region {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl vm_region {
    #[inline]
    pub fn vm_icache_flushed(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vm_icache_flushed(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(vm_icache_flushed: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vm_icache_flushed: u8 = unsafe { ::core::mem::transmute(vm_icache_flushed) };
            vm_icache_flushed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_userfaultfd_ctx {
    pub ctx: *mut userfaultfd_ctx,
}
impl Default for vm_userfaultfd_ctx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct anon_vma_name {
    pub kref: kref,
    pub name: __IncompleteArrayField<core::ffi::c_char>,
}
extern "C" {
    pub fn anon_vma_name(vma: *mut vm_area_struct) -> *mut anon_vma_name;
}
extern "C" {
    pub fn anon_vma_name_alloc(name: *const core::ffi::c_char) -> *mut anon_vma_name;
}
extern "C" {
    pub fn anon_vma_name_free(kref: *mut kref);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vma_lock {
    pub lock: rw_semaphore,
}
impl Default for vma_lock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vma_numab_state {
    pub next_scan: core::ffi::c_ulong,
    pub pids_active_reset: core::ffi::c_ulong,
    pub pids_active: [core::ffi::c_ulong; 2usize],
    pub start_scan_seq: core::ffi::c_int,
    pub prev_scan_seq: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_area_struct {
    pub __bindgen_anon_1: vm_area_struct__bindgen_ty_1,
    pub vm_mm: *mut mm_struct,
    pub vm_page_prot: pgprot_t,
    pub __bindgen_anon_2: vm_area_struct__bindgen_ty_2,
    pub vm_lock_seq: core::ffi::c_int,
    pub vm_lock: *mut vma_lock,
    pub detached: bool_,
    pub shared: vm_area_struct__bindgen_ty_3,
    pub anon_vma_chain: list_head,
    pub anon_vma: *mut anon_vma,
    pub vm_ops: *const vm_operations_struct,
    pub vm_pgoff: core::ffi::c_ulong,
    pub vm_file: *mut file,
    pub vm_private_data: *mut core::ffi::c_void,
    pub anon_name: *mut anon_vma_name,
    pub swap_readahead_info: atomic_long_t,
    pub vm_policy: *mut mempolicy,
    pub numab_state: *mut vma_numab_state,
    pub vm_userfaultfd_ctx: vm_userfaultfd_ctx,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vm_area_struct__bindgen_ty_1 {
    pub __bindgen_anon_1: vm_area_struct__bindgen_ty_1__bindgen_ty_1,
    pub vm_rcu: callback_head,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vm_area_struct__bindgen_ty_1__bindgen_ty_1 {
    pub vm_start: core::ffi::c_ulong,
    pub vm_end: core::ffi::c_ulong,
}
impl Default for vm_area_struct__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vm_area_struct__bindgen_ty_2 {
    pub vm_flags: vm_flags_t,
    pub __vm_flags: vm_flags_t,
}
impl Default for vm_area_struct__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_area_struct__bindgen_ty_3 {
    pub rb: rb_node,
    pub rb_subtree_last: core::ffi::c_ulong,
}
impl Default for vm_area_struct__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vm_area_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mm_cid {
    pub time: u64_,
    pub cid: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kioctx_table {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_mm_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
pub struct mm_struct {
    pub __bindgen_anon_1: mm_struct__bindgen_ty_1,
    pub cpu_bitmap: __IncompleteArrayField<core::ffi::c_ulong>,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct mm_struct__bindgen_ty_1 {
    pub __bindgen_anon_1: mm_struct__bindgen_ty_1__bindgen_ty_1,
    pub mm_mt: maple_tree,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            filp: *mut file,
            addr: core::ffi::c_ulong,
            len: core::ffi::c_ulong,
            pgoff: core::ffi::c_ulong,
            flags: core::ffi::c_ulong,
        ) -> core::ffi::c_ulong,
    >,
    pub mmap_base: core::ffi::c_ulong,
    pub mmap_legacy_base: core::ffi::c_ulong,
    pub mmap_compat_base: core::ffi::c_ulong,
    pub mmap_compat_legacy_base: core::ffi::c_ulong,
    pub task_size: core::ffi::c_ulong,
    pub pgd: *mut pgd_t,
    pub membarrier_state: atomic_t,
    pub mm_users: atomic_t,
    pub pcpu_cid: *mut mm_cid,
    pub mm_cid_next_scan: core::ffi::c_ulong,
    pub pgtables_bytes: atomic_long_t,
    pub map_count: core::ffi::c_int,
    pub page_table_lock: spinlock_t,
    pub mmap_lock: rw_semaphore,
    pub mmlist: list_head,
    pub mm_lock_seq: core::ffi::c_int,
    pub hiwater_rss: core::ffi::c_ulong,
    pub hiwater_vm: core::ffi::c_ulong,
    pub total_vm: core::ffi::c_ulong,
    pub locked_vm: core::ffi::c_ulong,
    pub pinned_vm: atomic64_t,
    pub data_vm: core::ffi::c_ulong,
    pub exec_vm: core::ffi::c_ulong,
    pub stack_vm: core::ffi::c_ulong,
    pub def_flags: core::ffi::c_ulong,
    pub write_protect_seq: seqcount_t,
    pub arg_lock: spinlock_t,
    pub start_code: core::ffi::c_ulong,
    pub end_code: core::ffi::c_ulong,
    pub start_data: core::ffi::c_ulong,
    pub end_data: core::ffi::c_ulong,
    pub start_brk: core::ffi::c_ulong,
    pub brk: core::ffi::c_ulong,
    pub start_stack: core::ffi::c_ulong,
    pub arg_start: core::ffi::c_ulong,
    pub arg_end: core::ffi::c_ulong,
    pub env_start: core::ffi::c_ulong,
    pub env_end: core::ffi::c_ulong,
    pub saved_auxv: [core::ffi::c_ulong; 52usize],
    pub rss_stat: [percpu_counter; 4usize],
    pub binfmt: *mut linux_binfmt,
    pub context: mm_context_t,
    pub flags: core::ffi::c_ulong,
    pub ioctx_lock: spinlock_t,
    pub ioctx_table: *mut kioctx_table,
    pub owner: *mut task_struct,
    pub user_ns: *mut user_namespace,
    pub exe_file: *mut file,
    pub notifier_subscriptions: *mut mmu_notifier_subscriptions,
    pub numa_next_scan: core::ffi::c_ulong,
    pub numa_scan_offset: core::ffi::c_ulong,
    pub numa_scan_seq: core::ffi::c_int,
    pub tlb_flush_pending: atomic_t,
    pub tlb_flush_batched: atomic_t,
    pub uprobes_state: uprobes_state,
    pub hugetlb_usage: atomic_long_t,
    pub async_put_work: work_struct,
    pub iommu_mm: *mut iommu_mm_data,
    pub ksm_merging_pages: core::ffi::c_ulong,
    pub ksm_rmap_items: core::ffi::c_ulong,
    pub ksm_zero_pages: atomic_long_t,
    pub lru_gen: mm_struct__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct mm_struct__bindgen_ty_1__bindgen_ty_1 {
    pub mm_count: atomic_t,
}
impl Default for mm_struct__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_struct__bindgen_ty_1__bindgen_ty_2 {
    pub list: list_head,
    pub bitmap: core::ffi::c_ulong,
    pub memcg: *mut mem_cgroup,
}
impl Default for mm_struct__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mm_struct__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mm_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut init_mm: mm_struct;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lru_gen_mm_list {
    pub fifo: list_head,
    pub lock: spinlock_t,
}
impl Default for lru_gen_mm_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lru_gen_add_mm(mm: *mut mm_struct);
}
extern "C" {
    pub fn lru_gen_del_mm(mm: *mut mm_struct);
}
extern "C" {
    pub fn lru_gen_migrate_mm(mm: *mut mm_struct);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vma_iterator {
    pub mas: ma_state,
}
impl Default for vma_iterator {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const mm_cid_state_MM_CID_UNSET: mm_cid_state = 4294967295;
pub const mm_cid_state_MM_CID_LAZY_PUT: mm_cid_state = 2147483648;
pub type mm_cid_state = core::ffi::c_uint;
extern "C" {
    pub fn tlb_gather_mmu(tlb: *mut mmu_gather, mm: *mut mm_struct);
}
extern "C" {
    pub fn tlb_gather_mmu_fullmm(tlb: *mut mmu_gather, mm: *mut mm_struct);
}
extern "C" {
    pub fn tlb_finish_mmu(tlb: *mut mmu_gather);
}
pub type vm_fault_t = core::ffi::c_uint;
pub const vm_fault_reason_VM_FAULT_OOM: vm_fault_reason = 1;
pub const vm_fault_reason_VM_FAULT_SIGBUS: vm_fault_reason = 2;
pub const vm_fault_reason_VM_FAULT_MAJOR: vm_fault_reason = 4;
pub const vm_fault_reason_VM_FAULT_HWPOISON: vm_fault_reason = 16;
pub const vm_fault_reason_VM_FAULT_HWPOISON_LARGE: vm_fault_reason = 32;
pub const vm_fault_reason_VM_FAULT_SIGSEGV: vm_fault_reason = 64;
pub const vm_fault_reason_VM_FAULT_NOPAGE: vm_fault_reason = 256;
pub const vm_fault_reason_VM_FAULT_LOCKED: vm_fault_reason = 512;
pub const vm_fault_reason_VM_FAULT_RETRY: vm_fault_reason = 1024;
pub const vm_fault_reason_VM_FAULT_FALLBACK: vm_fault_reason = 2048;
pub const vm_fault_reason_VM_FAULT_DONE_COW: vm_fault_reason = 4096;
pub const vm_fault_reason_VM_FAULT_NEEDDSYNC: vm_fault_reason = 8192;
pub const vm_fault_reason_VM_FAULT_COMPLETED: vm_fault_reason = 16384;
pub const vm_fault_reason_VM_FAULT_HINDEX_MASK: vm_fault_reason = 983040;
pub type vm_fault_reason = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_special_mapping {
    pub name: *const core::ffi::c_char,
    pub pages: *mut *mut page,
    pub fault: ::core::option::Option<
        unsafe extern "C" fn(
            sm: *const vm_special_mapping,
            vma: *mut vm_area_struct,
            vmf: *mut vm_fault,
        ) -> vm_fault_t,
    >,
    pub mremap: ::core::option::Option<
        unsafe extern "C" fn(
            sm: *const vm_special_mapping,
            new_vma: *mut vm_area_struct,
        ) -> core::ffi::c_int,
    >,
}
impl Default for vm_special_mapping {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const tlb_flush_reason_TLB_FLUSH_ON_TASK_SWITCH: tlb_flush_reason = 0;
pub const tlb_flush_reason_TLB_REMOTE_SHOOTDOWN: tlb_flush_reason = 1;
pub const tlb_flush_reason_TLB_LOCAL_SHOOTDOWN: tlb_flush_reason = 2;
pub const tlb_flush_reason_TLB_LOCAL_MM_SHOOTDOWN: tlb_flush_reason = 3;
pub const tlb_flush_reason_TLB_REMOTE_SEND_IPI: tlb_flush_reason = 4;
pub const tlb_flush_reason_NR_TLB_FLUSH_REASONS: tlb_flush_reason = 5;
pub type tlb_flush_reason = core::ffi::c_uint;
pub const fault_flag_FAULT_FLAG_WRITE: fault_flag = 1;
pub const fault_flag_FAULT_FLAG_MKWRITE: fault_flag = 2;
pub const fault_flag_FAULT_FLAG_ALLOW_RETRY: fault_flag = 4;
pub const fault_flag_FAULT_FLAG_RETRY_NOWAIT: fault_flag = 8;
pub const fault_flag_FAULT_FLAG_KILLABLE: fault_flag = 16;
pub const fault_flag_FAULT_FLAG_TRIED: fault_flag = 32;
pub const fault_flag_FAULT_FLAG_USER: fault_flag = 64;
pub const fault_flag_FAULT_FLAG_REMOTE: fault_flag = 128;
pub const fault_flag_FAULT_FLAG_INSTRUCTION: fault_flag = 256;
pub const fault_flag_FAULT_FLAG_INTERRUPTIBLE: fault_flag = 512;
pub const fault_flag_FAULT_FLAG_UNSHARE: fault_flag = 1024;
pub const fault_flag_FAULT_FLAG_ORIG_PTE_VALID: fault_flag = 2048;
pub const fault_flag_FAULT_FLAG_VMA_LOCK: fault_flag = 4096;
pub type fault_flag = core::ffi::c_uint;
pub type zap_flags_t = core::ffi::c_uint;
pub const FOLL_WRITE: _bindgen_ty_12 = 1;
pub const FOLL_GET: _bindgen_ty_12 = 2;
pub const FOLL_DUMP: _bindgen_ty_12 = 4;
pub const FOLL_FORCE: _bindgen_ty_12 = 8;
pub const FOLL_NOWAIT: _bindgen_ty_12 = 16;
pub const FOLL_NOFAULT: _bindgen_ty_12 = 32;
pub const FOLL_HWPOISON: _bindgen_ty_12 = 64;
pub const FOLL_ANON: _bindgen_ty_12 = 128;
pub const FOLL_LONGTERM: _bindgen_ty_12 = 256;
pub const FOLL_SPLIT_PMD: _bindgen_ty_12 = 512;
pub const FOLL_PCI_P2PDMA: _bindgen_ty_12 = 1024;
pub const FOLL_INTERRUPTIBLE: _bindgen_ty_12 = 2048;
pub const FOLL_HONOR_NUMA_FAULT: _bindgen_ty_12 = 4096;
pub type _bindgen_ty_12 = core::ffi::c_uint;
pub const pageflags_PG_locked: pageflags = 0;
pub const pageflags_PG_writeback: pageflags = 1;
pub const pageflags_PG_referenced: pageflags = 2;
pub const pageflags_PG_uptodate: pageflags = 3;
pub const pageflags_PG_dirty: pageflags = 4;
pub const pageflags_PG_lru: pageflags = 5;
pub const pageflags_PG_head: pageflags = 6;
pub const pageflags_PG_waiters: pageflags = 7;
pub const pageflags_PG_active: pageflags = 8;
pub const pageflags_PG_workingset: pageflags = 9;
pub const pageflags_PG_error: pageflags = 10;
pub const pageflags_PG_slab: pageflags = 11;
pub const pageflags_PG_owner_priv_1: pageflags = 12;
pub const pageflags_PG_arch_1: pageflags = 13;
pub const pageflags_PG_reserved: pageflags = 14;
pub const pageflags_PG_private: pageflags = 15;
pub const pageflags_PG_private_2: pageflags = 16;
pub const pageflags_PG_mappedtodisk: pageflags = 17;
pub const pageflags_PG_reclaim: pageflags = 18;
pub const pageflags_PG_swapbacked: pageflags = 19;
pub const pageflags_PG_unevictable: pageflags = 20;
pub const pageflags_PG_mlocked: pageflags = 21;
pub const pageflags_PG_uncached: pageflags = 22;
pub const pageflags_PG_hwpoison: pageflags = 23;
pub const pageflags_PG_young: pageflags = 24;
pub const pageflags_PG_idle: pageflags = 25;
pub const pageflags___NR_PAGEFLAGS: pageflags = 26;
pub const pageflags_PG_readahead: pageflags = 18;
pub const pageflags_PG_anon_exclusive: pageflags = 17;
pub const pageflags_PG_checked: pageflags = 12;
pub const pageflags_PG_swapcache: pageflags = 12;
pub const pageflags_PG_fscache: pageflags = 16;
pub const pageflags_PG_pinned: pageflags = 12;
pub const pageflags_PG_savepinned: pageflags = 4;
pub const pageflags_PG_foreign: pageflags = 12;
pub const pageflags_PG_xen_remapped: pageflags = 12;
pub const pageflags_PG_isolated: pageflags = 18;
pub const pageflags_PG_reported: pageflags = 3;
pub const pageflags_PG_vmemmap_self_hosted: pageflags = 12;
pub const pageflags_PG_has_hwpoisoned: pageflags = 10;
pub const pageflags_PG_large_rmappable: pageflags = 9;
pub type pageflags = core::ffi::c_uint;
extern "C" {
    pub static mut hugetlb_optimize_vmemmap_key: static_key_false;
}
extern "C" {
    pub fn SetPageHWPoisonTakenOff(page: *mut page);
}
extern "C" {
    pub fn ClearPageHWPoisonTakenOff(page: *mut page);
}
extern "C" {
    pub fn take_page_off_buddy(page: *mut page) -> bool_;
}
extern "C" {
    pub fn put_page_back_buddy(page: *mut page) -> bool_;
}
extern "C" {
    pub fn stable_page_flags(page: *mut page) -> u64_;
}
extern "C" {
    pub fn __folio_start_writeback(folio: *mut folio, keep_write: bool_);
}
extern "C" {
    pub fn set_page_writeback(page: *mut page);
}
extern "C" {
    pub fn page_offline_freeze();
}
extern "C" {
    pub fn page_offline_thaw();
}
extern "C" {
    pub fn page_offline_begin();
}
extern "C" {
    pub fn page_offline_end();
}
extern "C" {
    pub fn is_free_buddy_page(page: *mut page) -> bool_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct local_lock_t {}
extern "C" {
    pub static mut zswap_pool_total_size: u64_;
}
extern "C" {
    pub static mut zswap_stored_pages: atomic_t;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct zswap_lruvec_state {
    pub nr_zswap_protected: atomic_long_t,
}
extern "C" {
    pub fn zswap_store(folio: *mut folio) -> bool_;
}
extern "C" {
    pub fn zswap_load(folio: *mut folio) -> bool_;
}
extern "C" {
    pub fn zswap_invalidate(type_: core::ffi::c_int, offset: core::ffi::c_ulong);
}
extern "C" {
    pub fn zswap_swapon(type_: core::ffi::c_int);
}
extern "C" {
    pub fn zswap_swapoff(type_: core::ffi::c_int);
}
extern "C" {
    pub fn zswap_memcg_offline_cleanup(memcg: *mut mem_cgroup);
}
extern "C" {
    pub fn zswap_lruvec_state_init(lruvec: *mut lruvec);
}
extern "C" {
    pub fn zswap_folio_swapin(folio: *mut folio);
}
extern "C" {
    pub fn is_zswap_enabled() -> bool_;
}
pub const migratetype_MIGRATE_UNMOVABLE: migratetype = 0;
pub const migratetype_MIGRATE_MOVABLE: migratetype = 1;
pub const migratetype_MIGRATE_RECLAIMABLE: migratetype = 2;
pub const migratetype_MIGRATE_PCPTYPES: migratetype = 3;
pub const migratetype_MIGRATE_HIGHATOMIC: migratetype = 3;
pub const migratetype_MIGRATE_ISOLATE: migratetype = 4;
pub const migratetype_MIGRATE_TYPES: migratetype = 5;
pub type migratetype = core::ffi::c_uint;
extern "C" {
    pub static migratetype_names: [*const core::ffi::c_char; 5usize];
}
extern "C" {
    pub static mut page_group_by_mobility_disabled: core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct free_area {
    pub free_list: [list_head; 5usize],
    pub nr_free: core::ffi::c_ulong,
}
impl Default for free_area {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const numa_stat_item_NUMA_HIT: numa_stat_item = 0;
pub const numa_stat_item_NUMA_MISS: numa_stat_item = 1;
pub const numa_stat_item_NUMA_FOREIGN: numa_stat_item = 2;
pub const numa_stat_item_NUMA_INTERLEAVE_HIT: numa_stat_item = 3;
pub const numa_stat_item_NUMA_LOCAL: numa_stat_item = 4;
pub const numa_stat_item_NUMA_OTHER: numa_stat_item = 5;
pub const numa_stat_item_NR_VM_NUMA_EVENT_ITEMS: numa_stat_item = 6;
pub type numa_stat_item = core::ffi::c_uint;
pub const zone_stat_item_NR_FREE_PAGES: zone_stat_item = 0;
pub const zone_stat_item_NR_ZONE_LRU_BASE: zone_stat_item = 1;
pub const zone_stat_item_NR_ZONE_INACTIVE_ANON: zone_stat_item = 1;
pub const zone_stat_item_NR_ZONE_ACTIVE_ANON: zone_stat_item = 2;
pub const zone_stat_item_NR_ZONE_INACTIVE_FILE: zone_stat_item = 3;
pub const zone_stat_item_NR_ZONE_ACTIVE_FILE: zone_stat_item = 4;
pub const zone_stat_item_NR_ZONE_UNEVICTABLE: zone_stat_item = 5;
pub const zone_stat_item_NR_ZONE_WRITE_PENDING: zone_stat_item = 6;
pub const zone_stat_item_NR_MLOCK: zone_stat_item = 7;
pub const zone_stat_item_NR_BOUNCE: zone_stat_item = 8;
pub const zone_stat_item_NR_ZSPAGES: zone_stat_item = 9;
pub const zone_stat_item_NR_FREE_CMA_PAGES: zone_stat_item = 10;
pub const zone_stat_item_NR_UNACCEPTED: zone_stat_item = 11;
pub const zone_stat_item_NR_VM_ZONE_STAT_ITEMS: zone_stat_item = 12;
pub type zone_stat_item = core::ffi::c_uint;
pub const node_stat_item_NR_LRU_BASE: node_stat_item = 0;
pub const node_stat_item_NR_INACTIVE_ANON: node_stat_item = 0;
pub const node_stat_item_NR_ACTIVE_ANON: node_stat_item = 1;
pub const node_stat_item_NR_INACTIVE_FILE: node_stat_item = 2;
pub const node_stat_item_NR_ACTIVE_FILE: node_stat_item = 3;
pub const node_stat_item_NR_UNEVICTABLE: node_stat_item = 4;
pub const node_stat_item_NR_SLAB_RECLAIMABLE_B: node_stat_item = 5;
pub const node_stat_item_NR_SLAB_UNRECLAIMABLE_B: node_stat_item = 6;
pub const node_stat_item_NR_ISOLATED_ANON: node_stat_item = 7;
pub const node_stat_item_NR_ISOLATED_FILE: node_stat_item = 8;
pub const node_stat_item_WORKINGSET_NODES: node_stat_item = 9;
pub const node_stat_item_WORKINGSET_REFAULT_BASE: node_stat_item = 10;
pub const node_stat_item_WORKINGSET_REFAULT_ANON: node_stat_item = 10;
pub const node_stat_item_WORKINGSET_REFAULT_FILE: node_stat_item = 11;
pub const node_stat_item_WORKINGSET_ACTIVATE_BASE: node_stat_item = 12;
pub const node_stat_item_WORKINGSET_ACTIVATE_ANON: node_stat_item = 12;
pub const node_stat_item_WORKINGSET_ACTIVATE_FILE: node_stat_item = 13;
pub const node_stat_item_WORKINGSET_RESTORE_BASE: node_stat_item = 14;
pub const node_stat_item_WORKINGSET_RESTORE_ANON: node_stat_item = 14;
pub const node_stat_item_WORKINGSET_RESTORE_FILE: node_stat_item = 15;
pub const node_stat_item_WORKINGSET_NODERECLAIM: node_stat_item = 16;
pub const node_stat_item_NR_ANON_MAPPED: node_stat_item = 17;
pub const node_stat_item_NR_FILE_MAPPED: node_stat_item = 18;
pub const node_stat_item_NR_FILE_PAGES: node_stat_item = 19;
pub const node_stat_item_NR_FILE_DIRTY: node_stat_item = 20;
pub const node_stat_item_NR_WRITEBACK: node_stat_item = 21;
pub const node_stat_item_NR_WRITEBACK_TEMP: node_stat_item = 22;
pub const node_stat_item_NR_SHMEM: node_stat_item = 23;
pub const node_stat_item_NR_SHMEM_THPS: node_stat_item = 24;
pub const node_stat_item_NR_SHMEM_PMDMAPPED: node_stat_item = 25;
pub const node_stat_item_NR_FILE_THPS: node_stat_item = 26;
pub const node_stat_item_NR_FILE_PMDMAPPED: node_stat_item = 27;
pub const node_stat_item_NR_ANON_THPS: node_stat_item = 28;
pub const node_stat_item_NR_VMSCAN_WRITE: node_stat_item = 29;
pub const node_stat_item_NR_VMSCAN_IMMEDIATE: node_stat_item = 30;
pub const node_stat_item_NR_DIRTIED: node_stat_item = 31;
pub const node_stat_item_NR_WRITTEN: node_stat_item = 32;
pub const node_stat_item_NR_THROTTLED_WRITTEN: node_stat_item = 33;
pub const node_stat_item_NR_KERNEL_MISC_RECLAIMABLE: node_stat_item = 34;
pub const node_stat_item_NR_FOLL_PIN_ACQUIRED: node_stat_item = 35;
pub const node_stat_item_NR_FOLL_PIN_RELEASED: node_stat_item = 36;
pub const node_stat_item_NR_KERNEL_STACK_KB: node_stat_item = 37;
pub const node_stat_item_NR_PAGETABLE: node_stat_item = 38;
pub const node_stat_item_NR_SECONDARY_PAGETABLE: node_stat_item = 39;
pub const node_stat_item_NR_SWAPCACHE: node_stat_item = 40;
pub const node_stat_item_PGPROMOTE_SUCCESS: node_stat_item = 41;
pub const node_stat_item_PGPROMOTE_CANDIDATE: node_stat_item = 42;
pub const node_stat_item_PGDEMOTE_KSWAPD: node_stat_item = 43;
pub const node_stat_item_PGDEMOTE_DIRECT: node_stat_item = 44;
pub const node_stat_item_PGDEMOTE_KHUGEPAGED: node_stat_item = 45;
pub const node_stat_item_NR_VM_NODE_STAT_ITEMS: node_stat_item = 46;
pub type node_stat_item = core::ffi::c_uint;
pub const lru_list_LRU_INACTIVE_ANON: lru_list = 0;
pub const lru_list_LRU_ACTIVE_ANON: lru_list = 1;
pub const lru_list_LRU_INACTIVE_FILE: lru_list = 2;
pub const lru_list_LRU_ACTIVE_FILE: lru_list = 3;
pub const lru_list_LRU_UNEVICTABLE: lru_list = 4;
pub const lru_list_NR_LRU_LISTS: lru_list = 5;
pub type lru_list = core::ffi::c_uint;
pub const vmscan_throttle_state_VMSCAN_THROTTLE_WRITEBACK: vmscan_throttle_state = 0;
pub const vmscan_throttle_state_VMSCAN_THROTTLE_ISOLATED: vmscan_throttle_state = 1;
pub const vmscan_throttle_state_VMSCAN_THROTTLE_NOPROGRESS: vmscan_throttle_state = 2;
pub const vmscan_throttle_state_VMSCAN_THROTTLE_CONGESTED: vmscan_throttle_state = 3;
pub const vmscan_throttle_state_NR_VMSCAN_THROTTLE: vmscan_throttle_state = 4;
pub type vmscan_throttle_state = core::ffi::c_uint;
pub const lruvec_flags_LRUVEC_CGROUP_CONGESTED: lruvec_flags = 0;
pub const lruvec_flags_LRUVEC_NODE_CONGESTED: lruvec_flags = 1;
pub type lruvec_flags = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page_vma_mapped_walk {
    _unused: [u8; 0],
}
pub const LRU_GEN_ANON: _bindgen_ty_13 = 0;
pub const LRU_GEN_FILE: _bindgen_ty_13 = 1;
pub type _bindgen_ty_13 = core::ffi::c_uint;
pub const LRU_GEN_CORE: _bindgen_ty_14 = 0;
pub const LRU_GEN_MM_WALK: _bindgen_ty_14 = 1;
pub const LRU_GEN_NONLEAF_YOUNG: _bindgen_ty_14 = 2;
pub const NR_LRU_GEN_CAPS: _bindgen_ty_14 = 3;
pub type _bindgen_ty_14 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lru_gen_folio {
    pub max_seq: core::ffi::c_ulong,
    pub min_seq: [core::ffi::c_ulong; 2usize],
    pub timestamps: [core::ffi::c_ulong; 4usize],
    pub folios: [[[list_head; 5usize]; 2usize]; 4usize],
    pub nr_pages: [[[core::ffi::c_long; 5usize]; 2usize]; 4usize],
    pub avg_refaulted: [[core::ffi::c_ulong; 4usize]; 2usize],
    pub avg_total: [[core::ffi::c_ulong; 4usize]; 2usize],
    pub protected: [[[core::ffi::c_ulong; 3usize]; 2usize]; 1usize],
    pub evicted: [[[atomic_long_t; 4usize]; 2usize]; 1usize],
    pub refaulted: [[[atomic_long_t; 4usize]; 2usize]; 1usize],
    pub enabled: bool_,
    pub gen: u8_,
    pub seg: u8_,
    pub list: hlist_nulls_node,
}
impl Default for lru_gen_folio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const MM_LEAF_TOTAL: _bindgen_ty_15 = 0;
pub const MM_LEAF_OLD: _bindgen_ty_15 = 1;
pub const MM_LEAF_YOUNG: _bindgen_ty_15 = 2;
pub const MM_NONLEAF_TOTAL: _bindgen_ty_15 = 3;
pub const MM_NONLEAF_FOUND: _bindgen_ty_15 = 4;
pub const MM_NONLEAF_ADDED: _bindgen_ty_15 = 5;
pub const NR_MM_STATS: _bindgen_ty_15 = 6;
pub type _bindgen_ty_15 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lru_gen_mm_state {
    pub seq: core::ffi::c_ulong,
    pub head: *mut list_head,
    pub tail: *mut list_head,
    pub filters: [*mut core::ffi::c_ulong; 2usize],
    pub stats: [[core::ffi::c_ulong; 6usize]; 1usize],
}
impl Default for lru_gen_mm_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lru_gen_mm_walk {
    pub lruvec: *mut lruvec,
    pub max_seq: core::ffi::c_ulong,
    pub next_addr: core::ffi::c_ulong,
    pub nr_pages: [[[core::ffi::c_int; 5usize]; 2usize]; 4usize],
    pub mm_stats: [core::ffi::c_int; 6usize],
    pub batched: core::ffi::c_int,
    pub can_swap: bool_,
    pub force_scan: bool_,
}
impl Default for lru_gen_mm_walk {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lru_gen_memcg {
    pub seq: core::ffi::c_ulong,
    pub nr_memcgs: [core::ffi::c_ulong; 3usize],
    pub fifo: [[hlist_nulls_head; 8usize]; 3usize],
    pub lock: spinlock_t,
}
impl Default for lru_gen_memcg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lru_gen_init_pgdat(pgdat: *mut pglist_data);
}
extern "C" {
    pub fn lru_gen_init_lruvec(lruvec: *mut lruvec);
}
extern "C" {
    pub fn lru_gen_look_around(pvmw: *mut page_vma_mapped_walk);
}
extern "C" {
    pub fn lru_gen_init_memcg(memcg: *mut mem_cgroup);
}
extern "C" {
    pub fn lru_gen_exit_memcg(memcg: *mut mem_cgroup);
}
extern "C" {
    pub fn lru_gen_online_memcg(memcg: *mut mem_cgroup);
}
extern "C" {
    pub fn lru_gen_offline_memcg(memcg: *mut mem_cgroup);
}
extern "C" {
    pub fn lru_gen_release_memcg(memcg: *mut mem_cgroup);
}
extern "C" {
    pub fn lru_gen_soft_reclaim(memcg: *mut mem_cgroup, nid: core::ffi::c_int);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lruvec {
    pub lists: [list_head; 5usize],
    pub lru_lock: spinlock_t,
    pub anon_cost: core::ffi::c_ulong,
    pub file_cost: core::ffi::c_ulong,
    pub nonresident_age: atomic_long_t,
    pub refaults: [core::ffi::c_ulong; 2usize],
    pub flags: core::ffi::c_ulong,
    pub lrugen: lru_gen_folio,
    pub mm_state: lru_gen_mm_state,
    pub pgdat: *mut pglist_data,
    pub zswap_lruvec_state: zswap_lruvec_state,
}
impl Default for lruvec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type isolate_mode_t = core::ffi::c_uint;
pub const zone_watermarks_WMARK_MIN: zone_watermarks = 0;
pub const zone_watermarks_WMARK_LOW: zone_watermarks = 1;
pub const zone_watermarks_WMARK_HIGH: zone_watermarks = 2;
pub const zone_watermarks_WMARK_PROMO: zone_watermarks = 3;
pub const zone_watermarks_NR_WMARK: zone_watermarks = 4;
pub type zone_watermarks = core::ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct per_cpu_pages {
    pub lock: spinlock_t,
    pub count: core::ffi::c_int,
    pub high: core::ffi::c_int,
    pub high_min: core::ffi::c_int,
    pub high_max: core::ffi::c_int,
    pub batch: core::ffi::c_int,
    pub flags: u8_,
    pub alloc_factor: u8_,
    pub expire: u8_,
    pub free_count: core::ffi::c_short,
    pub lists: [list_head; 13usize],
}
impl Default for per_cpu_pages {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct per_cpu_zonestat {
    pub vm_stat_diff: [s8; 12usize],
    pub stat_threshold: s8,
    pub vm_numa_event: [core::ffi::c_ulong; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct per_cpu_nodestat {
    pub stat_threshold: s8,
    pub vm_node_stat_diff: [s8; 46usize],
}
impl Default for per_cpu_nodestat {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const zone_type_ZONE_DMA: zone_type = 0;
pub const zone_type_ZONE_DMA32: zone_type = 1;
pub const zone_type_ZONE_NORMAL: zone_type = 2;
pub const zone_type_ZONE_MOVABLE: zone_type = 3;
pub const zone_type_ZONE_DEVICE: zone_type = 4;
pub const zone_type___MAX_NR_ZONES: zone_type = 5;
pub type zone_type = core::ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
pub struct zone {
    pub _watermark: [core::ffi::c_ulong; 4usize],
    pub watermark_boost: core::ffi::c_ulong,
    pub nr_reserved_highatomic: core::ffi::c_ulong,
    pub lowmem_reserve: [core::ffi::c_long; 5usize],
    pub node: core::ffi::c_int,
    pub zone_pgdat: *mut pglist_data,
    pub per_cpu_pageset: *mut per_cpu_pages,
    pub per_cpu_zonestats: *mut per_cpu_zonestat,
    pub pageset_high_min: core::ffi::c_int,
    pub pageset_high_max: core::ffi::c_int,
    pub pageset_batch: core::ffi::c_int,
    pub zone_start_pfn: core::ffi::c_ulong,
    pub managed_pages: atomic_long_t,
    pub spanned_pages: core::ffi::c_ulong,
    pub present_pages: core::ffi::c_ulong,
    pub present_early_pages: core::ffi::c_ulong,
    pub name: *const core::ffi::c_char,
    pub nr_isolate_pageblock: core::ffi::c_ulong,
    pub span_seqlock: seqlock_t,
    pub initialized: core::ffi::c_int,
    pub __bindgen_padding_0: [u64; 6usize],
    pub _pad1_: cacheline_padding,
    pub free_area: [free_area; 11usize],
    pub unaccepted_pages: list_head,
    pub flags: core::ffi::c_ulong,
    pub lock: spinlock_t,
    pub __bindgen_padding_1: [u64; 3usize],
    pub _pad2_: cacheline_padding,
    pub percpu_drift_mark: core::ffi::c_ulong,
    pub compact_cached_free_pfn: core::ffi::c_ulong,
    pub compact_cached_migrate_pfn: [core::ffi::c_ulong; 2usize],
    pub compact_init_migrate_pfn: core::ffi::c_ulong,
    pub compact_init_free_pfn: core::ffi::c_ulong,
    pub compact_considered: core::ffi::c_uint,
    pub compact_defer_shift: core::ffi::c_uint,
    pub compact_order_failed: core::ffi::c_int,
    pub compact_blockskip_flush: bool_,
    pub contiguous: bool_,
    pub __bindgen_padding_2: [u64; 0usize],
    pub _pad3_: cacheline_padding,
    pub vm_stat: [atomic_long_t; 12usize],
    pub vm_numa_event: [atomic_long_t; 6usize],
}
impl Default for zone {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const pgdat_flags_PGDAT_DIRTY: pgdat_flags = 0;
pub const pgdat_flags_PGDAT_WRITEBACK: pgdat_flags = 1;
pub const pgdat_flags_PGDAT_RECLAIM_LOCKED: pgdat_flags = 2;
pub type pgdat_flags = core::ffi::c_uint;
pub const zone_flags_ZONE_BOOSTED_WATERMARK: zone_flags = 0;
pub const zone_flags_ZONE_RECLAIM_ACTIVE: zone_flags = 1;
pub const zone_flags_ZONE_BELOW_HIGH: zone_flags = 2;
pub type zone_flags = core::ffi::c_uint;
extern "C" {
    pub fn memmap_init_zone_device(
        arg1: *mut zone,
        arg2: core::ffi::c_ulong,
        arg3: core::ffi::c_ulong,
        arg4: *mut dev_pagemap,
    );
}
pub const ZONELIST_FALLBACK: _bindgen_ty_16 = 0;
pub const ZONELIST_NOFALLBACK: _bindgen_ty_16 = 1;
pub const MAX_ZONELISTS: _bindgen_ty_16 = 2;
pub type _bindgen_ty_16 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zoneref {
    pub zone: *mut zone,
    pub zone_idx: core::ffi::c_int,
}
impl Default for zoneref {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zonelist {
    pub _zonerefs: [zoneref; 5121usize],
}
impl Default for zonelist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut mem_map: *mut page;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct deferred_split {
    pub split_queue_lock: spinlock_t,
    pub split_queue: list_head,
    pub split_queue_len: core::ffi::c_ulong,
}
impl Default for deferred_split {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct memory_failure_stats {
    pub total: core::ffi::c_ulong,
    pub ignored: core::ffi::c_ulong,
    pub failed: core::ffi::c_ulong,
    pub delayed: core::ffi::c_ulong,
    pub recovered: core::ffi::c_ulong,
}
#[repr(C)]
#[repr(align(64))]
pub struct pglist_data {
    pub node_zones: [zone; 5usize],
    pub node_zonelists: [zonelist; 2usize],
    pub nr_zones: core::ffi::c_int,
    pub node_size_lock: spinlock_t,
    pub node_start_pfn: core::ffi::c_ulong,
    pub node_present_pages: core::ffi::c_ulong,
    pub node_spanned_pages: core::ffi::c_ulong,
    pub node_id: core::ffi::c_int,
    pub kswapd_wait: wait_queue_head_t,
    pub pfmemalloc_wait: wait_queue_head_t,
    pub reclaim_wait: [wait_queue_head_t; 4usize],
    pub nr_writeback_throttled: atomic_t,
    pub nr_reclaim_start: core::ffi::c_ulong,
    pub kswapd_lock: mutex,
    pub kswapd: *mut task_struct,
    pub kswapd_order: core::ffi::c_int,
    pub kswapd_highest_zoneidx: zone_type,
    pub kswapd_failures: core::ffi::c_int,
    pub kcompactd_max_order: core::ffi::c_int,
    pub kcompactd_highest_zoneidx: zone_type,
    pub kcompactd_wait: wait_queue_head_t,
    pub kcompactd: *mut task_struct,
    pub proactive_compact_trigger: bool_,
    pub totalreserve_pages: core::ffi::c_ulong,
    pub min_unmapped_pages: core::ffi::c_ulong,
    pub min_slab_pages: core::ffi::c_ulong,
    pub __bindgen_padding_0: [u64; 3usize],
    pub _pad1_: cacheline_padding,
    pub deferred_split_queue: deferred_split,
    pub nbp_rl_start: core::ffi::c_uint,
    pub nbp_rl_nr_cand: core::ffi::c_ulong,
    pub nbp_threshold: core::ffi::c_uint,
    pub nbp_th_start: core::ffi::c_uint,
    pub nbp_th_nr_cand: core::ffi::c_ulong,
    pub __lruvec: lruvec,
    pub flags: core::ffi::c_ulong,
    pub mm_walk: lru_gen_mm_walk,
    pub memcg_lru: lru_gen_memcg,
    pub __bindgen_padding_1: u64,
    pub _pad2_: cacheline_padding,
    pub per_cpu_nodestats: *mut per_cpu_nodestat,
    pub vm_stat: [atomic_long_t; 46usize],
    pub memtier: *mut memory_tier,
    pub mf_stats: memory_failure_stats,
}
impl Default for pglist_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pg_data_t = pglist_data;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memory_group {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut node_data: [*mut pg_data_t; 0usize];
}
extern "C" {
    pub fn pfn_to_online_page(pfn: core::ffi::c_ulong) -> *mut page;
}
pub const MMOP_OFFLINE: _bindgen_ty_17 = 0;
pub const MMOP_ONLINE: _bindgen_ty_17 = 1;
pub const MMOP_ONLINE_KERNEL: _bindgen_ty_17 = 2;
pub const MMOP_ONLINE_MOVABLE: _bindgen_ty_17 = 3;
pub type _bindgen_ty_17 = core::ffi::c_uint;
pub type mhp_t = core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mhp_params {
    pub altmap: *mut vmem_altmap,
    pub pgprot: pgprot_t,
    pub pgmap: *mut dev_pagemap,
}
impl Default for mhp_params {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn mhp_range_allowed(start: u64_, size: u64_, need_mapping: bool_) -> bool_;
}
extern "C" {
    pub fn mhp_get_pluggable_range(need_mapping: bool_) -> range;
}
extern "C" {
    pub fn adjust_present_page_count(
        page: *mut page,
        group: *mut memory_group,
        nr_pages: core::ffi::c_long,
    );
}
extern "C" {
    pub fn mhp_init_memmap_on_memory(
        pfn: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        zone: *mut zone,
        mhp_off_inaccessible: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mhp_deinit_memmap_on_memory(pfn: core::ffi::c_ulong, nr_pages: core::ffi::c_ulong);
}
extern "C" {
    pub fn online_pages(
        pfn: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        zone: *mut zone,
        group: *mut memory_group,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __offline_isolated_pages(start_pfn: core::ffi::c_ulong, end_pfn: core::ffi::c_ulong);
}
pub type online_page_callback_t =
    ::core::option::Option<unsafe extern "C" fn(page: *mut page, order: core::ffi::c_uint)>;
extern "C" {
    pub fn generic_online_page(page: *mut page, order: core::ffi::c_uint);
}
extern "C" {
    pub fn set_online_page_callback(callback: online_page_callback_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn restore_online_page_callback(callback: online_page_callback_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn try_online_node(nid: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_add_memory(
        nid: core::ffi::c_int,
        start: u64_,
        size: u64_,
        params: *mut mhp_params,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut max_mem_size: u64_;
}
extern "C" {
    pub fn mhp_online_type_from_str(str_: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub static mut mhp_default_online_type: core::ffi::c_int;
}
extern "C" {
    pub static mut movable_node_enabled: bool_;
}
extern "C" {
    pub fn arch_remove_memory(start: u64_, size: u64_, altmap: *mut vmem_altmap);
}
extern "C" {
    pub fn __remove_pages(
        start_pfn: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        altmap: *mut vmem_altmap,
    );
}
extern "C" {
    pub fn __add_pages(
        nid: core::ffi::c_int,
        start_pfn: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        params: *mut mhp_params,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn add_pages(
        nid: core::ffi::c_int,
        start_pfn: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        params: *mut mhp_params,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_online_mems();
}
extern "C" {
    pub fn put_online_mems();
}
extern "C" {
    pub fn mem_hotplug_begin();
}
extern "C" {
    pub fn mem_hotplug_done();
}
extern "C" {
    pub fn arch_get_mappable_range() -> range;
}
extern "C" {
    pub fn try_offline_node(nid: core::ffi::c_int);
}
extern "C" {
    pub fn offline_pages(
        start_pfn: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        zone: *mut zone,
        group: *mut memory_group,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn remove_memory(start: u64_, size: u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn __remove_memory(start: u64_, size: u64_);
}
extern "C" {
    pub fn offline_and_remove_memory(start: u64_, size: u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn free_area_init_core_hotplug(pgdat: *mut pglist_data);
}
extern "C" {
    pub fn __add_memory(
        nid: core::ffi::c_int,
        start: u64_,
        size: u64_,
        mhp_flags: mhp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn add_memory(
        nid: core::ffi::c_int,
        start: u64_,
        size: u64_,
        mhp_flags: mhp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn add_memory_resource(
        nid: core::ffi::c_int,
        resource: *mut resource,
        mhp_flags: mhp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn add_memory_driver_managed(
        nid: core::ffi::c_int,
        start: u64_,
        size: u64_,
        resource_name: *const core::ffi::c_char,
        mhp_flags: mhp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn move_pfn_range_to_zone(
        zone: *mut zone,
        start_pfn: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        altmap: *mut vmem_altmap,
        migratetype: core::ffi::c_int,
    );
}
extern "C" {
    pub fn remove_pfn_range_from_zone(
        zone: *mut zone,
        start_pfn: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn sparse_add_section(
        nid: core::ffi::c_int,
        pfn: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        altmap: *mut vmem_altmap,
        pgmap: *mut dev_pagemap,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sparse_remove_section(
        pfn: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        altmap: *mut vmem_altmap,
    );
}
extern "C" {
    pub fn sparse_decode_mem_map(
        coded_mem_map: core::ffi::c_ulong,
        pnum: core::ffi::c_ulong,
    ) -> *mut page;
}
extern "C" {
    pub fn zone_for_pfn_range(
        online_type: core::ffi::c_int,
        nid: core::ffi::c_int,
        group: *mut memory_group,
        start_pfn: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
    ) -> *mut zone;
}
extern "C" {
    pub fn arch_create_linear_mapping(
        nid: core::ffi::c_int,
        start: u64_,
        size: u64_,
        params: *mut mhp_params,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_remove_linear_mapping(start: u64_, size: u64_);
}
extern "C" {
    pub fn build_all_zonelists(pgdat: *mut pg_data_t);
}
extern "C" {
    pub fn wakeup_kswapd(
        zone: *mut zone,
        gfp_mask: gfp_t,
        order: core::ffi::c_int,
        highest_zoneidx: zone_type,
    );
}
extern "C" {
    pub fn __zone_watermark_ok(
        z: *mut zone,
        order: core::ffi::c_uint,
        mark: core::ffi::c_ulong,
        highest_zoneidx: core::ffi::c_int,
        alloc_flags: core::ffi::c_uint,
        free_pages: core::ffi::c_long,
    ) -> bool_;
}
extern "C" {
    pub fn zone_watermark_ok(
        z: *mut zone,
        order: core::ffi::c_uint,
        mark: core::ffi::c_ulong,
        highest_zoneidx: core::ffi::c_int,
        alloc_flags: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn zone_watermark_ok_safe(
        z: *mut zone,
        order: core::ffi::c_uint,
        mark: core::ffi::c_ulong,
        highest_zoneidx: core::ffi::c_int,
    ) -> bool_;
}
pub const meminit_context_MEMINIT_EARLY: meminit_context = 0;
pub const meminit_context_MEMINIT_HOTPLUG: meminit_context = 1;
pub type meminit_context = core::ffi::c_uint;
extern "C" {
    pub fn init_currently_empty_zone(
        zone: *mut zone,
        start_pfn: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn lruvec_init(lruvec: *mut lruvec);
}
extern "C" {
    pub static mut movable_zone: core::ffi::c_int;
}
extern "C" {
    pub fn has_managed_dma() -> bool_;
}
extern "C" {
    pub fn first_online_pgdat() -> *mut pglist_data;
}
extern "C" {
    pub fn next_online_pgdat(pgdat: *mut pglist_data) -> *mut pglist_data;
}
extern "C" {
    pub fn next_zone(zone: *mut zone) -> *mut zone;
}
extern "C" {
    pub fn __next_zones_zonelist(
        z: *mut zoneref,
        highest_zoneidx: zone_type,
        nodes: *mut nodemask_t,
    ) -> *mut zoneref;
}
#[repr(C)]
pub struct mem_section_usage {
    pub rcu: callback_head,
    pub subsection_map: [core::ffi::c_ulong; 1usize],
    pub pageblock_flags: __IncompleteArrayField<core::ffi::c_ulong>,
}
impl Default for mem_section_usage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn subsection_map_init(pfn: core::ffi::c_ulong, nr_pages: core::ffi::c_ulong);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page_ext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_section {
    pub section_mem_map: core::ffi::c_ulong,
    pub usage: *mut mem_section_usage,
}
impl Default for mem_section {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut mem_section: *mut *mut mem_section;
}
extern "C" {
    pub fn mem_section_usage_size() -> usize;
}
pub const SECTION_MARKED_PRESENT_BIT: _bindgen_ty_18 = 0;
pub const SECTION_HAS_MEM_MAP_BIT: _bindgen_ty_18 = 1;
pub const SECTION_IS_ONLINE_BIT: _bindgen_ty_18 = 2;
pub const SECTION_IS_EARLY_BIT: _bindgen_ty_18 = 3;
pub const SECTION_TAINT_ZONE_DEVICE_BIT: _bindgen_ty_18 = 4;
pub const SECTION_MAP_LAST_BIT: _bindgen_ty_18 = 5;
pub type _bindgen_ty_18 = core::ffi::c_uint;
extern "C" {
    pub fn online_mem_sections(start_pfn: core::ffi::c_ulong, end_pfn: core::ffi::c_ulong);
}
extern "C" {
    pub fn offline_mem_sections(start_pfn: core::ffi::c_ulong, end_pfn: core::ffi::c_ulong);
}
extern "C" {
    pub static mut __highest_present_section_nr: core::ffi::c_ulong;
}
extern "C" {
    pub fn sparse_init();
}
extern "C" {
    pub fn topology_normalize_cpu_scale();
}
extern "C" {
    pub fn topology_update_cpu_topology() -> core::ffi::c_int;
}
extern "C" {
    pub fn topology_init_cpu_capacity_cppc();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_node {
    _unused: [u8; 0],
}
extern "C" {
    pub fn topology_parse_cpu_capacity(cpu_node: *mut device_node, cpu: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub static mut cpu_scale: core::ffi::c_ulong;
}
extern "C" {
    pub fn topology_set_cpu_scale(cpu: core::ffi::c_uint, capacity: core::ffi::c_ulong);
}
extern "C" {
    pub static mut capacity_freq_ref: core::ffi::c_ulong;
}
extern "C" {
    pub static mut arch_freq_scale: core::ffi::c_ulong;
}
extern "C" {
    pub fn topology_set_freq_scale(
        cpus: *const cpumask,
        cur_freq: core::ffi::c_ulong,
        max_freq: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn topology_scale_freq_invariant() -> bool_;
}
pub const scale_freq_source_SCALE_FREQ_SOURCE_CPUFREQ: scale_freq_source = 0;
pub const scale_freq_source_SCALE_FREQ_SOURCE_ARCH: scale_freq_source = 1;
pub const scale_freq_source_SCALE_FREQ_SOURCE_CPPC: scale_freq_source = 2;
pub type scale_freq_source = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct scale_freq_data {
    pub source: scale_freq_source,
    pub set_freq_scale: ::core::option::Option<unsafe extern "C" fn()>,
}
impl Default for scale_freq_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn topology_scale_freq_tick();
}
extern "C" {
    pub fn topology_set_scale_freq_source(data: *mut scale_freq_data, cpus: *const cpumask);
}
extern "C" {
    pub fn topology_clear_scale_freq_source(source: scale_freq_source, cpus: *const cpumask);
}
extern "C" {
    pub static mut thermal_pressure: core::ffi::c_ulong;
}
extern "C" {
    pub fn topology_update_thermal_pressure(cpus: *const cpumask, capped_freq: core::ffi::c_ulong);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpu_topology {
    pub thread_id: core::ffi::c_int,
    pub core_id: core::ffi::c_int,
    pub cluster_id: core::ffi::c_int,
    pub package_id: core::ffi::c_int,
    pub thread_sibling: cpumask_t,
    pub core_sibling: cpumask_t,
    pub cluster_sibling: cpumask_t,
    pub llc_sibling: cpumask_t,
}
impl Default for cpu_topology {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mpf_intel {
    pub signature: [core::ffi::c_char; 4usize],
    pub physptr: core::ffi::c_uint,
    pub length: core::ffi::c_uchar,
    pub specification: core::ffi::c_uchar,
    pub checksum: core::ffi::c_uchar,
    pub feature1: core::ffi::c_uchar,
    pub feature2: core::ffi::c_uchar,
    pub feature3: core::ffi::c_uchar,
    pub feature4: core::ffi::c_uchar,
    pub feature5: core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mpc_table {
    pub signature: [core::ffi::c_char; 4usize],
    pub length: core::ffi::c_ushort,
    pub spec: core::ffi::c_char,
    pub checksum: core::ffi::c_char,
    pub oem: [core::ffi::c_char; 8usize],
    pub productid: [core::ffi::c_char; 12usize],
    pub oemptr: core::ffi::c_uint,
    pub oemsize: core::ffi::c_ushort,
    pub oemcount: core::ffi::c_ushort,
    pub lapic: core::ffi::c_uint,
    pub reserved: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mpc_cpu {
    pub type_: core::ffi::c_uchar,
    pub apicid: core::ffi::c_uchar,
    pub apicver: core::ffi::c_uchar,
    pub cpuflag: core::ffi::c_uchar,
    pub cpufeature: core::ffi::c_uint,
    pub featureflag: core::ffi::c_uint,
    pub reserved: [core::ffi::c_uint; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mpc_bus {
    pub type_: core::ffi::c_uchar,
    pub busid: core::ffi::c_uchar,
    pub bustype: [core::ffi::c_uchar; 6usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mpc_ioapic {
    pub type_: core::ffi::c_uchar,
    pub apicid: core::ffi::c_uchar,
    pub apicver: core::ffi::c_uchar,
    pub flags: core::ffi::c_uchar,
    pub apicaddr: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mpc_intsrc {
    pub type_: core::ffi::c_uchar,
    pub irqtype: core::ffi::c_uchar,
    pub irqflag: core::ffi::c_ushort,
    pub srcbus: core::ffi::c_uchar,
    pub srcbusirq: core::ffi::c_uchar,
    pub dstapic: core::ffi::c_uchar,
    pub dstirq: core::ffi::c_uchar,
}
pub const mp_irq_source_types_mp_INT: mp_irq_source_types = 0;
pub const mp_irq_source_types_mp_NMI: mp_irq_source_types = 1;
pub const mp_irq_source_types_mp_SMI: mp_irq_source_types = 2;
pub const mp_irq_source_types_mp_ExtINT: mp_irq_source_types = 3;
pub type mp_irq_source_types = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mpc_lintsrc {
    pub type_: core::ffi::c_uchar,
    pub irqtype: core::ffi::c_uchar,
    pub irqflag: core::ffi::c_ushort,
    pub srcbusid: core::ffi::c_uchar,
    pub srcbusirq: core::ffi::c_uchar,
    pub destapic: core::ffi::c_uchar,
    pub destapiclint: core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mpc_oemtable {
    pub signature: [core::ffi::c_char; 4usize],
    pub length: core::ffi::c_ushort,
    pub rev: core::ffi::c_char,
    pub checksum: core::ffi::c_char,
    pub mpc: [core::ffi::c_char; 8usize],
}
pub const mp_bustype_MP_BUS_ISA: mp_bustype = 1;
pub const mp_bustype_MP_BUS_EISA: mp_bustype = 2;
pub const mp_bustype_MP_BUS_PCI: mp_bustype = 3;
pub type mp_bustype = core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct screen_info {
    pub orig_x: __u8,
    pub orig_y: __u8,
    pub ext_mem_k: __u16,
    pub orig_video_page: __u16,
    pub orig_video_mode: __u8,
    pub orig_video_cols: __u8,
    pub flags: __u8,
    pub unused2: __u8,
    pub orig_video_ega_bx: __u16,
    pub unused3: __u16,
    pub orig_video_lines: __u8,
    pub orig_video_isVGA: __u8,
    pub orig_video_points: __u16,
    pub lfb_width: __u16,
    pub lfb_height: __u16,
    pub lfb_depth: __u16,
    pub lfb_base: __u32,
    pub lfb_size: __u32,
    pub cl_magic: __u16,
    pub cl_offset: __u16,
    pub lfb_linelength: __u16,
    pub red_size: __u8,
    pub red_pos: __u8,
    pub green_size: __u8,
    pub green_pos: __u8,
    pub blue_size: __u8,
    pub blue_pos: __u8,
    pub rsvd_size: __u8,
    pub rsvd_pos: __u8,
    pub vesapm_seg: __u16,
    pub vesapm_off: __u16,
    pub pages: __u16,
    pub vesa_attributes: __u16,
    pub capabilities: __u32,
    pub ext_lfb_base: __u32,
    pub _reserved: [__u8; 2usize],
}
extern "C" {
    pub static mut screen_info: screen_info;
}
pub type apm_event_t = core::ffi::c_ushort;
pub type apm_eventinfo_t = core::ffi::c_ushort;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct apm_bios_info {
    pub version: __u16,
    pub cseg: __u16,
    pub offset: __u32,
    pub cseg_16: __u16,
    pub dseg: __u16,
    pub flags: __u16,
    pub cseg_len: __u16,
    pub cseg_16_len: __u16,
    pub dseg_len: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct apm_info {
    pub bios: apm_bios_info,
    pub connection_version: core::ffi::c_ushort,
    pub get_power_status_broken: core::ffi::c_int,
    pub get_power_status_swabinminutes: core::ffi::c_int,
    pub allow_ints: core::ffi::c_int,
    pub forbid_idle: core::ffi::c_int,
    pub realmode_power_off: core::ffi::c_int,
    pub disabled: core::ffi::c_int,
}
extern "C" {
    pub static mut apm_info: apm_info;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params {
    pub length: __u16,
    pub info_flags: __u16,
    pub num_default_cylinders: __u32,
    pub num_default_heads: __u32,
    pub sectors_per_track: __u32,
    pub number_of_sectors: __u64,
    pub bytes_per_sector: __u16,
    pub dpte_ptr: __u32,
    pub key: __u16,
    pub device_path_info_length: __u8,
    pub reserved2: __u8,
    pub reserved3: __u16,
    pub host_bus_type: [__u8; 4usize],
    pub interface_type: [__u8; 8usize],
    pub interface_path: edd_device_params__bindgen_ty_1,
    pub device_path: edd_device_params__bindgen_ty_2,
    pub reserved4: __u8,
    pub checksum: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union edd_device_params__bindgen_ty_1 {
    pub isa: edd_device_params__bindgen_ty_1__bindgen_ty_1,
    pub pci: edd_device_params__bindgen_ty_1__bindgen_ty_2,
    pub ibnd: edd_device_params__bindgen_ty_1__bindgen_ty_3,
    pub xprs: edd_device_params__bindgen_ty_1__bindgen_ty_4,
    pub htpt: edd_device_params__bindgen_ty_1__bindgen_ty_5,
    pub unknown: edd_device_params__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_1 {
    pub base_address: __u16,
    pub reserved1: __u16,
    pub reserved2: __u32,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_2 {
    pub bus: __u8,
    pub slot: __u8,
    pub function: __u8,
    pub channel: __u8,
    pub reserved: __u32,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_3 {
    pub reserved: __u64,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_4 {
    pub reserved: __u64,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: __u64,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_6 {
    pub reserved: __u64,
}
impl Default for edd_device_params__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union edd_device_params__bindgen_ty_2 {
    pub ata: edd_device_params__bindgen_ty_2__bindgen_ty_1,
    pub atapi: edd_device_params__bindgen_ty_2__bindgen_ty_2,
    pub scsi: edd_device_params__bindgen_ty_2__bindgen_ty_3,
    pub usb: edd_device_params__bindgen_ty_2__bindgen_ty_4,
    pub i1394: edd_device_params__bindgen_ty_2__bindgen_ty_5,
    pub fibre: edd_device_params__bindgen_ty_2__bindgen_ty_6,
    pub i2o: edd_device_params__bindgen_ty_2__bindgen_ty_7,
    pub raid: edd_device_params__bindgen_ty_2__bindgen_ty_8,
    pub sata: edd_device_params__bindgen_ty_2__bindgen_ty_9,
    pub unknown: edd_device_params__bindgen_ty_2__bindgen_ty_10,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_1 {
    pub device: __u8,
    pub reserved1: __u8,
    pub reserved2: __u16,
    pub reserved3: __u32,
    pub reserved4: __u64,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_2 {
    pub device: __u8,
    pub lun: __u8,
    pub reserved1: __u8,
    pub reserved2: __u8,
    pub reserved3: __u32,
    pub reserved4: __u64,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_3 {
    pub id: __u16,
    pub lun: __u64,
    pub reserved1: __u16,
    pub reserved2: __u32,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_4 {
    pub serial_number: __u64,
    pub reserved: __u64,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_5 {
    pub eui: __u64,
    pub reserved: __u64,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_6 {
    pub wwid: __u64,
    pub lun: __u64,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_7 {
    pub identity_tag: __u64,
    pub reserved: __u64,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_8 {
    pub array_number: __u32,
    pub reserved1: __u32,
    pub reserved2: __u64,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_9 {
    pub device: __u8,
    pub reserved1: __u8,
    pub reserved2: __u16,
    pub reserved3: __u32,
    pub reserved4: __u64,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_10 {
    pub reserved1: __u64,
    pub reserved2: __u64,
}
impl Default for edd_device_params__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for edd_device_params {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_info {
    pub device: __u8,
    pub version: __u8,
    pub interface_support: __u16,
    pub legacy_max_cylinder: __u16,
    pub legacy_max_head: __u8,
    pub legacy_sectors_per_track: __u8,
    pub params: edd_device_params,
}
impl Default for edd_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct edd {
    pub mbr_signature: [core::ffi::c_uint; 16usize],
    pub edd_info: [edd_info; 6usize],
    pub mbr_signature_nr: core::ffi::c_uchar,
    pub edd_info_nr: core::ffi::c_uchar,
}
impl Default for edd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut edd: edd;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ist_info {
    pub signature: __u32,
    pub command: __u32,
    pub event: __u32,
    pub perf_level: __u32,
}
extern "C" {
    pub static mut ist_info: ist_info;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct edid_info {
    pub dummy: [core::ffi::c_uchar; 128usize],
}
impl Default for edid_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut edid_info: edid_info;
}
#[repr(C)]
#[derive(Default)]
pub struct setup_data {
    pub next: __u64,
    pub type_: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct setup_indirect {
    pub type_: __u32,
    pub reserved: __u32,
    pub len: __u64,
    pub addr: __u64,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct setup_header {
    pub setup_sects: __u8,
    pub root_flags: __u16,
    pub syssize: __u32,
    pub ram_size: __u16,
    pub vid_mode: __u16,
    pub root_dev: __u16,
    pub boot_flag: __u16,
    pub jump: __u16,
    pub header: __u32,
    pub version: __u16,
    pub realmode_swtch: __u32,
    pub start_sys_seg: __u16,
    pub kernel_version: __u16,
    pub type_of_loader: __u8,
    pub loadflags: __u8,
    pub setup_move_size: __u16,
    pub code32_start: __u32,
    pub ramdisk_image: __u32,
    pub ramdisk_size: __u32,
    pub bootsect_kludge: __u32,
    pub heap_end_ptr: __u16,
    pub ext_loader_ver: __u8,
    pub ext_loader_type: __u8,
    pub cmd_line_ptr: __u32,
    pub initrd_addr_max: __u32,
    pub kernel_alignment: __u32,
    pub relocatable_kernel: __u8,
    pub min_alignment: __u8,
    pub xloadflags: __u16,
    pub cmdline_size: __u32,
    pub hardware_subarch: __u32,
    pub hardware_subarch_data: __u64,
    pub payload_offset: __u32,
    pub payload_length: __u32,
    pub setup_data: __u64,
    pub pref_address: __u64,
    pub init_size: __u32,
    pub handover_offset: __u32,
    pub kernel_info_offset: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sys_desc_table {
    pub length: __u16,
    pub table: [__u8; 14usize],
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct olpc_ofw_header {
    pub ofw_magic: __u32,
    pub ofw_version: __u32,
    pub cif_handler: __u32,
    pub irq_desc_table: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct efi_info {
    pub efi_loader_signature: __u32,
    pub efi_systab: __u32,
    pub efi_memdesc_size: __u32,
    pub efi_memdesc_version: __u32,
    pub efi_memmap: __u32,
    pub efi_memmap_size: __u32,
    pub efi_systab_hi: __u32,
    pub efi_memmap_hi: __u32,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct boot_e820_entry {
    pub addr: __u64,
    pub size: __u64,
    pub type_: __u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct jailhouse_setup_data {
    pub hdr: jailhouse_setup_data__bindgen_ty_1,
    pub v1: jailhouse_setup_data__bindgen_ty_2,
    pub v2: jailhouse_setup_data__bindgen_ty_3,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct jailhouse_setup_data__bindgen_ty_1 {
    pub version: __u16,
    pub compatible_version: __u16,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct jailhouse_setup_data__bindgen_ty_2 {
    pub pm_timer_address: __u16,
    pub num_cpus: __u16,
    pub pci_mmconfig_base: __u64,
    pub tsc_khz: __u32,
    pub apic_khz: __u32,
    pub standard_ioapic: __u8,
    pub cpu_ids: [__u8; 255usize],
}
impl Default for jailhouse_setup_data__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct jailhouse_setup_data__bindgen_ty_3 {
    pub flags: __u32,
}
impl Default for jailhouse_setup_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct ima_setup_data {
    pub addr: __u64,
    pub size: __u64,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct boot_params {
    pub screen_info: screen_info,
    pub apm_bios_info: apm_bios_info,
    pub _pad2: [__u8; 4usize],
    pub tboot_addr: __u64,
    pub ist_info: ist_info,
    pub acpi_rsdp_addr: __u64,
    pub _pad3: [__u8; 8usize],
    pub hd0_info: [__u8; 16usize],
    pub hd1_info: [__u8; 16usize],
    pub sys_desc_table: sys_desc_table,
    pub olpc_ofw_header: olpc_ofw_header,
    pub ext_ramdisk_image: __u32,
    pub ext_ramdisk_size: __u32,
    pub ext_cmd_line_ptr: __u32,
    pub _pad4: [__u8; 112usize],
    pub cc_blob_address: __u32,
    pub edid_info: edid_info,
    pub efi_info: efi_info,
    pub alt_mem_k: __u32,
    pub scratch: __u32,
    pub e820_entries: __u8,
    pub eddbuf_entries: __u8,
    pub edd_mbr_sig_buf_entries: __u8,
    pub kbd_status: __u8,
    pub secure_boot: __u8,
    pub _pad5: [__u8; 2usize],
    pub sentinel: __u8,
    pub _pad6: [__u8; 1usize],
    pub hdr: setup_header,
    pub _pad7: [__u8; 36usize],
    pub edd_mbr_sig_buffer: [__u32; 16usize],
    pub e820_table: [boot_e820_entry; 128usize],
    pub _pad8: [__u8; 48usize],
    pub eddbuf: [edd_info; 6usize],
    pub _pad9: [__u8; 276usize],
}
impl Default for boot_params {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const x86_hardware_subarch_X86_SUBARCH_PC: x86_hardware_subarch = 0;
pub const x86_hardware_subarch_X86_SUBARCH_LGUEST: x86_hardware_subarch = 1;
pub const x86_hardware_subarch_X86_SUBARCH_XEN: x86_hardware_subarch = 2;
pub const x86_hardware_subarch_X86_SUBARCH_INTEL_MID: x86_hardware_subarch = 3;
pub const x86_hardware_subarch_X86_SUBARCH_CE4100: x86_hardware_subarch = 4;
pub const x86_hardware_subarch_X86_NR_SUBARCHS: x86_hardware_subarch = 5;
pub type x86_hardware_subarch = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ghcb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_domain {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_init_mpparse {
    pub setup_ioapic_ids: ::core::option::Option<unsafe extern "C" fn()>,
    pub find_smp_config: ::core::option::Option<unsafe extern "C" fn()>,
    pub get_smp_config: ::core::option::Option<unsafe extern "C" fn(early: core::ffi::c_uint)>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_init_resources {
    pub probe_roms: ::core::option::Option<unsafe extern "C" fn()>,
    pub reserve_resources: ::core::option::Option<unsafe extern "C" fn()>,
    pub memory_setup: ::core::option::Option<unsafe extern "C" fn() -> *mut core::ffi::c_char>,
    pub dmi_setup: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_init_irqs {
    pub pre_vector_init: ::core::option::Option<unsafe extern "C" fn()>,
    pub intr_init: ::core::option::Option<unsafe extern "C" fn()>,
    pub intr_mode_select: ::core::option::Option<unsafe extern "C" fn()>,
    pub intr_mode_init: ::core::option::Option<unsafe extern "C" fn()>,
    pub create_pci_msi_domain: ::core::option::Option<unsafe extern "C" fn() -> *mut irq_domain>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_init_oem {
    pub arch_setup: ::core::option::Option<unsafe extern "C" fn()>,
    pub banner: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_init_paging {
    pub pagetable_init: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_init_timers {
    pub setup_percpu_clockev: ::core::option::Option<unsafe extern "C" fn()>,
    pub timer_init: ::core::option::Option<unsafe extern "C" fn()>,
    pub wallclock_init: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_init_iommu {
    pub iommu_init: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_init_pci {
    pub arch_init: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub init: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub init_irq: ::core::option::Option<unsafe extern "C" fn()>,
    pub fixup_irqs: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_hyper_init {
    pub init_platform: ::core::option::Option<unsafe extern "C" fn()>,
    pub guest_late_init: ::core::option::Option<unsafe extern "C" fn()>,
    pub x2apic_available: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub msi_ext_dest_id: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub init_mem_mapping: ::core::option::Option<unsafe extern "C" fn()>,
    pub init_after_bootmem: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_init_acpi {
    pub set_root_pointer: ::core::option::Option<unsafe extern "C" fn(addr: u64_)>,
    pub get_root_pointer: ::core::option::Option<unsafe extern "C" fn() -> u64_>,
    pub reduced_hw_early_init: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_guest {
    pub enc_status_change_prepare: ::core::option::Option<
        unsafe extern "C" fn(
            vaddr: core::ffi::c_ulong,
            npages: core::ffi::c_int,
            enc: bool_,
        ) -> bool_,
    >,
    pub enc_status_change_finish: ::core::option::Option<
        unsafe extern "C" fn(
            vaddr: core::ffi::c_ulong,
            npages: core::ffi::c_int,
            enc: bool_,
        ) -> bool_,
    >,
    pub enc_tlb_flush_required: ::core::option::Option<unsafe extern "C" fn(enc: bool_) -> bool_>,
    pub enc_cache_flush_required: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_init_ops {
    pub resources: x86_init_resources,
    pub mpparse: x86_init_mpparse,
    pub irqs: x86_init_irqs,
    pub oem: x86_init_oem,
    pub paging: x86_init_paging,
    pub timers: x86_init_timers,
    pub iommu: x86_init_iommu,
    pub pci: x86_init_pci,
    pub hyper: x86_hyper_init,
    pub acpi: x86_init_acpi,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_cpuinit_ops {
    pub setup_percpu_clockev: ::core::option::Option<unsafe extern "C" fn()>,
    pub early_percpu_clock_init: ::core::option::Option<unsafe extern "C" fn()>,
    pub fixup_cpu_id:
        ::core::option::Option<unsafe extern "C" fn(c: *mut cpuinfo_x86, node: core::ffi::c_int)>,
    pub parallel_bringup: bool_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_legacy_devices {
    pub pnpbios: core::ffi::c_int,
}
pub const x86_legacy_i8042_state_X86_LEGACY_I8042_PLATFORM_ABSENT: x86_legacy_i8042_state = 0;
pub const x86_legacy_i8042_state_X86_LEGACY_I8042_FIRMWARE_ABSENT: x86_legacy_i8042_state = 1;
pub const x86_legacy_i8042_state_X86_LEGACY_I8042_EXPECTED_PRESENT: x86_legacy_i8042_state = 2;
pub type x86_legacy_i8042_state = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_legacy_features {
    pub i8042: x86_legacy_i8042_state,
    pub rtc: core::ffi::c_int,
    pub warm_reset: core::ffi::c_int,
    pub no_vga: core::ffi::c_int,
    pub reserve_bios_regions: core::ffi::c_int,
    pub devices: x86_legacy_devices,
}
impl Default for x86_legacy_features {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_hyper_runtime {
    pub pin_vcpu: ::core::option::Option<unsafe extern "C" fn(cpu: core::ffi::c_int)>,
    pub sev_es_hcall_prepare:
        ::core::option::Option<unsafe extern "C" fn(ghcb: *mut ghcb, regs: *mut pt_regs)>,
    pub sev_es_hcall_finish:
        ::core::option::Option<unsafe extern "C" fn(ghcb: *mut ghcb, regs: *mut pt_regs) -> bool_>,
    pub is_private_mmio: ::core::option::Option<unsafe extern "C" fn(addr: u64_) -> bool_>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_platform_ops {
    pub calibrate_cpu: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_ulong>,
    pub calibrate_tsc: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_ulong>,
    pub get_wallclock: ::core::option::Option<unsafe extern "C" fn(ts: *mut timespec64)>,
    pub set_wallclock:
        ::core::option::Option<unsafe extern "C" fn(ts: *const timespec64) -> core::ffi::c_int>,
    pub iommu_shutdown: ::core::option::Option<unsafe extern "C" fn()>,
    pub is_untracked_pat_range:
        ::core::option::Option<unsafe extern "C" fn(start: u64_, end: u64_) -> bool_>,
    pub nmi_init: ::core::option::Option<unsafe extern "C" fn()>,
    pub get_nmi_reason: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_uchar>,
    pub save_sched_clock_state: ::core::option::Option<unsafe extern "C" fn()>,
    pub restore_sched_clock_state: ::core::option::Option<unsafe extern "C" fn()>,
    pub apic_post_init: ::core::option::Option<unsafe extern "C" fn()>,
    pub legacy: x86_legacy_features,
    pub set_legacy_features: ::core::option::Option<unsafe extern "C" fn()>,
    pub realmode_reserve: ::core::option::Option<unsafe extern "C" fn()>,
    pub realmode_init: ::core::option::Option<unsafe extern "C" fn()>,
    pub hyper: x86_hyper_runtime,
    pub guest: x86_guest,
}
impl Default for x86_platform_ops {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_apic_ops {
    pub io_apic_read: ::core::option::Option<
        unsafe extern "C" fn(apic: core::ffi::c_uint, reg: core::ffi::c_uint) -> core::ffi::c_uint,
    >,
    pub restore: ::core::option::Option<unsafe extern "C" fn()>,
}
extern "C" {
    pub static mut x86_init: x86_init_ops;
}
extern "C" {
    pub static mut x86_cpuinit: x86_cpuinit_ops;
}
extern "C" {
    pub static mut x86_platform: x86_platform_ops;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_msi_ops {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut x86_msi: x86_msi_ops;
}
extern "C" {
    pub static mut x86_apic_ops: x86_apic_ops;
}
extern "C" {
    pub fn x86_early_init_platform_quirks();
}
extern "C" {
    pub fn x86_init_noop();
}
extern "C" {
    pub fn x86_init_uint_noop(unused: core::ffi::c_uint);
}
extern "C" {
    pub fn bool_x86_init_noop() -> bool_;
}
extern "C" {
    pub fn x86_op_int_noop(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn x86_pnpbios_disabled() -> bool_;
}
extern "C" {
    pub fn set_rtc_noop(now: *const timespec64) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_rtc_noop(now: *mut timespec64);
}
extern "C" {
    pub static mut pic_mode: core::ffi::c_int;
}
extern "C" {
    pub static mut mp_bus_id_to_type: [core::ffi::c_int; 256usize];
}
extern "C" {
    pub static mut mp_bus_not_pci: [core::ffi::c_ulong; 4usize];
}
extern "C" {
    pub static mut boot_cpu_physical_apicid: u32_;
}
extern "C" {
    pub static mut boot_cpu_apic_version: u8_;
}
extern "C" {
    pub static mut smp_found_config: core::ffi::c_int;
}
extern "C" {
    pub fn e820__memblock_alloc_reserved_mpc_new();
}
extern "C" {
    pub static mut enable_update_mptable: core::ffi::c_int;
}
extern "C" {
    pub fn default_find_smp_config();
}
extern "C" {
    pub fn default_get_smp_config(early: core::ffi::c_uint);
}
extern "C" {
    pub fn generic_processor_info(apicid: core::ffi::c_int) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct physid_mask {
    pub mask: [core::ffi::c_ulong; 512usize],
}
impl Default for physid_mask {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type physid_mask_t = physid_mask;
extern "C" {
    pub static mut phys_cpu_present_map: physid_mask_t;
}
extern "C" {
    pub static mut x86_cpu_to_node_map: core::ffi::c_int;
}
extern "C" {
    pub static mut x86_cpu_to_node_map_early_ptr: *mut core::ffi::c_int;
}
extern "C" {
    pub static mut x86_cpu_to_node_map_early_map: [core::ffi::c_int; 0usize];
}
extern "C" {
    pub static mut node_to_cpumask_map: [cpumask_var_t; 1024usize];
}
extern "C" {
    pub fn setup_node_to_cpumask_map();
}
extern "C" {
    pub fn __node_distance(arg1: core::ffi::c_int, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn cpu_coregroup_mask(cpu: core::ffi::c_int) -> *const cpumask;
}
extern "C" {
    pub fn cpu_clustergroup_mask(cpu: core::ffi::c_int) -> *const cpumask;
}
extern "C" {
    pub static mut __max_die_per_package: core::ffi::c_uint;
}
extern "C" {
    pub static mut __max_logical_packages: core::ffi::c_uint;
}
extern "C" {
    pub static mut __max_smt_threads: core::ffi::c_int;
}
pub const cpuhp_smt_control_CPU_SMT_ENABLED: cpuhp_smt_control = 0;
pub const cpuhp_smt_control_CPU_SMT_DISABLED: cpuhp_smt_control = 1;
pub const cpuhp_smt_control_CPU_SMT_FORCE_DISABLED: cpuhp_smt_control = 2;
pub const cpuhp_smt_control_CPU_SMT_NOT_SUPPORTED: cpuhp_smt_control = 3;
pub const cpuhp_smt_control_CPU_SMT_NOT_IMPLEMENTED: cpuhp_smt_control = 4;
pub type cpuhp_smt_control = core::ffi::c_uint;
extern "C" {
    pub static mut cpu_smt_control: cpuhp_smt_control;
}
extern "C" {
    pub static mut cpu_smt_num_threads: core::ffi::c_uint;
}
extern "C" {
    pub fn cpu_smt_disable(force: bool_);
}
extern "C" {
    pub fn cpu_smt_set_num_threads(num_threads: core::ffi::c_uint, max_threads: core::ffi::c_uint);
}
extern "C" {
    pub fn cpu_smt_possible() -> bool_;
}
extern "C" {
    pub fn cpuhp_smt_enable() -> core::ffi::c_int;
}
extern "C" {
    pub fn cpuhp_smt_disable(ctrlval: cpuhp_smt_control) -> core::ffi::c_int;
}
extern "C" {
    pub fn topology_update_package_map(
        apicid: core::ffi::c_uint,
        cpu: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn topology_update_die_map(
        dieid: core::ffi::c_uint,
        cpu: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn topology_phys_to_logical_pkg(pkg: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub static mut __cpu_primary_thread_mask: cpumask;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_bus {
    _unused: [u8; 0],
}
extern "C" {
    pub fn x86_pci_root_bus_node(bus: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn x86_pci_root_bus_resources(bus: core::ffi::c_int, resources: *mut list_head);
}
extern "C" {
    pub static mut x86_topology_update: bool_;
}
extern "C" {
    pub static mut sched_core_priority: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_sched_itmt_enabled: core::ffi::c_uint;
}
extern "C" {
    pub fn sched_set_itmt_core_prio(prio: core::ffi::c_int, core_cpu: core::ffi::c_int);
}
extern "C" {
    pub fn sched_set_itmt_support() -> core::ffi::c_int;
}
extern "C" {
    pub fn sched_clear_itmt_support();
}
extern "C" {
    pub static mut arch_scale_freq_key: static_key_false;
}
extern "C" {
    pub fn arch_set_max_freq_ratio(turbo_disabled: bool_);
}
extern "C" {
    pub fn freq_invariance_set_perf_ratio(ratio: u64_, turbo_disabled: bool_);
}
extern "C" {
    pub fn arch_scale_freq_tick();
}
extern "C" {
    pub fn init_freq_invariance_cppc();
}
extern "C" {
    pub fn arch_update_cpu_topology() -> core::ffi::c_int;
}
extern "C" {
    pub static mut node_reclaim_distance: core::ffi::c_int;
}
extern "C" {
    pub static mut numa_node: core::ffi::c_int;
}
extern "C" {
    pub fn sched_numa_find_nth_cpu(
        cpus: *const cpumask,
        cpu: core::ffi::c_int,
        node: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sched_numa_hop_mask(node: core::ffi::c_uint, hops: core::ffi::c_uint) -> *const cpumask;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mempolicy {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __alloc_pages(
        gfp: gfp_t,
        order: core::ffi::c_uint,
        preferred_nid: core::ffi::c_int,
        nodemask: *mut nodemask_t,
    ) -> *mut page;
}
extern "C" {
    pub fn __folio_alloc(
        gfp: gfp_t,
        order: core::ffi::c_uint,
        preferred_nid: core::ffi::c_int,
        nodemask: *mut nodemask_t,
    ) -> *mut folio;
}
extern "C" {
    pub fn __alloc_pages_bulk(
        gfp: gfp_t,
        preferred_nid: core::ffi::c_int,
        nodemask: *mut nodemask_t,
        nr_pages: core::ffi::c_int,
        page_list: *mut list_head,
        page_array: *mut *mut page,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn alloc_pages_bulk_array_mempolicy(
        gfp: gfp_t,
        nr_pages: core::ffi::c_ulong,
        page_array: *mut *mut page,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn alloc_pages(gfp: gfp_t, order: core::ffi::c_uint) -> *mut page;
}
extern "C" {
    pub fn alloc_pages_mpol(
        gfp: gfp_t,
        order: core::ffi::c_uint,
        mpol: *mut mempolicy,
        ilx: core::ffi::c_ulong,
        nid: core::ffi::c_int,
    ) -> *mut page;
}
extern "C" {
    pub fn folio_alloc(gfp: gfp_t, order: core::ffi::c_uint) -> *mut folio;
}
extern "C" {
    pub fn vma_alloc_folio(
        gfp: gfp_t,
        order: core::ffi::c_int,
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        hugepage: bool_,
    ) -> *mut folio;
}
extern "C" {
    pub fn __get_free_pages(gfp_mask: gfp_t, order: core::ffi::c_uint) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn get_zeroed_page(gfp_mask: gfp_t) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn alloc_pages_exact(size: usize, gfp_mask: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn free_pages_exact(virt: *mut core::ffi::c_void, size: usize);
}
extern "C" {
    pub fn alloc_pages_exact_nid(
        nid: core::ffi::c_int,
        size: usize,
        gfp_mask: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __free_pages(page: *mut page, order: core::ffi::c_uint);
}
extern "C" {
    pub fn free_pages(addr: core::ffi::c_ulong, order: core::ffi::c_uint);
}
extern "C" {
    pub fn __page_frag_cache_drain(page: *mut page, count: core::ffi::c_uint);
}
extern "C" {
    pub fn page_frag_alloc_align(
        nc: *mut page_frag_cache,
        fragsz: core::ffi::c_uint,
        gfp_mask: gfp_t,
        align_mask: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn page_frag_free(addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn page_alloc_init_cpuhp();
}
extern "C" {
    pub fn decay_pcp_high(zone: *mut zone, pcp: *mut per_cpu_pages) -> core::ffi::c_int;
}
extern "C" {
    pub fn drain_zone_pages(zone: *mut zone, pcp: *mut per_cpu_pages);
}
extern "C" {
    pub fn drain_all_pages(zone: *mut zone);
}
extern "C" {
    pub fn drain_local_pages(zone: *mut zone);
}
extern "C" {
    pub fn page_alloc_init_late();
}
extern "C" {
    pub fn setup_pcp_cacheinfo();
}
extern "C" {
    pub static mut gfp_allowed_mask: gfp_t;
}
extern "C" {
    pub fn gfp_pfmemalloc_allowed(gfp_mask: gfp_t) -> bool_;
}
extern "C" {
    pub fn vma_thp_gfp_mask(vma: *mut vm_area_struct) -> gfp_t;
}
extern "C" {
    pub fn alloc_contig_range(
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        migratetype: core::ffi::c_uint,
        gfp_mask: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn alloc_contig_pages(
        nr_pages: core::ffi::c_ulong,
        gfp_mask: gfp_t,
        nid: core::ffi::c_int,
        nodemask: *mut nodemask_t,
    ) -> *mut page;
}
extern "C" {
    pub fn free_contig_range(pfn: core::ffi::c_ulong, nr_pages: core::ffi::c_ulong);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sysctl_args {
    pub name: *mut core::ffi::c_int,
    pub nlen: core::ffi::c_int,
    pub oldval: *mut core::ffi::c_void,
    pub oldlenp: *mut usize,
    pub newval: *mut core::ffi::c_void,
    pub newlen: usize,
    pub __unused: [core::ffi::c_ulong; 4usize],
}
impl Default for __sysctl_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CTL_KERN: _bindgen_ty_19 = 1;
pub const CTL_VM: _bindgen_ty_19 = 2;
pub const CTL_NET: _bindgen_ty_19 = 3;
pub const CTL_PROC: _bindgen_ty_19 = 4;
pub const CTL_FS: _bindgen_ty_19 = 5;
pub const CTL_DEBUG: _bindgen_ty_19 = 6;
pub const CTL_DEV: _bindgen_ty_19 = 7;
pub const CTL_BUS: _bindgen_ty_19 = 8;
pub const CTL_ABI: _bindgen_ty_19 = 9;
pub const CTL_CPU: _bindgen_ty_19 = 10;
pub const CTL_ARLAN: _bindgen_ty_19 = 254;
pub const CTL_S390DBF: _bindgen_ty_19 = 5677;
pub const CTL_SUNRPC: _bindgen_ty_19 = 7249;
pub const CTL_PM: _bindgen_ty_19 = 9899;
pub const CTL_FRV: _bindgen_ty_19 = 9898;
pub type _bindgen_ty_19 = core::ffi::c_uint;
pub const CTL_BUS_ISA: _bindgen_ty_20 = 1;
pub type _bindgen_ty_20 = core::ffi::c_uint;
pub const INOTIFY_MAX_USER_INSTANCES: _bindgen_ty_21 = 1;
pub const INOTIFY_MAX_USER_WATCHES: _bindgen_ty_21 = 2;
pub const INOTIFY_MAX_QUEUED_EVENTS: _bindgen_ty_21 = 3;
pub type _bindgen_ty_21 = core::ffi::c_uint;
pub const KERN_OSTYPE: _bindgen_ty_22 = 1;
pub const KERN_OSRELEASE: _bindgen_ty_22 = 2;
pub const KERN_OSREV: _bindgen_ty_22 = 3;
pub const KERN_VERSION: _bindgen_ty_22 = 4;
pub const KERN_SECUREMASK: _bindgen_ty_22 = 5;
pub const KERN_PROF: _bindgen_ty_22 = 6;
pub const KERN_NODENAME: _bindgen_ty_22 = 7;
pub const KERN_DOMAINNAME: _bindgen_ty_22 = 8;
pub const KERN_PANIC: _bindgen_ty_22 = 15;
pub const KERN_REALROOTDEV: _bindgen_ty_22 = 16;
pub const KERN_SPARC_REBOOT: _bindgen_ty_22 = 21;
pub const KERN_CTLALTDEL: _bindgen_ty_22 = 22;
pub const KERN_PRINTK: _bindgen_ty_22 = 23;
pub const KERN_NAMETRANS: _bindgen_ty_22 = 24;
pub const KERN_PPC_HTABRECLAIM: _bindgen_ty_22 = 25;
pub const KERN_PPC_ZEROPAGED: _bindgen_ty_22 = 26;
pub const KERN_PPC_POWERSAVE_NAP: _bindgen_ty_22 = 27;
pub const KERN_MODPROBE: _bindgen_ty_22 = 28;
pub const KERN_SG_BIG_BUFF: _bindgen_ty_22 = 29;
pub const KERN_ACCT: _bindgen_ty_22 = 30;
pub const KERN_PPC_L2CR: _bindgen_ty_22 = 31;
pub const KERN_RTSIGNR: _bindgen_ty_22 = 32;
pub const KERN_RTSIGMAX: _bindgen_ty_22 = 33;
pub const KERN_SHMMAX: _bindgen_ty_22 = 34;
pub const KERN_MSGMAX: _bindgen_ty_22 = 35;
pub const KERN_MSGMNB: _bindgen_ty_22 = 36;
pub const KERN_MSGPOOL: _bindgen_ty_22 = 37;
pub const KERN_SYSRQ: _bindgen_ty_22 = 38;
pub const KERN_MAX_THREADS: _bindgen_ty_22 = 39;
pub const KERN_RANDOM: _bindgen_ty_22 = 40;
pub const KERN_SHMALL: _bindgen_ty_22 = 41;
pub const KERN_MSGMNI: _bindgen_ty_22 = 42;
pub const KERN_SEM: _bindgen_ty_22 = 43;
pub const KERN_SPARC_STOP_A: _bindgen_ty_22 = 44;
pub const KERN_SHMMNI: _bindgen_ty_22 = 45;
pub const KERN_OVERFLOWUID: _bindgen_ty_22 = 46;
pub const KERN_OVERFLOWGID: _bindgen_ty_22 = 47;
pub const KERN_SHMPATH: _bindgen_ty_22 = 48;
pub const KERN_HOTPLUG: _bindgen_ty_22 = 49;
pub const KERN_IEEE_EMULATION_WARNINGS: _bindgen_ty_22 = 50;
pub const KERN_S390_USER_DEBUG_LOGGING: _bindgen_ty_22 = 51;
pub const KERN_CORE_USES_PID: _bindgen_ty_22 = 52;
pub const KERN_TAINTED: _bindgen_ty_22 = 53;
pub const KERN_CADPID: _bindgen_ty_22 = 54;
pub const KERN_PIDMAX: _bindgen_ty_22 = 55;
pub const KERN_CORE_PATTERN: _bindgen_ty_22 = 56;
pub const KERN_PANIC_ON_OOPS: _bindgen_ty_22 = 57;
pub const KERN_HPPA_PWRSW: _bindgen_ty_22 = 58;
pub const KERN_HPPA_UNALIGNED: _bindgen_ty_22 = 59;
pub const KERN_PRINTK_RATELIMIT: _bindgen_ty_22 = 60;
pub const KERN_PRINTK_RATELIMIT_BURST: _bindgen_ty_22 = 61;
pub const KERN_PTY: _bindgen_ty_22 = 62;
pub const KERN_NGROUPS_MAX: _bindgen_ty_22 = 63;
pub const KERN_SPARC_SCONS_PWROFF: _bindgen_ty_22 = 64;
pub const KERN_HZ_TIMER: _bindgen_ty_22 = 65;
pub const KERN_UNKNOWN_NMI_PANIC: _bindgen_ty_22 = 66;
pub const KERN_BOOTLOADER_TYPE: _bindgen_ty_22 = 67;
pub const KERN_RANDOMIZE: _bindgen_ty_22 = 68;
pub const KERN_SETUID_DUMPABLE: _bindgen_ty_22 = 69;
pub const KERN_SPIN_RETRY: _bindgen_ty_22 = 70;
pub const KERN_ACPI_VIDEO_FLAGS: _bindgen_ty_22 = 71;
pub const KERN_IA64_UNALIGNED: _bindgen_ty_22 = 72;
pub const KERN_COMPAT_LOG: _bindgen_ty_22 = 73;
pub const KERN_MAX_LOCK_DEPTH: _bindgen_ty_22 = 74;
pub const KERN_NMI_WATCHDOG: _bindgen_ty_22 = 75;
pub const KERN_PANIC_ON_NMI: _bindgen_ty_22 = 76;
pub const KERN_PANIC_ON_WARN: _bindgen_ty_22 = 77;
pub const KERN_PANIC_PRINT: _bindgen_ty_22 = 78;
pub type _bindgen_ty_22 = core::ffi::c_uint;
pub const VM_UNUSED1: _bindgen_ty_23 = 1;
pub const VM_UNUSED2: _bindgen_ty_23 = 2;
pub const VM_UNUSED3: _bindgen_ty_23 = 3;
pub const VM_UNUSED4: _bindgen_ty_23 = 4;
pub const VM_OVERCOMMIT_MEMORY: _bindgen_ty_23 = 5;
pub const VM_UNUSED5: _bindgen_ty_23 = 6;
pub const VM_UNUSED7: _bindgen_ty_23 = 7;
pub const VM_UNUSED8: _bindgen_ty_23 = 8;
pub const VM_UNUSED9: _bindgen_ty_23 = 9;
pub const VM_PAGE_CLUSTER: _bindgen_ty_23 = 10;
pub const VM_DIRTY_BACKGROUND: _bindgen_ty_23 = 11;
pub const VM_DIRTY_RATIO: _bindgen_ty_23 = 12;
pub const VM_DIRTY_WB_CS: _bindgen_ty_23 = 13;
pub const VM_DIRTY_EXPIRE_CS: _bindgen_ty_23 = 14;
pub const VM_NR_PDFLUSH_THREADS: _bindgen_ty_23 = 15;
pub const VM_OVERCOMMIT_RATIO: _bindgen_ty_23 = 16;
pub const VM_PAGEBUF: _bindgen_ty_23 = 17;
pub const VM_HUGETLB_PAGES: _bindgen_ty_23 = 18;
pub const VM_SWAPPINESS: _bindgen_ty_23 = 19;
pub const VM_LOWMEM_RESERVE_RATIO: _bindgen_ty_23 = 20;
pub const VM_MIN_FREE_KBYTES: _bindgen_ty_23 = 21;
pub const VM_MAX_MAP_COUNT: _bindgen_ty_23 = 22;
pub const VM_LAPTOP_MODE: _bindgen_ty_23 = 23;
pub const VM_BLOCK_DUMP: _bindgen_ty_23 = 24;
pub const VM_HUGETLB_GROUP: _bindgen_ty_23 = 25;
pub const VM_VFS_CACHE_PRESSURE: _bindgen_ty_23 = 26;
pub const VM_LEGACY_VA_LAYOUT: _bindgen_ty_23 = 27;
pub const VM_SWAP_TOKEN_TIMEOUT: _bindgen_ty_23 = 28;
pub const VM_DROP_PAGECACHE: _bindgen_ty_23 = 29;
pub const VM_PERCPU_PAGELIST_FRACTION: _bindgen_ty_23 = 30;
pub const VM_ZONE_RECLAIM_MODE: _bindgen_ty_23 = 31;
pub const VM_MIN_UNMAPPED: _bindgen_ty_23 = 32;
pub const VM_PANIC_ON_OOM: _bindgen_ty_23 = 33;
pub const VM_VDSO_ENABLED: _bindgen_ty_23 = 34;
pub const VM_MIN_SLAB: _bindgen_ty_23 = 35;
pub type _bindgen_ty_23 = core::ffi::c_uint;
pub const NET_CORE: _bindgen_ty_24 = 1;
pub const NET_ETHER: _bindgen_ty_24 = 2;
pub const NET_802: _bindgen_ty_24 = 3;
pub const NET_UNIX: _bindgen_ty_24 = 4;
pub const NET_IPV4: _bindgen_ty_24 = 5;
pub const NET_IPX: _bindgen_ty_24 = 6;
pub const NET_ATALK: _bindgen_ty_24 = 7;
pub const NET_NETROM: _bindgen_ty_24 = 8;
pub const NET_AX25: _bindgen_ty_24 = 9;
pub const NET_BRIDGE: _bindgen_ty_24 = 10;
pub const NET_ROSE: _bindgen_ty_24 = 11;
pub const NET_IPV6: _bindgen_ty_24 = 12;
pub const NET_X25: _bindgen_ty_24 = 13;
pub const NET_TR: _bindgen_ty_24 = 14;
pub const NET_DECNET: _bindgen_ty_24 = 15;
pub const NET_ECONET: _bindgen_ty_24 = 16;
pub const NET_SCTP: _bindgen_ty_24 = 17;
pub const NET_LLC: _bindgen_ty_24 = 18;
pub const NET_NETFILTER: _bindgen_ty_24 = 19;
pub const NET_DCCP: _bindgen_ty_24 = 20;
pub const NET_IRDA: _bindgen_ty_24 = 412;
pub type _bindgen_ty_24 = core::ffi::c_uint;
pub const RANDOM_POOLSIZE: _bindgen_ty_25 = 1;
pub const RANDOM_ENTROPY_COUNT: _bindgen_ty_25 = 2;
pub const RANDOM_READ_THRESH: _bindgen_ty_25 = 3;
pub const RANDOM_WRITE_THRESH: _bindgen_ty_25 = 4;
pub const RANDOM_BOOT_ID: _bindgen_ty_25 = 5;
pub const RANDOM_UUID: _bindgen_ty_25 = 6;
pub type _bindgen_ty_25 = core::ffi::c_uint;
pub const PTY_MAX: _bindgen_ty_26 = 1;
pub const PTY_NR: _bindgen_ty_26 = 2;
pub type _bindgen_ty_26 = core::ffi::c_uint;
pub const BUS_ISA_MEM_BASE: _bindgen_ty_27 = 1;
pub const BUS_ISA_PORT_BASE: _bindgen_ty_27 = 2;
pub const BUS_ISA_PORT_SHIFT: _bindgen_ty_27 = 3;
pub type _bindgen_ty_27 = core::ffi::c_uint;
pub const NET_CORE_WMEM_MAX: _bindgen_ty_28 = 1;
pub const NET_CORE_RMEM_MAX: _bindgen_ty_28 = 2;
pub const NET_CORE_WMEM_DEFAULT: _bindgen_ty_28 = 3;
pub const NET_CORE_RMEM_DEFAULT: _bindgen_ty_28 = 4;
pub const NET_CORE_MAX_BACKLOG: _bindgen_ty_28 = 6;
pub const NET_CORE_FASTROUTE: _bindgen_ty_28 = 7;
pub const NET_CORE_MSG_COST: _bindgen_ty_28 = 8;
pub const NET_CORE_MSG_BURST: _bindgen_ty_28 = 9;
pub const NET_CORE_OPTMEM_MAX: _bindgen_ty_28 = 10;
pub const NET_CORE_HOT_LIST_LENGTH: _bindgen_ty_28 = 11;
pub const NET_CORE_DIVERT_VERSION: _bindgen_ty_28 = 12;
pub const NET_CORE_NO_CONG_THRESH: _bindgen_ty_28 = 13;
pub const NET_CORE_NO_CONG: _bindgen_ty_28 = 14;
pub const NET_CORE_LO_CONG: _bindgen_ty_28 = 15;
pub const NET_CORE_MOD_CONG: _bindgen_ty_28 = 16;
pub const NET_CORE_DEV_WEIGHT: _bindgen_ty_28 = 17;
pub const NET_CORE_SOMAXCONN: _bindgen_ty_28 = 18;
pub const NET_CORE_BUDGET: _bindgen_ty_28 = 19;
pub const NET_CORE_AEVENT_ETIME: _bindgen_ty_28 = 20;
pub const NET_CORE_AEVENT_RSEQTH: _bindgen_ty_28 = 21;
pub const NET_CORE_WARNINGS: _bindgen_ty_28 = 22;
pub type _bindgen_ty_28 = core::ffi::c_uint;
pub const NET_UNIX_DESTROY_DELAY: _bindgen_ty_29 = 1;
pub const NET_UNIX_DELETE_DELAY: _bindgen_ty_29 = 2;
pub const NET_UNIX_MAX_DGRAM_QLEN: _bindgen_ty_29 = 3;
pub type _bindgen_ty_29 = core::ffi::c_uint;
pub const NET_NF_CONNTRACK_MAX: _bindgen_ty_30 = 1;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT: _bindgen_ty_30 = 2;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV: _bindgen_ty_30 = 3;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED: _bindgen_ty_30 = 4;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT: _bindgen_ty_30 = 5;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT: _bindgen_ty_30 = 6;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK: _bindgen_ty_30 = 7;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT: _bindgen_ty_30 = 8;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE: _bindgen_ty_30 = 9;
pub const NET_NF_CONNTRACK_UDP_TIMEOUT: _bindgen_ty_30 = 10;
pub const NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM: _bindgen_ty_30 = 11;
pub const NET_NF_CONNTRACK_ICMP_TIMEOUT: _bindgen_ty_30 = 12;
pub const NET_NF_CONNTRACK_GENERIC_TIMEOUT: _bindgen_ty_30 = 13;
pub const NET_NF_CONNTRACK_BUCKETS: _bindgen_ty_30 = 14;
pub const NET_NF_CONNTRACK_LOG_INVALID: _bindgen_ty_30 = 15;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS: _bindgen_ty_30 = 16;
pub const NET_NF_CONNTRACK_TCP_LOOSE: _bindgen_ty_30 = 17;
pub const NET_NF_CONNTRACK_TCP_BE_LIBERAL: _bindgen_ty_30 = 18;
pub const NET_NF_CONNTRACK_TCP_MAX_RETRANS: _bindgen_ty_30 = 19;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED: _bindgen_ty_30 = 20;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT: _bindgen_ty_30 = 21;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED: _bindgen_ty_30 = 22;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED: _bindgen_ty_30 = 23;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT: _bindgen_ty_30 = 24;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD: _bindgen_ty_30 = 25;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT: _bindgen_ty_30 = 26;
pub const NET_NF_CONNTRACK_COUNT: _bindgen_ty_30 = 27;
pub const NET_NF_CONNTRACK_ICMPV6_TIMEOUT: _bindgen_ty_30 = 28;
pub const NET_NF_CONNTRACK_FRAG6_TIMEOUT: _bindgen_ty_30 = 29;
pub const NET_NF_CONNTRACK_FRAG6_LOW_THRESH: _bindgen_ty_30 = 30;
pub const NET_NF_CONNTRACK_FRAG6_HIGH_THRESH: _bindgen_ty_30 = 31;
pub const NET_NF_CONNTRACK_CHECKSUM: _bindgen_ty_30 = 32;
pub type _bindgen_ty_30 = core::ffi::c_uint;
pub const NET_IPV4_FORWARD: _bindgen_ty_31 = 8;
pub const NET_IPV4_DYNADDR: _bindgen_ty_31 = 9;
pub const NET_IPV4_CONF: _bindgen_ty_31 = 16;
pub const NET_IPV4_NEIGH: _bindgen_ty_31 = 17;
pub const NET_IPV4_ROUTE: _bindgen_ty_31 = 18;
pub const NET_IPV4_FIB_HASH: _bindgen_ty_31 = 19;
pub const NET_IPV4_NETFILTER: _bindgen_ty_31 = 20;
pub const NET_IPV4_TCP_TIMESTAMPS: _bindgen_ty_31 = 33;
pub const NET_IPV4_TCP_WINDOW_SCALING: _bindgen_ty_31 = 34;
pub const NET_IPV4_TCP_SACK: _bindgen_ty_31 = 35;
pub const NET_IPV4_TCP_RETRANS_COLLAPSE: _bindgen_ty_31 = 36;
pub const NET_IPV4_DEFAULT_TTL: _bindgen_ty_31 = 37;
pub const NET_IPV4_AUTOCONFIG: _bindgen_ty_31 = 38;
pub const NET_IPV4_NO_PMTU_DISC: _bindgen_ty_31 = 39;
pub const NET_IPV4_TCP_SYN_RETRIES: _bindgen_ty_31 = 40;
pub const NET_IPV4_IPFRAG_HIGH_THRESH: _bindgen_ty_31 = 41;
pub const NET_IPV4_IPFRAG_LOW_THRESH: _bindgen_ty_31 = 42;
pub const NET_IPV4_IPFRAG_TIME: _bindgen_ty_31 = 43;
pub const NET_IPV4_TCP_MAX_KA_PROBES: _bindgen_ty_31 = 44;
pub const NET_IPV4_TCP_KEEPALIVE_TIME: _bindgen_ty_31 = 45;
pub const NET_IPV4_TCP_KEEPALIVE_PROBES: _bindgen_ty_31 = 46;
pub const NET_IPV4_TCP_RETRIES1: _bindgen_ty_31 = 47;
pub const NET_IPV4_TCP_RETRIES2: _bindgen_ty_31 = 48;
pub const NET_IPV4_TCP_FIN_TIMEOUT: _bindgen_ty_31 = 49;
pub const NET_IPV4_IP_MASQ_DEBUG: _bindgen_ty_31 = 50;
pub const NET_TCP_SYNCOOKIES: _bindgen_ty_31 = 51;
pub const NET_TCP_STDURG: _bindgen_ty_31 = 52;
pub const NET_TCP_RFC1337: _bindgen_ty_31 = 53;
pub const NET_TCP_SYN_TAILDROP: _bindgen_ty_31 = 54;
pub const NET_TCP_MAX_SYN_BACKLOG: _bindgen_ty_31 = 55;
pub const NET_IPV4_LOCAL_PORT_RANGE: _bindgen_ty_31 = 56;
pub const NET_IPV4_ICMP_ECHO_IGNORE_ALL: _bindgen_ty_31 = 57;
pub const NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS: _bindgen_ty_31 = 58;
pub const NET_IPV4_ICMP_SOURCEQUENCH_RATE: _bindgen_ty_31 = 59;
pub const NET_IPV4_ICMP_DESTUNREACH_RATE: _bindgen_ty_31 = 60;
pub const NET_IPV4_ICMP_TIMEEXCEED_RATE: _bindgen_ty_31 = 61;
pub const NET_IPV4_ICMP_PARAMPROB_RATE: _bindgen_ty_31 = 62;
pub const NET_IPV4_ICMP_ECHOREPLY_RATE: _bindgen_ty_31 = 63;
pub const NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES: _bindgen_ty_31 = 64;
pub const NET_IPV4_IGMP_MAX_MEMBERSHIPS: _bindgen_ty_31 = 65;
pub const NET_TCP_TW_RECYCLE: _bindgen_ty_31 = 66;
pub const NET_IPV4_ALWAYS_DEFRAG: _bindgen_ty_31 = 67;
pub const NET_IPV4_TCP_KEEPALIVE_INTVL: _bindgen_ty_31 = 68;
pub const NET_IPV4_INET_PEER_THRESHOLD: _bindgen_ty_31 = 69;
pub const NET_IPV4_INET_PEER_MINTTL: _bindgen_ty_31 = 70;
pub const NET_IPV4_INET_PEER_MAXTTL: _bindgen_ty_31 = 71;
pub const NET_IPV4_INET_PEER_GC_MINTIME: _bindgen_ty_31 = 72;
pub const NET_IPV4_INET_PEER_GC_MAXTIME: _bindgen_ty_31 = 73;
pub const NET_TCP_ORPHAN_RETRIES: _bindgen_ty_31 = 74;
pub const NET_TCP_ABORT_ON_OVERFLOW: _bindgen_ty_31 = 75;
pub const NET_TCP_SYNACK_RETRIES: _bindgen_ty_31 = 76;
pub const NET_TCP_MAX_ORPHANS: _bindgen_ty_31 = 77;
pub const NET_TCP_MAX_TW_BUCKETS: _bindgen_ty_31 = 78;
pub const NET_TCP_FACK: _bindgen_ty_31 = 79;
pub const NET_TCP_REORDERING: _bindgen_ty_31 = 80;
pub const NET_TCP_ECN: _bindgen_ty_31 = 81;
pub const NET_TCP_DSACK: _bindgen_ty_31 = 82;
pub const NET_TCP_MEM: _bindgen_ty_31 = 83;
pub const NET_TCP_WMEM: _bindgen_ty_31 = 84;
pub const NET_TCP_RMEM: _bindgen_ty_31 = 85;
pub const NET_TCP_APP_WIN: _bindgen_ty_31 = 86;
pub const NET_TCP_ADV_WIN_SCALE: _bindgen_ty_31 = 87;
pub const NET_IPV4_NONLOCAL_BIND: _bindgen_ty_31 = 88;
pub const NET_IPV4_ICMP_RATELIMIT: _bindgen_ty_31 = 89;
pub const NET_IPV4_ICMP_RATEMASK: _bindgen_ty_31 = 90;
pub const NET_TCP_TW_REUSE: _bindgen_ty_31 = 91;
pub const NET_TCP_FRTO: _bindgen_ty_31 = 92;
pub const NET_TCP_LOW_LATENCY: _bindgen_ty_31 = 93;
pub const NET_IPV4_IPFRAG_SECRET_INTERVAL: _bindgen_ty_31 = 94;
pub const NET_IPV4_IGMP_MAX_MSF: _bindgen_ty_31 = 96;
pub const NET_TCP_NO_METRICS_SAVE: _bindgen_ty_31 = 97;
pub const NET_TCP_DEFAULT_WIN_SCALE: _bindgen_ty_31 = 105;
pub const NET_TCP_MODERATE_RCVBUF: _bindgen_ty_31 = 106;
pub const NET_TCP_TSO_WIN_DIVISOR: _bindgen_ty_31 = 107;
pub const NET_TCP_BIC_BETA: _bindgen_ty_31 = 108;
pub const NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR: _bindgen_ty_31 = 109;
pub const NET_TCP_CONG_CONTROL: _bindgen_ty_31 = 110;
pub const NET_TCP_ABC: _bindgen_ty_31 = 111;
pub const NET_IPV4_IPFRAG_MAX_DIST: _bindgen_ty_31 = 112;
pub const NET_TCP_MTU_PROBING: _bindgen_ty_31 = 113;
pub const NET_TCP_BASE_MSS: _bindgen_ty_31 = 114;
pub const NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS: _bindgen_ty_31 = 115;
pub const NET_TCP_DMA_COPYBREAK: _bindgen_ty_31 = 116;
pub const NET_TCP_SLOW_START_AFTER_IDLE: _bindgen_ty_31 = 117;
pub const NET_CIPSOV4_CACHE_ENABLE: _bindgen_ty_31 = 118;
pub const NET_CIPSOV4_CACHE_BUCKET_SIZE: _bindgen_ty_31 = 119;
pub const NET_CIPSOV4_RBM_OPTFMT: _bindgen_ty_31 = 120;
pub const NET_CIPSOV4_RBM_STRICTVALID: _bindgen_ty_31 = 121;
pub const NET_TCP_AVAIL_CONG_CONTROL: _bindgen_ty_31 = 122;
pub const NET_TCP_ALLOWED_CONG_CONTROL: _bindgen_ty_31 = 123;
pub const NET_TCP_MAX_SSTHRESH: _bindgen_ty_31 = 124;
pub const NET_TCP_FRTO_RESPONSE: _bindgen_ty_31 = 125;
pub type _bindgen_ty_31 = core::ffi::c_uint;
pub const NET_IPV4_ROUTE_FLUSH: _bindgen_ty_32 = 1;
pub const NET_IPV4_ROUTE_MIN_DELAY: _bindgen_ty_32 = 2;
pub const NET_IPV4_ROUTE_MAX_DELAY: _bindgen_ty_32 = 3;
pub const NET_IPV4_ROUTE_GC_THRESH: _bindgen_ty_32 = 4;
pub const NET_IPV4_ROUTE_MAX_SIZE: _bindgen_ty_32 = 5;
pub const NET_IPV4_ROUTE_GC_MIN_INTERVAL: _bindgen_ty_32 = 6;
pub const NET_IPV4_ROUTE_GC_TIMEOUT: _bindgen_ty_32 = 7;
pub const NET_IPV4_ROUTE_GC_INTERVAL: _bindgen_ty_32 = 8;
pub const NET_IPV4_ROUTE_REDIRECT_LOAD: _bindgen_ty_32 = 9;
pub const NET_IPV4_ROUTE_REDIRECT_NUMBER: _bindgen_ty_32 = 10;
pub const NET_IPV4_ROUTE_REDIRECT_SILENCE: _bindgen_ty_32 = 11;
pub const NET_IPV4_ROUTE_ERROR_COST: _bindgen_ty_32 = 12;
pub const NET_IPV4_ROUTE_ERROR_BURST: _bindgen_ty_32 = 13;
pub const NET_IPV4_ROUTE_GC_ELASTICITY: _bindgen_ty_32 = 14;
pub const NET_IPV4_ROUTE_MTU_EXPIRES: _bindgen_ty_32 = 15;
pub const NET_IPV4_ROUTE_MIN_PMTU: _bindgen_ty_32 = 16;
pub const NET_IPV4_ROUTE_MIN_ADVMSS: _bindgen_ty_32 = 17;
pub const NET_IPV4_ROUTE_SECRET_INTERVAL: _bindgen_ty_32 = 18;
pub const NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS: _bindgen_ty_32 = 19;
pub type _bindgen_ty_32 = core::ffi::c_uint;
pub const NET_PROTO_CONF_ALL: _bindgen_ty_33 = -2;
pub const NET_PROTO_CONF_DEFAULT: _bindgen_ty_33 = -3;
pub type _bindgen_ty_33 = core::ffi::c_int;
pub const NET_IPV4_CONF_FORWARDING: _bindgen_ty_34 = 1;
pub const NET_IPV4_CONF_MC_FORWARDING: _bindgen_ty_34 = 2;
pub const NET_IPV4_CONF_PROXY_ARP: _bindgen_ty_34 = 3;
pub const NET_IPV4_CONF_ACCEPT_REDIRECTS: _bindgen_ty_34 = 4;
pub const NET_IPV4_CONF_SECURE_REDIRECTS: _bindgen_ty_34 = 5;
pub const NET_IPV4_CONF_SEND_REDIRECTS: _bindgen_ty_34 = 6;
pub const NET_IPV4_CONF_SHARED_MEDIA: _bindgen_ty_34 = 7;
pub const NET_IPV4_CONF_RP_FILTER: _bindgen_ty_34 = 8;
pub const NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE: _bindgen_ty_34 = 9;
pub const NET_IPV4_CONF_BOOTP_RELAY: _bindgen_ty_34 = 10;
pub const NET_IPV4_CONF_LOG_MARTIANS: _bindgen_ty_34 = 11;
pub const NET_IPV4_CONF_TAG: _bindgen_ty_34 = 12;
pub const NET_IPV4_CONF_ARPFILTER: _bindgen_ty_34 = 13;
pub const NET_IPV4_CONF_MEDIUM_ID: _bindgen_ty_34 = 14;
pub const NET_IPV4_CONF_NOXFRM: _bindgen_ty_34 = 15;
pub const NET_IPV4_CONF_NOPOLICY: _bindgen_ty_34 = 16;
pub const NET_IPV4_CONF_FORCE_IGMP_VERSION: _bindgen_ty_34 = 17;
pub const NET_IPV4_CONF_ARP_ANNOUNCE: _bindgen_ty_34 = 18;
pub const NET_IPV4_CONF_ARP_IGNORE: _bindgen_ty_34 = 19;
pub const NET_IPV4_CONF_PROMOTE_SECONDARIES: _bindgen_ty_34 = 20;
pub const NET_IPV4_CONF_ARP_ACCEPT: _bindgen_ty_34 = 21;
pub const NET_IPV4_CONF_ARP_NOTIFY: _bindgen_ty_34 = 22;
pub const NET_IPV4_CONF_ARP_EVICT_NOCARRIER: _bindgen_ty_34 = 23;
pub type _bindgen_ty_34 = core::ffi::c_uint;
pub const NET_IPV4_NF_CONNTRACK_MAX: _bindgen_ty_35 = 1;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT: _bindgen_ty_35 = 2;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV: _bindgen_ty_35 = 3;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED: _bindgen_ty_35 = 4;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT: _bindgen_ty_35 = 5;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT: _bindgen_ty_35 = 6;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK: _bindgen_ty_35 = 7;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT: _bindgen_ty_35 = 8;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE: _bindgen_ty_35 = 9;
pub const NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT: _bindgen_ty_35 = 10;
pub const NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM: _bindgen_ty_35 = 11;
pub const NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT: _bindgen_ty_35 = 12;
pub const NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT: _bindgen_ty_35 = 13;
pub const NET_IPV4_NF_CONNTRACK_BUCKETS: _bindgen_ty_35 = 14;
pub const NET_IPV4_NF_CONNTRACK_LOG_INVALID: _bindgen_ty_35 = 15;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS: _bindgen_ty_35 = 16;
pub const NET_IPV4_NF_CONNTRACK_TCP_LOOSE: _bindgen_ty_35 = 17;
pub const NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL: _bindgen_ty_35 = 18;
pub const NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS: _bindgen_ty_35 = 19;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED: _bindgen_ty_35 = 20;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT: _bindgen_ty_35 = 21;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED: _bindgen_ty_35 = 22;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED: _bindgen_ty_35 = 23;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT: _bindgen_ty_35 = 24;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD: _bindgen_ty_35 = 25;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT: _bindgen_ty_35 = 26;
pub const NET_IPV4_NF_CONNTRACK_COUNT: _bindgen_ty_35 = 27;
pub const NET_IPV4_NF_CONNTRACK_CHECKSUM: _bindgen_ty_35 = 28;
pub type _bindgen_ty_35 = core::ffi::c_uint;
pub const NET_IPV6_CONF: _bindgen_ty_36 = 16;
pub const NET_IPV6_NEIGH: _bindgen_ty_36 = 17;
pub const NET_IPV6_ROUTE: _bindgen_ty_36 = 18;
pub const NET_IPV6_ICMP: _bindgen_ty_36 = 19;
pub const NET_IPV6_BINDV6ONLY: _bindgen_ty_36 = 20;
pub const NET_IPV6_IP6FRAG_HIGH_THRESH: _bindgen_ty_36 = 21;
pub const NET_IPV6_IP6FRAG_LOW_THRESH: _bindgen_ty_36 = 22;
pub const NET_IPV6_IP6FRAG_TIME: _bindgen_ty_36 = 23;
pub const NET_IPV6_IP6FRAG_SECRET_INTERVAL: _bindgen_ty_36 = 24;
pub const NET_IPV6_MLD_MAX_MSF: _bindgen_ty_36 = 25;
pub type _bindgen_ty_36 = core::ffi::c_uint;
pub const NET_IPV6_ROUTE_FLUSH: _bindgen_ty_37 = 1;
pub const NET_IPV6_ROUTE_GC_THRESH: _bindgen_ty_37 = 2;
pub const NET_IPV6_ROUTE_MAX_SIZE: _bindgen_ty_37 = 3;
pub const NET_IPV6_ROUTE_GC_MIN_INTERVAL: _bindgen_ty_37 = 4;
pub const NET_IPV6_ROUTE_GC_TIMEOUT: _bindgen_ty_37 = 5;
pub const NET_IPV6_ROUTE_GC_INTERVAL: _bindgen_ty_37 = 6;
pub const NET_IPV6_ROUTE_GC_ELASTICITY: _bindgen_ty_37 = 7;
pub const NET_IPV6_ROUTE_MTU_EXPIRES: _bindgen_ty_37 = 8;
pub const NET_IPV6_ROUTE_MIN_ADVMSS: _bindgen_ty_37 = 9;
pub const NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS: _bindgen_ty_37 = 10;
pub type _bindgen_ty_37 = core::ffi::c_uint;
pub const NET_IPV6_FORWARDING: _bindgen_ty_38 = 1;
pub const NET_IPV6_HOP_LIMIT: _bindgen_ty_38 = 2;
pub const NET_IPV6_MTU: _bindgen_ty_38 = 3;
pub const NET_IPV6_ACCEPT_RA: _bindgen_ty_38 = 4;
pub const NET_IPV6_ACCEPT_REDIRECTS: _bindgen_ty_38 = 5;
pub const NET_IPV6_AUTOCONF: _bindgen_ty_38 = 6;
pub const NET_IPV6_DAD_TRANSMITS: _bindgen_ty_38 = 7;
pub const NET_IPV6_RTR_SOLICITS: _bindgen_ty_38 = 8;
pub const NET_IPV6_RTR_SOLICIT_INTERVAL: _bindgen_ty_38 = 9;
pub const NET_IPV6_RTR_SOLICIT_DELAY: _bindgen_ty_38 = 10;
pub const NET_IPV6_USE_TEMPADDR: _bindgen_ty_38 = 11;
pub const NET_IPV6_TEMP_VALID_LFT: _bindgen_ty_38 = 12;
pub const NET_IPV6_TEMP_PREFERED_LFT: _bindgen_ty_38 = 13;
pub const NET_IPV6_REGEN_MAX_RETRY: _bindgen_ty_38 = 14;
pub const NET_IPV6_MAX_DESYNC_FACTOR: _bindgen_ty_38 = 15;
pub const NET_IPV6_MAX_ADDRESSES: _bindgen_ty_38 = 16;
pub const NET_IPV6_FORCE_MLD_VERSION: _bindgen_ty_38 = 17;
pub const NET_IPV6_ACCEPT_RA_DEFRTR: _bindgen_ty_38 = 18;
pub const NET_IPV6_ACCEPT_RA_PINFO: _bindgen_ty_38 = 19;
pub const NET_IPV6_ACCEPT_RA_RTR_PREF: _bindgen_ty_38 = 20;
pub const NET_IPV6_RTR_PROBE_INTERVAL: _bindgen_ty_38 = 21;
pub const NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN: _bindgen_ty_38 = 22;
pub const NET_IPV6_PROXY_NDP: _bindgen_ty_38 = 23;
pub const NET_IPV6_ACCEPT_SOURCE_ROUTE: _bindgen_ty_38 = 25;
pub const NET_IPV6_ACCEPT_RA_FROM_LOCAL: _bindgen_ty_38 = 26;
pub const NET_IPV6_ACCEPT_RA_RT_INFO_MIN_PLEN: _bindgen_ty_38 = 27;
pub const NET_IPV6_RA_DEFRTR_METRIC: _bindgen_ty_38 = 28;
pub const __NET_IPV6_MAX: _bindgen_ty_38 = 29;
pub type _bindgen_ty_38 = core::ffi::c_uint;
pub const NET_IPV6_ICMP_RATELIMIT: _bindgen_ty_39 = 1;
pub const NET_IPV6_ICMP_ECHO_IGNORE_ALL: _bindgen_ty_39 = 2;
pub type _bindgen_ty_39 = core::ffi::c_uint;
pub const NET_NEIGH_MCAST_SOLICIT: _bindgen_ty_40 = 1;
pub const NET_NEIGH_UCAST_SOLICIT: _bindgen_ty_40 = 2;
pub const NET_NEIGH_APP_SOLICIT: _bindgen_ty_40 = 3;
pub const NET_NEIGH_RETRANS_TIME: _bindgen_ty_40 = 4;
pub const NET_NEIGH_REACHABLE_TIME: _bindgen_ty_40 = 5;
pub const NET_NEIGH_DELAY_PROBE_TIME: _bindgen_ty_40 = 6;
pub const NET_NEIGH_GC_STALE_TIME: _bindgen_ty_40 = 7;
pub const NET_NEIGH_UNRES_QLEN: _bindgen_ty_40 = 8;
pub const NET_NEIGH_PROXY_QLEN: _bindgen_ty_40 = 9;
pub const NET_NEIGH_ANYCAST_DELAY: _bindgen_ty_40 = 10;
pub const NET_NEIGH_PROXY_DELAY: _bindgen_ty_40 = 11;
pub const NET_NEIGH_LOCKTIME: _bindgen_ty_40 = 12;
pub const NET_NEIGH_GC_INTERVAL: _bindgen_ty_40 = 13;
pub const NET_NEIGH_GC_THRESH1: _bindgen_ty_40 = 14;
pub const NET_NEIGH_GC_THRESH2: _bindgen_ty_40 = 15;
pub const NET_NEIGH_GC_THRESH3: _bindgen_ty_40 = 16;
pub const NET_NEIGH_RETRANS_TIME_MS: _bindgen_ty_40 = 17;
pub const NET_NEIGH_REACHABLE_TIME_MS: _bindgen_ty_40 = 18;
pub const NET_NEIGH_INTERVAL_PROBE_TIME_MS: _bindgen_ty_40 = 19;
pub type _bindgen_ty_40 = core::ffi::c_uint;
pub const NET_DCCP_DEFAULT: _bindgen_ty_41 = 1;
pub type _bindgen_ty_41 = core::ffi::c_uint;
pub const NET_IPX_PPROP_BROADCASTING: _bindgen_ty_42 = 1;
pub const NET_IPX_FORWARDING: _bindgen_ty_42 = 2;
pub type _bindgen_ty_42 = core::ffi::c_uint;
pub const NET_LLC2: _bindgen_ty_43 = 1;
pub const NET_LLC_STATION: _bindgen_ty_43 = 2;
pub type _bindgen_ty_43 = core::ffi::c_uint;
pub const NET_LLC2_TIMEOUT: _bindgen_ty_44 = 1;
pub type _bindgen_ty_44 = core::ffi::c_uint;
pub const NET_LLC_STATION_ACK_TIMEOUT: _bindgen_ty_45 = 1;
pub type _bindgen_ty_45 = core::ffi::c_uint;
pub const NET_LLC2_ACK_TIMEOUT: _bindgen_ty_46 = 1;
pub const NET_LLC2_P_TIMEOUT: _bindgen_ty_46 = 2;
pub const NET_LLC2_REJ_TIMEOUT: _bindgen_ty_46 = 3;
pub const NET_LLC2_BUSY_TIMEOUT: _bindgen_ty_46 = 4;
pub type _bindgen_ty_46 = core::ffi::c_uint;
pub const NET_ATALK_AARP_EXPIRY_TIME: _bindgen_ty_47 = 1;
pub const NET_ATALK_AARP_TICK_TIME: _bindgen_ty_47 = 2;
pub const NET_ATALK_AARP_RETRANSMIT_LIMIT: _bindgen_ty_47 = 3;
pub const NET_ATALK_AARP_RESOLVE_TIME: _bindgen_ty_47 = 4;
pub type _bindgen_ty_47 = core::ffi::c_uint;
pub const NET_NETROM_DEFAULT_PATH_QUALITY: _bindgen_ty_48 = 1;
pub const NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER: _bindgen_ty_48 = 2;
pub const NET_NETROM_NETWORK_TTL_INITIALISER: _bindgen_ty_48 = 3;
pub const NET_NETROM_TRANSPORT_TIMEOUT: _bindgen_ty_48 = 4;
pub const NET_NETROM_TRANSPORT_MAXIMUM_TRIES: _bindgen_ty_48 = 5;
pub const NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY: _bindgen_ty_48 = 6;
pub const NET_NETROM_TRANSPORT_BUSY_DELAY: _bindgen_ty_48 = 7;
pub const NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE: _bindgen_ty_48 = 8;
pub const NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT: _bindgen_ty_48 = 9;
pub const NET_NETROM_ROUTING_CONTROL: _bindgen_ty_48 = 10;
pub const NET_NETROM_LINK_FAILS_COUNT: _bindgen_ty_48 = 11;
pub const NET_NETROM_RESET: _bindgen_ty_48 = 12;
pub type _bindgen_ty_48 = core::ffi::c_uint;
pub const NET_AX25_IP_DEFAULT_MODE: _bindgen_ty_49 = 1;
pub const NET_AX25_DEFAULT_MODE: _bindgen_ty_49 = 2;
pub const NET_AX25_BACKOFF_TYPE: _bindgen_ty_49 = 3;
pub const NET_AX25_CONNECT_MODE: _bindgen_ty_49 = 4;
pub const NET_AX25_STANDARD_WINDOW: _bindgen_ty_49 = 5;
pub const NET_AX25_EXTENDED_WINDOW: _bindgen_ty_49 = 6;
pub const NET_AX25_T1_TIMEOUT: _bindgen_ty_49 = 7;
pub const NET_AX25_T2_TIMEOUT: _bindgen_ty_49 = 8;
pub const NET_AX25_T3_TIMEOUT: _bindgen_ty_49 = 9;
pub const NET_AX25_IDLE_TIMEOUT: _bindgen_ty_49 = 10;
pub const NET_AX25_N2: _bindgen_ty_49 = 11;
pub const NET_AX25_PACLEN: _bindgen_ty_49 = 12;
pub const NET_AX25_PROTOCOL: _bindgen_ty_49 = 13;
pub const NET_AX25_DAMA_SLAVE_TIMEOUT: _bindgen_ty_49 = 14;
pub type _bindgen_ty_49 = core::ffi::c_uint;
pub const NET_ROSE_RESTART_REQUEST_TIMEOUT: _bindgen_ty_50 = 1;
pub const NET_ROSE_CALL_REQUEST_TIMEOUT: _bindgen_ty_50 = 2;
pub const NET_ROSE_RESET_REQUEST_TIMEOUT: _bindgen_ty_50 = 3;
pub const NET_ROSE_CLEAR_REQUEST_TIMEOUT: _bindgen_ty_50 = 4;
pub const NET_ROSE_ACK_HOLD_BACK_TIMEOUT: _bindgen_ty_50 = 5;
pub const NET_ROSE_ROUTING_CONTROL: _bindgen_ty_50 = 6;
pub const NET_ROSE_LINK_FAIL_TIMEOUT: _bindgen_ty_50 = 7;
pub const NET_ROSE_MAX_VCS: _bindgen_ty_50 = 8;
pub const NET_ROSE_WINDOW_SIZE: _bindgen_ty_50 = 9;
pub const NET_ROSE_NO_ACTIVITY_TIMEOUT: _bindgen_ty_50 = 10;
pub type _bindgen_ty_50 = core::ffi::c_uint;
pub const NET_X25_RESTART_REQUEST_TIMEOUT: _bindgen_ty_51 = 1;
pub const NET_X25_CALL_REQUEST_TIMEOUT: _bindgen_ty_51 = 2;
pub const NET_X25_RESET_REQUEST_TIMEOUT: _bindgen_ty_51 = 3;
pub const NET_X25_CLEAR_REQUEST_TIMEOUT: _bindgen_ty_51 = 4;
pub const NET_X25_ACK_HOLD_BACK_TIMEOUT: _bindgen_ty_51 = 5;
pub const NET_X25_FORWARD: _bindgen_ty_51 = 6;
pub type _bindgen_ty_51 = core::ffi::c_uint;
pub const NET_TR_RIF_TIMEOUT: _bindgen_ty_52 = 1;
pub type _bindgen_ty_52 = core::ffi::c_uint;
pub const NET_DECNET_NODE_TYPE: _bindgen_ty_53 = 1;
pub const NET_DECNET_NODE_ADDRESS: _bindgen_ty_53 = 2;
pub const NET_DECNET_NODE_NAME: _bindgen_ty_53 = 3;
pub const NET_DECNET_DEFAULT_DEVICE: _bindgen_ty_53 = 4;
pub const NET_DECNET_TIME_WAIT: _bindgen_ty_53 = 5;
pub const NET_DECNET_DN_COUNT: _bindgen_ty_53 = 6;
pub const NET_DECNET_DI_COUNT: _bindgen_ty_53 = 7;
pub const NET_DECNET_DR_COUNT: _bindgen_ty_53 = 8;
pub const NET_DECNET_DST_GC_INTERVAL: _bindgen_ty_53 = 9;
pub const NET_DECNET_CONF: _bindgen_ty_53 = 10;
pub const NET_DECNET_NO_FC_MAX_CWND: _bindgen_ty_53 = 11;
pub const NET_DECNET_MEM: _bindgen_ty_53 = 12;
pub const NET_DECNET_RMEM: _bindgen_ty_53 = 13;
pub const NET_DECNET_WMEM: _bindgen_ty_53 = 14;
pub const NET_DECNET_DEBUG_LEVEL: _bindgen_ty_53 = 255;
pub type _bindgen_ty_53 = core::ffi::c_uint;
pub const NET_DECNET_CONF_LOOPBACK: _bindgen_ty_54 = -2;
pub const NET_DECNET_CONF_DDCMP: _bindgen_ty_54 = -3;
pub const NET_DECNET_CONF_PPP: _bindgen_ty_54 = -4;
pub const NET_DECNET_CONF_X25: _bindgen_ty_54 = -5;
pub const NET_DECNET_CONF_GRE: _bindgen_ty_54 = -6;
pub const NET_DECNET_CONF_ETHER: _bindgen_ty_54 = -7;
pub type _bindgen_ty_54 = core::ffi::c_int;
pub const NET_DECNET_CONF_DEV_PRIORITY: _bindgen_ty_55 = 1;
pub const NET_DECNET_CONF_DEV_T1: _bindgen_ty_55 = 2;
pub const NET_DECNET_CONF_DEV_T2: _bindgen_ty_55 = 3;
pub const NET_DECNET_CONF_DEV_T3: _bindgen_ty_55 = 4;
pub const NET_DECNET_CONF_DEV_FORWARDING: _bindgen_ty_55 = 5;
pub const NET_DECNET_CONF_DEV_BLKSIZE: _bindgen_ty_55 = 6;
pub const NET_DECNET_CONF_DEV_STATE: _bindgen_ty_55 = 7;
pub type _bindgen_ty_55 = core::ffi::c_uint;
pub const NET_SCTP_RTO_INITIAL: _bindgen_ty_56 = 1;
pub const NET_SCTP_RTO_MIN: _bindgen_ty_56 = 2;
pub const NET_SCTP_RTO_MAX: _bindgen_ty_56 = 3;
pub const NET_SCTP_RTO_ALPHA: _bindgen_ty_56 = 4;
pub const NET_SCTP_RTO_BETA: _bindgen_ty_56 = 5;
pub const NET_SCTP_VALID_COOKIE_LIFE: _bindgen_ty_56 = 6;
pub const NET_SCTP_ASSOCIATION_MAX_RETRANS: _bindgen_ty_56 = 7;
pub const NET_SCTP_PATH_MAX_RETRANS: _bindgen_ty_56 = 8;
pub const NET_SCTP_MAX_INIT_RETRANSMITS: _bindgen_ty_56 = 9;
pub const NET_SCTP_HB_INTERVAL: _bindgen_ty_56 = 10;
pub const NET_SCTP_PRESERVE_ENABLE: _bindgen_ty_56 = 11;
pub const NET_SCTP_MAX_BURST: _bindgen_ty_56 = 12;
pub const NET_SCTP_ADDIP_ENABLE: _bindgen_ty_56 = 13;
pub const NET_SCTP_PRSCTP_ENABLE: _bindgen_ty_56 = 14;
pub const NET_SCTP_SNDBUF_POLICY: _bindgen_ty_56 = 15;
pub const NET_SCTP_SACK_TIMEOUT: _bindgen_ty_56 = 16;
pub const NET_SCTP_RCVBUF_POLICY: _bindgen_ty_56 = 17;
pub type _bindgen_ty_56 = core::ffi::c_uint;
pub const NET_BRIDGE_NF_CALL_ARPTABLES: _bindgen_ty_57 = 1;
pub const NET_BRIDGE_NF_CALL_IPTABLES: _bindgen_ty_57 = 2;
pub const NET_BRIDGE_NF_CALL_IP6TABLES: _bindgen_ty_57 = 3;
pub const NET_BRIDGE_NF_FILTER_VLAN_TAGGED: _bindgen_ty_57 = 4;
pub const NET_BRIDGE_NF_FILTER_PPPOE_TAGGED: _bindgen_ty_57 = 5;
pub type _bindgen_ty_57 = core::ffi::c_uint;
pub const FS_NRINODE: _bindgen_ty_58 = 1;
pub const FS_STATINODE: _bindgen_ty_58 = 2;
pub const FS_MAXINODE: _bindgen_ty_58 = 3;
pub const FS_NRDQUOT: _bindgen_ty_58 = 4;
pub const FS_MAXDQUOT: _bindgen_ty_58 = 5;
pub const FS_NRFILE: _bindgen_ty_58 = 6;
pub const FS_MAXFILE: _bindgen_ty_58 = 7;
pub const FS_DENTRY: _bindgen_ty_58 = 8;
pub const FS_NRSUPER: _bindgen_ty_58 = 9;
pub const FS_MAXSUPER: _bindgen_ty_58 = 10;
pub const FS_OVERFLOWUID: _bindgen_ty_58 = 11;
pub const FS_OVERFLOWGID: _bindgen_ty_58 = 12;
pub const FS_LEASES: _bindgen_ty_58 = 13;
pub const FS_DIR_NOTIFY: _bindgen_ty_58 = 14;
pub const FS_LEASE_TIME: _bindgen_ty_58 = 15;
pub const FS_DQSTATS: _bindgen_ty_58 = 16;
pub const FS_XFS: _bindgen_ty_58 = 17;
pub const FS_AIO_NR: _bindgen_ty_58 = 18;
pub const FS_AIO_MAX_NR: _bindgen_ty_58 = 19;
pub const FS_INOTIFY: _bindgen_ty_58 = 20;
pub const FS_OCFS2: _bindgen_ty_58 = 988;
pub type _bindgen_ty_58 = core::ffi::c_uint;
pub const FS_DQ_LOOKUPS: _bindgen_ty_59 = 1;
pub const FS_DQ_DROPS: _bindgen_ty_59 = 2;
pub const FS_DQ_READS: _bindgen_ty_59 = 3;
pub const FS_DQ_WRITES: _bindgen_ty_59 = 4;
pub const FS_DQ_CACHE_HITS: _bindgen_ty_59 = 5;
pub const FS_DQ_ALLOCATED: _bindgen_ty_59 = 6;
pub const FS_DQ_FREE: _bindgen_ty_59 = 7;
pub const FS_DQ_SYNCS: _bindgen_ty_59 = 8;
pub const FS_DQ_WARNINGS: _bindgen_ty_59 = 9;
pub type _bindgen_ty_59 = core::ffi::c_uint;
pub const DEV_CDROM: _bindgen_ty_60 = 1;
pub const DEV_HWMON: _bindgen_ty_60 = 2;
pub const DEV_PARPORT: _bindgen_ty_60 = 3;
pub const DEV_RAID: _bindgen_ty_60 = 4;
pub const DEV_MAC_HID: _bindgen_ty_60 = 5;
pub const DEV_SCSI: _bindgen_ty_60 = 6;
pub const DEV_IPMI: _bindgen_ty_60 = 7;
pub type _bindgen_ty_60 = core::ffi::c_uint;
pub const DEV_CDROM_INFO: _bindgen_ty_61 = 1;
pub const DEV_CDROM_AUTOCLOSE: _bindgen_ty_61 = 2;
pub const DEV_CDROM_AUTOEJECT: _bindgen_ty_61 = 3;
pub const DEV_CDROM_DEBUG: _bindgen_ty_61 = 4;
pub const DEV_CDROM_LOCK: _bindgen_ty_61 = 5;
pub const DEV_CDROM_CHECK_MEDIA: _bindgen_ty_61 = 6;
pub type _bindgen_ty_61 = core::ffi::c_uint;
pub const DEV_PARPORT_DEFAULT: _bindgen_ty_62 = -3;
pub type _bindgen_ty_62 = core::ffi::c_int;
pub const DEV_RAID_SPEED_LIMIT_MIN: _bindgen_ty_63 = 1;
pub const DEV_RAID_SPEED_LIMIT_MAX: _bindgen_ty_63 = 2;
pub type _bindgen_ty_63 = core::ffi::c_uint;
pub const DEV_PARPORT_DEFAULT_TIMESLICE: _bindgen_ty_64 = 1;
pub const DEV_PARPORT_DEFAULT_SPINTIME: _bindgen_ty_64 = 2;
pub type _bindgen_ty_64 = core::ffi::c_uint;
pub const DEV_PARPORT_SPINTIME: _bindgen_ty_65 = 1;
pub const DEV_PARPORT_BASE_ADDR: _bindgen_ty_65 = 2;
pub const DEV_PARPORT_IRQ: _bindgen_ty_65 = 3;
pub const DEV_PARPORT_DMA: _bindgen_ty_65 = 4;
pub const DEV_PARPORT_MODES: _bindgen_ty_65 = 5;
pub const DEV_PARPORT_DEVICES: _bindgen_ty_65 = 6;
pub const DEV_PARPORT_AUTOPROBE: _bindgen_ty_65 = 16;
pub type _bindgen_ty_65 = core::ffi::c_uint;
pub const DEV_PARPORT_DEVICES_ACTIVE: _bindgen_ty_66 = -3;
pub type _bindgen_ty_66 = core::ffi::c_int;
pub const DEV_PARPORT_DEVICE_TIMESLICE: _bindgen_ty_67 = 1;
pub type _bindgen_ty_67 = core::ffi::c_uint;
pub const DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES: _bindgen_ty_68 = 1;
pub const DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES: _bindgen_ty_68 = 2;
pub const DEV_MAC_HID_MOUSE_BUTTON_EMULATION: _bindgen_ty_68 = 3;
pub const DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE: _bindgen_ty_68 = 4;
pub const DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE: _bindgen_ty_68 = 5;
pub const DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES: _bindgen_ty_68 = 6;
pub type _bindgen_ty_68 = core::ffi::c_uint;
pub const DEV_SCSI_LOGGING_LEVEL: _bindgen_ty_69 = 1;
pub type _bindgen_ty_69 = core::ffi::c_uint;
pub const DEV_IPMI_POWEROFF_POWERCYCLE: _bindgen_ty_70 = 1;
pub type _bindgen_ty_70 = core::ffi::c_uint;
pub const ABI_DEFHANDLER_COFF: _bindgen_ty_71 = 1;
pub const ABI_DEFHANDLER_ELF: _bindgen_ty_71 = 2;
pub const ABI_DEFHANDLER_LCALL7: _bindgen_ty_71 = 3;
pub const ABI_DEFHANDLER_LIBCSO: _bindgen_ty_71 = 4;
pub const ABI_TRACE: _bindgen_ty_71 = 5;
pub const ABI_FAKE_UTSNAME: _bindgen_ty_71 = 6;
pub type _bindgen_ty_71 = core::ffi::c_uint;
extern "C" {
    pub static sysctl_vals: [core::ffi::c_int; 0usize];
}
extern "C" {
    pub static sysctl_long_vals: [core::ffi::c_ulong; 0usize];
}
pub type proc_handler = ::core::option::Option<
    unsafe extern "C" fn(
        ctl: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int,
>;
extern "C" {
    pub fn proc_dostring(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_dobool(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_dointvec(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_douintvec(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_dointvec_minmax(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_douintvec_minmax(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_dou8vec_minmax(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_dointvec_jiffies(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_dointvec_ms_jiffies_minmax(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_dointvec_userhz_jiffies(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_dointvec_ms_jiffies(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_doulongvec_minmax(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_doulongvec_ms_jiffies_minmax(
        table: *mut ctl_table,
        arg1: core::ffi::c_int,
        arg2: *mut core::ffi::c_void,
        arg3: *mut usize,
        arg4: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_do_large_bitmap(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_do_static_key(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_poll {
    pub event: atomic_t,
    pub wait: wait_queue_head_t,
}
impl Default for ctl_table_poll {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table {
    pub procname: *const core::ffi::c_char,
    pub data: *mut core::ffi::c_void,
    pub maxlen: core::ffi::c_int,
    pub mode: umode_t,
    pub type_: ctl_table__bindgen_ty_1,
    pub proc_handler: proc_handler,
    pub poll: *mut ctl_table_poll,
    pub extra1: *mut core::ffi::c_void,
    pub extra2: *mut core::ffi::c_void,
}
pub const ctl_table_SYSCTL_TABLE_TYPE_DEFAULT: ctl_table__bindgen_ty_1 = 0;
pub const ctl_table_SYSCTL_TABLE_TYPE_PERMANENTLY_EMPTY: ctl_table__bindgen_ty_1 = 1;
pub type ctl_table__bindgen_ty_1 = core::ffi::c_uint;
impl Default for ctl_table {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_node {
    pub node: rb_node,
    pub header: *mut ctl_table_header,
}
impl Default for ctl_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_header {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1,
    pub unregistering: *mut completion,
    pub ctl_table_arg: *mut ctl_table,
    pub root: *mut ctl_table_root,
    pub set: *mut ctl_table_set,
    pub parent: *mut ctl_dir,
    pub node: *mut ctl_node,
    pub inodes: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ctl_table_header__bindgen_ty_1 {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1__bindgen_ty_1,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    pub ctl_table: *mut ctl_table,
    pub ctl_table_size: core::ffi::c_int,
    pub used: core::ffi::c_int,
    pub count: core::ffi::c_int,
    pub nreg: core::ffi::c_int,
}
impl Default for ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ctl_table_header__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ctl_table_header {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_dir {
    pub header: ctl_table_header,
    pub root: rb_root,
}
impl Default for ctl_dir {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_set {
    pub is_seen:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ctl_table_set) -> core::ffi::c_int>,
    pub dir: ctl_dir,
}
impl Default for ctl_table_set {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_root {
    pub default_set: ctl_table_set,
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(root: *mut ctl_table_root) -> *mut ctl_table_set,
    >,
    pub set_ownership: ::core::option::Option<
        unsafe extern "C" fn(
            head: *mut ctl_table_header,
            table: *mut ctl_table,
            uid: *mut kuid_t,
            gid: *mut kgid_t,
        ),
    >,
    pub permissions: ::core::option::Option<
        unsafe extern "C" fn(
            head: *mut ctl_table_header,
            table: *mut ctl_table,
        ) -> core::ffi::c_int,
    >,
}
impl Default for ctl_table_root {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn proc_sys_poll_notify(poll: *mut ctl_table_poll);
}
extern "C" {
    pub fn setup_sysctl_set(
        p: *mut ctl_table_set,
        root: *mut ctl_table_root,
        is_seen: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ctl_table_set) -> core::ffi::c_int,
        >,
    );
}
extern "C" {
    pub fn retire_sysctl_set(set: *mut ctl_table_set);
}
extern "C" {
    pub fn __register_sysctl_table(
        set: *mut ctl_table_set,
        path: *const core::ffi::c_char,
        table: *mut ctl_table,
        table_size: usize,
    ) -> *mut ctl_table_header;
}
extern "C" {
    pub fn register_sysctl_sz(
        path: *const core::ffi::c_char,
        table: *mut ctl_table,
        table_size: usize,
    ) -> *mut ctl_table_header;
}
extern "C" {
    pub fn unregister_sysctl_table(table: *mut ctl_table_header);
}
extern "C" {
    pub fn sysctl_init_bases() -> core::ffi::c_int;
}
extern "C" {
    pub fn __register_sysctl_init(
        path: *const core::ffi::c_char,
        table: *mut ctl_table,
        table_name: *const core::ffi::c_char,
        table_size: usize,
    );
}
extern "C" {
    pub fn register_sysctl_mount_point(path: *const core::ffi::c_char) -> *mut ctl_table_header;
}
extern "C" {
    pub fn do_sysctl_args();
}
extern "C" {
    pub fn sysctl_is_alias(param: *mut core::ffi::c_char) -> bool_;
}
extern "C" {
    pub fn do_proc_douintvec(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
        conv: ::core::option::Option<
            unsafe extern "C" fn(
                lvalp: *mut core::ffi::c_ulong,
                valp: *mut core::ffi::c_uint,
                write: core::ffi::c_int,
                data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut pwrsw_enabled: core::ffi::c_int;
}
extern "C" {
    pub static mut unaligned_enabled: core::ffi::c_int;
}
extern "C" {
    pub static mut unaligned_dump_stack: core::ffi::c_int;
}
extern "C" {
    pub static mut no_unaligned_warning: core::ffi::c_int;
}
extern "C" {
    pub fn sysctl_max_threads(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subprocess_info {
    pub work: work_struct,
    pub complete: *mut completion,
    pub path: *const core::ffi::c_char,
    pub argv: *mut *mut core::ffi::c_char,
    pub envp: *mut *mut core::ffi::c_char,
    pub wait: core::ffi::c_int,
    pub retval: core::ffi::c_int,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(info: *mut subprocess_info, new: *mut cred) -> core::ffi::c_int,
    >,
    pub cleanup: ::core::option::Option<unsafe extern "C" fn(info: *mut subprocess_info)>,
    pub data: *mut core::ffi::c_void,
}
impl Default for subprocess_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn call_usermodehelper(
        path: *const core::ffi::c_char,
        argv: *mut *mut core::ffi::c_char,
        envp: *mut *mut core::ffi::c_char,
        wait: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn call_usermodehelper_setup(
        path: *const core::ffi::c_char,
        argv: *mut *mut core::ffi::c_char,
        envp: *mut *mut core::ffi::c_char,
        gfp_mask: gfp_t,
        init: ::core::option::Option<
            unsafe extern "C" fn(info: *mut subprocess_info, new: *mut cred) -> core::ffi::c_int,
        >,
        cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut subprocess_info)>,
        data: *mut core::ffi::c_void,
    ) -> *mut subprocess_info;
}
extern "C" {
    pub fn call_usermodehelper_exec(
        info: *mut subprocess_info,
        wait: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
pub const umh_disable_depth_UMH_ENABLED: umh_disable_depth = 0;
pub const umh_disable_depth_UMH_FREEZING: umh_disable_depth = 1;
pub const umh_disable_depth_UMH_DISABLED: umh_disable_depth = 2;
pub type umh_disable_depth = core::ffi::c_uint;
extern "C" {
    pub fn __usermodehelper_disable(depth: umh_disable_depth) -> core::ffi::c_int;
}
extern "C" {
    pub fn __usermodehelper_set_disable_depth(depth: umh_disable_depth);
}
extern "C" {
    pub fn usermodehelper_read_trylock() -> core::ffi::c_int;
}
extern "C" {
    pub fn usermodehelper_read_lock_wait(timeout: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn usermodehelper_read_unlock();
}
extern "C" {
    pub static mut modprobe_path: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub fn __request_module(wait: bool_, name: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhash_head {
    pub next: *mut rhash_head,
}
impl Default for rhash_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhlist_head {
    pub rhead: rhash_head,
    pub next: *mut rhlist_head,
}
impl Default for rhlist_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bucket_table {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable_compare_arg {
    pub ht: *mut rhashtable,
    pub key: *const core::ffi::c_void,
}
impl Default for rhashtable_compare_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type rht_hashfn_t = ::core::option::Option<
    unsafe extern "C" fn(data: *const core::ffi::c_void, len: u32_, seed: u32_) -> u32_,
>;
pub type rht_obj_hashfn_t = ::core::option::Option<
    unsafe extern "C" fn(data: *const core::ffi::c_void, len: u32_, seed: u32_) -> u32_,
>;
pub type rht_obj_cmpfn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut rhashtable_compare_arg,
        obj: *const core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rhashtable_params {
    pub nelem_hint: u16_,
    pub key_len: u16_,
    pub key_offset: u16_,
    pub head_offset: u16_,
    pub max_size: core::ffi::c_uint,
    pub min_size: u16_,
    pub automatic_shrinking: bool_,
    pub hashfn: rht_hashfn_t,
    pub obj_hashfn: rht_obj_hashfn_t,
    pub obj_cmpfn: rht_obj_cmpfn_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable {
    pub tbl: *mut bucket_table,
    pub key_len: core::ffi::c_uint,
    pub max_elems: core::ffi::c_uint,
    pub p: rhashtable_params,
    pub rhlist: bool_,
    pub run_work: work_struct,
    pub mutex: mutex,
    pub lock: spinlock_t,
    pub nelems: atomic_t,
}
impl Default for rhashtable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhltable {
    pub ht: rhashtable,
}
impl Default for rhltable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable_walker {
    pub list: list_head,
    pub tbl: *mut bucket_table,
}
impl Default for rhashtable_walker {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable_iter {
    pub ht: *mut rhashtable,
    pub p: *mut rhash_head,
    pub list: *mut rhlist_head,
    pub walker: rhashtable_walker,
    pub slot: core::ffi::c_uint,
    pub skip: core::ffi::c_uint,
    pub end_of_table: bool_,
}
impl Default for rhashtable_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn rhashtable_init(
        ht: *mut rhashtable,
        params: *const rhashtable_params,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rhltable_init(hlt: *mut rhltable, params: *const rhashtable_params) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ipc_perm {
    pub key: __kernel_key_t,
    pub uid: __kernel_uid_t,
    pub gid: __kernel_gid_t,
    pub cuid: __kernel_uid_t,
    pub cgid: __kernel_gid_t,
    pub mode: __kernel_mode_t,
    pub seq: core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Default)]
pub struct ipc64_perm {
    pub key: __kernel_key_t,
    pub uid: __kernel_uid32_t,
    pub gid: __kernel_gid32_t,
    pub cuid: __kernel_uid32_t,
    pub cgid: __kernel_gid32_t,
    pub mode: __kernel_mode_t,
    pub __pad1: __IncompleteArrayField<core::ffi::c_uchar>,
    pub seq: core::ffi::c_ushort,
    pub __pad2: core::ffi::c_ushort,
    pub __unused1: __kernel_ulong_t,
    pub __unused2: __kernel_ulong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipc_kludge {
    pub msgp: *mut msgbuf,
    pub msgtyp: core::ffi::c_long,
}
impl Default for ipc_kludge {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct kern_ipc_perm {
    pub lock: spinlock_t,
    pub deleted: bool_,
    pub id: core::ffi::c_int,
    pub key: key_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub cuid: kuid_t,
    pub cgid: kgid_t,
    pub mode: umode_t,
    pub seq: core::ffi::c_ulong,
    pub security: *mut core::ffi::c_void,
    pub khtnode: rhash_head,
    pub rcu: callback_head,
    pub refcount: refcount_t,
}
impl Default for kern_ipc_perm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct semid_ds {
    pub sem_perm: ipc_perm,
    pub sem_otime: __kernel_old_time_t,
    pub sem_ctime: __kernel_old_time_t,
    pub sem_base: *mut sem,
    pub sem_pending: *mut sem_queue,
    pub sem_pending_last: *mut *mut sem_queue,
    pub undo: *mut sem_undo,
    pub sem_nsems: core::ffi::c_ushort,
}
impl Default for semid_ds {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct semid64_ds {
    pub sem_perm: ipc64_perm,
    pub sem_otime: __kernel_long_t,
    pub __unused1: __kernel_ulong_t,
    pub sem_ctime: __kernel_long_t,
    pub __unused2: __kernel_ulong_t,
    pub sem_nsems: __kernel_ulong_t,
    pub __unused3: __kernel_ulong_t,
    pub __unused4: __kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sembuf {
    pub sem_num: core::ffi::c_ushort,
    pub sem_op: core::ffi::c_short,
    pub sem_flg: core::ffi::c_short,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union semun {
    pub val: core::ffi::c_int,
    pub buf: *mut semid_ds,
    pub array: *mut core::ffi::c_ushort,
    pub __buf: *mut seminfo,
    pub __pad: *mut core::ffi::c_void,
}
impl Default for semun {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seminfo {
    pub semmap: core::ffi::c_int,
    pub semmni: core::ffi::c_int,
    pub semmns: core::ffi::c_int,
    pub semmnu: core::ffi::c_int,
    pub semmsl: core::ffi::c_int,
    pub semopm: core::ffi::c_int,
    pub semume: core::ffi::c_int,
    pub semusz: core::ffi::c_int,
    pub semvmx: core::ffi::c_int,
    pub semaem: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sem_undo_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sysv_sem {
    pub undo_list: *mut sem_undo_list,
}
impl Default for sysv_sem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn copy_semundo(clone_flags: core::ffi::c_ulong, tsk: *mut task_struct)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn exit_sem(tsk: *mut task_struct);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut core::ffi::c_void,
    pub iov_len: __kernel_size_t,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type iov_iter_extraction_t = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvec {
    pub iov_base: *mut core::ffi::c_void,
    pub iov_len: usize,
}
impl Default for kvec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const iter_type_ITER_UBUF: iter_type = 0;
pub const iter_type_ITER_IOVEC: iter_type = 1;
pub const iter_type_ITER_BVEC: iter_type = 2;
pub const iter_type_ITER_KVEC: iter_type = 3;
pub const iter_type_ITER_XARRAY: iter_type = 4;
pub const iter_type_ITER_DISCARD: iter_type = 5;
pub type iter_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct iov_iter_state {
    pub iov_offset: usize,
    pub count: usize,
    pub nr_segs: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iov_iter {
    pub iter_type: u8_,
    pub nofault: bool_,
    pub data_source: bool_,
    pub iov_offset: usize,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_1,
    pub __bindgen_anon_2: iov_iter__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_1 {
    pub __ubuf_iovec: iovec,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iov_iter__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: iov_iter__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub count: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __iov: *const iovec,
    pub kvec: *const kvec,
    pub bvec: *const bio_vec,
    pub xarray: *mut xarray,
    pub ubuf: *mut core::ffi::c_void,
}
impl Default for iov_iter__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iov_iter__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iov_iter__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_2 {
    pub nr_segs: core::ffi::c_ulong,
    pub xarray_start: loff_t,
}
impl Default for iov_iter__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iov_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn copy_page_from_iter_atomic(
        page: *mut page,
        offset: usize,
        bytes: usize,
        i: *mut iov_iter,
    ) -> usize;
}
extern "C" {
    pub fn iov_iter_advance(i: *mut iov_iter, bytes: usize);
}
extern "C" {
    pub fn iov_iter_revert(i: *mut iov_iter, bytes: usize);
}
extern "C" {
    pub fn fault_in_iov_iter_readable(i: *const iov_iter, bytes: usize) -> usize;
}
extern "C" {
    pub fn fault_in_iov_iter_writeable(i: *const iov_iter, bytes: usize) -> usize;
}
extern "C" {
    pub fn iov_iter_single_seg_count(i: *const iov_iter) -> usize;
}
extern "C" {
    pub fn copy_page_to_iter(
        page: *mut page,
        offset: usize,
        bytes: usize,
        i: *mut iov_iter,
    ) -> usize;
}
extern "C" {
    pub fn copy_page_from_iter(
        page: *mut page,
        offset: usize,
        bytes: usize,
        i: *mut iov_iter,
    ) -> usize;
}
extern "C" {
    pub fn _copy_to_iter(addr: *const core::ffi::c_void, bytes: usize, i: *mut iov_iter) -> usize;
}
extern "C" {
    pub fn _copy_from_iter(addr: *mut core::ffi::c_void, bytes: usize, i: *mut iov_iter) -> usize;
}
extern "C" {
    pub fn _copy_from_iter_nocache(
        addr: *mut core::ffi::c_void,
        bytes: usize,
        i: *mut iov_iter,
    ) -> usize;
}
extern "C" {
    pub fn copy_page_to_iter_nofault(
        page: *mut page,
        offset: core::ffi::c_uint,
        bytes: usize,
        i: *mut iov_iter,
    ) -> usize;
}
extern "C" {
    pub fn _copy_from_iter_flushcache(
        addr: *mut core::ffi::c_void,
        bytes: usize,
        i: *mut iov_iter,
    ) -> usize;
}
extern "C" {
    pub fn _copy_mc_to_iter(
        addr: *const core::ffi::c_void,
        bytes: usize,
        i: *mut iov_iter,
    ) -> usize;
}
extern "C" {
    pub fn iov_iter_zero(bytes: usize, arg1: *mut iov_iter) -> usize;
}
extern "C" {
    pub fn iov_iter_is_aligned(
        i: *const iov_iter,
        addr_mask: core::ffi::c_uint,
        len_mask: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn iov_iter_alignment(i: *const iov_iter) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn iov_iter_gap_alignment(i: *const iov_iter) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn iov_iter_init(
        i: *mut iov_iter,
        direction: core::ffi::c_uint,
        iov: *const iovec,
        nr_segs: core::ffi::c_ulong,
        count: usize,
    );
}
extern "C" {
    pub fn iov_iter_kvec(
        i: *mut iov_iter,
        direction: core::ffi::c_uint,
        kvec: *const kvec,
        nr_segs: core::ffi::c_ulong,
        count: usize,
    );
}
extern "C" {
    pub fn iov_iter_bvec(
        i: *mut iov_iter,
        direction: core::ffi::c_uint,
        bvec: *const bio_vec,
        nr_segs: core::ffi::c_ulong,
        count: usize,
    );
}
extern "C" {
    pub fn iov_iter_discard(i: *mut iov_iter, direction: core::ffi::c_uint, count: usize);
}
extern "C" {
    pub fn iov_iter_xarray(
        i: *mut iov_iter,
        direction: core::ffi::c_uint,
        xarray: *mut xarray,
        start: loff_t,
        count: usize,
    );
}
extern "C" {
    pub fn iov_iter_get_pages2(
        i: *mut iov_iter,
        pages: *mut *mut page,
        maxsize: usize,
        maxpages: core::ffi::c_uint,
        start: *mut usize,
    ) -> isize;
}
extern "C" {
    pub fn iov_iter_get_pages_alloc2(
        i: *mut iov_iter,
        pages: *mut *mut *mut page,
        maxsize: usize,
        start: *mut usize,
    ) -> isize;
}
extern "C" {
    pub fn iov_iter_npages(i: *const iov_iter, maxpages: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn iov_iter_restore(i: *mut iov_iter, state: *mut iov_iter_state);
}
extern "C" {
    pub fn dup_iter(
        new: *mut iov_iter,
        old: *mut iov_iter,
        flags: gfp_t,
    ) -> *const core::ffi::c_void;
}
extern "C" {
    pub fn iovec_from_user(
        uvector: *const iovec,
        nr_segs: core::ffi::c_ulong,
        fast_segs: core::ffi::c_ulong,
        fast_iov: *mut iovec,
        compat: bool_,
    ) -> *mut iovec;
}
extern "C" {
    pub fn import_iovec(
        type_: core::ffi::c_int,
        uvec: *const iovec,
        nr_segs: core::ffi::c_uint,
        fast_segs: core::ffi::c_uint,
        iovp: *mut *mut iovec,
        i: *mut iov_iter,
    ) -> isize;
}
extern "C" {
    pub fn __import_iovec(
        type_: core::ffi::c_int,
        uvec: *const iovec,
        nr_segs: core::ffi::c_uint,
        fast_segs: core::ffi::c_uint,
        iovp: *mut *mut iovec,
        i: *mut iov_iter,
        compat: bool_,
    ) -> isize;
}
extern "C" {
    pub fn import_ubuf(
        type_: core::ffi::c_int,
        buf: *mut core::ffi::c_void,
        len: usize,
        i: *mut iov_iter,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn iov_iter_extract_pages(
        i: *mut iov_iter,
        pages: *mut *mut *mut page,
        maxsize: usize,
        maxpages: core::ffi::c_uint,
        extraction_flags: iov_iter_extraction_t,
        offset0: *mut usize,
    ) -> isize;
}
extern "C" {
    pub fn extract_iter_to_sg(
        iter: *mut iov_iter,
        len: usize,
        sgtable: *mut sg_table,
        sg_max: core::ffi::c_uint,
        extraction_flags: iov_iter_extraction_t,
    ) -> isize;
}
pub type __kernel_sa_family_t = core::ffi::c_ushort;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_sockaddr_storage {
    pub __bindgen_anon_1: __kernel_sockaddr_storage__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __kernel_sockaddr_storage__bindgen_ty_1 {
    pub __bindgen_anon_1: __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1,
    pub __align: *mut core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1 {
    pub ss_family: __kernel_sa_family_t,
    pub __data: [core::ffi::c_char; 126usize],
}
impl Default for __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __kernel_sockaddr_storage__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __kernel_sockaddr_storage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seq_file {
    _unused: [u8; 0],
}
extern "C" {
    pub fn socket_seq_show(seq: *mut seq_file);
}
pub type sa_family_t = __kernel_sa_family_t;
#[repr(C)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub __bindgen_anon_1: sockaddr__bindgen_ty_1,
}
#[repr(C)]
pub struct sockaddr__bindgen_ty_1 {
    pub sa_data_min: __BindgenUnionField<[core::ffi::c_char; 14usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<sockaddr__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u8; 14usize],
}
#[repr(C)]
#[derive(Default)]
pub struct sockaddr__bindgen_ty_1__bindgen_ty_1 {
    pub __empty_sa_data: sockaddr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub sa_data: __IncompleteArrayField<core::ffi::c_char>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sockaddr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
impl Default for sockaddr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sockaddr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct linger {
    pub l_onoff: core::ffi::c_int,
    pub l_linger: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut core::ffi::c_void,
    pub msg_namelen: core::ffi::c_int,
    pub msg_inq: core::ffi::c_int,
    pub msg_iter: iov_iter,
    pub __bindgen_anon_1: msghdr__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub msg_flags: core::ffi::c_uint,
    pub msg_controllen: __kernel_size_t,
    pub msg_iocb: *mut kiocb,
    pub msg_ubuf: *mut ubuf_info,
    pub sg_from_iter: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            skb: *mut sk_buff,
            from: *mut iov_iter,
            length: usize,
        ) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msghdr__bindgen_ty_1 {
    pub msg_control: *mut core::ffi::c_void,
    pub msg_control_user: *mut core::ffi::c_void,
}
impl Default for msghdr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for msghdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl msghdr {
    #[inline]
    pub fn msg_control_is_user(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_msg_control_is_user(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn msg_get_inq(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_msg_get_inq(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        msg_control_is_user: bool_,
        msg_get_inq: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let msg_control_is_user: u8 = unsafe { ::core::mem::transmute(msg_control_is_user) };
            msg_control_is_user as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let msg_get_inq: u8 = unsafe { ::core::mem::transmute(msg_get_inq) };
            msg_get_inq as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_msghdr {
    pub msg_name: *mut core::ffi::c_void,
    pub msg_namelen: core::ffi::c_int,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: __kernel_size_t,
    pub msg_control: *mut core::ffi::c_void,
    pub msg_controllen: __kernel_size_t,
    pub msg_flags: core::ffi::c_uint,
}
impl Default for user_msghdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmsghdr {
    pub msg_hdr: user_msghdr,
    pub msg_len: core::ffi::c_uint,
}
impl Default for mmsghdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: __kernel_size_t,
    pub cmsg_level: core::ffi::c_int,
    pub cmsg_type: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ucred {
    pub pid: __u32,
    pub uid: __u32,
    pub gid: __u32,
}
extern "C" {
    pub fn move_addr_to_kernel(
        uaddr: *mut core::ffi::c_void,
        ulen: core::ffi::c_int,
        kaddr: *mut __kernel_sockaddr_storage,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_cmsg(
        arg1: *mut msghdr,
        level: core::ffi::c_int,
        type_: core::ffi::c_int,
        len: core::ffi::c_int,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct scm_timestamping_internal {
    pub ts: [timespec64; 3usize],
}
extern "C" {
    pub fn put_cmsg_scm_timestamping64(msg: *mut msghdr, tss: *mut scm_timestamping_internal);
}
extern "C" {
    pub fn put_cmsg_scm_timestamping(msg: *mut msghdr, tss: *mut scm_timestamping_internal);
}
extern "C" {
    pub fn __sys_recvmsg(
        fd: core::ffi::c_int,
        msg: *mut user_msghdr,
        flags: core::ffi::c_uint,
        forbid_cmsg_compat: bool_,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn __sys_sendmsg(
        fd: core::ffi::c_int,
        msg: *mut user_msghdr,
        flags: core::ffi::c_uint,
        forbid_cmsg_compat: bool_,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn __sys_recvmmsg(
        fd: core::ffi::c_int,
        mmsg: *mut mmsghdr,
        vlen: core::ffi::c_uint,
        flags: core::ffi::c_uint,
        timeout: *mut __kernel_timespec,
        timeout32: *mut old_timespec32,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_sendmmsg(
        fd: core::ffi::c_int,
        mmsg: *mut mmsghdr,
        vlen: core::ffi::c_uint,
        flags: core::ffi::c_uint,
        forbid_cmsg_compat: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_sendmsg_sock(
        sock: *mut socket,
        msg: *mut msghdr,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn __sys_recvmsg_sock(
        sock: *mut socket,
        msg: *mut msghdr,
        umsg: *mut user_msghdr,
        uaddr: *mut sockaddr,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn sendmsg_copy_msghdr(
        msg: *mut msghdr,
        umsg: *mut user_msghdr,
        flags: core::ffi::c_uint,
        iov: *mut *mut iovec,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn recvmsg_copy_msghdr(
        msg: *mut msghdr,
        umsg: *mut user_msghdr,
        flags: core::ffi::c_uint,
        uaddr: *mut *mut sockaddr,
        iov: *mut *mut iovec,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __copy_msghdr(
        kmsg: *mut msghdr,
        umsg: *mut user_msghdr,
        save_addr: *mut *mut sockaddr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_recvfrom(
        fd: core::ffi::c_int,
        ubuf: *mut core::ffi::c_void,
        size: usize,
        flags: core::ffi::c_uint,
        addr: *mut sockaddr,
        addr_len: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_sendto(
        fd: core::ffi::c_int,
        buff: *mut core::ffi::c_void,
        len: usize,
        flags: core::ffi::c_uint,
        addr: *mut sockaddr,
        addr_len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_accept(
        file: *mut file,
        file_flags: core::ffi::c_uint,
        upeer_sockaddr: *mut sockaddr,
        upeer_addrlen: *mut core::ffi::c_int,
        flags: core::ffi::c_int,
    ) -> *mut file;
}
extern "C" {
    pub fn __sys_accept4(
        fd: core::ffi::c_int,
        upeer_sockaddr: *mut sockaddr,
        upeer_addrlen: *mut core::ffi::c_int,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_socket(
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        protocol: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_socket_file(
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        protocol: core::ffi::c_int,
    ) -> *mut file;
}
extern "C" {
    pub fn __sys_bind(
        fd: core::ffi::c_int,
        umyaddr: *mut sockaddr,
        addrlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_connect_file(
        file: *mut file,
        addr: *mut __kernel_sockaddr_storage,
        addrlen: core::ffi::c_int,
        file_flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_connect(
        fd: core::ffi::c_int,
        uservaddr: *mut sockaddr,
        addrlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_listen(fd: core::ffi::c_int, backlog: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_getsockname(
        fd: core::ffi::c_int,
        usockaddr: *mut sockaddr,
        usockaddr_len: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_getpeername(
        fd: core::ffi::c_int,
        usockaddr: *mut sockaddr,
        usockaddr_len: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_socketpair(
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        protocol: core::ffi::c_int,
        usockvec: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_shutdown_sock(sock: *mut socket, how: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_shutdown(fd: core::ffi::c_int, how: core::ffi::c_int) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sync_serial_settings {
    pub clock_rate: core::ffi::c_uint,
    pub clock_type: core::ffi::c_uint,
    pub loopback: core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct te1_settings {
    pub clock_rate: core::ffi::c_uint,
    pub clock_type: core::ffi::c_uint,
    pub loopback: core::ffi::c_ushort,
    pub slot_map: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct raw_hdlc_proto {
    pub encoding: core::ffi::c_ushort,
    pub parity: core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fr_proto {
    pub t391: core::ffi::c_uint,
    pub t392: core::ffi::c_uint,
    pub n391: core::ffi::c_uint,
    pub n392: core::ffi::c_uint,
    pub n393: core::ffi::c_uint,
    pub lmi: core::ffi::c_ushort,
    pub dce: core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fr_proto_pvc {
    pub dlci: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fr_proto_pvc_info {
    pub dlci: core::ffi::c_uint,
    pub master: [core::ffi::c_char; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cisco_proto {
    pub interval: core::ffi::c_uint,
    pub timeout: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x25_hdlc_proto {
    pub dce: core::ffi::c_ushort,
    pub modulo: core::ffi::c_uint,
    pub window: core::ffi::c_uint,
    pub t1: core::ffi::c_uint,
    pub t2: core::ffi::c_uint,
    pub n2: core::ffi::c_uint,
}
pub const net_device_flags_IFF_UP: net_device_flags = 1;
pub const net_device_flags_IFF_BROADCAST: net_device_flags = 2;
pub const net_device_flags_IFF_DEBUG: net_device_flags = 4;
pub const net_device_flags_IFF_LOOPBACK: net_device_flags = 8;
pub const net_device_flags_IFF_POINTOPOINT: net_device_flags = 16;
pub const net_device_flags_IFF_NOTRAILERS: net_device_flags = 32;
pub const net_device_flags_IFF_RUNNING: net_device_flags = 64;
pub const net_device_flags_IFF_NOARP: net_device_flags = 128;
pub const net_device_flags_IFF_PROMISC: net_device_flags = 256;
pub const net_device_flags_IFF_ALLMULTI: net_device_flags = 512;
pub const net_device_flags_IFF_MASTER: net_device_flags = 1024;
pub const net_device_flags_IFF_SLAVE: net_device_flags = 2048;
pub const net_device_flags_IFF_MULTICAST: net_device_flags = 4096;
pub const net_device_flags_IFF_PORTSEL: net_device_flags = 8192;
pub const net_device_flags_IFF_AUTOMEDIA: net_device_flags = 16384;
pub const net_device_flags_IFF_DYNAMIC: net_device_flags = 32768;
pub const net_device_flags_IFF_LOWER_UP: net_device_flags = 65536;
pub const net_device_flags_IFF_DORMANT: net_device_flags = 131072;
pub const net_device_flags_IFF_ECHO: net_device_flags = 262144;
pub type net_device_flags = core::ffi::c_uint;
pub const IF_OPER_UNKNOWN: _bindgen_ty_72 = 0;
pub const IF_OPER_NOTPRESENT: _bindgen_ty_72 = 1;
pub const IF_OPER_DOWN: _bindgen_ty_72 = 2;
pub const IF_OPER_LOWERLAYERDOWN: _bindgen_ty_72 = 3;
pub const IF_OPER_TESTING: _bindgen_ty_72 = 4;
pub const IF_OPER_DORMANT: _bindgen_ty_72 = 5;
pub const IF_OPER_UP: _bindgen_ty_72 = 6;
pub type _bindgen_ty_72 = core::ffi::c_uint;
pub const IF_LINK_MODE_DEFAULT: _bindgen_ty_73 = 0;
pub const IF_LINK_MODE_DORMANT: _bindgen_ty_73 = 1;
pub const IF_LINK_MODE_TESTING: _bindgen_ty_73 = 2;
pub type _bindgen_ty_73 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifmap {
    pub mem_start: core::ffi::c_ulong,
    pub mem_end: core::ffi::c_ulong,
    pub base_addr: core::ffi::c_ushort,
    pub irq: core::ffi::c_uchar,
    pub dma: core::ffi::c_uchar,
    pub port: core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct if_settings {
    pub type_: core::ffi::c_uint,
    pub size: core::ffi::c_uint,
    pub ifs_ifsu: if_settings__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union if_settings__bindgen_ty_1 {
    pub raw_hdlc: *mut raw_hdlc_proto,
    pub cisco: *mut cisco_proto,
    pub fr: *mut fr_proto,
    pub fr_pvc: *mut fr_proto_pvc,
    pub fr_pvc_info: *mut fr_proto_pvc_info,
    pub x25: *mut x25_hdlc_proto,
    pub sync: *mut sync_serial_settings,
    pub te1: *mut te1_settings,
}
impl Default for if_settings__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for if_settings {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ifreq {
    pub ifr_ifrn: ifreq__bindgen_ty_1,
    pub ifr_ifru: ifreq__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifreq__bindgen_ty_1 {
    pub ifrn_name: [core::ffi::c_char; 16usize],
}
impl Default for ifreq__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ifreq__bindgen_ty_2 {
    pub ifru_addr: __BindgenUnionField<sockaddr>,
    pub ifru_dstaddr: __BindgenUnionField<sockaddr>,
    pub ifru_broadaddr: __BindgenUnionField<sockaddr>,
    pub ifru_netmask: __BindgenUnionField<sockaddr>,
    pub ifru_hwaddr: __BindgenUnionField<sockaddr>,
    pub ifru_flags: __BindgenUnionField<core::ffi::c_short>,
    pub ifru_ivalue: __BindgenUnionField<core::ffi::c_int>,
    pub ifru_mtu: __BindgenUnionField<core::ffi::c_int>,
    pub ifru_map: __BindgenUnionField<ifmap>,
    pub ifru_slave: __BindgenUnionField<[core::ffi::c_char; 16usize]>,
    pub ifru_newname: __BindgenUnionField<[core::ffi::c_char; 16usize]>,
    pub ifru_data: __BindgenUnionField<*mut core::ffi::c_void>,
    pub ifru_settings: __BindgenUnionField<if_settings>,
    pub bindgen_union_field: [u64; 3usize],
}
impl Default for ifreq__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ifreq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifconf {
    pub ifc_len: core::ffi::c_int,
    pub ifc_ifcu: ifconf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifconf__bindgen_ty_1 {
    pub ifcu_buf: *mut core::ffi::c_char,
    pub ifcu_req: *mut ifreq,
}
impl Default for ifconf__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ifconf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_bit_key {
    pub flags: *mut core::ffi::c_void,
    pub bit_nr: core::ffi::c_int,
    pub timeout: core::ffi::c_ulong,
}
impl Default for wait_bit_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_bit_queue_entry {
    pub key: wait_bit_key,
    pub wq_entry: wait_queue_entry,
}
impl Default for wait_bit_queue_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type wait_bit_action_f = ::core::option::Option<
    unsafe extern "C" fn(key: *mut wait_bit_key, mode: core::ffi::c_int) -> core::ffi::c_int,
>;
extern "C" {
    pub fn __wake_up_bit(
        wq_head: *mut wait_queue_head,
        word: *mut core::ffi::c_void,
        bit: core::ffi::c_int,
    );
}
extern "C" {
    pub fn __wait_on_bit(
        wq_head: *mut wait_queue_head,
        wbq_entry: *mut wait_bit_queue_entry,
        action: wait_bit_action_f,
        mode: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wait_on_bit_lock(
        wq_head: *mut wait_queue_head,
        wbq_entry: *mut wait_bit_queue_entry,
        action: wait_bit_action_f,
        mode: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn wake_up_bit(word: *mut core::ffi::c_void, bit: core::ffi::c_int);
}
extern "C" {
    pub fn out_of_line_wait_on_bit(
        word: *mut core::ffi::c_void,
        arg1: core::ffi::c_int,
        action: wait_bit_action_f,
        mode: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn out_of_line_wait_on_bit_timeout(
        word: *mut core::ffi::c_void,
        arg1: core::ffi::c_int,
        action: wait_bit_action_f,
        mode: core::ffi::c_uint,
        timeout: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn out_of_line_wait_on_bit_lock(
        word: *mut core::ffi::c_void,
        arg1: core::ffi::c_int,
        action: wait_bit_action_f,
        mode: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bit_waitqueue(
        word: *mut core::ffi::c_void,
        bit: core::ffi::c_int,
    ) -> *mut wait_queue_head;
}
extern "C" {
    pub fn wait_bit_init();
}
extern "C" {
    pub fn wake_bit_function(
        wq_entry: *mut wait_queue_entry,
        mode: core::ffi::c_uint,
        sync: core::ffi::c_int,
        key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bit_wait(key: *mut wait_bit_key, mode: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn bit_wait_io(key: *mut wait_bit_key, mode: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn bit_wait_timeout(key: *mut wait_bit_key, mode: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn bit_wait_io_timeout(key: *mut wait_bit_key, mode: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn init_wait_var_entry(
        wbq_entry: *mut wait_bit_queue_entry,
        var: *mut core::ffi::c_void,
        flags: core::ffi::c_int,
    );
}
extern "C" {
    pub fn wake_up_var(var: *mut core::ffi::c_void);
}
extern "C" {
    pub fn __var_waitqueue(p: *mut core::ffi::c_void) -> *mut wait_queue_head_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_bl_head {
    pub first: *mut hlist_bl_node,
}
impl Default for hlist_bl_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_bl_node {
    pub next: *mut hlist_bl_node,
    pub pprev: *mut *mut hlist_bl_node,
}
impl Default for hlist_bl_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref {
    pub __bindgen_anon_1: lockref__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lockref__bindgen_ty_1 {
    pub lock_count: __u64,
    pub __bindgen_anon_1: lockref__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lockref__bindgen_ty_1__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub count: core::ffi::c_int,
}
impl Default for lockref__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for lockref {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn lockref_get(arg1: *mut lockref);
}
extern "C" {
    pub fn lockref_put_return(arg1: *mut lockref) -> core::ffi::c_int;
}
extern "C" {
    pub fn lockref_get_not_zero(arg1: *mut lockref) -> core::ffi::c_int;
}
extern "C" {
    pub fn lockref_put_not_zero(arg1: *mut lockref) -> core::ffi::c_int;
}
extern "C" {
    pub fn lockref_put_or_lock(arg1: *mut lockref) -> core::ffi::c_int;
}
extern "C" {
    pub fn lockref_mark_dead(arg1: *mut lockref);
}
extern "C" {
    pub fn lockref_get_not_dead(arg1: *mut lockref) -> core::ffi::c_int;
}
extern "C" {
    pub fn full_name_hash(
        salt: *const core::ffi::c_void,
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn hashlen_string(salt: *const core::ffi::c_void, name: *const core::ffi::c_char) -> u64_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qstr {
    pub __bindgen_anon_1: qstr__bindgen_ty_1,
    pub name: *const core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qstr__bindgen_ty_1 {
    pub __bindgen_anon_1: qstr__bindgen_ty_1__bindgen_ty_1,
    pub hash_len: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qstr__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u32_,
    pub len: u32_,
}
impl Default for qstr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for qstr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static empty_name: qstr;
}
extern "C" {
    pub static slash_name: qstr;
}
extern "C" {
    pub static dotdot_name: qstr;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dentry {
    pub d_flags: core::ffi::c_uint,
    pub d_seq: seqcount_spinlock_t,
    pub d_hash: hlist_bl_node,
    pub d_parent: *mut dentry,
    pub d_name: qstr,
    pub d_inode: *mut inode,
    pub d_iname: [core::ffi::c_uchar; 40usize],
    pub d_lockref: lockref,
    pub d_op: *const dentry_operations,
    pub d_sb: *mut super_block,
    pub d_time: core::ffi::c_ulong,
    pub d_fsdata: *mut core::ffi::c_void,
    pub __bindgen_anon_1: dentry__bindgen_ty_1,
    pub d_sib: hlist_node,
    pub d_children: hlist_head,
    pub d_u: dentry__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_1 {
    pub d_lru: list_head,
    pub d_wait: *mut wait_queue_head_t,
}
impl Default for dentry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_2 {
    pub d_alias: hlist_node,
    pub d_in_lookup_hash: hlist_bl_node,
    pub d_rcu: callback_head,
}
impl Default for dentry__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for dentry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const dentry_d_lock_class_DENTRY_D_LOCK_NORMAL: dentry_d_lock_class = 0;
pub const dentry_d_lock_class_DENTRY_D_LOCK_NESTED: dentry_d_lock_class = 1;
pub type dentry_d_lock_class = core::ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct dentry_operations {
    pub d_revalidate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub d_weak_revalidate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub d_hash: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dentry, arg2: *mut qstr) -> core::ffi::c_int,
    >,
    pub d_compare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const dentry,
            arg2: core::ffi::c_uint,
            arg3: *const core::ffi::c_char,
            arg4: *const qstr,
        ) -> core::ffi::c_int,
    >,
    pub d_delete:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const dentry) -> core::ffi::c_int>,
    pub d_init: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> core::ffi::c_int>,
    pub d_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_prune: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_iput: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut inode)>,
    pub d_dname: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut core::ffi::c_char,
            arg3: core::ffi::c_int,
        ) -> *mut core::ffi::c_char,
    >,
    pub d_automount: ::core::option::Option<unsafe extern "C" fn(arg1: *mut path) -> *mut vfsmount>,
    pub d_manage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const path, arg2: bool_) -> core::ffi::c_int,
    >,
    pub d_real: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *const inode) -> *mut dentry,
    >,
}
impl Default for dentry_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut rename_lock: seqlock_t;
}
extern "C" {
    pub fn d_instantiate(arg1: *mut dentry, arg2: *mut inode);
}
extern "C" {
    pub fn d_instantiate_new(arg1: *mut dentry, arg2: *mut inode);
}
extern "C" {
    pub fn __d_drop(dentry: *mut dentry);
}
extern "C" {
    pub fn d_drop(dentry: *mut dentry);
}
extern "C" {
    pub fn d_delete(arg1: *mut dentry);
}
extern "C" {
    pub fn d_set_d_op(dentry: *mut dentry, op: *const dentry_operations);
}
extern "C" {
    pub fn d_alloc(arg1: *mut dentry, arg2: *const qstr) -> *mut dentry;
}
extern "C" {
    pub fn d_alloc_anon(arg1: *mut super_block) -> *mut dentry;
}
extern "C" {
    pub fn d_alloc_parallel(
        arg1: *mut dentry,
        arg2: *const qstr,
        arg3: *mut wait_queue_head_t,
    ) -> *mut dentry;
}
extern "C" {
    pub fn d_splice_alias(arg1: *mut inode, arg2: *mut dentry) -> *mut dentry;
}
extern "C" {
    pub fn d_add_ci(arg1: *mut dentry, arg2: *mut inode, arg3: *mut qstr) -> *mut dentry;
}
extern "C" {
    pub fn d_same_name(dentry: *const dentry, parent: *const dentry, name: *const qstr) -> bool_;
}
extern "C" {
    pub fn d_exact_alias(arg1: *mut dentry, arg2: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_find_any_alias(inode: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_obtain_alias(arg1: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_obtain_root(arg1: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn shrink_dcache_sb(arg1: *mut super_block);
}
extern "C" {
    pub fn shrink_dcache_parent(arg1: *mut dentry);
}
extern "C" {
    pub fn d_invalidate(arg1: *mut dentry);
}
extern "C" {
    pub fn d_make_root(arg1: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_mark_tmpfile(arg1: *mut file, arg2: *mut inode);
}
extern "C" {
    pub fn d_tmpfile(arg1: *mut file, arg2: *mut inode);
}
extern "C" {
    pub fn d_find_alias(arg1: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_prune_aliases(arg1: *mut inode);
}
extern "C" {
    pub fn d_find_alias_rcu(arg1: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn path_has_submounts(arg1: *const path) -> core::ffi::c_int;
}
extern "C" {
    pub fn d_rehash(arg1: *mut dentry);
}
extern "C" {
    pub fn d_add(arg1: *mut dentry, arg2: *mut inode);
}
extern "C" {
    pub fn d_move(arg1: *mut dentry, arg2: *mut dentry);
}
extern "C" {
    pub fn d_exchange(arg1: *mut dentry, arg2: *mut dentry);
}
extern "C" {
    pub fn d_ancestor(arg1: *mut dentry, arg2: *mut dentry) -> *mut dentry;
}
extern "C" {
    pub fn d_lookup(arg1: *const dentry, arg2: *const qstr) -> *mut dentry;
}
extern "C" {
    pub fn d_hash_and_lookup(arg1: *mut dentry, arg2: *mut qstr) -> *mut dentry;
}
extern "C" {
    pub fn dynamic_dname(
        arg1: *mut core::ffi::c_char,
        arg2: core::ffi::c_int,
        arg3: *const core::ffi::c_char,
        ...
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn __d_path(
        arg1: *const path,
        arg2: *const path,
        arg3: *mut core::ffi::c_char,
        arg4: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn d_absolute_path(
        arg1: *const path,
        arg2: *mut core::ffi::c_char,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn d_path(
        arg1: *const path,
        arg2: *mut core::ffi::c_char,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn dentry_path_raw(
        arg1: *const dentry,
        arg2: *mut core::ffi::c_char,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn dentry_path(
        arg1: *const dentry,
        arg2: *mut core::ffi::c_char,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn dget_parent(dentry: *mut dentry) -> *mut dentry;
}
extern "C" {
    pub fn __d_lookup_unhash_wake(dentry: *mut dentry);
}
extern "C" {
    pub fn dput(arg1: *mut dentry);
}
extern "C" {
    pub static mut sysctl_vfs_cache_pressure: core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct name_snapshot {
    pub name: qstr,
    pub inline_name: [core::ffi::c_uchar; 40usize],
}
impl Default for name_snapshot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn take_dentry_name_snapshot(arg1: *mut name_snapshot, arg2: *mut dentry);
}
extern "C" {
    pub fn release_dentry_name_snapshot(arg1: *mut name_snapshot);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct path {
    pub mnt: *mut vfsmount,
    pub dentry: *mut dentry,
}
impl Default for path {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn path_get(arg1: *const path);
}
extern "C" {
    pub fn path_put(arg1: *const path);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct shrinker_info_unit {
    pub nr_deferred: [atomic_long_t; 64usize],
    pub map: [core::ffi::c_ulong; 1usize],
}
impl Default for shrinker_info_unit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct shrinker_info {
    pub rcu: callback_head,
    pub map_nr_max: core::ffi::c_int,
    pub unit: __IncompleteArrayField<*mut shrinker_info_unit>,
}
impl Default for shrinker_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct shrink_control {
    pub gfp_mask: gfp_t,
    pub nid: core::ffi::c_int,
    pub nr_to_scan: core::ffi::c_ulong,
    pub nr_scanned: core::ffi::c_ulong,
    pub memcg: *mut mem_cgroup,
}
impl Default for shrink_control {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct shrinker {
    pub count_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> core::ffi::c_ulong,
    >,
    pub scan_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> core::ffi::c_ulong,
    >,
    pub batch: core::ffi::c_long,
    pub seeks: core::ffi::c_int,
    pub flags: core::ffi::c_uint,
    pub refcount: refcount_t,
    pub done: completion,
    pub rcu: callback_head,
    pub private_data: *mut core::ffi::c_void,
    pub list: list_head,
    pub id: core::ffi::c_int,
    pub nr_deferred: *mut atomic_long_t,
}
impl Default for shrinker {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn shrinker_alloc(
        flags: core::ffi::c_uint,
        fmt: *const core::ffi::c_char,
        ...
    ) -> *mut shrinker;
}
extern "C" {
    pub fn shrinker_register(shrinker: *mut shrinker);
}
extern "C" {
    pub fn shrinker_free(shrinker: *mut shrinker);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct clone_args {
    pub flags: __u64,
    pub pidfd: __u64,
    pub child_tid: __u64,
    pub parent_tid: __u64,
    pub exit_signal: __u64,
    pub stack: __u64,
    pub stack_size: __u64,
    pub tls: __u64,
    pub set_tid: __u64,
    pub set_tid_size: __u64,
    pub cgroup: __u64,
}
pub const pid_type_PIDTYPE_PID: pid_type = 0;
pub const pid_type_PIDTYPE_TGID: pid_type = 1;
pub const pid_type_PIDTYPE_PGID: pid_type = 2;
pub const pid_type_PIDTYPE_SID: pid_type = 3;
pub const pid_type_PIDTYPE_MAX: pid_type = 4;
pub type pid_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pid_namespace {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut init_pid_ns: pid_namespace;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sysv_shm {
    pub shm_clist: list_head,
}
impl Default for sysv_shm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn do_shmat(
        shmid: core::ffi::c_int,
        shmaddr: *mut core::ffi::c_char,
        shmflg: core::ffi::c_int,
        addr: *mut core::ffi::c_ulong,
        shmlba: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn is_file_shm_hugepages(file: *mut file) -> bool_;
}
extern "C" {
    pub fn exit_shm(task: *mut task_struct);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmsan_context_state {
    pub param_tls: [core::ffi::c_char; 800usize],
    pub retval_tls: [core::ffi::c_char; 800usize],
    pub va_arg_tls: [core::ffi::c_char; 800usize],
    pub va_arg_origin_tls: [core::ffi::c_char; 800usize],
    pub va_arg_overflow_size_tls: u64_,
    pub param_origin_tls: [core::ffi::c_char; 800usize],
    pub retval_origin_tls: u32_,
}
impl Default for kmsan_context_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmsan_ctx {
    pub cstate: kmsan_context_state,
    pub kmsan_in_runtime: core::ffi::c_int,
    pub allow_reporting: bool_,
}
impl Default for kmsan_ctx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct plist_head {
    pub node_list: list_head,
}
impl Default for plist_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct plist_node {
    pub prio: core::ffi::c_int,
    pub prio_list: list_head,
    pub node_list: list_head,
}
impl Default for plist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timerqueue_node {
    pub node: rb_node,
    pub expires: ktime_t,
}
impl Default for timerqueue_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timerqueue_head {
    pub rb_root: rb_root_cached,
}
impl Default for timerqueue_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hrtimer_restart_HRTIMER_NORESTART: hrtimer_restart = 0;
pub const hrtimer_restart_HRTIMER_RESTART: hrtimer_restart = 1;
pub type hrtimer_restart = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hrtimer {
    pub node: timerqueue_node,
    pub _softexpires: ktime_t,
    pub function:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut hrtimer) -> hrtimer_restart>,
    pub base: *mut hrtimer_clock_base,
    pub state: u8_,
    pub is_rel: u8_,
    pub is_soft: u8_,
    pub is_hard: u8_,
}
impl Default for hrtimer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seccomp_filter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seccomp {
    pub mode: core::ffi::c_int,
    pub filter_count: atomic_t,
    pub filter: *mut seccomp_filter,
}
impl Default for seccomp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rusage {
    pub ru_utime: __kernel_old_timeval,
    pub ru_stime: __kernel_old_timeval,
    pub ru_maxrss: __kernel_long_t,
    pub ru_ixrss: __kernel_long_t,
    pub ru_idrss: __kernel_long_t,
    pub ru_isrss: __kernel_long_t,
    pub ru_minflt: __kernel_long_t,
    pub ru_majflt: __kernel_long_t,
    pub ru_nswap: __kernel_long_t,
    pub ru_inblock: __kernel_long_t,
    pub ru_oublock: __kernel_long_t,
    pub ru_msgsnd: __kernel_long_t,
    pub ru_msgrcv: __kernel_long_t,
    pub ru_nsignals: __kernel_long_t,
    pub ru_nvcsw: __kernel_long_t,
    pub ru_nivcsw: __kernel_long_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: __kernel_ulong_t,
    pub rlim_max: __kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rlimit64 {
    pub rlim_cur: __u64,
    pub rlim_max: __u64,
}
extern "C" {
    pub fn getrusage(p: *mut task_struct, who: core::ffi::c_int, ru: *mut rusage);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct latency_record {
    pub backtrace: [core::ffi::c_ulong; 12usize],
    pub count: core::ffi::c_uint,
    pub time: core::ffi::c_ulong,
    pub max: core::ffi::c_ulong,
}
extern "C" {
    pub static mut latencytop_enabled: core::ffi::c_int;
}
extern "C" {
    pub fn __account_scheduler_latency(
        task: *mut task_struct,
        usecs: core::ffi::c_int,
        inter: core::ffi::c_int,
    );
}
extern "C" {
    pub fn clear_tsk_latency_tracing(p: *mut task_struct);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct task_cputime {
    pub stime: u64_,
    pub utime: u64_,
    pub sum_exec_runtime: core::ffi::c_ulonglong,
}
pub type old_sigset_t = core::ffi::c_ulong;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sigset_t {
    pub sig: [core::ffi::c_ulong; 1usize],
}
pub type __signalfn_t = ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int)>;
pub type __sighandler_t = __signalfn_t;
pub type __restorefn_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type __sigrestore_t = __restorefn_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut core::ffi::c_void,
    pub ss_flags: core::ffi::c_int,
    pub ss_size: __kernel_size_t,
}
impl Default for sigaltstack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type stack_t = sigaltstack;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: core::ffi::c_int,
    pub sival_ptr: *mut core::ffi::c_void,
}
impl Default for sigval {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields {
    pub _kill: __sifields__bindgen_ty_1,
    pub _timer: __sifields__bindgen_ty_2,
    pub _rt: __sifields__bindgen_ty_3,
    pub _sigchld: __sifields__bindgen_ty_4,
    pub _sigfault: __sifields__bindgen_ty_5,
    pub _sigpoll: __sifields__bindgen_ty_6,
    pub _sigsys: __sifields__bindgen_ty_7,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_1 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_2 {
    pub _tid: __kernel_timer_t,
    pub _overrun: core::ffi::c_int,
    pub _sigval: sigval_t,
    pub _sys_private: core::ffi::c_int,
}
impl Default for __sifields__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_3 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _sigval: sigval_t,
}
impl Default for __sifields__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_4 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _status: core::ffi::c_int,
    pub _utime: __kernel_clock_t,
    pub _stime: __kernel_clock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_5 {
    pub _addr: *mut core::ffi::c_void,
    pub __bindgen_anon_1: __sifields__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields__bindgen_ty_5__bindgen_ty_1 {
    pub _trapno: core::ffi::c_int,
    pub _addr_lsb: core::ffi::c_short,
    pub _addr_bnd: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _addr_pkey: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
    pub _perf: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _dummy_bnd: [core::ffi::c_char; 8usize],
    pub _lower: *mut core::ffi::c_void,
    pub _upper: *mut core::ffi::c_void,
}
impl Default for __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub _dummy_pkey: [core::ffi::c_char; 8usize],
    pub _pkey: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3 {
    pub _data: core::ffi::c_ulong,
    pub _type: __u32,
    pub _flags: __u32,
}
impl Default for __sifields__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __sifields__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_6 {
    pub _band: core::ffi::c_long,
    pub _fd: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_7 {
    pub _call_addr: *mut core::ffi::c_void,
    pub _syscall: core::ffi::c_int,
    pub _arch: core::ffi::c_uint,
}
impl Default for __sifields__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __sifields {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo {
    pub __bindgen_anon_1: siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo__bindgen_ty_1 {
    pub __bindgen_anon_1: siginfo__bindgen_ty_1__bindgen_ty_1,
    pub _si_pad: [core::ffi::c_int; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub si_signo: core::ffi::c_int,
    pub si_errno: core::ffi::c_int,
    pub si_code: core::ffi::c_int,
    pub _sifields: __sifields,
}
impl Default for siginfo__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for siginfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for siginfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type siginfo_t = siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: core::ffi::c_int,
    pub sigev_notify: core::ffi::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [core::ffi::c_int; 12usize],
    pub _tid: core::ffi::c_int,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::core::option::Option<unsafe extern "C" fn(arg1: sigval_t)>,
    pub _attribute: *mut core::ffi::c_void,
}
impl Default for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigevent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigevent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sigevent_t = sigevent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_siginfo {
    pub __bindgen_anon_1: kernel_siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_siginfo__bindgen_ty_1 {
    pub si_signo: core::ffi::c_int,
    pub si_errno: core::ffi::c_int,
    pub si_code: core::ffi::c_int,
    pub _sifields: __sifields,
}
impl Default for kernel_siginfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kernel_siginfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type kernel_siginfo_t = kernel_siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ucounts {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigqueue {
    pub list: list_head,
    pub flags: core::ffi::c_int,
    pub info: kernel_siginfo_t,
    pub ucounts: *mut ucounts,
}
impl Default for sigqueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigpending {
    pub list: list_head,
    pub signal: sigset_t,
}
impl Default for sigpending {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: __sighandler_t,
    pub sa_flags: core::ffi::c_ulong,
    pub sa_restorer: __sigrestore_t,
    pub sa_mask: sigset_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct k_sigaction {
    pub sa: sigaction,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ksignal {
    pub ka: k_sigaction,
    pub info: kernel_siginfo_t,
    pub sig: core::ffi::c_int,
}
impl Default for ksignal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct syscall_user_dispatch {
    pub selector: *mut core::ffi::c_char,
    pub offset: core::ffi::c_ulong,
    pub len: core::ffi::c_ulong,
    pub on_dispatch: bool_,
}
impl Default for syscall_user_dispatch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct task_io_accounting {
    pub rchar: u64_,
    pub wchar: u64_,
    pub syscr: u64_,
    pub syscw: u64_,
    pub read_bytes: u64_,
    pub write_bytes: u64_,
    pub cancelled_write_bytes: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct posix_cputimer_base {
    pub nextevt: u64_,
    pub tqhead: timerqueue_head,
}
impl Default for posix_cputimer_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct posix_cputimers {
    pub bases: [posix_cputimer_base; 3usize],
    pub timers_active: core::ffi::c_uint,
    pub expiry_active: core::ffi::c_uint,
}
impl Default for posix_cputimers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct posix_cputimers_work {
    pub work: callback_head,
    pub mutex: mutex,
    pub scheduled: core::ffi::c_uint,
}
impl Default for posix_cputimers_work {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const rseq_cpu_id_state_RSEQ_CPU_ID_UNINITIALIZED: rseq_cpu_id_state = -1;
pub const rseq_cpu_id_state_RSEQ_CPU_ID_REGISTRATION_FAILED: rseq_cpu_id_state = -2;
pub type rseq_cpu_id_state = core::ffi::c_int;
pub const rseq_flags_RSEQ_FLAG_UNREGISTER: rseq_flags = 1;
pub type rseq_flags = core::ffi::c_uint;
pub const rseq_cs_flags_bit_RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT: rseq_cs_flags_bit = 0;
pub const rseq_cs_flags_bit_RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT: rseq_cs_flags_bit = 1;
pub const rseq_cs_flags_bit_RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT: rseq_cs_flags_bit = 2;
pub type rseq_cs_flags_bit = core::ffi::c_uint;
pub const rseq_cs_flags_RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT: rseq_cs_flags = 1;
pub const rseq_cs_flags_RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL: rseq_cs_flags = 2;
pub const rseq_cs_flags_RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE: rseq_cs_flags = 4;
pub type rseq_cs_flags = core::ffi::c_uint;
#[repr(C)]
#[repr(align(32))]
#[derive(Default, Copy, Clone)]
pub struct rseq_cs {
    pub version: __u32,
    pub flags: __u32,
    pub start_ip: __u64,
    pub post_commit_offset: __u64,
    pub abort_ip: __u64,
}
#[repr(C)]
#[repr(align(32))]
#[derive(Default)]
pub struct rseq {
    pub cpu_id_start: __u32,
    pub cpu_id: __u32,
    pub rseq_cs: __u64,
    pub flags: __u32,
    pub node_id: __u32,
    pub mm_cid: __u32,
    pub end: __IncompleteArrayField<core::ffi::c_char>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct da_monitor {
    pub monitoring: bool_,
    pub curr_state: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rv_task_monitor {
    pub da_mon: da_monitor,
}
impl Default for rv_task_monitor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rv_reactor {
    pub name: *const core::ffi::c_char,
    pub description: *const core::ffi::c_char,
    pub react: ::core::option::Option<unsafe extern "C" fn(msg: *mut core::ffi::c_char)>,
}
impl Default for rv_reactor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rv_monitor {
    pub name: *const core::ffi::c_char,
    pub description: *const core::ffi::c_char,
    pub enabled: bool_,
    pub enable: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub disable: ::core::option::Option<unsafe extern "C" fn()>,
    pub reset: ::core::option::Option<unsafe extern "C" fn()>,
    pub react: ::core::option::Option<unsafe extern "C" fn(msg: *mut core::ffi::c_char)>,
}
impl Default for rv_monitor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn rv_monitoring_on() -> bool_;
}
extern "C" {
    pub fn rv_unregister_monitor(monitor: *mut rv_monitor) -> core::ffi::c_int;
}
extern "C" {
    pub fn rv_register_monitor(monitor: *mut rv_monitor) -> core::ffi::c_int;
}
extern "C" {
    pub fn rv_get_task_monitor_slot() -> core::ffi::c_int;
}
extern "C" {
    pub fn rv_put_task_monitor_slot(slot: core::ffi::c_int);
}
extern "C" {
    pub fn rv_reacting_on() -> bool_;
}
extern "C" {
    pub fn rv_unregister_reactor(reactor: *mut rv_reactor) -> core::ffi::c_int;
}
extern "C" {
    pub fn rv_register_reactor(reactor: *mut rv_reactor) -> core::ffi::c_int;
}
extern "C" {
    pub fn __klp_sched_try_switch();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_plug {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_local_storage {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_run_ctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct capture_control {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cfs_rq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct futex_pi_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_uring_task {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nameidata {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pipe_inode_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct reclaim_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct robust_list_head {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct root_domain {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct task_delay_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct task_group {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_event_mm {
    _unused: [u8; 0],
}
pub const TASK_COMM_LEN: _bindgen_ty_74 = 16;
pub type _bindgen_ty_74 = core::ffi::c_uint;
extern "C" {
    pub fn scheduler_tick();
}
extern "C" {
    pub fn schedule_timeout(timeout: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn schedule_timeout_interruptible(timeout: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn schedule_timeout_killable(timeout: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn schedule_timeout_uninterruptible(timeout: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn schedule_timeout_idle(timeout: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn schedule();
}
extern "C" {
    pub fn schedule_preempt_disabled();
}
extern "C" {
    pub fn preempt_schedule_irq();
}
extern "C" {
    pub fn io_schedule_prepare() -> core::ffi::c_int;
}
extern "C" {
    pub fn io_schedule_finish(token: core::ffi::c_int);
}
extern "C" {
    pub fn io_schedule_timeout(timeout: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn io_schedule();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prev_cputime {
    pub utime: u64_,
    pub stime: u64_,
    pub lock: raw_spinlock_t,
}
impl Default for prev_cputime {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const vtime_state_VTIME_INACTIVE: vtime_state = 0;
pub const vtime_state_VTIME_IDLE: vtime_state = 1;
pub const vtime_state_VTIME_SYS: vtime_state = 2;
pub const vtime_state_VTIME_USER: vtime_state = 3;
pub const vtime_state_VTIME_GUEST: vtime_state = 4;
pub type vtime_state = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vtime {
    pub seqcount: seqcount_t,
    pub starttime: core::ffi::c_ulonglong,
    pub state: vtime_state,
    pub cpu: core::ffi::c_uint,
    pub utime: u64_,
    pub stime: u64_,
    pub gtime: u64_,
}
impl Default for vtime {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const uclamp_id_UCLAMP_MIN: uclamp_id = 0;
pub const uclamp_id_UCLAMP_MAX: uclamp_id = 1;
pub const uclamp_id_UCLAMP_CNT: uclamp_id = 2;
pub type uclamp_id = core::ffi::c_uint;
extern "C" {
    pub static mut def_root_domain: root_domain;
}
extern "C" {
    pub static mut sched_domains_mutex: mutex;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_info {
    pub pcount: core::ffi::c_ulong,
    pub run_delay: core::ffi::c_ulonglong,
    pub last_arrival: core::ffi::c_ulonglong,
    pub last_queued: core::ffi::c_ulonglong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct load_weight {
    pub weight: core::ffi::c_ulong,
    pub inv_weight: u32_,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sched_avg {
    pub last_update_time: u64_,
    pub load_sum: u64_,
    pub runnable_sum: u64_,
    pub util_sum: u32_,
    pub period_contrib: u32_,
    pub load_avg: core::ffi::c_ulong,
    pub runnable_avg: core::ffi::c_ulong,
    pub util_avg: core::ffi::c_ulong,
    pub util_est: core::ffi::c_uint,
}
impl Default for sched_avg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sched_statistics {
    pub wait_start: u64_,
    pub wait_max: u64_,
    pub wait_count: u64_,
    pub wait_sum: u64_,
    pub iowait_count: u64_,
    pub iowait_sum: u64_,
    pub sleep_start: u64_,
    pub sleep_max: u64_,
    pub sum_sleep_runtime: s64,
    pub block_start: u64_,
    pub block_max: u64_,
    pub sum_block_runtime: s64,
    pub exec_max: s64,
    pub slice_max: u64_,
    pub nr_migrations_cold: u64_,
    pub nr_failed_migrations_affine: u64_,
    pub nr_failed_migrations_running: u64_,
    pub nr_failed_migrations_hot: u64_,
    pub nr_forced_migrations: u64_,
    pub nr_wakeups: u64_,
    pub nr_wakeups_sync: u64_,
    pub nr_wakeups_migrate: u64_,
    pub nr_wakeups_local: u64_,
    pub nr_wakeups_remote: u64_,
    pub nr_wakeups_affine: u64_,
    pub nr_wakeups_affine_attempts: u64_,
    pub nr_wakeups_passive: u64_,
    pub nr_wakeups_idle: u64_,
    pub core_forceidle_sum: u64_,
}
impl Default for sched_statistics {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sched_entity {
    pub load: load_weight,
    pub run_node: rb_node,
    pub deadline: u64_,
    pub min_vruntime: u64_,
    pub group_node: list_head,
    pub on_rq: core::ffi::c_uint,
    pub exec_start: u64_,
    pub sum_exec_runtime: u64_,
    pub prev_sum_exec_runtime: u64_,
    pub vruntime: u64_,
    pub vlag: s64,
    pub slice: u64_,
    pub nr_migrations: u64_,
    pub depth: core::ffi::c_int,
    pub parent: *mut sched_entity,
    pub cfs_rq: *mut cfs_rq,
    pub my_q: *mut cfs_rq,
    pub runnable_weight: core::ffi::c_ulong,
    pub __bindgen_padding_0: [u64; 2usize],
    pub avg: sched_avg,
}
impl Default for sched_entity {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_rt_entity {
    pub run_list: list_head,
    pub timeout: core::ffi::c_ulong,
    pub watchdog_stamp: core::ffi::c_ulong,
    pub time_slice: core::ffi::c_uint,
    pub on_rq: core::ffi::c_ushort,
    pub on_list: core::ffi::c_ushort,
    pub back: *mut sched_rt_entity,
}
impl Default for sched_rt_entity {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type dl_server_has_tasks_f =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut sched_dl_entity) -> bool_>;
pub type dl_server_pick_f =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut sched_dl_entity) -> *mut task_struct>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_dl_entity {
    pub rb_node: rb_node,
    pub dl_runtime: u64_,
    pub dl_deadline: u64_,
    pub dl_period: u64_,
    pub dl_bw: u64_,
    pub dl_density: u64_,
    pub runtime: s64,
    pub deadline: u64_,
    pub flags: core::ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub dl_timer: hrtimer,
    pub inactive_timer: hrtimer,
    pub rq: *mut rq,
    pub server_has_tasks: dl_server_has_tasks_f,
    pub server_pick: dl_server_pick_f,
    pub pi_se: *mut sched_dl_entity,
}
impl Default for sched_dl_entity {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sched_dl_entity {
    #[inline]
    pub fn dl_throttled(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_throttled(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_yielded(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_yielded(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_non_contending(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_non_contending(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_overrun(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_overrun(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_server(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_server(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dl_throttled: core::ffi::c_uint,
        dl_yielded: core::ffi::c_uint,
        dl_non_contending: core::ffi::c_uint,
        dl_overrun: core::ffi::c_uint,
        dl_server: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dl_throttled: u32 = unsafe { ::core::mem::transmute(dl_throttled) };
            dl_throttled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dl_yielded: u32 = unsafe { ::core::mem::transmute(dl_yielded) };
            dl_yielded as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dl_non_contending: u32 = unsafe { ::core::mem::transmute(dl_non_contending) };
            dl_non_contending as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dl_overrun: u32 = unsafe { ::core::mem::transmute(dl_overrun) };
            dl_overrun as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dl_server: u32 = unsafe { ::core::mem::transmute(dl_server) };
            dl_server as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Default, Copy, Clone)]
pub struct uclamp_se {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl uclamp_se {
    #[inline]
    pub fn value(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_value(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn bucket_id(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_bucket_id(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn active(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn user_defined(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_user_defined(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        value: core::ffi::c_uint,
        bucket_id: core::ffi::c_uint,
        active: core::ffi::c_uint,
        user_defined: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let value: u32 = unsafe { ::core::mem::transmute(value) };
            value as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let bucket_id: u32 = unsafe { ::core::mem::transmute(bucket_id) };
            bucket_id as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let active: u32 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let user_defined: u32 = unsafe { ::core::mem::transmute(user_defined) };
            user_defined as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rcu_special {
    pub b: rcu_special__bindgen_ty_1,
    pub s: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rcu_special__bindgen_ty_1 {
    pub blocked: u8_,
    pub need_qs: u8_,
    pub exp_hint: u8_,
    pub need_mb: u8_,
}
impl Default for rcu_special {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const perf_event_task_context_perf_invalid_context: perf_event_task_context = -1;
pub const perf_event_task_context_perf_hw_context: perf_event_task_context = 0;
pub const perf_event_task_context_perf_sw_context: perf_event_task_context = 1;
pub const perf_event_task_context_perf_nr_task_contexts: perf_event_task_context = 2;
pub type perf_event_task_context = core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wake_q_node {
    pub next: *mut wake_q_node,
}
impl Default for wake_q_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kmap_ctrl {}
#[repr(C)]
#[repr(align(64))]
pub struct task_struct {
    pub thread_info: thread_info,
    pub __state: core::ffi::c_uint,
    pub saved_state: core::ffi::c_uint,
    pub stack: *mut core::ffi::c_void,
    pub usage: refcount_t,
    pub flags: core::ffi::c_uint,
    pub ptrace: core::ffi::c_uint,
    pub on_cpu: core::ffi::c_int,
    pub wake_entry: __call_single_node,
    pub wakee_flips: core::ffi::c_uint,
    pub wakee_flip_decay_ts: core::ffi::c_ulong,
    pub last_wakee: *mut task_struct,
    pub recent_used_cpu: core::ffi::c_int,
    pub wake_cpu: core::ffi::c_int,
    pub on_rq: core::ffi::c_int,
    pub prio: core::ffi::c_int,
    pub static_prio: core::ffi::c_int,
    pub normal_prio: core::ffi::c_int,
    pub rt_priority: core::ffi::c_uint,
    pub __bindgen_padding_0: [u64; 0usize],
    pub se: sched_entity,
    pub rt: sched_rt_entity,
    pub dl: sched_dl_entity,
    pub dl_server: *mut sched_dl_entity,
    pub sched_class: *mut sched_class,
    pub core_node: rb_node,
    pub core_cookie: core::ffi::c_ulong,
    pub core_occupation: core::ffi::c_uint,
    pub sched_task_group: *mut task_group,
    pub uclamp_req: [uclamp_se; 2usize],
    pub uclamp: [uclamp_se; 2usize],
    pub __bindgen_padding_1: u64,
    pub stats: sched_statistics,
    pub preempt_notifiers: hlist_head,
    pub btrace_seq: core::ffi::c_uint,
    pub policy: core::ffi::c_uint,
    pub nr_cpus_allowed: core::ffi::c_int,
    pub cpus_ptr: *const cpumask_t,
    pub user_cpus_ptr: *mut cpumask_t,
    pub cpus_mask: cpumask_t,
    pub migration_pending: *mut core::ffi::c_void,
    pub migration_disabled: core::ffi::c_ushort,
    pub migration_flags: core::ffi::c_ushort,
    pub rcu_read_lock_nesting: core::ffi::c_int,
    pub rcu_read_unlock_special: rcu_special,
    pub rcu_node_entry: list_head,
    pub rcu_blocked_node: *mut rcu_node,
    pub rcu_tasks_nvcsw: core::ffi::c_ulong,
    pub rcu_tasks_holdout: u8_,
    pub rcu_tasks_idx: u8_,
    pub rcu_tasks_idle_cpu: core::ffi::c_int,
    pub rcu_tasks_holdout_list: list_head,
    pub trc_reader_nesting: core::ffi::c_int,
    pub trc_ipi_to_cpu: core::ffi::c_int,
    pub trc_reader_special: rcu_special,
    pub trc_holdout_list: list_head,
    pub trc_blkd_node: list_head,
    pub trc_blkd_cpu: core::ffi::c_int,
    pub sched_info: sched_info,
    pub tasks: list_head,
    pub pushable_tasks: plist_node,
    pub pushable_dl_tasks: rb_node,
    pub mm: *mut mm_struct,
    pub active_mm: *mut mm_struct,
    pub faults_disabled_mapping: *mut address_space,
    pub exit_state: core::ffi::c_int,
    pub exit_code: core::ffi::c_int,
    pub exit_signal: core::ffi::c_int,
    pub pdeath_signal: core::ffi::c_int,
    pub jobctl: core::ffi::c_ulong,
    pub personality: core::ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub atomic_flags: core::ffi::c_ulong,
    pub restart_block: restart_block,
    pub pid: pid_t,
    pub tgid: pid_t,
    pub stack_canary: core::ffi::c_ulong,
    pub real_parent: *mut task_struct,
    pub parent: *mut task_struct,
    pub children: list_head,
    pub sibling: list_head,
    pub group_leader: *mut task_struct,
    pub ptraced: list_head,
    pub ptrace_entry: list_head,
    pub thread_pid: *mut pid,
    pub pid_links: [hlist_node; 4usize],
    pub thread_node: list_head,
    pub vfork_done: *mut completion,
    pub set_child_tid: *mut core::ffi::c_int,
    pub clear_child_tid: *mut core::ffi::c_int,
    pub worker_private: *mut core::ffi::c_void,
    pub utime: u64_,
    pub stime: u64_,
    pub gtime: u64_,
    pub prev_cputime: prev_cputime,
    pub vtime: vtime,
    pub tick_dep_mask: atomic_t,
    pub nvcsw: core::ffi::c_ulong,
    pub nivcsw: core::ffi::c_ulong,
    pub start_time: u64_,
    pub start_boottime: u64_,
    pub min_flt: core::ffi::c_ulong,
    pub maj_flt: core::ffi::c_ulong,
    pub posix_cputimers: posix_cputimers,
    pub posix_cputimers_work: posix_cputimers_work,
    pub ptracer_cred: *const cred,
    pub real_cred: *const cred,
    pub cred: *const cred,
    pub cached_requested_key: *mut key,
    pub comm: [core::ffi::c_char; 16usize],
    pub nameidata: *mut nameidata,
    pub sysvsem: sysv_sem,
    pub sysvshm: sysv_shm,
    pub last_switch_count: core::ffi::c_ulong,
    pub last_switch_time: core::ffi::c_ulong,
    pub fs: *mut fs_struct,
    pub files: *mut files_struct,
    pub io_uring: *mut io_uring_task,
    pub nsproxy: *mut nsproxy,
    pub signal: *mut signal_struct,
    pub sighand: *mut sighand_struct,
    pub blocked: sigset_t,
    pub real_blocked: sigset_t,
    pub saved_sigmask: sigset_t,
    pub pending: sigpending,
    pub sas_ss_sp: core::ffi::c_ulong,
    pub sas_ss_size: usize,
    pub sas_ss_flags: core::ffi::c_uint,
    pub task_works: *mut callback_head,
    pub audit_context: *mut audit_context,
    pub loginuid: kuid_t,
    pub sessionid: core::ffi::c_uint,
    pub seccomp: seccomp,
    pub syscall_dispatch: syscall_user_dispatch,
    pub parent_exec_id: u64_,
    pub self_exec_id: u64_,
    pub alloc_lock: spinlock_t,
    pub pi_lock: raw_spinlock_t,
    pub wake_q: wake_q_node,
    pub pi_waiters: rb_root_cached,
    pub pi_top_task: *mut task_struct,
    pub pi_blocked_on: *mut rt_mutex_waiter,
    pub in_ubsan: core::ffi::c_uint,
    pub journal_info: *mut core::ffi::c_void,
    pub bio_list: *mut bio_list,
    pub plug: *mut blk_plug,
    pub reclaim_state: *mut reclaim_state,
    pub io_context: *mut io_context,
    pub capture_control: *mut capture_control,
    pub ptrace_message: core::ffi::c_ulong,
    pub last_siginfo: *mut kernel_siginfo_t,
    pub ioac: task_io_accounting,
    pub psi_flags: core::ffi::c_uint,
    pub acct_rss_mem1: u64_,
    pub acct_vm_mem1: u64_,
    pub acct_timexpd: u64_,
    pub mems_allowed: nodemask_t,
    pub mems_allowed_seq: seqcount_spinlock_t,
    pub cpuset_mem_spread_rotor: core::ffi::c_int,
    pub cpuset_slab_spread_rotor: core::ffi::c_int,
    pub cgroups: *mut css_set,
    pub cg_list: list_head,
    pub closid: u32_,
    pub rmid: u32_,
    pub robust_list: *mut robust_list_head,
    pub compat_robust_list: *mut compat_robust_list_head,
    pub pi_state_list: list_head,
    pub pi_state_cache: *mut futex_pi_state,
    pub futex_exit_mutex: mutex,
    pub futex_state: core::ffi::c_uint,
    pub perf_event_ctxp: *mut perf_event_context,
    pub perf_event_mutex: mutex,
    pub perf_event_list: list_head,
    pub mempolicy: *mut mempolicy,
    pub il_prev: core::ffi::c_short,
    pub pref_node_fork: core::ffi::c_short,
    pub numa_scan_seq: core::ffi::c_int,
    pub numa_scan_period: core::ffi::c_uint,
    pub numa_scan_period_max: core::ffi::c_uint,
    pub numa_preferred_nid: core::ffi::c_int,
    pub numa_migrate_retry: core::ffi::c_ulong,
    pub node_stamp: u64_,
    pub last_task_numa_placement: u64_,
    pub last_sum_exec_runtime: u64_,
    pub numa_work: callback_head,
    pub numa_group: *mut numa_group,
    pub numa_faults: *mut core::ffi::c_ulong,
    pub total_numa_faults: core::ffi::c_ulong,
    pub numa_faults_locality: [core::ffi::c_ulong; 3usize],
    pub numa_pages_migrated: core::ffi::c_ulong,
    pub rseq: *mut rseq,
    pub rseq_len: u32_,
    pub rseq_sig: u32_,
    pub rseq_event_mask: core::ffi::c_ulong,
    pub mm_cid: core::ffi::c_int,
    pub last_mm_cid: core::ffi::c_int,
    pub migrate_from_cpu: core::ffi::c_int,
    pub mm_cid_active: core::ffi::c_int,
    pub cid_work: callback_head,
    pub tlb_ubc: tlbflush_unmap_batch,
    pub splice_pipe: *mut pipe_inode_info,
    pub task_frag: page_frag,
    pub delays: *mut task_delay_info,
    pub nr_dirtied: core::ffi::c_int,
    pub nr_dirtied_pause: core::ffi::c_int,
    pub dirty_paused_when: core::ffi::c_ulong,
    pub latency_record_count: core::ffi::c_int,
    pub latency_record: [latency_record; 32usize],
    pub timer_slack_ns: u64_,
    pub default_timer_slack_ns: u64_,
    pub curr_ret_stack: core::ffi::c_int,
    pub curr_ret_depth: core::ffi::c_int,
    pub ret_stack: *mut ftrace_ret_stack,
    pub ftrace_timestamp: core::ffi::c_ulonglong,
    pub trace_overrun: atomic_t,
    pub tracing_graph_pause: atomic_t,
    pub trace_recursion: core::ffi::c_ulong,
    pub memcg_in_oom: *mut mem_cgroup,
    pub memcg_oom_gfp_mask: gfp_t,
    pub memcg_oom_order: core::ffi::c_int,
    pub memcg_nr_pages_over_high: core::ffi::c_uint,
    pub active_memcg: *mut mem_cgroup,
    pub objcg: *mut obj_cgroup,
    pub throttle_disk: *mut gendisk,
    pub utask: *mut uprobe_task,
    pub sequential_io: core::ffi::c_uint,
    pub sequential_io_avg: core::ffi::c_uint,
    pub kmap_ctrl: kmap_ctrl,
    pub rcu: callback_head,
    pub rcu_users: refcount_t,
    pub pagefault_disabled: core::ffi::c_int,
    pub oom_reaper_list: *mut task_struct,
    pub oom_reaper_timer: timer_list,
    pub stack_vm_area: *mut vm_struct,
    pub stack_refcount: refcount_t,
    pub patch_state: core::ffi::c_int,
    pub security: *mut core::ffi::c_void,
    pub bpf_storage: *mut bpf_local_storage,
    pub bpf_ctx: *mut bpf_run_ctx,
    pub mce_vaddr: *mut core::ffi::c_void,
    pub mce_kflags: __u64,
    pub mce_addr: u64_,
    pub _bitfield_align_2: [u64; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub mce_kill_me: callback_head,
    pub mce_count: core::ffi::c_int,
    pub kretprobe_instances: llist_head,
    pub rethooks: llist_head,
    pub l1d_flush_kill: callback_head,
    pub rv: [rv_task_monitor; 1usize],
    pub user_event_mm: *mut user_event_mm,
    pub __bindgen_padding_2: [u64; 3usize],
    pub thread: thread_struct,
}
impl Default for task_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl task_struct {
    #[inline]
    pub fn sched_reset_on_fork(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_reset_on_fork(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_contributes_to_load(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_contributes_to_load(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_migrated(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_migrated(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_remote_wakeup(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_remote_wakeup(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_rt_mutex(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_rt_mutex(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_execve(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_execve(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_iowait(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_iowait(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restore_sigmask(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restore_sigmask(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_user_fault(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_user_fault(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_lru_fault(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_lru_fault(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cgroup_migration(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cgroup_migration(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frozen(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frozen(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_memdelay(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_memdelay(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_memstall(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_memstall(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_eventfd(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_eventfd(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pasid_activated(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pasid_activated(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reported_split_lock(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reported_split_lock(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_thrashing(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_thrashing(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sched_reset_on_fork: core::ffi::c_uint,
        sched_contributes_to_load: core::ffi::c_uint,
        sched_migrated: core::ffi::c_uint,
        sched_remote_wakeup: core::ffi::c_uint,
        sched_rt_mutex: core::ffi::c_uint,
        in_execve: core::ffi::c_uint,
        in_iowait: core::ffi::c_uint,
        restore_sigmask: core::ffi::c_uint,
        in_user_fault: core::ffi::c_uint,
        in_lru_fault: core::ffi::c_uint,
        no_cgroup_migration: core::ffi::c_uint,
        frozen: core::ffi::c_uint,
        use_memdelay: core::ffi::c_uint,
        in_memstall: core::ffi::c_uint,
        in_eventfd: core::ffi::c_uint,
        pasid_activated: core::ffi::c_uint,
        reported_split_lock: core::ffi::c_uint,
        in_thrashing: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sched_reset_on_fork: u32 = unsafe { ::core::mem::transmute(sched_reset_on_fork) };
            sched_reset_on_fork as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sched_contributes_to_load: u32 =
                unsafe { ::core::mem::transmute(sched_contributes_to_load) };
            sched_contributes_to_load as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sched_migrated: u32 = unsafe { ::core::mem::transmute(sched_migrated) };
            sched_migrated as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let sched_remote_wakeup: u32 = unsafe { ::core::mem::transmute(sched_remote_wakeup) };
            sched_remote_wakeup as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let sched_rt_mutex: u32 = unsafe { ::core::mem::transmute(sched_rt_mutex) };
            sched_rt_mutex as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let in_execve: u32 = unsafe { ::core::mem::transmute(in_execve) };
            in_execve as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let in_iowait: u32 = unsafe { ::core::mem::transmute(in_iowait) };
            in_iowait as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let restore_sigmask: u32 = unsafe { ::core::mem::transmute(restore_sigmask) };
            restore_sigmask as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let in_user_fault: u32 = unsafe { ::core::mem::transmute(in_user_fault) };
            in_user_fault as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let in_lru_fault: u32 = unsafe { ::core::mem::transmute(in_lru_fault) };
            in_lru_fault as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let no_cgroup_migration: u32 = unsafe { ::core::mem::transmute(no_cgroup_migration) };
            no_cgroup_migration as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let frozen: u32 = unsafe { ::core::mem::transmute(frozen) };
            frozen as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let use_memdelay: u32 = unsafe { ::core::mem::transmute(use_memdelay) };
            use_memdelay as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let in_memstall: u32 = unsafe { ::core::mem::transmute(in_memstall) };
            in_memstall as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let in_eventfd: u32 = unsafe { ::core::mem::transmute(in_eventfd) };
            in_eventfd as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let pasid_activated: u32 = unsafe { ::core::mem::transmute(pasid_activated) };
            pasid_activated as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let reported_split_lock: u32 = unsafe { ::core::mem::transmute(reported_split_lock) };
            reported_split_lock as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let in_thrashing: u32 = unsafe { ::core::mem::transmute(in_thrashing) };
            in_thrashing as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn mce_ripv(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mce_ripv(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mce_whole_page(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mce_whole_page(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __mce_reserved(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set___mce_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        mce_ripv: __u64,
        mce_whole_page: __u64,
        __mce_reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mce_ripv: u64 = unsafe { ::core::mem::transmute(mce_ripv) };
            mce_ripv as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mce_whole_page: u64 = unsafe { ::core::mem::transmute(mce_whole_page) };
            mce_whole_page as u64
        });
        __bindgen_bitfield_unit.set(2usize, 62u8, {
            let __mce_reserved: u64 = unsafe { ::core::mem::transmute(__mce_reserved) };
            __mce_reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static mut cad_pid: *mut pid;
}
extern "C" {
    pub fn cpuset_cpumask_can_shrink(
        cur: *const cpumask,
        trial: *const cpumask,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn task_can_attach(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn dl_bw_alloc(cpu: core::ffi::c_int, dl_bw: u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn dl_bw_free(cpu: core::ffi::c_int, dl_bw: u64_);
}
extern "C" {
    pub fn do_set_cpus_allowed(p: *mut task_struct, new_mask: *const cpumask);
}
extern "C" {
    pub fn set_cpus_allowed_ptr(p: *mut task_struct, new_mask: *const cpumask) -> core::ffi::c_int;
}
extern "C" {
    pub fn dup_user_cpus_ptr(
        dst: *mut task_struct,
        src: *mut task_struct,
        node: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn release_user_cpus_ptr(p: *mut task_struct);
}
extern "C" {
    pub fn dl_task_check_affinity(p: *mut task_struct, mask: *const cpumask) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_compatible_cpus_allowed_ptr(p: *mut task_struct);
}
extern "C" {
    pub fn relax_compatible_cpus_allowed_ptr(p: *mut task_struct);
}
extern "C" {
    pub fn yield_to(p: *mut task_struct, preempt: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_user_nice(p: *mut task_struct, nice: core::ffi::c_long);
}
extern "C" {
    pub fn task_prio(p: *const task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn can_nice(p: *const task_struct, nice: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn task_curr(p: *const task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn idle_cpu(cpu: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn available_idle_cpu(cpu: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        arg1: *mut task_struct,
        arg2: core::ffi::c_int,
        arg3: *const sched_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sched_setscheduler_nocheck(
        arg1: *mut task_struct,
        arg2: core::ffi::c_int,
        arg3: *const sched_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sched_set_fifo(p: *mut task_struct);
}
extern "C" {
    pub fn sched_set_fifo_low(p: *mut task_struct);
}
extern "C" {
    pub fn sched_set_normal(p: *mut task_struct, nice: core::ffi::c_int);
}
extern "C" {
    pub fn sched_setattr(arg1: *mut task_struct, arg2: *const sched_attr) -> core::ffi::c_int;
}
extern "C" {
    pub fn sched_setattr_nocheck(
        arg1: *mut task_struct,
        arg2: *const sched_attr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn idle_task(cpu: core::ffi::c_int) -> *mut task_struct;
}
extern "C" {
    pub fn curr_task(cpu: core::ffi::c_int) -> *mut task_struct;
}
extern "C" {
    pub fn ia64_set_curr_task(cpu: core::ffi::c_int, p: *mut task_struct);
}
extern "C" {
    #[link_name = "\u{1}yield"]
    pub fn yield_();
}
#[repr(C)]
#[repr(align(64))]
pub struct thread_union {
    pub task: __BindgenUnionField<task_struct>,
    pub stack: __BindgenUnionField<[core::ffi::c_ulong; 2048usize]>,
    pub bindgen_union_field: [u8; 16384usize],
}
impl Default for thread_union {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut init_stack: [core::ffi::c_ulong; 2048usize];
}
extern "C" {
    pub fn find_task_by_vpid(nr: pid_t) -> *mut task_struct;
}
extern "C" {
    pub fn find_task_by_pid_ns(nr: pid_t, ns: *mut pid_namespace) -> *mut task_struct;
}
extern "C" {
    pub fn find_get_task_by_vpid(nr: pid_t) -> *mut task_struct;
}
extern "C" {
    pub fn wake_up_state(tsk: *mut task_struct, state: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn wake_up_process(tsk: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn wake_up_new_task(tsk: *mut task_struct);
}
extern "C" {
    pub fn kick_process(tsk: *mut task_struct);
}
extern "C" {
    pub fn __set_task_comm(tsk: *mut task_struct, from: *const core::ffi::c_char, exec: bool_);
}
extern "C" {
    pub fn __get_task_comm(
        to: *mut core::ffi::c_char,
        len: usize,
        tsk: *mut task_struct,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn wait_task_inactive(
        arg1: *mut task_struct,
        match_state: core::ffi::c_uint,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn sched_dynamic_klp_enable();
}
extern "C" {
    pub fn sched_dynamic_klp_disable();
}
extern "C" {
    pub static mut __SCK__cond_resched: static_call_key;
}
extern "C" {
    pub fn __SCT__cond_resched() -> core::ffi::c_int;
}
extern "C" {
    pub fn __cond_resched_lock(lock: *mut spinlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cond_resched_rwlock_read(lock: *mut rwlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cond_resched_rwlock_write(lock: *mut rwlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn preempt_model_none() -> bool_;
}
extern "C" {
    pub fn preempt_model_voluntary() -> bool_;
}
extern "C" {
    pub fn preempt_model_full() -> bool_;
}
extern "C" {
    pub fn set_task_cpu(p: *mut task_struct, cpu: core::ffi::c_uint);
}
extern "C" {
    pub fn sched_task_on_rq(p: *mut task_struct) -> bool_;
}
extern "C" {
    pub fn get_wchan(p: *mut task_struct) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn cpu_curr_snapshot(cpu: core::ffi::c_int) -> *mut task_struct;
}
extern "C" {
    pub fn sched_setaffinity(pid: pid_t, new_mask: *const cpumask) -> core::ffi::c_long;
}
extern "C" {
    pub fn sched_getaffinity(pid: pid_t, mask: *mut cpumask) -> core::ffi::c_long;
}
extern "C" {
    pub fn sched_cpu_util(cpu: core::ffi::c_int) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn sched_core_free(tsk: *mut task_struct);
}
extern "C" {
    pub fn sched_core_fork(p: *mut task_struct);
}
extern "C" {
    pub fn sched_core_share_pid(
        cmd: core::ffi::c_uint,
        pid: pid_t,
        type_: pid_type,
        uaddr: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sched_core_idle_cpu(cpu: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn sched_set_stop_task(cpu: core::ffi::c_int, stop: *mut task_struct);
}
extern "C" {
    pub fn mm_alloc() -> *mut mm_struct;
}
extern "C" {
    pub fn __mmdrop(mm: *mut mm_struct);
}
extern "C" {
    pub fn mmput(arg1: *mut mm_struct);
}
extern "C" {
    pub fn mmput_async(arg1: *mut mm_struct);
}
extern "C" {
    pub fn get_task_mm(task: *mut task_struct) -> *mut mm_struct;
}
extern "C" {
    pub fn mm_access(task: *mut task_struct, mode: core::ffi::c_uint) -> *mut mm_struct;
}
extern "C" {
    pub fn exit_mm_release(arg1: *mut task_struct, arg2: *mut mm_struct);
}
extern "C" {
    pub fn exec_mm_release(arg1: *mut task_struct, arg2: *mut mm_struct);
}
extern "C" {
    pub fn mm_update_next_owner(mm: *mut mm_struct);
}
extern "C" {
    pub fn arch_pick_mmap_layout(mm: *mut mm_struct, rlim_stack: *mut rlimit);
}
extern "C" {
    pub fn arch_get_unmapped_area(
        arg1: *mut file,
        arg2: core::ffi::c_ulong,
        arg3: core::ffi::c_ulong,
        arg4: core::ffi::c_ulong,
        arg5: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn arch_get_unmapped_area_topdown(
        filp: *mut file,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        pgoff: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn generic_get_unmapped_area(
        filp: *mut file,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        pgoff: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn generic_get_unmapped_area_topdown(
        filp: *mut file,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        pgoff: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub static mut int_active_memcg: *mut mem_cgroup;
}
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY: _bindgen_ty_75 = 1;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED: _bindgen_ty_75 = 2;
pub const MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY: _bindgen_ty_75 = 4;
pub const MEMBARRIER_STATE_GLOBAL_EXPEDITED: _bindgen_ty_75 = 8;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY: _bindgen_ty_75 = 16;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE: _bindgen_ty_75 = 32;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY: _bindgen_ty_75 = 64;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ: _bindgen_ty_75 = 128;
pub type _bindgen_ty_75 = core::ffi::c_uint;
pub const MEMBARRIER_FLAG_SYNC_CORE: _bindgen_ty_76 = 1;
pub const MEMBARRIER_FLAG_RSEQ: _bindgen_ty_76 = 2;
pub type _bindgen_ty_76 = core::ffi::c_uint;
extern "C" {
    pub fn membarrier_exec_mmap(mm: *mut mm_struct);
}
extern "C" {
    pub fn membarrier_update_current_mm(next_mm: *mut mm_struct);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xa_limit {
    pub max: u32_,
    pub min: u32_,
}
pub type xa_mark_t = core::ffi::c_uint;
pub const xa_lock_type_XA_LOCK_IRQ: xa_lock_type = 1;
pub const xa_lock_type_XA_LOCK_BH: xa_lock_type = 2;
pub type xa_lock_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xarray {
    pub xa_lock: spinlock_t,
    pub xa_flags: gfp_t,
    pub xa_head: *mut core::ffi::c_void,
}
impl Default for xarray {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn xa_load(arg1: *mut xarray, index: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xa_store(
        arg1: *mut xarray,
        index: core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        arg2: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xa_erase(arg1: *mut xarray, index: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xa_store_range(
        arg1: *mut xarray,
        first: core::ffi::c_ulong,
        last: core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        arg2: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xa_get_mark(arg1: *mut xarray, index: core::ffi::c_ulong, arg2: xa_mark_t) -> bool_;
}
extern "C" {
    pub fn xa_set_mark(arg1: *mut xarray, index: core::ffi::c_ulong, arg2: xa_mark_t);
}
extern "C" {
    pub fn xa_clear_mark(arg1: *mut xarray, index: core::ffi::c_ulong, arg2: xa_mark_t);
}
extern "C" {
    pub fn xa_find(
        xa: *mut xarray,
        index: *mut core::ffi::c_ulong,
        max: core::ffi::c_ulong,
        arg1: xa_mark_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xa_find_after(
        xa: *mut xarray,
        index: *mut core::ffi::c_ulong,
        max: core::ffi::c_ulong,
        arg1: xa_mark_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xa_extract(
        arg1: *mut xarray,
        dst: *mut *mut core::ffi::c_void,
        start: core::ffi::c_ulong,
        max: core::ffi::c_ulong,
        n: core::ffi::c_uint,
        arg2: xa_mark_t,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn xa_destroy(arg1: *mut xarray);
}
extern "C" {
    pub fn __xa_erase(arg1: *mut xarray, index: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __xa_store(
        arg1: *mut xarray,
        index: core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        arg2: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __xa_cmpxchg(
        arg1: *mut xarray,
        index: core::ffi::c_ulong,
        old: *mut core::ffi::c_void,
        entry: *mut core::ffi::c_void,
        arg2: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __xa_insert(
        arg1: *mut xarray,
        index: core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        arg2: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __xa_alloc(
        arg1: *mut xarray,
        id: *mut u32_,
        entry: *mut core::ffi::c_void,
        arg2: xa_limit,
        arg3: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __xa_alloc_cyclic(
        arg1: *mut xarray,
        id: *mut u32_,
        entry: *mut core::ffi::c_void,
        arg2: xa_limit,
        next: *mut u32_,
        arg3: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __xa_set_mark(arg1: *mut xarray, index: core::ffi::c_ulong, arg2: xa_mark_t);
}
extern "C" {
    pub fn __xa_clear_mark(arg1: *mut xarray, index: core::ffi::c_ulong, arg2: xa_mark_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xa_node {
    pub shift: core::ffi::c_uchar,
    pub offset: core::ffi::c_uchar,
    pub count: core::ffi::c_uchar,
    pub nr_values: core::ffi::c_uchar,
    pub parent: *mut xa_node,
    pub array: *mut xarray,
    pub __bindgen_anon_1: xa_node__bindgen_ty_1,
    pub slots: [*mut core::ffi::c_void; 64usize],
    pub __bindgen_anon_2: xa_node__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xa_node__bindgen_ty_1 {
    pub private_list: list_head,
    pub callback_head: callback_head,
}
impl Default for xa_node__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xa_node__bindgen_ty_2 {
    pub tags: [[core::ffi::c_ulong; 1usize]; 3usize],
    pub marks: [[core::ffi::c_ulong; 1usize]; 3usize],
}
impl Default for xa_node__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for xa_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn xa_dump(arg1: *const xarray);
}
extern "C" {
    pub fn xa_dump_node(arg1: *const xa_node);
}
pub type xa_update_node_t = ::core::option::Option<unsafe extern "C" fn(node: *mut xa_node)>;
extern "C" {
    pub fn xa_delete_node(arg1: *mut xa_node, arg2: xa_update_node_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xa_state {
    pub xa: *mut xarray,
    pub xa_index: core::ffi::c_ulong,
    pub xa_shift: core::ffi::c_uchar,
    pub xa_sibs: core::ffi::c_uchar,
    pub xa_offset: core::ffi::c_uchar,
    pub xa_pad: core::ffi::c_uchar,
    pub xa_node: *mut xa_node,
    pub xa_alloc: *mut xa_node,
    pub xa_update: xa_update_node_t,
    pub xa_lru: *mut list_lru,
}
impl Default for xa_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn xas_load(arg1: *mut xa_state) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xas_store(arg1: *mut xa_state, entry: *mut core::ffi::c_void) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xas_find(arg1: *mut xa_state, max: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xas_find_conflict(arg1: *mut xa_state) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xas_get_mark(arg1: *const xa_state, arg2: xa_mark_t) -> bool_;
}
extern "C" {
    pub fn xas_set_mark(arg1: *const xa_state, arg2: xa_mark_t);
}
extern "C" {
    pub fn xas_clear_mark(arg1: *const xa_state, arg2: xa_mark_t);
}
extern "C" {
    pub fn xas_find_marked(
        arg1: *mut xa_state,
        max: core::ffi::c_ulong,
        arg2: xa_mark_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xas_init_marks(arg1: *const xa_state);
}
extern "C" {
    pub fn xas_nomem(arg1: *mut xa_state, arg2: gfp_t) -> bool_;
}
extern "C" {
    pub fn xas_destroy(arg1: *mut xa_state);
}
extern "C" {
    pub fn xas_pause(arg1: *mut xa_state);
}
extern "C" {
    pub fn xas_create_range(arg1: *mut xa_state);
}
extern "C" {
    pub fn xa_get_order(arg1: *mut xarray, index: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn xas_split(arg1: *mut xa_state, entry: *mut core::ffi::c_void, order: core::ffi::c_uint);
}
extern "C" {
    pub fn xas_split_alloc(
        arg1: *mut xa_state,
        entry: *mut core::ffi::c_void,
        order: core::ffi::c_uint,
        arg2: gfp_t,
    );
}
pub const XA_CHECK_SCHED: _bindgen_ty_77 = 4096;
pub type _bindgen_ty_77 = core::ffi::c_uint;
extern "C" {
    pub fn __xas_next(arg1: *mut xa_state) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __xas_prev(arg1: *mut xa_state) -> *mut core::ffi::c_void;
}
pub const lru_status_LRU_REMOVED: lru_status = 0;
pub const lru_status_LRU_REMOVED_RETRY: lru_status = 1;
pub const lru_status_LRU_ROTATE: lru_status = 2;
pub const lru_status_LRU_SKIP: lru_status = 3;
pub const lru_status_LRU_RETRY: lru_status = 4;
pub type lru_status = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_lru_one {
    pub list: list_head,
    pub nr_items: core::ffi::c_long,
}
impl Default for list_lru_one {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct list_lru_memcg {
    pub rcu: callback_head,
    pub node: __IncompleteArrayField<list_lru_one>,
}
impl Default for list_lru_memcg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct list_lru_node {
    pub lock: spinlock_t,
    pub lru: list_lru_one,
    pub nr_items: core::ffi::c_long,
}
impl Default for list_lru_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_lru {
    pub node: *mut list_lru_node,
    pub list: list_head,
    pub shrinker_id: core::ffi::c_int,
    pub memcg_aware: bool_,
    pub xa: xarray,
}
impl Default for list_lru {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn list_lru_destroy(lru: *mut list_lru);
}
extern "C" {
    pub fn __list_lru_init(
        lru: *mut list_lru,
        memcg_aware: bool_,
        key: *mut lock_class_key,
        shrinker: *mut shrinker,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memcg_list_lru_alloc(
        memcg: *mut mem_cgroup,
        lru: *mut list_lru,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memcg_reparent_list_lrus(memcg: *mut mem_cgroup, parent: *mut mem_cgroup);
}
extern "C" {
    pub fn list_lru_add(
        lru: *mut list_lru,
        item: *mut list_head,
        nid: core::ffi::c_int,
        memcg: *mut mem_cgroup,
    ) -> bool_;
}
extern "C" {
    pub fn list_lru_add_obj(lru: *mut list_lru, item: *mut list_head) -> bool_;
}
extern "C" {
    pub fn list_lru_del(
        lru: *mut list_lru,
        item: *mut list_head,
        nid: core::ffi::c_int,
        memcg: *mut mem_cgroup,
    ) -> bool_;
}
extern "C" {
    pub fn list_lru_del_obj(lru: *mut list_lru, item: *mut list_head) -> bool_;
}
extern "C" {
    pub fn list_lru_count_one(
        lru: *mut list_lru,
        nid: core::ffi::c_int,
        memcg: *mut mem_cgroup,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn list_lru_count_node(lru: *mut list_lru, nid: core::ffi::c_int) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn list_lru_isolate(list: *mut list_lru_one, item: *mut list_head);
}
extern "C" {
    pub fn list_lru_isolate_move(
        list: *mut list_lru_one,
        item: *mut list_head,
        head: *mut list_head,
    );
}
extern "C" {
    pub fn list_lru_putback(
        lru: *mut list_lru,
        item: *mut list_head,
        nid: core::ffi::c_int,
        memcg: *mut mem_cgroup,
    );
}
pub type list_lru_walk_cb = ::core::option::Option<
    unsafe extern "C" fn(
        item: *mut list_head,
        list: *mut list_lru_one,
        lock: *mut spinlock_t,
        cb_arg: *mut core::ffi::c_void,
    ) -> lru_status,
>;
extern "C" {
    pub fn list_lru_walk_one(
        lru: *mut list_lru,
        nid: core::ffi::c_int,
        memcg: *mut mem_cgroup,
        isolate: list_lru_walk_cb,
        cb_arg: *mut core::ffi::c_void,
        nr_to_walk: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn list_lru_walk_one_irq(
        lru: *mut list_lru,
        nid: core::ffi::c_int,
        memcg: *mut mem_cgroup,
        isolate: list_lru_walk_cb,
        cb_arg: *mut core::ffi::c_void,
        nr_to_walk: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn list_lru_walk_node(
        lru: *mut list_lru,
        nid: core::ffi::c_int,
        isolate: list_lru_walk_cb,
        cb_arg: *mut core::ffi::c_void,
        nr_to_walk: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct radix_tree_preload {
    pub lock: local_lock_t,
    pub nr: core::ffi::c_uint,
    pub nodes: *mut xa_node,
}
impl Default for radix_tree_preload {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut radix_tree_preloads: radix_tree_preload;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct radix_tree_iter {
    pub index: core::ffi::c_ulong,
    pub next_index: core::ffi::c_ulong,
    pub tags: core::ffi::c_ulong,
    pub node: *mut xa_node,
}
impl Default for radix_tree_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn radix_tree_insert(
        arg1: *mut xarray,
        index: core::ffi::c_ulong,
        arg2: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __radix_tree_lookup(
        arg1: *const xarray,
        index: core::ffi::c_ulong,
        nodep: *mut *mut xa_node,
        slotp: *mut *mut *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn radix_tree_lookup(
        arg1: *const xarray,
        arg2: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn radix_tree_lookup_slot(
        arg1: *const xarray,
        index: core::ffi::c_ulong,
    ) -> *mut *mut core::ffi::c_void;
}
extern "C" {
    pub fn __radix_tree_replace(
        arg1: *mut xarray,
        arg2: *mut xa_node,
        slot: *mut *mut core::ffi::c_void,
        entry: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn radix_tree_iter_replace(
        arg1: *mut xarray,
        arg2: *const radix_tree_iter,
        slot: *mut *mut core::ffi::c_void,
        entry: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn radix_tree_replace_slot(
        arg1: *mut xarray,
        slot: *mut *mut core::ffi::c_void,
        entry: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn radix_tree_iter_delete(
        arg1: *mut xarray,
        iter: *mut radix_tree_iter,
        slot: *mut *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn radix_tree_delete_item(
        arg1: *mut xarray,
        arg2: core::ffi::c_ulong,
        arg3: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn radix_tree_delete(arg1: *mut xarray, arg2: core::ffi::c_ulong)
        -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn radix_tree_gang_lookup(
        arg1: *const xarray,
        results: *mut *mut core::ffi::c_void,
        first_index: core::ffi::c_ulong,
        max_items: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn radix_tree_preload(gfp_mask: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn radix_tree_maybe_preload(gfp_mask: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn radix_tree_init();
}
extern "C" {
    pub fn radix_tree_tag_set(
        arg1: *mut xarray,
        index: core::ffi::c_ulong,
        tag: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn radix_tree_tag_clear(
        arg1: *mut xarray,
        index: core::ffi::c_ulong,
        tag: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn radix_tree_tag_get(
        arg1: *const xarray,
        index: core::ffi::c_ulong,
        tag: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn radix_tree_iter_tag_clear(
        arg1: *mut xarray,
        iter: *const radix_tree_iter,
        tag: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn radix_tree_gang_lookup_tag(
        arg1: *const xarray,
        results: *mut *mut core::ffi::c_void,
        first_index: core::ffi::c_ulong,
        max_items: core::ffi::c_uint,
        tag: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn radix_tree_gang_lookup_tag_slot(
        arg1: *const xarray,
        results: *mut *mut *mut core::ffi::c_void,
        first_index: core::ffi::c_ulong,
        max_items: core::ffi::c_uint,
        tag: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn radix_tree_tagged(arg1: *const xarray, tag: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn idr_get_free(
        root: *mut xarray,
        iter: *mut radix_tree_iter,
        gfp: gfp_t,
        max: core::ffi::c_ulong,
    ) -> *mut *mut core::ffi::c_void;
}
pub const RADIX_TREE_ITER_TAG_MASK: _bindgen_ty_78 = 15;
pub const RADIX_TREE_ITER_TAGGED: _bindgen_ty_78 = 16;
pub const RADIX_TREE_ITER_CONTIG: _bindgen_ty_78 = 32;
pub type _bindgen_ty_78 = core::ffi::c_uint;
extern "C" {
    pub fn radix_tree_next_chunk(
        arg1: *const xarray,
        iter: *mut radix_tree_iter,
        flags: core::ffi::c_uint,
    ) -> *mut *mut core::ffi::c_void;
}
extern "C" {
    pub fn radix_tree_iter_resume(
        slot: *mut *mut core::ffi::c_void,
        iter: *mut radix_tree_iter,
    ) -> *mut *mut core::ffi::c_void;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct upid {
    pub nr: core::ffi::c_int,
    pub ns: *mut pid_namespace,
}
impl Default for upid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct pid {
    pub count: refcount_t,
    pub level: core::ffi::c_uint,
    pub lock: spinlock_t,
    pub tasks: [hlist_head; 4usize],
    pub inodes: hlist_head,
    pub wait_pidfd: wait_queue_head_t,
    pub rcu: callback_head,
    pub numbers: __IncompleteArrayField<upid>,
}
impl Default for pid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut init_struct_pid: pid;
}
extern "C" {
    pub static pidfd_fops: file_operations;
}
extern "C" {
    pub fn pidfd_pid(file: *const file) -> *mut pid;
}
extern "C" {
    pub fn pidfd_get_pid(fd: core::ffi::c_uint, flags: *mut core::ffi::c_uint) -> *mut pid;
}
extern "C" {
    pub fn pidfd_get_task(
        pidfd: core::ffi::c_int,
        flags: *mut core::ffi::c_uint,
    ) -> *mut task_struct;
}
extern "C" {
    pub fn pidfd_create(pid: *mut pid, flags: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn pidfd_prepare(
        pid: *mut pid,
        flags: core::ffi::c_uint,
        ret: *mut *mut file,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_pid(pid: *mut pid);
}
extern "C" {
    pub fn pid_task(pid: *mut pid, arg1: pid_type) -> *mut task_struct;
}
extern "C" {
    pub fn get_pid_task(pid: *mut pid, arg1: pid_type) -> *mut task_struct;
}
extern "C" {
    pub fn get_task_pid(task: *mut task_struct, type_: pid_type) -> *mut pid;
}
extern "C" {
    pub fn attach_pid(task: *mut task_struct, arg1: pid_type);
}
extern "C" {
    pub fn detach_pid(task: *mut task_struct, arg1: pid_type);
}
extern "C" {
    pub fn change_pid(task: *mut task_struct, arg1: pid_type, pid: *mut pid);
}
extern "C" {
    pub fn exchange_tids(task: *mut task_struct, old: *mut task_struct);
}
extern "C" {
    pub fn transfer_pid(old: *mut task_struct, new: *mut task_struct, arg1: pid_type);
}
extern "C" {
    pub static mut pid_max: core::ffi::c_int;
}
extern "C" {
    pub static mut pid_max_min: core::ffi::c_int;
}
extern "C" {
    pub static mut pid_max_max: core::ffi::c_int;
}
extern "C" {
    pub fn find_pid_ns(nr: core::ffi::c_int, ns: *mut pid_namespace) -> *mut pid;
}
extern "C" {
    pub fn find_vpid(nr: core::ffi::c_int) -> *mut pid;
}
extern "C" {
    pub fn find_get_pid(nr: core::ffi::c_int) -> *mut pid;
}
extern "C" {
    pub fn find_ge_pid(nr: core::ffi::c_int, arg1: *mut pid_namespace) -> *mut pid;
}
extern "C" {
    pub fn alloc_pid(ns: *mut pid_namespace, set_tid: *mut pid_t, set_tid_size: usize) -> *mut pid;
}
extern "C" {
    pub fn free_pid(pid: *mut pid);
}
extern "C" {
    pub fn disable_pid_allocation(ns: *mut pid_namespace);
}
extern "C" {
    pub fn pid_nr_ns(pid: *mut pid, ns: *mut pid_namespace) -> pid_t;
}
extern "C" {
    pub fn pid_vnr(pid: *mut pid) -> pid_t;
}
extern "C" {
    pub fn __task_pid_nr_ns(
        task: *mut task_struct,
        type_: pid_type,
        ns: *mut pid_namespace,
    ) -> pid_t;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __user_cap_header_struct {
    pub version: __u32,
    pub pid: core::ffi::c_int,
}
pub type cap_user_header_t = *mut __user_cap_header_struct;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __user_cap_data_struct {
    pub effective: __u32,
    pub permitted: __u32,
    pub inheritable: __u32,
}
pub type cap_user_data_t = *mut __user_cap_data_struct;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfs_cap_data {
    pub magic_etc: __le32,
    pub data: [vfs_cap_data__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfs_cap_data__bindgen_ty_1 {
    pub permitted: __le32,
    pub inheritable: __le32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfs_ns_cap_data {
    pub magic_etc: __le32,
    pub data: [vfs_ns_cap_data__bindgen_ty_1; 2usize],
    pub rootid: __le32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfs_ns_cap_data__bindgen_ty_1 {
    pub permitted: __le32,
    pub inheritable: __le32,
}
extern "C" {
    pub static mut file_caps_enabled: core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_cap_t {
    pub val: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpu_vfs_cap_data {
    pub magic_etc: __u32,
    pub rootid: kuid_t,
    pub permitted: kernel_cap_t,
    pub inheritable: kernel_cap_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mnt_idmap {
    _unused: [u8; 0],
}
extern "C" {
    pub fn has_capability(t: *mut task_struct, cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn has_ns_capability(
        t: *mut task_struct,
        ns: *mut user_namespace,
        cap: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn has_capability_noaudit(t: *mut task_struct, cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn has_ns_capability_noaudit(
        t: *mut task_struct,
        ns: *mut user_namespace,
        cap: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn capable(cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn ns_capable(ns: *mut user_namespace, cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn ns_capable_noaudit(ns: *mut user_namespace, cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn ns_capable_setid(ns: *mut user_namespace, cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn privileged_wrt_inode_uidgid(
        ns: *mut user_namespace,
        idmap: *mut mnt_idmap,
        inode: *const inode,
    ) -> bool_;
}
extern "C" {
    pub fn capable_wrt_inode_uidgid(
        idmap: *mut mnt_idmap,
        inode: *const inode,
        cap: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn file_ns_capable(
        file: *const file,
        ns: *mut user_namespace,
        cap: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn ptracer_capable(tsk: *mut task_struct, ns: *mut user_namespace) -> bool_;
}
extern "C" {
    pub fn get_vfs_caps_from_disk(
        idmap: *mut mnt_idmap,
        dentry: *const dentry,
        cpu_caps: *mut cpu_vfs_cap_data,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_convert_nscap(
        idmap: *mut mnt_idmap,
        dentry: *mut dentry,
        ivalue: *mut *const core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct semaphore {
    pub lock: raw_spinlock_t,
    pub count: core::ffi::c_uint,
    pub wait_list: list_head,
}
impl Default for semaphore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn down(sem: *mut semaphore);
}
extern "C" {
    pub fn down_interruptible(sem: *mut semaphore) -> core::ffi::c_int;
}
extern "C" {
    pub fn down_killable(sem: *mut semaphore) -> core::ffi::c_int;
}
extern "C" {
    pub fn down_trylock(sem: *mut semaphore) -> core::ffi::c_int;
}
extern "C" {
    pub fn down_timeout(sem: *mut semaphore, jiffies: core::ffi::c_long) -> core::ffi::c_int;
}
extern "C" {
    pub fn up(sem: *mut semaphore);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct f_owner_ex {
    pub type_: core::ffi::c_int,
    pub pid: __kernel_pid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flock {
    pub l_type: core::ffi::c_short,
    pub l_whence: core::ffi::c_short,
    pub l_start: __kernel_off_t,
    pub l_len: __kernel_off_t,
    pub l_pid: __kernel_pid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flock64 {
    pub l_type: core::ffi::c_short,
    pub l_whence: core::ffi::c_short,
    pub l_start: __kernel_loff_t,
    pub l_len: __kernel_loff_t,
    pub l_pid: __kernel_pid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct open_how {
    pub flags: __u64,
    pub mode: __u64,
    pub resolve: __u64,
}
pub const migrate_mode_MIGRATE_ASYNC: migrate_mode = 0;
pub const migrate_mode_MIGRATE_SYNC_LIGHT: migrate_mode = 1;
pub const migrate_mode_MIGRATE_SYNC: migrate_mode = 2;
pub const migrate_mode_MIGRATE_SYNC_NO_COPY: migrate_mode = 3;
pub type migrate_mode = core::ffi::c_uint;
pub const migrate_reason_MR_COMPACTION: migrate_reason = 0;
pub const migrate_reason_MR_MEMORY_FAILURE: migrate_reason = 1;
pub const migrate_reason_MR_MEMORY_HOTPLUG: migrate_reason = 2;
pub const migrate_reason_MR_SYSCALL: migrate_reason = 3;
pub const migrate_reason_MR_MEMPOLICY_MBIND: migrate_reason = 4;
pub const migrate_reason_MR_NUMA_MISPLACED: migrate_reason = 5;
pub const migrate_reason_MR_CONTIG_RANGE: migrate_reason = 6;
pub const migrate_reason_MR_LONGTERM_PIN: migrate_reason = 7;
pub const migrate_reason_MR_DEMOTION: migrate_reason = 8;
pub const migrate_reason_MR_TYPES: migrate_reason = 9;
pub type migrate_reason = core::ffi::c_uint;
extern "C" {
    pub static mut print_fatal_signals: core::ffi::c_int;
}
extern "C" {
    pub fn copy_siginfo_to_user(
        to: *mut siginfo_t,
        from: *const kernel_siginfo_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn copy_siginfo_from_user(
        to: *mut kernel_siginfo_t,
        from: *const siginfo_t,
    ) -> core::ffi::c_int;
}
pub const siginfo_layout_SIL_KILL: siginfo_layout = 0;
pub const siginfo_layout_SIL_TIMER: siginfo_layout = 1;
pub const siginfo_layout_SIL_POLL: siginfo_layout = 2;
pub const siginfo_layout_SIL_FAULT: siginfo_layout = 3;
pub const siginfo_layout_SIL_FAULT_TRAPNO: siginfo_layout = 4;
pub const siginfo_layout_SIL_FAULT_MCEERR: siginfo_layout = 5;
pub const siginfo_layout_SIL_FAULT_BNDERR: siginfo_layout = 6;
pub const siginfo_layout_SIL_FAULT_PKUERR: siginfo_layout = 7;
pub const siginfo_layout_SIL_FAULT_PERF_EVENT: siginfo_layout = 8;
pub const siginfo_layout_SIL_CHLD: siginfo_layout = 9;
pub const siginfo_layout_SIL_RT: siginfo_layout = 10;
pub const siginfo_layout_SIL_SYS: siginfo_layout = 11;
pub type siginfo_layout = core::ffi::c_uint;
extern "C" {
    pub fn siginfo_layout(sig: core::ffi::c_uint, si_code: core::ffi::c_int) -> siginfo_layout;
}
extern "C" {
    pub fn flush_sigqueue(queue: *mut sigpending);
}
extern "C" {
    pub fn next_signal(pending: *mut sigpending, mask: *mut sigset_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_send_sig_info(
        sig: core::ffi::c_int,
        info: *mut kernel_siginfo,
        p: *mut task_struct,
        type_: pid_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn group_send_sig_info(
        sig: core::ffi::c_int,
        info: *mut kernel_siginfo,
        p: *mut task_struct,
        type_: pid_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn send_signal_locked(
        sig: core::ffi::c_int,
        info: *mut kernel_siginfo,
        p: *mut task_struct,
        type_: pid_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sigprocmask(
        arg1: core::ffi::c_int,
        arg2: *mut sigset_t,
        arg3: *mut sigset_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_current_blocked(arg1: *mut sigset_t);
}
extern "C" {
    pub fn __set_current_blocked(arg1: *const sigset_t);
}
extern "C" {
    pub static mut show_unhandled_signals: core::ffi::c_int;
}
extern "C" {
    pub fn get_signal(ksig: *mut ksignal) -> bool_;
}
extern "C" {
    pub fn signal_setup_done(
        failed: core::ffi::c_int,
        ksig: *mut ksignal,
        stepping: core::ffi::c_int,
    );
}
extern "C" {
    pub fn exit_signals(tsk: *mut task_struct);
}
extern "C" {
    pub fn kernel_sigaction(arg1: core::ffi::c_int, arg2: __sighandler_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmem_cache {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut sighand_cachep: *mut kmem_cache;
}
extern "C" {
    pub fn unhandled_signal(tsk: *mut task_struct, sig: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn signals_init();
}
extern "C" {
    pub fn restore_altstack(arg1: *const stack_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn __save_altstack(arg1: *mut stack_t, arg2: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn sigaltstack_size_valid(ss_size: usize) -> bool_;
}
extern "C" {
    pub fn render_sigset_t(
        arg1: *mut seq_file,
        arg2: *const core::ffi::c_char,
        arg3: *mut sigset_t,
    );
}
extern "C" {
    pub fn task_set_jobctl_pending(task: *mut task_struct, mask: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn task_clear_jobctl_trapping(task: *mut task_struct);
}
extern "C" {
    pub fn task_clear_jobctl_pending(task: *mut task_struct, mask: core::ffi::c_ulong);
}
extern "C" {
    pub static mut __tracepoint_mmap_lock_start_locking: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_mmap_lock_acquire_returned: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_mmap_lock_released: tracepoint;
}
extern "C" {
    pub fn __mmap_lock_do_trace_start_locking(mm: *mut mm_struct, write: bool_);
}
extern "C" {
    pub fn __mmap_lock_do_trace_acquire_returned(mm: *mut mm_struct, write: bool_, success: bool_);
}
extern "C" {
    pub fn __mmap_lock_do_trace_released(mm: *mut mm_struct, write: bool_);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct exception_table_entry {
    pub insn: core::ffi::c_int,
    pub fixup: core::ffi::c_int,
    pub data: core::ffi::c_int,
}
extern "C" {
    pub fn fixup_exception(
        regs: *mut pt_regs,
        trapnr: core::ffi::c_int,
        error_code: core::ffi::c_ulong,
        fault_addr: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fixup_bug(regs: *mut pt_regs, trapnr: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ex_get_fixup_type(ip: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn early_fixup_exception(regs: *mut pt_regs, trapnr: core::ffi::c_int);
}
extern "C" {
    pub fn ex_handler_msr_mce(regs: *mut pt_regs, wrmsr: bool_) -> !;
}
extern "C" {
    pub fn ex_handler_bpf(x: *const exception_table_entry, regs: *mut pt_regs) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct interval_tree_node {
    pub rb: rb_node,
    pub start: core::ffi::c_ulong,
    pub last: core::ffi::c_ulong,
    pub __subtree_last: core::ffi::c_ulong,
}
impl Default for interval_tree_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn interval_tree_insert(node: *mut interval_tree_node, root: *mut rb_root_cached);
}
extern "C" {
    pub fn interval_tree_remove(node: *mut interval_tree_node, root: *mut rb_root_cached);
}
extern "C" {
    pub fn interval_tree_iter_first(
        root: *mut rb_root_cached,
        start: core::ffi::c_ulong,
        last: core::ffi::c_ulong,
    ) -> *mut interval_tree_node;
}
extern "C" {
    pub fn interval_tree_iter_next(
        node: *mut interval_tree_node,
        start: core::ffi::c_ulong,
        last: core::ffi::c_ulong,
    ) -> *mut interval_tree_node;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct interval_tree_span_iter {
    pub nodes: [*mut interval_tree_node; 2usize],
    pub first_index: core::ffi::c_ulong,
    pub last_index: core::ffi::c_ulong,
    pub __bindgen_anon_1: interval_tree_span_iter__bindgen_ty_1,
    pub __bindgen_anon_2: interval_tree_span_iter__bindgen_ty_2,
    pub is_hole: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union interval_tree_span_iter__bindgen_ty_1 {
    pub start_hole: core::ffi::c_ulong,
    pub start_used: core::ffi::c_ulong,
}
impl Default for interval_tree_span_iter__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union interval_tree_span_iter__bindgen_ty_2 {
    pub last_hole: core::ffi::c_ulong,
    pub last_used: core::ffi::c_ulong,
}
impl Default for interval_tree_span_iter__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for interval_tree_span_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn interval_tree_span_iter_first(
        state: *mut interval_tree_span_iter,
        itree: *mut rb_root_cached,
        first_index: core::ffi::c_ulong,
        last_index: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn interval_tree_span_iter_advance(
        iter: *mut interval_tree_span_iter,
        itree: *mut rb_root_cached,
        new_index: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn interval_tree_span_iter_next(state: *mut interval_tree_span_iter);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmu_notifier_subscriptions {
    _unused: [u8; 0],
}
pub const mmu_notifier_event_MMU_NOTIFY_UNMAP: mmu_notifier_event = 0;
pub const mmu_notifier_event_MMU_NOTIFY_CLEAR: mmu_notifier_event = 1;
pub const mmu_notifier_event_MMU_NOTIFY_PROTECTION_VMA: mmu_notifier_event = 2;
pub const mmu_notifier_event_MMU_NOTIFY_PROTECTION_PAGE: mmu_notifier_event = 3;
pub const mmu_notifier_event_MMU_NOTIFY_SOFT_DIRTY: mmu_notifier_event = 4;
pub const mmu_notifier_event_MMU_NOTIFY_RELEASE: mmu_notifier_event = 5;
pub const mmu_notifier_event_MMU_NOTIFY_MIGRATE: mmu_notifier_event = 6;
pub const mmu_notifier_event_MMU_NOTIFY_EXCLUSIVE: mmu_notifier_event = 7;
pub type mmu_notifier_event = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mmu_notifier_ops {
    pub release: ::core::option::Option<
        unsafe extern "C" fn(subscription: *mut mmu_notifier, mm: *mut mm_struct),
    >,
    pub clear_flush_young: ::core::option::Option<
        unsafe extern "C" fn(
            subscription: *mut mmu_notifier,
            mm: *mut mm_struct,
            start: core::ffi::c_ulong,
            end: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub clear_young: ::core::option::Option<
        unsafe extern "C" fn(
            subscription: *mut mmu_notifier,
            mm: *mut mm_struct,
            start: core::ffi::c_ulong,
            end: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub test_young: ::core::option::Option<
        unsafe extern "C" fn(
            subscription: *mut mmu_notifier,
            mm: *mut mm_struct,
            address: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub change_pte: ::core::option::Option<
        unsafe extern "C" fn(
            subscription: *mut mmu_notifier,
            mm: *mut mm_struct,
            address: core::ffi::c_ulong,
            pte: pte_t,
        ),
    >,
    pub invalidate_range_start: ::core::option::Option<
        unsafe extern "C" fn(
            subscription: *mut mmu_notifier,
            range: *const mmu_notifier_range,
        ) -> core::ffi::c_int,
    >,
    pub invalidate_range_end: ::core::option::Option<
        unsafe extern "C" fn(subscription: *mut mmu_notifier, range: *const mmu_notifier_range),
    >,
    pub arch_invalidate_secondary_tlbs: ::core::option::Option<
        unsafe extern "C" fn(
            subscription: *mut mmu_notifier,
            mm: *mut mm_struct,
            start: core::ffi::c_ulong,
            end: core::ffi::c_ulong,
        ),
    >,
    pub alloc_notifier:
        ::core::option::Option<unsafe extern "C" fn(mm: *mut mm_struct) -> *mut mmu_notifier>,
    pub free_notifier:
        ::core::option::Option<unsafe extern "C" fn(subscription: *mut mmu_notifier)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmu_notifier {
    pub hlist: hlist_node,
    pub ops: *const mmu_notifier_ops,
    pub mm: *mut mm_struct,
    pub rcu: callback_head,
    pub users: core::ffi::c_uint,
}
impl Default for mmu_notifier {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mmu_interval_notifier_ops {
    pub invalidate: ::core::option::Option<
        unsafe extern "C" fn(
            interval_sub: *mut mmu_interval_notifier,
            range: *const mmu_notifier_range,
            cur_seq: core::ffi::c_ulong,
        ) -> bool_,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmu_interval_notifier {
    pub interval_tree: interval_tree_node,
    pub ops: *const mmu_interval_notifier_ops,
    pub mm: *mut mm_struct,
    pub deferred_item: hlist_node,
    pub invalidate_seq: core::ffi::c_ulong,
}
impl Default for mmu_interval_notifier {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmu_notifier_range {
    pub mm: *mut mm_struct,
    pub start: core::ffi::c_ulong,
    pub end: core::ffi::c_ulong,
    pub flags: core::ffi::c_uint,
    pub event: mmu_notifier_event,
    pub owner: *mut core::ffi::c_void,
}
impl Default for mmu_notifier_range {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn mmu_notifier_get_locked(
        ops: *const mmu_notifier_ops,
        mm: *mut mm_struct,
    ) -> *mut mmu_notifier;
}
extern "C" {
    pub fn mmu_notifier_put(subscription: *mut mmu_notifier);
}
extern "C" {
    pub fn mmu_notifier_synchronize();
}
extern "C" {
    pub fn mmu_notifier_register(
        subscription: *mut mmu_notifier,
        mm: *mut mm_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __mmu_notifier_register(
        subscription: *mut mmu_notifier,
        mm: *mut mm_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mmu_notifier_unregister(subscription: *mut mmu_notifier, mm: *mut mm_struct);
}
extern "C" {
    pub fn mmu_interval_read_begin(interval_sub: *mut mmu_interval_notifier) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn mmu_interval_notifier_insert(
        interval_sub: *mut mmu_interval_notifier,
        mm: *mut mm_struct,
        start: core::ffi::c_ulong,
        length: core::ffi::c_ulong,
        ops: *const mmu_interval_notifier_ops,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mmu_interval_notifier_insert_locked(
        interval_sub: *mut mmu_interval_notifier,
        mm: *mut mm_struct,
        start: core::ffi::c_ulong,
        length: core::ffi::c_ulong,
        ops: *const mmu_interval_notifier_ops,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mmu_interval_notifier_remove(interval_sub: *mut mmu_interval_notifier);
}
extern "C" {
    pub fn __mmu_notifier_subscriptions_destroy(mm: *mut mm_struct);
}
extern "C" {
    pub fn __mmu_notifier_release(mm: *mut mm_struct);
}
extern "C" {
    pub fn __mmu_notifier_clear_flush_young(
        mm: *mut mm_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __mmu_notifier_clear_young(
        mm: *mut mm_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __mmu_notifier_test_young(
        mm: *mut mm_struct,
        address: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __mmu_notifier_change_pte(mm: *mut mm_struct, address: core::ffi::c_ulong, pte: pte_t);
}
extern "C" {
    pub fn __mmu_notifier_invalidate_range_start(r: *mut mmu_notifier_range) -> core::ffi::c_int;
}
extern "C" {
    pub fn __mmu_notifier_invalidate_range_end(r: *mut mmu_notifier_range);
}
extern "C" {
    pub fn __mmu_notifier_arch_invalidate_secondary_tlbs(
        mm: *mut mm_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn mmu_notifier_range_update_to_read_only(range: *const mmu_notifier_range) -> bool_;
}
extern "C" {
    pub fn pti_init();
}
extern "C" {
    pub fn pti_check_boottime_disable();
}
extern "C" {
    pub fn pti_finalize();
}
extern "C" {
    pub static mut init_pkru_value: u32_;
}
extern "C" {
    pub fn kernel_fpu_begin_mask(kfpu_mask: core::ffi::c_uint);
}
extern "C" {
    pub fn kernel_fpu_end();
}
extern "C" {
    pub fn irq_fpu_usable() -> bool_;
}
extern "C" {
    pub fn fpregs_mark_activate();
}
extern "C" {
    pub fn fpregs_lock_and_load();
}
extern "C" {
    pub fn fpregs_assert_state_consistent();
}
extern "C" {
    pub fn switch_fpu_return();
}
extern "C" {
    pub fn cpu_has_xfeatures(
        xfeatures_mask: u64_,
        feature_name: *mut *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fpu__exception_code(fpu: *mut fpu, trap_nr: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn fpu_sync_fpstate(fpu: *mut fpu);
}
extern "C" {
    pub fn fpu_reset_from_exception_fixup();
}
extern "C" {
    pub fn fpu__init_cpu();
}
extern "C" {
    pub fn fpu__init_system();
}
extern "C" {
    pub fn fpu__init_check_bugs();
}
extern "C" {
    pub fn fpu__resume_cpu();
}
extern "C" {
    pub static mut fpu_fpregs_owner_ctx: *mut fpu;
}
extern "C" {
    pub fn fpstate_free(fpu: *mut fpu);
}
extern "C" {
    pub fn fpstate_clear_xstate_component(fps: *mut fpstate, xfeature: core::ffi::c_uint);
}
extern "C" {
    pub fn xstate_get_guest_group_perm() -> u64_;
}
extern "C" {
    pub fn fpu_alloc_guest_fpstate(gfpu: *mut fpu_guest) -> bool_;
}
extern "C" {
    pub fn fpu_free_guest_fpstate(gfpu: *mut fpu_guest);
}
extern "C" {
    pub fn fpu_swap_kvm_fpstate(gfpu: *mut fpu_guest, enter_guest: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn fpu_enable_guest_xfd_features(
        guest_fpu: *mut fpu_guest,
        xfeatures: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fpu_update_guest_xfd(guest_fpu: *mut fpu_guest, xfd: u64_);
}
extern "C" {
    pub fn fpu_sync_guest_vmexit_xfd_state();
}
extern "C" {
    pub fn fpu_copy_guest_fpstate_to_uabi(
        gfpu: *mut fpu_guest,
        buf: *mut core::ffi::c_void,
        size: core::ffi::c_uint,
        xfeatures: u64_,
        pkru: u32_,
    );
}
extern "C" {
    pub fn fpu_copy_uabi_to_guest_fpstate(
        gfpu: *mut fpu_guest,
        buf: *const core::ffi::c_void,
        xcr0: u64_,
        vpkru: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fpu_xstate_prctl(
        option: core::ffi::c_int,
        arg2: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn fpu_idle_fpregs();
}
pub const cc_vendor_CC_VENDOR_NONE: cc_vendor = 0;
pub const cc_vendor_CC_VENDOR_AMD: cc_vendor = 1;
pub const cc_vendor_CC_VENDOR_INTEL: cc_vendor = 2;
pub type cc_vendor = core::ffi::c_uint;
extern "C" {
    pub static mut cc_vendor: cc_vendor;
}
extern "C" {
    pub static mut cc_mask: u64_;
}
extern "C" {
    pub fn cc_mkenc(val: u64_) -> u64_;
}
extern "C" {
    pub fn cc_mkdec(val: u64_) -> u64_;
}
extern "C" {
    pub fn cc_random_init();
}
extern "C" {
    pub static mut early_top_pgt: [pgd_t; 512usize];
}
extern "C" {
    pub fn __early_make_pgtable(address: core::ffi::c_ulong, pmd: pmdval_t) -> bool_;
}
extern "C" {
    pub fn ptdump_walk_pgd_level(m: *mut seq_file, mm: *mut mm_struct);
}
extern "C" {
    pub fn ptdump_walk_pgd_level_debugfs(m: *mut seq_file, mm: *mut mm_struct, user: bool_);
}
extern "C" {
    pub fn ptdump_walk_pgd_level_checkwx();
}
extern "C" {
    pub fn ptdump_walk_user_pgd_level_checkwx();
}
extern "C" {
    pub static mut empty_zero_page: [core::ffi::c_ulong; 512usize];
}
extern "C" {
    pub static mut pgd_lock: spinlock_t;
}
extern "C" {
    pub static mut pgd_list: list_head;
}
extern "C" {
    pub fn pgd_page_get_mm(page: *mut page) -> *mut mm_struct;
}
extern "C" {
    pub static mut early_pmd_flags: pmdval_t;
}
extern "C" {
    pub fn pte_mkwrite(pte: pte_t, vma: *mut vm_area_struct) -> pte_t;
}
extern "C" {
    pub fn pmd_mkwrite(pmd: pmd_t, vma: *mut vm_area_struct) -> pmd_t;
}
extern "C" {
    pub fn populate_extra_pmd(vaddr: core::ffi::c_ulong) -> *mut pmd_t;
}
extern "C" {
    pub fn populate_extra_pte(vaddr: core::ffi::c_ulong) -> *mut pte_t;
}
extern "C" {
    pub fn __pti_set_user_pgtbl(pgdp: *mut pgd_t, pgd: pgd_t) -> pgd_t;
}
pub const vsyscall_num___NR_vgettimeofday: vsyscall_num = 0;
pub const vsyscall_num___NR_vtime: vsyscall_num = 1;
pub const vsyscall_num___NR_vgetcpu: vsyscall_num = 2;
pub type vsyscall_num = core::ffi::c_uint;
pub const fixed_addresses_VSYSCALL_PAGE: fixed_addresses = 511;
pub const fixed_addresses_FIX_DBGP_BASE: fixed_addresses = 512;
pub const fixed_addresses_FIX_EARLYCON_MEM_BASE: fixed_addresses = 513;
pub const fixed_addresses_FIX_APIC_BASE: fixed_addresses = 514;
pub const fixed_addresses_FIX_IO_APIC_BASE_0: fixed_addresses = 515;
pub const fixed_addresses_FIX_IO_APIC_BASE_END: fixed_addresses = 642;
pub const fixed_addresses_FIX_PARAVIRT_BOOTMAP: fixed_addresses = 643;
pub const fixed_addresses_FIX_APEI_GHES_IRQ: fixed_addresses = 644;
pub const fixed_addresses_FIX_APEI_GHES_NMI: fixed_addresses = 645;
pub const fixed_addresses___end_of_permanent_fixed_addresses: fixed_addresses = 646;
pub const fixed_addresses_FIX_BTMAP_END: fixed_addresses = 1024;
pub const fixed_addresses_FIX_BTMAP_BEGIN: fixed_addresses = 1535;
pub const fixed_addresses_FIX_TBOOT_BASE: fixed_addresses = 1536;
pub const fixed_addresses___end_of_fixed_addresses: fixed_addresses = 1537;
pub type fixed_addresses = core::ffi::c_uint;
extern "C" {
    pub fn reserve_top_address(reserve: core::ffi::c_ulong);
}
extern "C" {
    pub static mut fixmaps_set: core::ffi::c_int;
}
extern "C" {
    pub static mut pkmap_page_table: *mut pte_t;
}
extern "C" {
    pub fn __native_set_fixmap(idx: fixed_addresses, pte: pte_t);
}
extern "C" {
    pub fn native_set_fixmap(idx: core::ffi::c_uint, phys: phys_addr_t, flags: pgprot_t);
}
extern "C" {
    pub fn early_memremap_encrypted(
        phys_addr: resource_size_t,
        size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn early_memremap_encrypted_wp(
        phys_addr: resource_size_t,
        size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn early_memremap_decrypted(
        phys_addr: resource_size_t,
        size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn early_memremap_decrypted_wp(
        phys_addr: resource_size_t,
        size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __early_set_fixmap(idx: fixed_addresses, phys: phys_addr_t, flags: pgprot_t);
}
extern "C" {
    pub static mut level4_kernel_pgt: [p4d_t; 512usize];
}
extern "C" {
    pub static mut level4_ident_pgt: [p4d_t; 512usize];
}
extern "C" {
    pub static mut level3_kernel_pgt: [pud_t; 512usize];
}
extern "C" {
    pub static mut level3_ident_pgt: [pud_t; 512usize];
}
extern "C" {
    pub static mut level2_kernel_pgt: [pmd_t; 512usize];
}
extern "C" {
    pub static mut level2_fixmap_pgt: [pmd_t; 512usize];
}
extern "C" {
    pub static mut level2_ident_pgt: [pmd_t; 512usize];
}
extern "C" {
    pub static mut level1_fixmap_pgt: [pte_t; 1024usize];
}
extern "C" {
    pub static mut init_top_pgt: [pgd_t; 0usize];
}
extern "C" {
    pub fn paging_init();
}
extern "C" {
    pub fn set_pte_vaddr_p4d(p4d_page: *mut p4d_t, vaddr: core::ffi::c_ulong, new_pte: pte_t);
}
extern "C" {
    pub fn set_pte_vaddr_pud(pud_page: *mut pud_t, vaddr: core::ffi::c_ulong, new_pte: pte_t);
}
extern "C" {
    pub fn cleanup_highmap();
}
extern "C" {
    pub fn init_extra_mapping_uc(phys: core::ffi::c_ulong, size: core::ffi::c_ulong);
}
extern "C" {
    pub fn init_extra_mapping_wb(phys: core::ffi::c_ulong, size: core::ffi::c_ulong);
}
extern "C" {
    pub static mut direct_gbpages: core::ffi::c_int;
}
extern "C" {
    pub fn init_mem_mapping();
}
extern "C" {
    pub fn early_alloc_pgt_buf();
}
extern "C" {
    pub fn memblock_find_dma_reserve();
}
extern "C" {
    pub fn init_memory_mapping(
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        prot: pgprot_t,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub static mut trampoline_pgd_entry: pgd_t;
}
extern "C" {
    pub fn ptep_set_access_flags(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        ptep: *mut pte_t,
        entry: pte_t,
        dirty: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ptep_test_and_clear_young(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        ptep: *mut pte_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ptep_clear_flush_young(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        ptep: *mut pte_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pmdp_set_access_flags(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        pmdp: *mut pmd_t,
        entry: pmd_t,
        dirty: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pudp_set_access_flags(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        pudp: *mut pud_t,
        entry: pud_t,
        dirty: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pmdp_test_and_clear_young(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pmdp: *mut pmd_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pudp_test_and_clear_young(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pudp: *mut pud_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pmdp_clear_flush_young(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        pmdp: *mut pmd_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pmdp_invalidate_ad(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        pmdp: *mut pmd_t,
    ) -> pmd_t;
}
extern "C" {
    pub fn pfn_modify_allowed(pfn: core::ffi::c_ulong, prot: pgprot_t) -> bool_;
}
extern "C" {
    pub fn arch_check_zapped_pte(vma: *mut vm_area_struct, pte: pte_t);
}
extern "C" {
    pub fn arch_check_zapped_pmd(vma: *mut vm_area_struct, pmd: pmd_t);
}
extern "C" {
    pub fn arch_memory_failure(
        pfn: core::ffi::c_ulong,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_is_platform_page(paddr: u64_) -> bool_;
}
extern "C" {
    pub static mut tlbstate_untag_mask: core::ffi::c_ulonglong;
}
extern "C" {
    pub fn __flush_tlb_all();
}
extern "C" {
    pub fn cr4_update_irqsoff(set: core::ffi::c_ulong, clear: core::ffi::c_ulong);
}
extern "C" {
    pub fn cr4_read_shadow() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn rep_movs_alternative(
        to: *mut core::ffi::c_void,
        from: *const core::ffi::c_void,
        len: core::ffi::c_uint,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __copy_user_nocache(
        dst: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        size: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn __copy_user_flushcache(
        dst: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        size: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn rep_stos_alternative(
        addr: *mut core::ffi::c_void,
        len: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __get_user_1() -> core::ffi::c_int;
}
extern "C" {
    pub fn __get_user_2() -> core::ffi::c_int;
}
extern "C" {
    pub fn __get_user_4() -> core::ffi::c_int;
}
extern "C" {
    pub fn __get_user_8() -> core::ffi::c_int;
}
extern "C" {
    pub fn __get_user_nocheck_1() -> core::ffi::c_int;
}
extern "C" {
    pub fn __get_user_nocheck_2() -> core::ffi::c_int;
}
extern "C" {
    pub fn __get_user_nocheck_4() -> core::ffi::c_int;
}
extern "C" {
    pub fn __get_user_nocheck_8() -> core::ffi::c_int;
}
extern "C" {
    pub fn __get_user_bad() -> core::ffi::c_int;
}
extern "C" {
    pub fn __put_user_bad();
}
extern "C" {
    pub fn __put_user_1();
}
extern "C" {
    pub fn __put_user_2();
}
extern "C" {
    pub fn __put_user_4();
}
extern "C" {
    pub fn __put_user_8();
}
extern "C" {
    pub fn __put_user_nocheck_1();
}
extern "C" {
    pub fn __put_user_nocheck_2();
}
extern "C" {
    pub fn __put_user_nocheck_4();
}
extern "C" {
    pub fn __put_user_nocheck_8();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __large_struct {
    pub buf: [core::ffi::c_ulong; 100usize],
}
impl Default for __large_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn copy_from_user_nmi(
        to: *mut core::ffi::c_void,
        from: *const core::ffi::c_void,
        n: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn strncpy_from_user(
        dst: *mut core::ffi::c_char,
        src: *const core::ffi::c_char,
        count: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn strnlen_user(str_: *const core::ffi::c_char, n: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn copy_mc_to_kernel(
        to: *mut core::ffi::c_void,
        from: *const core::ffi::c_void,
        len: core::ffi::c_uint,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn copy_mc_to_user(
        to: *mut core::ffi::c_void,
        from: *const core::ffi::c_void,
        len: core::ffi::c_uint,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __try_cmpxchg_user_wrong_size();
}
extern "C" {
    pub fn _copy_from_user(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _copy_to_user(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn check_zeroed_user(from: *const core::ffi::c_void, size: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn copy_from_kernel_nofault_allowed(
        unsafe_src: *const core::ffi::c_void,
        size: usize,
    ) -> bool_;
}
extern "C" {
    pub fn copy_to_kernel_nofault(
        dst: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn copy_from_user_nofault(
        dst: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn copy_to_user_nofault(
        dst: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn strncpy_from_kernel_nofault(
        dst: *mut core::ffi::c_char,
        unsafe_addr: *const core::ffi::c_void,
        count: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn strncpy_from_user_nofault(
        dst: *mut core::ffi::c_char,
        unsafe_addr: *const core::ffi::c_void,
        count: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn strnlen_user_nofault(
        unsafe_addr: *const core::ffi::c_void,
        count: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn usercopy_abort(
        name: *const core::ffi::c_char,
        detail: *const core::ffi::c_char,
        to_user: bool_,
        offset: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
    ) -> !;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct css_set {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_clone_args {
    pub flags: u64_,
    pub pidfd: *mut core::ffi::c_int,
    pub child_tid: *mut core::ffi::c_int,
    pub parent_tid: *mut core::ffi::c_int,
    pub name: *const core::ffi::c_char,
    pub exit_signal: core::ffi::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub stack: core::ffi::c_ulong,
    pub stack_size: core::ffi::c_ulong,
    pub tls: core::ffi::c_ulong,
    pub set_tid: *mut pid_t,
    pub set_tid_size: usize,
    pub cgroup: core::ffi::c_int,
    pub idle: core::ffi::c_int,
    pub fn_: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub fn_arg: *mut core::ffi::c_void,
    pub cgrp: *mut cgroup,
    pub cset: *mut css_set,
}
impl Default for kernel_clone_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl kernel_clone_args {
    #[inline]
    pub fn kthread(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_kthread(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn io_thread(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_io_thread(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn user_worker(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_user_worker(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_files(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_files(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        kthread: u32_,
        io_thread: u32_,
        user_worker: u32_,
        no_files: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let kthread: u32 = unsafe { ::core::mem::transmute(kthread) };
            kthread as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let io_thread: u32 = unsafe { ::core::mem::transmute(io_thread) };
            io_thread as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let user_worker: u32 = unsafe { ::core::mem::transmute(user_worker) };
            user_worker as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let no_files: u32 = unsafe { ::core::mem::transmute(no_files) };
            no_files as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static mut tasklist_lock: rwlock_t;
}
extern "C" {
    pub static mut mmlist_lock: spinlock_t;
}
extern "C" {
    pub static mut init_thread_union: thread_union;
}
extern "C" {
    pub static mut init_task: task_struct;
}
extern "C" {
    pub fn lockdep_tasklist_lock_is_held() -> core::ffi::c_int;
}
extern "C" {
    pub fn schedule_tail(prev: *mut task_struct);
}
extern "C" {
    pub fn init_idle(idle: *mut task_struct, cpu: core::ffi::c_int);
}
extern "C" {
    pub fn sched_fork(clone_flags: core::ffi::c_ulong, p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn sched_cgroup_fork(p: *mut task_struct, kargs: *mut kernel_clone_args);
}
extern "C" {
    pub fn sched_post_fork(p: *mut task_struct);
}
extern "C" {
    pub fn sched_dead(p: *mut task_struct);
}
extern "C" {
    pub fn do_task_dead() -> !;
}
extern "C" {
    pub fn make_task_dead(signr: core::ffi::c_int) -> !;
}
extern "C" {
    pub fn mm_cache_init();
}
extern "C" {
    pub fn proc_caches_init();
}
extern "C" {
    pub fn fork_init();
}
extern "C" {
    pub fn release_task(p: *mut task_struct);
}
extern "C" {
    pub fn copy_thread(arg1: *mut task_struct, arg2: *const kernel_clone_args) -> core::ffi::c_int;
}
extern "C" {
    pub fn flush_thread();
}
extern "C" {
    pub fn exit_thread(tsk: *mut task_struct);
}
extern "C" {
    pub fn do_group_exit(arg1: core::ffi::c_int) -> !;
}
extern "C" {
    pub fn exit_files(arg1: *mut task_struct);
}
extern "C" {
    pub fn exit_itimers(arg1: *mut task_struct);
}
extern "C" {
    pub fn kernel_clone(kargs: *mut kernel_clone_args) -> pid_t;
}
extern "C" {
    pub fn copy_process(
        pid: *mut pid,
        trace: core::ffi::c_int,
        node: core::ffi::c_int,
        args: *mut kernel_clone_args,
    ) -> *mut task_struct;
}
extern "C" {
    pub fn create_io_thread(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> core::ffi::c_int,
        >,
        arg: *mut core::ffi::c_void,
        node: core::ffi::c_int,
    ) -> *mut task_struct;
}
extern "C" {
    pub fn fork_idle(arg1: core::ffi::c_int) -> *mut task_struct;
}
extern "C" {
    pub fn kernel_thread(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> core::ffi::c_int,
        >,
        arg: *mut core::ffi::c_void,
        name: *const core::ffi::c_char,
        flags: core::ffi::c_ulong,
    ) -> pid_t;
}
extern "C" {
    pub fn user_mode_thread(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> core::ffi::c_int,
        >,
        arg: *mut core::ffi::c_void,
        flags: core::ffi::c_ulong,
    ) -> pid_t;
}
extern "C" {
    pub fn kernel_wait4(
        arg1: pid_t,
        arg2: *mut core::ffi::c_int,
        arg3: core::ffi::c_int,
        arg4: *mut rusage,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn kernel_wait(pid: pid_t, stat: *mut core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn free_task(tsk: *mut task_struct);
}
extern "C" {
    pub fn sched_exec();
}
extern "C" {
    pub fn __put_task_struct(t: *mut task_struct);
}
extern "C" {
    pub fn __put_task_struct_rcu_cb(rhp: *mut callback_head);
}
extern "C" {
    pub fn put_task_struct_rcu_user(task: *mut task_struct);
}
extern "C" {
    pub fn release_thread(dead_task: *mut task_struct);
}
extern "C" {
    pub static mut arch_task_struct_size: core::ffi::c_int;
}
pub type class_task_lock_t = *mut task_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct assoc_array {
    pub root: *mut assoc_array_ptr,
    pub nr_leaves_on_tree: core::ffi::c_ulong,
}
impl Default for assoc_array {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct assoc_array_ops {
    pub get_key_chunk: ::core::option::Option<
        unsafe extern "C" fn(
            index_key: *const core::ffi::c_void,
            level: core::ffi::c_int,
        ) -> core::ffi::c_ulong,
    >,
    pub get_object_key_chunk: ::core::option::Option<
        unsafe extern "C" fn(
            object: *const core::ffi::c_void,
            level: core::ffi::c_int,
        ) -> core::ffi::c_ulong,
    >,
    pub compare_object: ::core::option::Option<
        unsafe extern "C" fn(
            object: *const core::ffi::c_void,
            index_key: *const core::ffi::c_void,
        ) -> bool_,
    >,
    pub diff_objects: ::core::option::Option<
        unsafe extern "C" fn(
            object: *const core::ffi::c_void,
            index_key: *const core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub free_object: ::core::option::Option<unsafe extern "C" fn(object: *mut core::ffi::c_void)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct assoc_array_edit {
    _unused: [u8; 0],
}
extern "C" {
    pub fn assoc_array_iterate(
        array: *const assoc_array,
        iterator: ::core::option::Option<
            unsafe extern "C" fn(
                object: *const core::ffi::c_void,
                iterator_data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        iterator_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn assoc_array_find(
        array: *const assoc_array,
        ops: *const assoc_array_ops,
        index_key: *const core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn assoc_array_destroy(array: *mut assoc_array, ops: *const assoc_array_ops);
}
extern "C" {
    pub fn assoc_array_insert(
        array: *mut assoc_array,
        ops: *const assoc_array_ops,
        index_key: *const core::ffi::c_void,
        object: *mut core::ffi::c_void,
    ) -> *mut assoc_array_edit;
}
extern "C" {
    pub fn assoc_array_insert_set_object(
        edit: *mut assoc_array_edit,
        object: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn assoc_array_delete(
        array: *mut assoc_array,
        ops: *const assoc_array_ops,
        index_key: *const core::ffi::c_void,
    ) -> *mut assoc_array_edit;
}
extern "C" {
    pub fn assoc_array_clear(
        array: *mut assoc_array,
        ops: *const assoc_array_ops,
    ) -> *mut assoc_array_edit;
}
extern "C" {
    pub fn assoc_array_apply_edit(edit: *mut assoc_array_edit);
}
extern "C" {
    pub fn assoc_array_cancel_edit(edit: *mut assoc_array_edit);
}
extern "C" {
    pub fn assoc_array_gc(
        array: *mut assoc_array,
        ops: *const assoc_array_ops,
        iterator: ::core::option::Option<
            unsafe extern "C" fn(
                object: *mut core::ffi::c_void,
                iterator_data: *mut core::ffi::c_void,
            ) -> bool_,
        >,
        iterator_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
pub type key_serial_t = i32;
pub type key_perm_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net {
    _unused: [u8; 0],
}
pub const key_need_perm_KEY_NEED_UNSPECIFIED: key_need_perm = 0;
pub const key_need_perm_KEY_NEED_VIEW: key_need_perm = 1;
pub const key_need_perm_KEY_NEED_READ: key_need_perm = 2;
pub const key_need_perm_KEY_NEED_WRITE: key_need_perm = 3;
pub const key_need_perm_KEY_NEED_SEARCH: key_need_perm = 4;
pub const key_need_perm_KEY_NEED_LINK: key_need_perm = 5;
pub const key_need_perm_KEY_NEED_SETATTR: key_need_perm = 6;
pub const key_need_perm_KEY_NEED_UNLINK: key_need_perm = 7;
pub const key_need_perm_KEY_SYSADMIN_OVERRIDE: key_need_perm = 8;
pub const key_need_perm_KEY_AUTHTOKEN_OVERRIDE: key_need_perm = 9;
pub const key_need_perm_KEY_DEFER_PERM_CHECK: key_need_perm = 10;
pub type key_need_perm = core::ffi::c_uint;
pub const key_lookup_flag_KEY_LOOKUP_CREATE: key_lookup_flag = 1;
pub const key_lookup_flag_KEY_LOOKUP_PARTIAL: key_lookup_flag = 2;
pub const key_lookup_flag_KEY_LOOKUP_ALL: key_lookup_flag = 3;
pub type key_lookup_flag = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_owner {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct keyring_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct keyring_name {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_tag {
    pub rcu: callback_head,
    pub usage: refcount_t,
    pub removed: bool_,
}
impl Default for key_tag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct keyring_index_key {
    pub hash: core::ffi::c_ulong,
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *const core::ffi::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union keyring_index_key__bindgen_ty_1 {
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1__bindgen_ty_1,
    pub x: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct keyring_index_key__bindgen_ty_1__bindgen_ty_1 {
    pub desc_len: u16_,
    pub desc: [core::ffi::c_char; 6usize],
}
impl Default for keyring_index_key__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for keyring_index_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key_payload {
    pub rcu_data0: *mut core::ffi::c_void,
    pub data: [*mut core::ffi::c_void; 4usize],
}
impl Default for key_payload {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __key_reference_with_attributes {
    _unused: [u8; 0],
}
pub type key_ref_t = *mut __key_reference_with_attributes;
pub type key_restrict_link_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        dest_keyring: *mut key,
        type_: *const key_type,
        payload: *const key_payload,
        restriction_key: *mut key,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_restriction {
    pub check: key_restrict_link_func_t,
    pub key: *mut key,
    pub keytype: *mut key_type,
}
impl Default for key_restriction {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const key_state_KEY_IS_UNINSTANTIATED: key_state = 0;
pub const key_state_KEY_IS_POSITIVE: key_state = 1;
pub type key_state = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key {
    pub usage: refcount_t,
    pub serial: key_serial_t,
    pub __bindgen_anon_1: key__bindgen_ty_1,
    pub watchers: *mut watch_list,
    pub sem: rw_semaphore,
    pub user: *mut key_user,
    pub security: *mut core::ffi::c_void,
    pub __bindgen_anon_2: key__bindgen_ty_2,
    pub last_used_at: time64_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub perm: key_perm_t,
    pub quotalen: core::ffi::c_ushort,
    pub datalen: core::ffi::c_ushort,
    pub state: core::ffi::c_short,
    pub flags: core::ffi::c_ulong,
    pub __bindgen_anon_3: key__bindgen_ty_3,
    pub __bindgen_anon_4: key__bindgen_ty_4,
    pub restrict_link: *mut key_restriction,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_1 {
    pub graveyard_link: list_head,
    pub serial_node: rb_node,
}
impl Default for key__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_2 {
    pub expiry: time64_t,
    pub revoked_at: time64_t,
}
impl Default for key__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_3 {
    pub index_key: keyring_index_key,
    pub __bindgen_anon_1: key__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key__bindgen_ty_3__bindgen_ty_1 {
    pub hash: core::ffi::c_ulong,
    pub len_desc: core::ffi::c_ulong,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *mut core::ffi::c_char,
}
impl Default for key__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for key__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_4 {
    pub payload: key_payload,
    pub __bindgen_anon_1: key__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key__bindgen_ty_4__bindgen_ty_1 {
    pub name_link: list_head,
    pub keys: assoc_array,
}
impl Default for key__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for key__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn key_alloc(
        type_: *mut key_type,
        desc: *const core::ffi::c_char,
        uid: kuid_t,
        gid: kgid_t,
        cred: *const cred,
        perm: key_perm_t,
        flags: core::ffi::c_ulong,
        restrict_link: *mut key_restriction,
    ) -> *mut key;
}
extern "C" {
    pub fn key_revoke(key: *mut key);
}
extern "C" {
    pub fn key_invalidate(key: *mut key);
}
extern "C" {
    pub fn key_put(key: *mut key);
}
extern "C" {
    pub fn key_put_tag(tag: *mut key_tag) -> bool_;
}
extern "C" {
    pub fn key_remove_domain(domain_tag: *mut key_tag);
}
extern "C" {
    pub fn request_key_tag(
        type_: *mut key_type,
        description: *const core::ffi::c_char,
        domain_tag: *mut key_tag,
        callout_info: *const core::ffi::c_char,
    ) -> *mut key;
}
extern "C" {
    pub fn request_key_rcu(
        type_: *mut key_type,
        description: *const core::ffi::c_char,
        domain_tag: *mut key_tag,
    ) -> *mut key;
}
extern "C" {
    pub fn request_key_with_auxdata(
        type_: *mut key_type,
        description: *const core::ffi::c_char,
        domain_tag: *mut key_tag,
        callout_info: *const core::ffi::c_void,
        callout_len: usize,
        aux: *mut core::ffi::c_void,
    ) -> *mut key;
}
extern "C" {
    pub fn wait_for_key_construction(key: *mut key, intr: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn key_validate(key: *const key) -> core::ffi::c_int;
}
extern "C" {
    pub fn key_create(
        keyring: key_ref_t,
        type_: *const core::ffi::c_char,
        description: *const core::ffi::c_char,
        payload: *const core::ffi::c_void,
        plen: usize,
        perm: key_perm_t,
        flags: core::ffi::c_ulong,
    ) -> key_ref_t;
}
extern "C" {
    pub fn key_create_or_update(
        keyring: key_ref_t,
        type_: *const core::ffi::c_char,
        description: *const core::ffi::c_char,
        payload: *const core::ffi::c_void,
        plen: usize,
        perm: key_perm_t,
        flags: core::ffi::c_ulong,
    ) -> key_ref_t;
}
extern "C" {
    pub fn key_update(
        key: key_ref_t,
        payload: *const core::ffi::c_void,
        plen: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn key_link(keyring: *mut key, key: *mut key) -> core::ffi::c_int;
}
extern "C" {
    pub fn key_move(
        key: *mut key,
        from_keyring: *mut key,
        to_keyring: *mut key,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn key_unlink(keyring: *mut key, key: *mut key) -> core::ffi::c_int;
}
extern "C" {
    pub fn keyring_alloc(
        description: *const core::ffi::c_char,
        uid: kuid_t,
        gid: kgid_t,
        cred: *const cred,
        perm: key_perm_t,
        flags: core::ffi::c_ulong,
        restrict_link: *mut key_restriction,
        dest: *mut key,
    ) -> *mut key;
}
extern "C" {
    pub fn restrict_link_reject(
        keyring: *mut key,
        type_: *const key_type,
        payload: *const key_payload,
        restriction_key: *mut key,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn keyring_clear(keyring: *mut key) -> core::ffi::c_int;
}
extern "C" {
    pub fn keyring_search(
        keyring: key_ref_t,
        type_: *mut key_type,
        description: *const core::ffi::c_char,
        recurse: bool_,
    ) -> key_ref_t;
}
extern "C" {
    pub fn keyring_add_key(keyring: *mut key, key: *mut key) -> core::ffi::c_int;
}
extern "C" {
    pub fn keyring_restrict(
        keyring: key_ref_t,
        type_: *const core::ffi::c_char,
        restriction: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn key_lookup(id: key_serial_t) -> *mut key;
}
extern "C" {
    pub fn key_set_timeout(arg1: *mut key, arg2: core::ffi::c_uint);
}
extern "C" {
    pub fn lookup_user_key(
        id: key_serial_t,
        flags: core::ffi::c_ulong,
        need_perm: key_need_perm,
    ) -> key_ref_t;
}
extern "C" {
    pub fn key_free_user_ns(arg1: *mut user_namespace);
}
extern "C" {
    pub fn install_thread_keyring_to_cred(cred: *mut cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn key_fsuid_changed(new_cred: *mut cred);
}
extern "C" {
    pub fn key_fsgid_changed(new_cred: *mut cred);
}
extern "C" {
    pub fn key_init();
}
extern "C" {
    pub static mut printk_ratelimit_state: ratelimit_state;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_struct {
    pub __count: refcount_t,
    pub epoll_watches: percpu_counter,
    pub unix_inflight: core::ffi::c_ulong,
    pub pipe_bufs: atomic_long_t,
    pub uidhash_node: hlist_node,
    pub uid: kuid_t,
    pub locked_vm: atomic_long_t,
    pub nr_watches: atomic_t,
    pub ratelimit: ratelimit_state,
}
impl Default for user_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn uids_sysfs_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn find_user(arg1: kuid_t) -> *mut user_struct;
}
extern "C" {
    pub static mut root_user: user_struct;
}
extern "C" {
    pub fn alloc_uid(arg1: kuid_t) -> *mut user_struct;
}
extern "C" {
    pub fn free_uid(arg1: *mut user_struct);
}
#[repr(C)]
#[derive(Default)]
pub struct group_info {
    pub usage: refcount_t,
    pub ngroups: core::ffi::c_int,
    pub gid: __IncompleteArrayField<kgid_t>,
}
extern "C" {
    pub fn groups_alloc(arg1: core::ffi::c_int) -> *mut group_info;
}
extern "C" {
    pub fn groups_free(arg1: *mut group_info);
}
extern "C" {
    pub fn in_group_p(arg1: kgid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn in_egroup_p(arg1: kgid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn groups_search(arg1: *const group_info, arg2: kgid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_current_groups(arg1: *mut group_info) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_groups(arg1: *mut cred, arg2: *mut group_info);
}
extern "C" {
    pub fn may_setgroups() -> bool_;
}
extern "C" {
    pub fn groups_sort(arg1: *mut group_info);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cred {
    pub usage: atomic_long_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub suid: kuid_t,
    pub sgid: kgid_t,
    pub euid: kuid_t,
    pub egid: kgid_t,
    pub fsuid: kuid_t,
    pub fsgid: kgid_t,
    pub securebits: core::ffi::c_uint,
    pub cap_inheritable: kernel_cap_t,
    pub cap_permitted: kernel_cap_t,
    pub cap_effective: kernel_cap_t,
    pub cap_bset: kernel_cap_t,
    pub cap_ambient: kernel_cap_t,
    pub jit_keyring: core::ffi::c_uchar,
    pub session_keyring: *mut key,
    pub process_keyring: *mut key,
    pub thread_keyring: *mut key,
    pub request_key_auth: *mut key,
    pub security: *mut core::ffi::c_void,
    pub user: *mut user_struct,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub group_info: *mut group_info,
    pub __bindgen_anon_1: cred__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cred__bindgen_ty_1 {
    pub non_rcu: core::ffi::c_int,
    pub rcu: callback_head,
}
impl Default for cred__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cred {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __put_cred(arg1: *mut cred);
}
extern "C" {
    pub fn exit_creds(arg1: *mut task_struct);
}
extern "C" {
    pub fn copy_creds(arg1: *mut task_struct, arg2: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_task_cred(arg1: *mut task_struct) -> *const cred;
}
extern "C" {
    pub fn cred_alloc_blank() -> *mut cred;
}
extern "C" {
    pub fn prepare_creds() -> *mut cred;
}
extern "C" {
    pub fn prepare_exec_creds() -> *mut cred;
}
extern "C" {
    pub fn commit_creds(arg1: *mut cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn abort_creds(arg1: *mut cred);
}
extern "C" {
    pub fn override_creds(arg1: *const cred) -> *const cred;
}
extern "C" {
    pub fn revert_creds(arg1: *const cred);
}
extern "C" {
    pub fn prepare_kernel_cred(arg1: *mut task_struct) -> *mut cred;
}
extern "C" {
    pub fn set_security_override(arg1: *mut cred, arg2: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_security_override_from_ctx(
        arg1: *mut cred,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_create_files_as(arg1: *mut cred, arg2: *mut inode) -> core::ffi::c_int;
}
extern "C" {
    pub fn cred_fscmp(arg1: *const cred, arg2: *const cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn cred_init();
}
extern "C" {
    pub fn set_cred_ucounts(arg1: *mut cred) -> core::ffi::c_int;
}
pub const hrtimer_mode_HRTIMER_MODE_ABS: hrtimer_mode = 0;
pub const hrtimer_mode_HRTIMER_MODE_REL: hrtimer_mode = 1;
pub const hrtimer_mode_HRTIMER_MODE_PINNED: hrtimer_mode = 2;
pub const hrtimer_mode_HRTIMER_MODE_SOFT: hrtimer_mode = 4;
pub const hrtimer_mode_HRTIMER_MODE_HARD: hrtimer_mode = 8;
pub const hrtimer_mode_HRTIMER_MODE_ABS_PINNED: hrtimer_mode = 2;
pub const hrtimer_mode_HRTIMER_MODE_REL_PINNED: hrtimer_mode = 3;
pub const hrtimer_mode_HRTIMER_MODE_ABS_SOFT: hrtimer_mode = 4;
pub const hrtimer_mode_HRTIMER_MODE_REL_SOFT: hrtimer_mode = 5;
pub const hrtimer_mode_HRTIMER_MODE_ABS_PINNED_SOFT: hrtimer_mode = 6;
pub const hrtimer_mode_HRTIMER_MODE_REL_PINNED_SOFT: hrtimer_mode = 7;
pub const hrtimer_mode_HRTIMER_MODE_ABS_HARD: hrtimer_mode = 8;
pub const hrtimer_mode_HRTIMER_MODE_REL_HARD: hrtimer_mode = 9;
pub const hrtimer_mode_HRTIMER_MODE_ABS_PINNED_HARD: hrtimer_mode = 10;
pub const hrtimer_mode_HRTIMER_MODE_REL_PINNED_HARD: hrtimer_mode = 11;
pub type hrtimer_mode = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hrtimer_sleeper {
    pub timer: hrtimer,
    pub task: *mut task_struct,
}
impl Default for hrtimer_sleeper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_clock_base {
    pub cpu_base: *mut hrtimer_cpu_base,
    pub index: core::ffi::c_uint,
    pub clockid: clockid_t,
    pub seq: seqcount_raw_spinlock_t,
    pub running: *mut hrtimer,
    pub active: timerqueue_head,
    pub get_time: ::core::option::Option<unsafe extern "C" fn() -> ktime_t>,
    pub offset: ktime_t,
}
impl Default for hrtimer_clock_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hrtimer_base_type_HRTIMER_BASE_MONOTONIC: hrtimer_base_type = 0;
pub const hrtimer_base_type_HRTIMER_BASE_REALTIME: hrtimer_base_type = 1;
pub const hrtimer_base_type_HRTIMER_BASE_BOOTTIME: hrtimer_base_type = 2;
pub const hrtimer_base_type_HRTIMER_BASE_TAI: hrtimer_base_type = 3;
pub const hrtimer_base_type_HRTIMER_BASE_MONOTONIC_SOFT: hrtimer_base_type = 4;
pub const hrtimer_base_type_HRTIMER_BASE_REALTIME_SOFT: hrtimer_base_type = 5;
pub const hrtimer_base_type_HRTIMER_BASE_BOOTTIME_SOFT: hrtimer_base_type = 6;
pub const hrtimer_base_type_HRTIMER_BASE_TAI_SOFT: hrtimer_base_type = 7;
pub const hrtimer_base_type_HRTIMER_MAX_CLOCK_BASES: hrtimer_base_type = 8;
pub type hrtimer_base_type = core::ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_cpu_base {
    pub lock: raw_spinlock_t,
    pub cpu: core::ffi::c_uint,
    pub active_bases: core::ffi::c_uint,
    pub clock_was_set_seq: core::ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub nr_events: core::ffi::c_uint,
    pub nr_retries: core::ffi::c_ushort,
    pub nr_hangs: core::ffi::c_ushort,
    pub max_hang_time: core::ffi::c_uint,
    pub expires_next: ktime_t,
    pub next_timer: *mut hrtimer,
    pub softirq_expires_next: ktime_t,
    pub softirq_next_timer: *mut hrtimer,
    pub clock_base: [hrtimer_clock_base; 8usize],
}
impl Default for hrtimer_cpu_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl hrtimer_cpu_base {
    #[inline]
    pub fn hres_active(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hres_active(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_hrtirq(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_hrtirq(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hang_detected(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hang_detected(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn softirq_activated(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_softirq_activated(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn online(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_online(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hres_active: core::ffi::c_uint,
        in_hrtirq: core::ffi::c_uint,
        hang_detected: core::ffi::c_uint,
        softirq_activated: core::ffi::c_uint,
        online: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hres_active: u32 = unsafe { ::core::mem::transmute(hres_active) };
            hres_active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_hrtirq: u32 = unsafe { ::core::mem::transmute(in_hrtirq) };
            in_hrtirq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hang_detected: u32 = unsafe { ::core::mem::transmute(hang_detected) };
            hang_detected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let softirq_activated: u32 = unsafe { ::core::mem::transmute(softirq_activated) };
            softirq_activated as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let online: u32 = unsafe { ::core::mem::transmute(online) };
            online as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clock_event_device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hrtimer_interrupt(dev: *mut clock_event_device);
}
extern "C" {
    pub static mut hrtimer_resolution: core::ffi::c_uint;
}
extern "C" {
    pub fn timerfd_clock_was_set();
}
extern "C" {
    pub fn timerfd_resume();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tick_device {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut tick_cpu_device: tick_device;
}
extern "C" {
    pub fn hrtimer_init(timer: *mut hrtimer, which_clock: clockid_t, mode: hrtimer_mode);
}
extern "C" {
    pub fn hrtimer_init_sleeper(sl: *mut hrtimer_sleeper, clock_id: clockid_t, mode: hrtimer_mode);
}
extern "C" {
    pub fn hrtimer_start_range_ns(
        timer: *mut hrtimer,
        tim: ktime_t,
        range_ns: u64_,
        mode: hrtimer_mode,
    );
}
extern "C" {
    pub fn hrtimer_cancel(timer: *mut hrtimer) -> core::ffi::c_int;
}
extern "C" {
    pub fn hrtimer_try_to_cancel(timer: *mut hrtimer) -> core::ffi::c_int;
}
extern "C" {
    pub fn hrtimer_sleeper_start_expires(sl: *mut hrtimer_sleeper, mode: hrtimer_mode);
}
extern "C" {
    pub fn __hrtimer_get_remaining(timer: *const hrtimer, adjust: bool_) -> ktime_t;
}
extern "C" {
    pub fn hrtimer_get_next_event() -> u64_;
}
extern "C" {
    pub fn hrtimer_next_event_without(exclude: *const hrtimer) -> u64_;
}
extern "C" {
    pub fn hrtimer_active(timer: *const hrtimer) -> bool_;
}
extern "C" {
    pub fn hrtimer_forward(timer: *mut hrtimer, now: ktime_t, interval: ktime_t) -> u64_;
}
extern "C" {
    pub fn nanosleep_copyout(arg1: *mut restart_block, arg2: *mut timespec64) -> core::ffi::c_int;
}
extern "C" {
    pub fn hrtimer_nanosleep(
        rqtp: ktime_t,
        mode: hrtimer_mode,
        clockid: clockid_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn schedule_hrtimeout_range(
        expires: *mut ktime_t,
        delta: u64_,
        mode: hrtimer_mode,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn schedule_hrtimeout_range_clock(
        expires: *mut ktime_t,
        delta: u64_,
        mode: hrtimer_mode,
        clock_id: clockid_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn schedule_hrtimeout(expires: *mut ktime_t, mode: hrtimer_mode) -> core::ffi::c_int;
}
extern "C" {
    pub fn hrtimer_run_queues();
}
extern "C" {
    pub fn hrtimers_init();
}
extern "C" {
    pub fn sysrq_timer_list_show();
}
extern "C" {
    pub fn hrtimers_prepare_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn hrtimers_cpu_dying(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn timerqueue_add(head: *mut timerqueue_head, node: *mut timerqueue_node) -> bool_;
}
extern "C" {
    pub fn timerqueue_del(head: *mut timerqueue_head, node: *mut timerqueue_node) -> bool_;
}
extern "C" {
    pub fn timerqueue_iterate_next(node: *mut timerqueue_node) -> *mut timerqueue_node;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtc_device {
    _unused: [u8; 0],
}
pub const alarmtimer_type_ALARM_REALTIME: alarmtimer_type = 0;
pub const alarmtimer_type_ALARM_BOOTTIME: alarmtimer_type = 1;
pub const alarmtimer_type_ALARM_NUMTYPE: alarmtimer_type = 2;
pub const alarmtimer_type_ALARM_REALTIME_FREEZER: alarmtimer_type = 3;
pub const alarmtimer_type_ALARM_BOOTTIME_FREEZER: alarmtimer_type = 4;
pub type alarmtimer_type = core::ffi::c_uint;
pub const alarmtimer_restart_ALARMTIMER_NORESTART: alarmtimer_restart = 0;
pub const alarmtimer_restart_ALARMTIMER_RESTART: alarmtimer_restart = 1;
pub type alarmtimer_restart = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct alarm {
    pub node: timerqueue_node,
    pub timer: hrtimer,
    pub function: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut alarm, now: ktime_t) -> alarmtimer_restart,
    >,
    pub type_: alarmtimer_type,
    pub state: core::ffi::c_int,
    pub data: *mut core::ffi::c_void,
}
impl Default for alarm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn alarm_init(
        alarm: *mut alarm,
        type_: alarmtimer_type,
        function: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut alarm, arg2: ktime_t) -> alarmtimer_restart,
        >,
    );
}
extern "C" {
    pub fn alarm_start(alarm: *mut alarm, start: ktime_t);
}
extern "C" {
    pub fn alarm_start_relative(alarm: *mut alarm, start: ktime_t);
}
extern "C" {
    pub fn alarm_restart(alarm: *mut alarm);
}
extern "C" {
    pub fn alarm_try_to_cancel(alarm: *mut alarm) -> core::ffi::c_int;
}
extern "C" {
    pub fn alarm_cancel(alarm: *mut alarm) -> core::ffi::c_int;
}
extern "C" {
    pub fn alarm_forward(alarm: *mut alarm, now: ktime_t, interval: ktime_t) -> u64_;
}
extern "C" {
    pub fn alarm_forward_now(alarm: *mut alarm, interval: ktime_t) -> u64_;
}
extern "C" {
    pub fn alarm_expires_remaining(alarm: *const alarm) -> ktime_t;
}
extern "C" {
    pub fn alarmtimer_get_rtcdev() -> *mut rtc_device;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpu_timer {
    pub node: timerqueue_node,
    pub head: *mut timerqueue_head,
    pub pid: *mut pid,
    pub elist: list_head,
    pub firing: core::ffi::c_int,
    pub handling: *mut task_struct,
}
impl Default for cpu_timer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn posix_cputimers_group_init(pct: *mut posix_cputimers, cpu_limit: u64_);
}
extern "C" {
    pub fn clear_posix_cputimers_work(p: *mut task_struct);
}
extern "C" {
    pub fn posix_cputimers_init_work();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_itimer {
    pub list: list_head,
    pub t_hash: hlist_node,
    pub it_lock: spinlock_t,
    pub kclock: *mut k_clock,
    pub it_clock: clockid_t,
    pub it_id: timer_t,
    pub it_active: core::ffi::c_int,
    pub it_overrun: s64,
    pub it_overrun_last: s64,
    pub it_requeue_pending: core::ffi::c_int,
    pub it_sigev_notify: core::ffi::c_int,
    pub it_interval: ktime_t,
    pub it_signal: *mut signal_struct,
    pub __bindgen_anon_1: k_itimer__bindgen_ty_1,
    pub sigq: *mut sigqueue,
    pub it: k_itimer__bindgen_ty_2,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k_itimer__bindgen_ty_1 {
    pub it_pid: *mut pid,
    pub it_process: *mut task_struct,
}
impl Default for k_itimer__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k_itimer__bindgen_ty_2 {
    pub real: k_itimer__bindgen_ty_2__bindgen_ty_1,
    pub cpu: cpu_timer,
    pub alarm: k_itimer__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_itimer__bindgen_ty_2__bindgen_ty_1 {
    pub timer: hrtimer,
}
impl Default for k_itimer__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_itimer__bindgen_ty_2__bindgen_ty_2 {
    pub alarmtimer: alarm,
}
impl Default for k_itimer__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for k_itimer__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for k_itimer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn run_posix_cpu_timers();
}
extern "C" {
    pub fn posix_cpu_timers_exit(task: *mut task_struct);
}
extern "C" {
    pub fn posix_cpu_timers_exit_group(task: *mut task_struct);
}
extern "C" {
    pub fn set_process_cpu_timer(
        task: *mut task_struct,
        clock_idx: core::ffi::c_uint,
        newval: *mut u64_,
        oldval: *mut u64_,
    );
}
extern "C" {
    pub fn update_rlimit_cpu(
        task: *mut task_struct,
        rlim_new: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn posixtimer_rearm(info: *mut kernel_siginfo);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sighand_struct {
    pub siglock: spinlock_t,
    pub count: refcount_t,
    pub signalfd_wqh: wait_queue_head_t,
    pub action: [k_sigaction; 64usize],
}
impl Default for sighand_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pacct_struct {
    pub ac_flag: core::ffi::c_int,
    pub ac_exitcode: core::ffi::c_long,
    pub ac_mem: core::ffi::c_ulong,
    pub ac_utime: u64_,
    pub ac_stime: u64_,
    pub ac_minflt: core::ffi::c_ulong,
    pub ac_majflt: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpu_itimer {
    pub expires: u64_,
    pub incr: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct task_cputime_atomic {
    pub utime: atomic64_t,
    pub stime: atomic64_t,
    pub sum_exec_runtime: atomic64_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct thread_group_cputimer {
    pub cputime_atomic: task_cputime_atomic,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct multiprocess_signals {
    pub signal: sigset_t,
    pub node: hlist_node,
}
impl Default for multiprocess_signals {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct core_thread {
    pub task: *mut task_struct,
    pub next: *mut core_thread,
}
impl Default for core_thread {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct core_state {
    pub nr_threads: atomic_t,
    pub dumper: core_thread,
    pub startup: completion,
}
impl Default for core_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct signal_struct {
    pub sigcnt: refcount_t,
    pub live: atomic_t,
    pub nr_threads: core::ffi::c_int,
    pub quick_threads: core::ffi::c_int,
    pub thread_head: list_head,
    pub wait_chldexit: wait_queue_head_t,
    pub curr_target: *mut task_struct,
    pub shared_pending: sigpending,
    pub multiprocess: hlist_head,
    pub group_exit_code: core::ffi::c_int,
    pub notify_count: core::ffi::c_int,
    pub group_exec_task: *mut task_struct,
    pub group_stop_count: core::ffi::c_int,
    pub flags: core::ffi::c_uint,
    pub core_state: *mut core_state,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub next_posix_timer_id: core::ffi::c_uint,
    pub posix_timers: list_head,
    pub real_timer: hrtimer,
    pub it_real_incr: ktime_t,
    pub it: [cpu_itimer; 2usize],
    pub cputimer: thread_group_cputimer,
    pub posix_cputimers: posix_cputimers,
    pub pids: [*mut pid; 4usize],
    pub tick_dep_mask: atomic_t,
    pub tty_old_pgrp: *mut pid,
    pub leader: core::ffi::c_int,
    pub tty: *mut tty_struct,
    pub autogroup: *mut autogroup,
    pub stats_lock: seqlock_t,
    pub utime: u64_,
    pub stime: u64_,
    pub cutime: u64_,
    pub cstime: u64_,
    pub gtime: u64_,
    pub cgtime: u64_,
    pub prev_cputime: prev_cputime,
    pub nvcsw: core::ffi::c_ulong,
    pub nivcsw: core::ffi::c_ulong,
    pub cnvcsw: core::ffi::c_ulong,
    pub cnivcsw: core::ffi::c_ulong,
    pub min_flt: core::ffi::c_ulong,
    pub maj_flt: core::ffi::c_ulong,
    pub cmin_flt: core::ffi::c_ulong,
    pub cmaj_flt: core::ffi::c_ulong,
    pub inblock: core::ffi::c_ulong,
    pub oublock: core::ffi::c_ulong,
    pub cinblock: core::ffi::c_ulong,
    pub coublock: core::ffi::c_ulong,
    pub maxrss: core::ffi::c_ulong,
    pub cmaxrss: core::ffi::c_ulong,
    pub ioac: task_io_accounting,
    pub sum_sched_runtime: core::ffi::c_ulonglong,
    pub rlim: [rlimit; 16usize],
    pub pacct: pacct_struct,
    pub stats: *mut taskstats,
    pub audit_tty: core::ffi::c_uint,
    pub tty_audit_buf: *mut tty_audit_buf,
    pub oom_flag_origin: bool_,
    pub oom_score_adj: core::ffi::c_short,
    pub oom_score_adj_min: core::ffi::c_short,
    pub oom_mm: *mut mm_struct,
    pub cred_guard_mutex: mutex,
    pub exec_update_lock: rw_semaphore,
}
impl Default for signal_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl signal_struct {
    #[inline]
    pub fn is_child_subreaper(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_child_subreaper(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_child_subreaper(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_child_subreaper(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_child_subreaper: core::ffi::c_uint,
        has_child_subreaper: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_child_subreaper: u32 = unsafe { ::core::mem::transmute(is_child_subreaper) };
            is_child_subreaper as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_child_subreaper: u32 = unsafe { ::core::mem::transmute(has_child_subreaper) };
            has_child_subreaper as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn flush_signals(arg1: *mut task_struct);
}
extern "C" {
    pub fn ignore_signals(arg1: *mut task_struct);
}
extern "C" {
    pub fn flush_signal_handlers(arg1: *mut task_struct, force_default: core::ffi::c_int);
}
extern "C" {
    pub fn dequeue_signal(
        task: *mut task_struct,
        mask: *mut sigset_t,
        info: *mut kernel_siginfo_t,
        type_: *mut pid_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sig_fault_to_task(
        sig: core::ffi::c_int,
        code: core::ffi::c_int,
        addr: *mut core::ffi::c_void,
        t: *mut task_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sig_fault(
        sig: core::ffi::c_int,
        code: core::ffi::c_int,
        addr: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn send_sig_fault(
        sig: core::ffi::c_int,
        code: core::ffi::c_int,
        addr: *mut core::ffi::c_void,
        t: *mut task_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sig_mceerr(
        code: core::ffi::c_int,
        arg1: *mut core::ffi::c_void,
        arg2: core::ffi::c_short,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn send_sig_mceerr(
        code: core::ffi::c_int,
        arg1: *mut core::ffi::c_void,
        arg2: core::ffi::c_short,
        arg3: *mut task_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sig_bnderr(
        addr: *mut core::ffi::c_void,
        lower: *mut core::ffi::c_void,
        upper: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sig_pkuerr(addr: *mut core::ffi::c_void, pkey: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn send_sig_perf(
        addr: *mut core::ffi::c_void,
        type_: u32_,
        sig_data: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sig_ptrace_errno_trap(
        errno: core::ffi::c_int,
        addr: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sig_fault_trapno(
        sig: core::ffi::c_int,
        code: core::ffi::c_int,
        addr: *mut core::ffi::c_void,
        trapno: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn send_sig_fault_trapno(
        sig: core::ffi::c_int,
        code: core::ffi::c_int,
        addr: *mut core::ffi::c_void,
        trapno: core::ffi::c_int,
        t: *mut task_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sig_seccomp(
        syscall: core::ffi::c_int,
        reason: core::ffi::c_int,
        force_coredump: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn send_sig_info(
        arg1: core::ffi::c_int,
        arg2: *mut kernel_siginfo,
        arg3: *mut task_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sigsegv(sig: core::ffi::c_int);
}
extern "C" {
    pub fn force_sig_info(arg1: *mut kernel_siginfo) -> core::ffi::c_int;
}
extern "C" {
    pub fn __kill_pgrp_info(
        sig: core::ffi::c_int,
        info: *mut kernel_siginfo,
        pgrp: *mut pid,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kill_pid_info(
        sig: core::ffi::c_int,
        info: *mut kernel_siginfo,
        pid: *mut pid,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kill_pid_usb_asyncio(
        sig: core::ffi::c_int,
        errno: core::ffi::c_int,
        addr: sigval_t,
        arg1: *mut pid,
        arg2: *const cred,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kill_pgrp(
        pid: *mut pid,
        sig: core::ffi::c_int,
        priv_: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kill_pid(
        pid: *mut pid,
        sig: core::ffi::c_int,
        priv_: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_notify_parent(arg1: *mut task_struct, arg2: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn __wake_up_parent(p: *mut task_struct, parent: *mut task_struct);
}
extern "C" {
    pub fn force_sig(arg1: core::ffi::c_int);
}
extern "C" {
    pub fn force_fatal_sig(arg1: core::ffi::c_int);
}
extern "C" {
    pub fn force_exit_sig(arg1: core::ffi::c_int);
}
extern "C" {
    pub fn send_sig(
        arg1: core::ffi::c_int,
        arg2: *mut task_struct,
        arg3: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn zap_other_threads(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn sigqueue_alloc() -> *mut sigqueue;
}
extern "C" {
    pub fn sigqueue_free(arg1: *mut sigqueue);
}
extern "C" {
    pub fn send_sigqueue(arg1: *mut sigqueue, arg2: *mut pid, arg3: pid_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_sigaction(
        arg1: core::ffi::c_int,
        arg2: *mut k_sigaction,
        arg3: *mut k_sigaction,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn recalc_sigpending();
}
extern "C" {
    pub fn calculate_sigpending();
}
extern "C" {
    pub fn signal_wake_up_state(t: *mut task_struct, state: core::ffi::c_uint);
}
extern "C" {
    pub fn task_join_group_stop(task: *mut task_struct);
}
extern "C" {
    pub fn set_user_sigmask(umask: *const sigset_t, sigsetsize: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cleanup_sighand(arg1: *mut sighand_struct);
}
extern "C" {
    pub fn flush_itimer_signals();
}
extern "C" {
    pub fn current_is_single_threaded() -> bool_;
}
pub type proc_visitor = ::core::option::Option<
    unsafe extern "C" fn(p: *mut task_struct, data: *mut core::ffi::c_void) -> core::ffi::c_int,
>;
extern "C" {
    pub fn walk_process_tree(
        top: *mut task_struct,
        arg1: proc_visitor,
        arg2: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn thread_group_exited(pid: *mut pid) -> bool_;
}
extern "C" {
    pub fn __lock_task_sighand(
        task: *mut task_struct,
        flags: *mut core::ffi::c_ulong,
    ) -> *mut sighand_struct;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcuwait {
    pub task: *mut task_struct,
}
impl Default for rcuwait {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn rcuwait_wake_up(w: *mut rcuwait) -> core::ffi::c_int;
}
extern "C" {
    pub fn finish_rcuwait(w: *mut rcuwait);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_sync {
    pub gp_state: core::ffi::c_int,
    pub gp_count: core::ffi::c_int,
    pub gp_wait: wait_queue_head_t,
    pub cb_head: callback_head,
}
impl Default for rcu_sync {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn rcu_sync_init(arg1: *mut rcu_sync);
}
extern "C" {
    pub fn rcu_sync_enter_start(arg1: *mut rcu_sync);
}
extern "C" {
    pub fn rcu_sync_enter(arg1: *mut rcu_sync);
}
extern "C" {
    pub fn rcu_sync_exit(arg1: *mut rcu_sync);
}
extern "C" {
    pub fn rcu_sync_dtor(arg1: *mut rcu_sync);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_rw_semaphore {
    pub rss: rcu_sync,
    pub read_count: *mut core::ffi::c_uint,
    pub writer: rcuwait,
    pub waiters: wait_queue_head_t,
    pub block: atomic_t,
}
impl Default for percpu_rw_semaphore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __percpu_down_read(arg1: *mut percpu_rw_semaphore, arg2: bool_) -> bool_;
}
extern "C" {
    pub fn percpu_is_read_locked(arg1: *mut percpu_rw_semaphore) -> bool_;
}
extern "C" {
    pub fn percpu_down_write(arg1: *mut percpu_rw_semaphore);
}
extern "C" {
    pub fn percpu_up_write(arg1: *mut percpu_rw_semaphore);
}
extern "C" {
    pub fn __percpu_init_rwsem(
        arg1: *mut percpu_rw_semaphore,
        arg2: *const core::ffi::c_char,
        arg3: *mut lock_class_key,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn percpu_free_rwsem(arg1: *mut percpu_rw_semaphore);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct delayed_call {
    pub fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
    pub arg: *mut core::ffi::c_void,
}
impl Default for delayed_call {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct guid_t {
    pub b: [__u8; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct uuid_t {
    pub b: [__u8; 16usize],
}
extern "C" {
    pub static guid_null: guid_t;
}
extern "C" {
    pub static uuid_null: uuid_t;
}
extern "C" {
    pub fn generate_random_uuid(uuid: *mut core::ffi::c_uchar);
}
extern "C" {
    pub fn generate_random_guid(guid: *mut core::ffi::c_uchar);
}
extern "C" {
    pub fn guid_gen(u: *mut guid_t);
}
extern "C" {
    pub fn uuid_gen(u: *mut uuid_t);
}
extern "C" {
    pub fn uuid_is_valid(uuid: *const core::ffi::c_char) -> bool_;
}
extern "C" {
    pub static guid_index: [u8_; 16usize];
}
extern "C" {
    pub static uuid_index: [u8_; 16usize];
}
extern "C" {
    pub fn guid_parse(uuid: *const core::ffi::c_char, u: *mut guid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn uuid_parse(uuid: *const core::ffi::c_char, u: *mut uuid_t) -> core::ffi::c_int;
}
pub type errseq_t = u32_;
extern "C" {
    pub fn errseq_set(eseq: *mut errseq_t, err: core::ffi::c_int) -> errseq_t;
}
extern "C" {
    pub fn errseq_sample(eseq: *mut errseq_t) -> errseq_t;
}
extern "C" {
    pub fn errseq_check(eseq: *mut errseq_t, since: errseq_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn errseq_check_and_advance(eseq: *mut errseq_t, since: *mut errseq_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_mutex_pre_schedule();
}
extern "C" {
    pub fn rt_mutex_schedule();
}
extern "C" {
    pub fn rt_mutex_post_schedule();
}
extern "C" {
    pub fn rt_mutex_setprio(p: *mut task_struct, pi_task: *mut task_struct);
}
extern "C" {
    pub fn rt_mutex_adjust_pi(p: *mut task_struct);
}
extern "C" {
    pub fn normalize_rt_tasks();
}
pub const ICQ_EXITED: _bindgen_ty_79 = 4;
pub const ICQ_DESTROYED: _bindgen_ty_79 = 8;
pub type _bindgen_ty_79 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_cq {
    pub q: *mut request_queue,
    pub ioc: *mut io_context,
    pub __bindgen_anon_1: io_cq__bindgen_ty_1,
    pub __bindgen_anon_2: io_cq__bindgen_ty_2,
    pub flags: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_1 {
    pub q_node: list_head,
    pub __rcu_icq_cache: *mut kmem_cache,
}
impl Default for io_cq__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_2 {
    pub ioc_node: hlist_node,
    pub __rcu_head: callback_head,
}
impl Default for io_cq__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for io_cq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_context {
    pub refcount: atomic_long_t,
    pub active_ref: atomic_t,
    pub ioprio: core::ffi::c_ushort,
    pub lock: spinlock_t,
    pub icq_tree: xarray,
    pub icq_hint: *mut io_cq,
    pub icq_list: hlist_head,
    pub release_work: work_struct,
}
impl Default for io_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn put_io_context(ioc: *mut io_context);
}
extern "C" {
    pub fn exit_io_context(task: *mut task_struct);
}
extern "C" {
    pub fn __copy_io(clone_flags: core::ffi::c_ulong, tsk: *mut task_struct) -> core::ffi::c_int;
}
pub const IOPRIO_CLASS_NONE: _bindgen_ty_80 = 0;
pub const IOPRIO_CLASS_RT: _bindgen_ty_80 = 1;
pub const IOPRIO_CLASS_BE: _bindgen_ty_80 = 2;
pub const IOPRIO_CLASS_IDLE: _bindgen_ty_80 = 3;
pub const IOPRIO_CLASS_INVALID: _bindgen_ty_80 = 7;
pub type _bindgen_ty_80 = core::ffi::c_uint;
pub const IOPRIO_WHO_PROCESS: _bindgen_ty_81 = 1;
pub const IOPRIO_WHO_PGRP: _bindgen_ty_81 = 2;
pub const IOPRIO_WHO_USER: _bindgen_ty_81 = 3;
pub type _bindgen_ty_81 = core::ffi::c_uint;
pub const IOPRIO_HINT_NONE: _bindgen_ty_82 = 0;
pub const IOPRIO_HINT_DEV_DURATION_LIMIT_1: _bindgen_ty_82 = 1;
pub const IOPRIO_HINT_DEV_DURATION_LIMIT_2: _bindgen_ty_82 = 2;
pub const IOPRIO_HINT_DEV_DURATION_LIMIT_3: _bindgen_ty_82 = 3;
pub const IOPRIO_HINT_DEV_DURATION_LIMIT_4: _bindgen_ty_82 = 4;
pub const IOPRIO_HINT_DEV_DURATION_LIMIT_5: _bindgen_ty_82 = 5;
pub const IOPRIO_HINT_DEV_DURATION_LIMIT_6: _bindgen_ty_82 = 6;
pub const IOPRIO_HINT_DEV_DURATION_LIMIT_7: _bindgen_ty_82 = 7;
pub type _bindgen_ty_82 = core::ffi::c_uint;
extern "C" {
    pub fn set_task_ioprio(task: *mut task_struct, ioprio: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ioprio_check_cap(ioprio: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn fs_ftype_to_dtype(filetype: core::ffi::c_uint) -> core::ffi::c_uchar;
}
extern "C" {
    pub fn fs_umode_to_ftype(mode: umode_t) -> core::ffi::c_uchar;
}
extern "C" {
    pub fn fs_umode_to_dtype(mode: umode_t) -> core::ffi::c_uchar;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vfsmount {
    pub mnt_root: *mut dentry,
    pub mnt_sb: *mut super_block,
    pub mnt_flags: core::ffi::c_int,
    pub mnt_idmap: *mut mnt_idmap,
}
impl Default for vfsmount {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn mnt_want_write(mnt: *mut vfsmount) -> core::ffi::c_int;
}
extern "C" {
    pub fn mnt_want_write_file(file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn mnt_drop_write(mnt: *mut vfsmount);
}
extern "C" {
    pub fn mnt_drop_write_file(file: *mut file);
}
extern "C" {
    pub fn mntput(mnt: *mut vfsmount);
}
extern "C" {
    pub fn mntget(mnt: *mut vfsmount) -> *mut vfsmount;
}
extern "C" {
    pub fn mnt_make_shortterm(mnt: *mut vfsmount);
}
extern "C" {
    pub fn mnt_clone_internal(path: *const path) -> *mut vfsmount;
}
extern "C" {
    pub fn __mnt_is_readonly(mnt: *mut vfsmount) -> bool_;
}
extern "C" {
    pub fn mnt_may_suid(mnt: *mut vfsmount) -> bool_;
}
extern "C" {
    pub fn clone_private_mount(path: *const path) -> *mut vfsmount;
}
extern "C" {
    pub fn mnt_get_write_access(mnt: *mut vfsmount) -> core::ffi::c_int;
}
extern "C" {
    pub fn mnt_put_write_access(mnt: *mut vfsmount);
}
extern "C" {
    pub fn fc_mount(fc: *mut fs_context) -> *mut vfsmount;
}
extern "C" {
    pub fn vfs_create_mount(fc: *mut fs_context) -> *mut vfsmount;
}
extern "C" {
    pub fn vfs_kern_mount(
        type_: *mut file_system_type,
        flags: core::ffi::c_int,
        name: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
    ) -> *mut vfsmount;
}
extern "C" {
    pub fn vfs_submount(
        mountpoint: *const dentry,
        type_: *mut file_system_type,
        name: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
    ) -> *mut vfsmount;
}
extern "C" {
    pub fn mnt_set_expiry(mnt: *mut vfsmount, expiry_list: *mut list_head);
}
extern "C" {
    pub fn mark_mounts_for_expiry(mounts: *mut list_head);
}
extern "C" {
    pub fn path_is_mountpoint(path: *const path) -> bool_;
}
extern "C" {
    pub fn our_mnt(mnt: *mut vfsmount) -> bool_;
}
extern "C" {
    pub fn kern_mount(arg1: *mut file_system_type) -> *mut vfsmount;
}
extern "C" {
    pub fn kern_unmount(mnt: *mut vfsmount);
}
extern "C" {
    pub fn may_umount_tree(arg1: *mut vfsmount) -> core::ffi::c_int;
}
extern "C" {
    pub fn may_umount(arg1: *mut vfsmount) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_mount(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: *const core::ffi::c_char,
        arg4: core::ffi::c_ulong,
        arg5: *mut core::ffi::c_void,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn collect_mounts(arg1: *const path) -> *mut vfsmount;
}
extern "C" {
    pub fn drop_collected_mounts(arg1: *mut vfsmount);
}
extern "C" {
    pub fn iterate_mounts(
        arg1: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut vfsmount,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        arg2: *mut core::ffi::c_void,
        arg3: *mut vfsmount,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kern_unmount_array(mnt: *mut *mut vfsmount, num: core::ffi::c_uint);
}
extern "C" {
    pub fn cifs_root_data(
        dev: *mut *mut core::ffi::c_char,
        opts: *mut *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut nop_mnt_idmap: mnt_idmap;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfsuid_t {
    pub val: uid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfsgid_t {
    pub val: gid_t,
}
extern "C" {
    pub fn vfsgid_in_group_p(vfsgid: vfsgid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn mnt_idmap_get(idmap: *mut mnt_idmap) -> *mut mnt_idmap;
}
extern "C" {
    pub fn mnt_idmap_put(idmap: *mut mnt_idmap);
}
extern "C" {
    pub fn make_vfsuid(
        idmap: *mut mnt_idmap,
        fs_userns: *mut user_namespace,
        kuid: kuid_t,
    ) -> vfsuid_t;
}
extern "C" {
    pub fn make_vfsgid(
        idmap: *mut mnt_idmap,
        fs_userns: *mut user_namespace,
        kgid: kgid_t,
    ) -> vfsgid_t;
}
extern "C" {
    pub fn from_vfsuid(
        idmap: *mut mnt_idmap,
        fs_userns: *mut user_namespace,
        vfsuid: vfsuid_t,
    ) -> kuid_t;
}
extern "C" {
    pub fn from_vfsgid(
        idmap: *mut mnt_idmap,
        fs_userns: *mut user_namespace,
        vfsgid: vfsgid_t,
    ) -> kgid_t;
}
pub type percpu_ref_func_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut percpu_ref)>;
pub const __PERCPU_REF_ATOMIC: _bindgen_ty_83 = 1;
pub const __PERCPU_REF_DEAD: _bindgen_ty_83 = 2;
pub const __PERCPU_REF_ATOMIC_DEAD: _bindgen_ty_83 = 3;
pub const __PERCPU_REF_FLAG_BITS: _bindgen_ty_83 = 2;
pub type _bindgen_ty_83 = core::ffi::c_uint;
pub const PERCPU_REF_INIT_ATOMIC: _bindgen_ty_84 = 1;
pub const PERCPU_REF_INIT_DEAD: _bindgen_ty_84 = 2;
pub const PERCPU_REF_ALLOW_REINIT: _bindgen_ty_84 = 4;
pub type _bindgen_ty_84 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_ref_data {
    pub count: atomic_long_t,
    pub release: percpu_ref_func_t,
    pub confirm_switch: percpu_ref_func_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub rcu: callback_head,
    pub ref_: *mut percpu_ref,
}
impl Default for percpu_ref_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl percpu_ref_data {
    #[inline]
    pub fn force_atomic(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_atomic(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_reinit(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_allow_reinit(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_atomic: bool_,
        allow_reinit: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_atomic: u8 = unsafe { ::core::mem::transmute(force_atomic) };
            force_atomic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let allow_reinit: u8 = unsafe { ::core::mem::transmute(allow_reinit) };
            allow_reinit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_ref {
    pub percpu_count_ptr: core::ffi::c_ulong,
    pub data: *mut percpu_ref_data,
}
impl Default for percpu_ref {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn percpu_ref_init(
        ref_: *mut percpu_ref,
        release: percpu_ref_func_t,
        flags: core::ffi::c_uint,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn percpu_ref_exit(ref_: *mut percpu_ref);
}
extern "C" {
    pub fn percpu_ref_switch_to_atomic(ref_: *mut percpu_ref, confirm_switch: percpu_ref_func_t);
}
extern "C" {
    pub fn percpu_ref_switch_to_atomic_sync(ref_: *mut percpu_ref);
}
extern "C" {
    pub fn percpu_ref_switch_to_percpu(ref_: *mut percpu_ref);
}
extern "C" {
    pub fn percpu_ref_kill_and_confirm(ref_: *mut percpu_ref, confirm_kill: percpu_ref_func_t);
}
extern "C" {
    pub fn percpu_ref_resurrect(ref_: *mut percpu_ref);
}
extern "C" {
    pub fn percpu_ref_reinit(ref_: *mut percpu_ref);
}
extern "C" {
    pub fn percpu_ref_is_zero(ref_: *mut percpu_ref) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct slab {
    _unused: [u8; 0],
}
pub type kasan_vmalloc_flags_t = core::ffi::c_uint;
extern "C" {
    pub fn slab_is_available() -> bool_;
}
extern "C" {
    pub fn kmem_cache_create(
        name: *const core::ffi::c_char,
        size: core::ffi::c_uint,
        align: core::ffi::c_uint,
        flags: slab_flags_t,
        ctor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
    ) -> *mut kmem_cache;
}
extern "C" {
    pub fn kmem_cache_create_usercopy(
        name: *const core::ffi::c_char,
        size: core::ffi::c_uint,
        align: core::ffi::c_uint,
        flags: slab_flags_t,
        useroffset: core::ffi::c_uint,
        usersize: core::ffi::c_uint,
        ctor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
    ) -> *mut kmem_cache;
}
extern "C" {
    pub fn kmem_cache_destroy(s: *mut kmem_cache);
}
extern "C" {
    pub fn kmem_cache_shrink(s: *mut kmem_cache) -> core::ffi::c_int;
}
extern "C" {
    pub fn krealloc(
        objp: *const core::ffi::c_void,
        new_size: usize,
        flags: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kfree(objp: *const core::ffi::c_void);
}
extern "C" {
    pub fn kfree_sensitive(objp: *const core::ffi::c_void);
}
extern "C" {
    pub fn __ksize(objp: *const core::ffi::c_void) -> usize;
}
extern "C" {
    pub fn ksize(objp: *const core::ffi::c_void) -> usize;
}
extern "C" {
    pub fn kmem_dump_obj(object: *mut core::ffi::c_void) -> bool_;
}
pub const kmalloc_cache_type_KMALLOC_NORMAL: kmalloc_cache_type = 0;
pub const kmalloc_cache_type_KMALLOC_RANDOM_START: kmalloc_cache_type = 0;
pub const kmalloc_cache_type_KMALLOC_RANDOM_END: kmalloc_cache_type = 15;
pub const kmalloc_cache_type_KMALLOC_RECLAIM: kmalloc_cache_type = 16;
pub const kmalloc_cache_type_KMALLOC_DMA: kmalloc_cache_type = 17;
pub const kmalloc_cache_type_KMALLOC_CGROUP: kmalloc_cache_type = 18;
pub const kmalloc_cache_type_NR_KMALLOC_TYPES: kmalloc_cache_type = 19;
pub type kmalloc_cache_type = core::ffi::c_uint;
extern "C" {
    pub static mut kmalloc_caches: [[*mut kmem_cache; 14usize]; 19usize];
}
extern "C" {
    pub static mut random_kmalloc_seed: core::ffi::c_ulong;
}
extern "C" {
    pub fn __kmalloc(size: usize, flags: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc(cachep: *mut kmem_cache, flags: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc_lru(
        s: *mut kmem_cache,
        lru: *mut list_lru,
        gfpflags: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kmem_cache_free(s: *mut kmem_cache, objp: *mut core::ffi::c_void);
}
extern "C" {
    pub fn kmem_cache_free_bulk(s: *mut kmem_cache, size: usize, p: *mut *mut core::ffi::c_void);
}
extern "C" {
    pub fn kmem_cache_alloc_bulk(
        s: *mut kmem_cache,
        flags: gfp_t,
        size: usize,
        p: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __kmalloc_node(
        size: usize,
        flags: gfp_t,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc_node(
        s: *mut kmem_cache,
        flags: gfp_t,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kmalloc_trace(s: *mut kmem_cache, flags: gfp_t, size: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kmalloc_node_trace(
        s: *mut kmem_cache,
        gfpflags: gfp_t,
        node: core::ffi::c_int,
        size: usize,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kmalloc_large(size: usize, flags: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kmalloc_large_node(
        size: usize,
        flags: gfp_t,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __kmalloc_node_track_caller(
        size: usize,
        flags: gfp_t,
        node: core::ffi::c_int,
        caller: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kvmalloc_node(
        size: usize,
        flags: gfp_t,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kvrealloc(
        p: *const core::ffi::c_void,
        oldsize: usize,
        newsize: usize,
        flags: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kvfree(addr: *const core::ffi::c_void);
}
extern "C" {
    pub fn kvfree_sensitive(addr: *const core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn kmem_cache_size(s: *mut kmem_cache) -> core::ffi::c_uint;
}
extern "C" {
    pub fn kmalloc_size_roundup(size: usize) -> usize;
}
extern "C" {
    pub fn kmem_cache_init_late();
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct file_clone_range {
    pub src_fd: __s64,
    pub src_offset: __u64,
    pub src_length: __u64,
    pub dest_offset: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fstrim_range {
    pub start: __u64,
    pub len: __u64,
    pub minlen: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct file_dedupe_range_info {
    pub dest_fd: __s64,
    pub dest_offset: __u64,
    pub bytes_deduped: __u64,
    pub status: __s32,
    pub reserved: __u32,
}
#[repr(C)]
#[derive(Default)]
pub struct file_dedupe_range {
    pub src_offset: __u64,
    pub src_length: __u64,
    pub dest_count: __u16,
    pub reserved1: __u16,
    pub reserved2: __u32,
    pub info: __IncompleteArrayField<file_dedupe_range_info>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct files_stat_struct {
    pub nr_files: core::ffi::c_ulong,
    pub nr_free_files: core::ffi::c_ulong,
    pub max_files: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct inodes_stat_t {
    pub nr_inodes: core::ffi::c_long,
    pub nr_unused: core::ffi::c_long,
    pub dummy: [core::ffi::c_long; 5usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fsxattr {
    pub fsx_xflags: __u32,
    pub fsx_extsize: __u32,
    pub fsx_nextents: __u32,
    pub fsx_projid: __u32,
    pub fsx_cowextsize: __u32,
    pub fsx_pad: [core::ffi::c_uchar; 8usize],
}
pub type __kernel_rwf_t = core::ffi::c_int;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct page_region {
    pub start: __u64,
    pub end: __u64,
    pub categories: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pm_scan_arg {
    pub size: __u64,
    pub flags: __u64,
    pub start: __u64,
    pub end: __u64,
    pub walk_end: __u64,
    pub vec: __u64,
    pub vec_len: __u64,
    pub max_pages: __u64,
    pub category_inverted: __u64,
    pub category_mask: __u64,
    pub category_anyof_mask: __u64,
    pub return_mask: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct backing_dev_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bdi_writeback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_comp_batch {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct export_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fiemap_extent_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hd_geometry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct poll_table_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kstatfs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swap_info_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_inode_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsverity_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsverity_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_parameter_spec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fileattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iomap_ops {
    _unused: [u8; 0],
}
extern "C" {
    pub fn inode_init();
}
extern "C" {
    pub fn inode_init_early();
}
extern "C" {
    pub fn files_init();
}
extern "C" {
    pub fn files_maxfiles_init();
}
extern "C" {
    pub fn get_max_files() -> core::ffi::c_ulong;
}
extern "C" {
    pub static mut sysctl_nr_open: core::ffi::c_uint;
}
pub type rwf_t = __kernel_rwf_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct buffer_head {
    _unused: [u8; 0],
}
pub type get_block_t = ::core::option::Option<
    unsafe extern "C" fn(
        inode: *mut inode,
        iblock: sector_t,
        bh_result: *mut buffer_head,
        create: core::ffi::c_int,
    ) -> core::ffi::c_int,
>;
pub type dio_iodone_t = ::core::option::Option<
    unsafe extern "C" fn(
        iocb: *mut kiocb,
        offset: loff_t,
        bytes: isize,
        private: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iattr {
    pub ia_valid: core::ffi::c_uint,
    pub ia_mode: umode_t,
    pub __bindgen_anon_1: iattr__bindgen_ty_1,
    pub __bindgen_anon_2: iattr__bindgen_ty_2,
    pub ia_size: loff_t,
    pub ia_atime: timespec64,
    pub ia_mtime: timespec64,
    pub ia_ctime: timespec64,
    pub ia_file: *mut file,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iattr__bindgen_ty_1 {
    pub ia_uid: kuid_t,
    pub ia_vfsuid: vfsuid_t,
}
impl Default for iattr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iattr__bindgen_ty_2 {
    pub ia_gid: kgid_t,
    pub ia_vfsgid: vfsgid_t,
}
impl Default for iattr__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iattr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fs_disk_quota {
    pub d_version: __s8,
    pub d_flags: __s8,
    pub d_fieldmask: __u16,
    pub d_id: __u32,
    pub d_blk_hardlimit: __u64,
    pub d_blk_softlimit: __u64,
    pub d_ino_hardlimit: __u64,
    pub d_ino_softlimit: __u64,
    pub d_bcount: __u64,
    pub d_icount: __u64,
    pub d_itimer: __s32,
    pub d_btimer: __s32,
    pub d_iwarns: __u16,
    pub d_bwarns: __u16,
    pub d_itimer_hi: __s8,
    pub d_btimer_hi: __s8,
    pub d_rtbtimer_hi: __s8,
    pub d_padding2: __s8,
    pub d_rtb_hardlimit: __u64,
    pub d_rtb_softlimit: __u64,
    pub d_rtbcount: __u64,
    pub d_rtbtimer: __s32,
    pub d_rtbwarns: __u16,
    pub d_padding3: __s16,
    pub d_padding4: [core::ffi::c_char; 8usize],
}
pub type fs_disk_quota_t = fs_disk_quota;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fs_qfilestat {
    pub qfs_ino: __u64,
    pub qfs_nblks: __u64,
    pub qfs_nextents: __u32,
}
pub type fs_qfilestat_t = fs_qfilestat;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fs_quota_stat {
    pub qs_version: __s8,
    pub qs_flags: __u16,
    pub qs_pad: __s8,
    pub qs_uquota: fs_qfilestat_t,
    pub qs_gquota: fs_qfilestat_t,
    pub qs_incoredqs: __u32,
    pub qs_btimelimit: __s32,
    pub qs_itimelimit: __s32,
    pub qs_rtbtimelimit: __s32,
    pub qs_bwarnlimit: __u16,
    pub qs_iwarnlimit: __u16,
}
pub type fs_quota_stat_t = fs_quota_stat;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fs_qfilestatv {
    pub qfs_ino: __u64,
    pub qfs_nblks: __u64,
    pub qfs_nextents: __u32,
    pub qfs_pad: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fs_quota_statv {
    pub qs_version: __s8,
    pub qs_pad1: __u8,
    pub qs_flags: __u16,
    pub qs_incoredqs: __u32,
    pub qs_uquota: fs_qfilestatv,
    pub qs_gquota: fs_qfilestatv,
    pub qs_pquota: fs_qfilestatv,
    pub qs_btimelimit: __s32,
    pub qs_itimelimit: __s32,
    pub qs_rtbtimelimit: __s32,
    pub qs_bwarnlimit: __u16,
    pub qs_iwarnlimit: __u16,
    pub qs_rtbwarnlimit: __u16,
    pub qs_pad3: __u16,
    pub qs_pad4: __u32,
    pub qs_pad2: [__u64; 7usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qtree_fmt_operations {
    pub mem2disk_dqblk: ::core::option::Option<
        unsafe extern "C" fn(disk: *mut core::ffi::c_void, dquot: *mut dquot),
    >,
    pub disk2mem_dqblk: ::core::option::Option<
        unsafe extern "C" fn(dquot: *mut dquot, disk: *mut core::ffi::c_void),
    >,
    pub is_id: ::core::option::Option<
        unsafe extern "C" fn(disk: *mut core::ffi::c_void, dquot: *mut dquot) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qtree_mem_dqinfo {
    pub dqi_sb: *mut super_block,
    pub dqi_type: core::ffi::c_int,
    pub dqi_blocks: core::ffi::c_uint,
    pub dqi_free_blk: core::ffi::c_uint,
    pub dqi_free_entry: core::ffi::c_uint,
    pub dqi_blocksize_bits: core::ffi::c_uint,
    pub dqi_entry_size: core::ffi::c_uint,
    pub dqi_usable_bs: core::ffi::c_uint,
    pub dqi_qtree_depth: core::ffi::c_uint,
    pub dqi_ops: *const qtree_fmt_operations,
}
impl Default for qtree_mem_dqinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn qtree_write_dquot(info: *mut qtree_mem_dqinfo, dquot: *mut dquot) -> core::ffi::c_int;
}
extern "C" {
    pub fn qtree_read_dquot(info: *mut qtree_mem_dqinfo, dquot: *mut dquot) -> core::ffi::c_int;
}
extern "C" {
    pub fn qtree_delete_dquot(info: *mut qtree_mem_dqinfo, dquot: *mut dquot) -> core::ffi::c_int;
}
extern "C" {
    pub fn qtree_release_dquot(info: *mut qtree_mem_dqinfo, dquot: *mut dquot) -> core::ffi::c_int;
}
extern "C" {
    pub fn qtree_entry_unused(
        info: *mut qtree_mem_dqinfo,
        disk: *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn qtree_get_next_id(info: *mut qtree_mem_dqinfo, qid: *mut kqid) -> core::ffi::c_int;
}
pub type projid_t = __kernel_uid32_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kprojid_t {
    pub val: projid_t,
}
extern "C" {
    pub fn make_kprojid(from: *mut user_namespace, projid: projid_t) -> kprojid_t;
}
extern "C" {
    pub fn from_kprojid(to: *mut user_namespace, projid: kprojid_t) -> projid_t;
}
extern "C" {
    pub fn from_kprojid_munged(to: *mut user_namespace, projid: kprojid_t) -> projid_t;
}
pub const QIF_BLIMITS_B: _bindgen_ty_85 = 0;
pub const QIF_SPACE_B: _bindgen_ty_85 = 1;
pub const QIF_ILIMITS_B: _bindgen_ty_85 = 2;
pub const QIF_INODES_B: _bindgen_ty_85 = 3;
pub const QIF_BTIME_B: _bindgen_ty_85 = 4;
pub const QIF_ITIME_B: _bindgen_ty_85 = 5;
pub type _bindgen_ty_85 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct if_dqblk {
    pub dqb_bhardlimit: __u64,
    pub dqb_bsoftlimit: __u64,
    pub dqb_curspace: __u64,
    pub dqb_ihardlimit: __u64,
    pub dqb_isoftlimit: __u64,
    pub dqb_curinodes: __u64,
    pub dqb_btime: __u64,
    pub dqb_itime: __u64,
    pub dqb_valid: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct if_nextdqblk {
    pub dqb_bhardlimit: __u64,
    pub dqb_bsoftlimit: __u64,
    pub dqb_curspace: __u64,
    pub dqb_ihardlimit: __u64,
    pub dqb_isoftlimit: __u64,
    pub dqb_curinodes: __u64,
    pub dqb_btime: __u64,
    pub dqb_itime: __u64,
    pub dqb_valid: __u32,
    pub dqb_id: __u32,
}
pub const DQF_ROOT_SQUASH_B: _bindgen_ty_86 = 0;
pub const DQF_SYS_FILE_B: _bindgen_ty_86 = 16;
pub const DQF_PRIVATE: _bindgen_ty_86 = 17;
pub type _bindgen_ty_86 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct if_dqinfo {
    pub dqi_bgrace: __u64,
    pub dqi_igrace: __u64,
    pub dqi_flags: __u32,
    pub dqi_valid: __u32,
}
pub const QUOTA_NL_C_UNSPEC: _bindgen_ty_87 = 0;
pub const QUOTA_NL_C_WARNING: _bindgen_ty_87 = 1;
pub const __QUOTA_NL_C_MAX: _bindgen_ty_87 = 2;
pub type _bindgen_ty_87 = core::ffi::c_uint;
pub const QUOTA_NL_A_UNSPEC: _bindgen_ty_88 = 0;
pub const QUOTA_NL_A_QTYPE: _bindgen_ty_88 = 1;
pub const QUOTA_NL_A_EXCESS_ID: _bindgen_ty_88 = 2;
pub const QUOTA_NL_A_WARNING: _bindgen_ty_88 = 3;
pub const QUOTA_NL_A_DEV_MAJOR: _bindgen_ty_88 = 4;
pub const QUOTA_NL_A_DEV_MINOR: _bindgen_ty_88 = 5;
pub const QUOTA_NL_A_CAUSED_ID: _bindgen_ty_88 = 6;
pub const QUOTA_NL_A_PAD: _bindgen_ty_88 = 7;
pub const __QUOTA_NL_A_MAX: _bindgen_ty_88 = 8;
pub type _bindgen_ty_88 = core::ffi::c_uint;
pub const quota_type_USRQUOTA: quota_type = 0;
pub const quota_type_GRPQUOTA: quota_type = 1;
pub const quota_type_PRJQUOTA: quota_type = 2;
pub type quota_type = core::ffi::c_uint;
pub type qid_t = __kernel_uid32_t;
pub type qsize_t = core::ffi::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kqid {
    pub __bindgen_anon_1: kqid__bindgen_ty_1,
    pub type_: quota_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kqid__bindgen_ty_1 {
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub projid: kprojid_t,
}
impl Default for kqid__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kqid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn qid_eq(left: kqid, right: kqid) -> bool_;
}
extern "C" {
    pub fn qid_lt(left: kqid, right: kqid) -> bool_;
}
extern "C" {
    pub fn from_kqid(to: *mut user_namespace, qid: kqid) -> qid_t;
}
extern "C" {
    pub fn from_kqid_munged(to: *mut user_namespace, qid: kqid) -> qid_t;
}
extern "C" {
    pub fn qid_valid(qid: kqid) -> bool_;
}
extern "C" {
    pub static mut dq_data_lock: spinlock_t;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mem_dqblk {
    pub dqb_bhardlimit: qsize_t,
    pub dqb_bsoftlimit: qsize_t,
    pub dqb_curspace: qsize_t,
    pub dqb_rsvspace: qsize_t,
    pub dqb_ihardlimit: qsize_t,
    pub dqb_isoftlimit: qsize_t,
    pub dqb_curinodes: qsize_t,
    pub dqb_btime: time64_t,
    pub dqb_itime: time64_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_dqinfo {
    pub dqi_format: *mut quota_format_type,
    pub dqi_fmt_id: core::ffi::c_int,
    pub dqi_dirty_list: list_head,
    pub dqi_flags: core::ffi::c_ulong,
    pub dqi_bgrace: core::ffi::c_uint,
    pub dqi_igrace: core::ffi::c_uint,
    pub dqi_max_spc_limit: qsize_t,
    pub dqi_max_ino_limit: qsize_t,
    pub dqi_priv: *mut core::ffi::c_void,
}
impl Default for mem_dqinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const DQF_INFO_DIRTY_B: _bindgen_ty_89 = 17;
pub type _bindgen_ty_89 = core::ffi::c_uint;
extern "C" {
    pub fn mark_info_dirty(sb: *mut super_block, type_: core::ffi::c_int);
}
pub const DQST_LOOKUPS: _bindgen_ty_90 = 0;
pub const DQST_DROPS: _bindgen_ty_90 = 1;
pub const DQST_READS: _bindgen_ty_90 = 2;
pub const DQST_WRITES: _bindgen_ty_90 = 3;
pub const DQST_CACHE_HITS: _bindgen_ty_90 = 4;
pub const DQST_ALLOC_DQUOTS: _bindgen_ty_90 = 5;
pub const DQST_FREE_DQUOTS: _bindgen_ty_90 = 6;
pub const DQST_SYNCS: _bindgen_ty_90 = 7;
pub const _DQST_DQSTAT_LAST: _bindgen_ty_90 = 8;
pub type _bindgen_ty_90 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dqstats {
    pub stat: [core::ffi::c_ulong; 8usize],
    pub counter: [percpu_counter; 8usize],
}
impl Default for dqstats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut dqstats: dqstats;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dquot {
    pub dq_hash: hlist_node,
    pub dq_inuse: list_head,
    pub dq_free: list_head,
    pub dq_dirty: list_head,
    pub dq_lock: mutex,
    pub dq_dqb_lock: spinlock_t,
    pub dq_count: atomic_t,
    pub dq_sb: *mut super_block,
    pub dq_id: kqid,
    pub dq_off: loff_t,
    pub dq_flags: core::ffi::c_ulong,
    pub dq_dqb: mem_dqblk,
}
impl Default for dquot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct quota_format_ops {
    pub check_quota_file: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub read_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub write_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub free_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub read_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> core::ffi::c_int>,
    pub commit_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> core::ffi::c_int>,
    pub release_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> core::ffi::c_int>,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dquot_operations {
    pub write_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> core::ffi::c_int>,
    pub alloc_dquot: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_int) -> *mut dquot,
    >,
    pub destroy_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot)>,
    pub acquire_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> core::ffi::c_int>,
    pub release_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> core::ffi::c_int>,
    pub mark_dirty:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> core::ffi::c_int>,
    pub write_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub get_reserved_space:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut qsize_t>,
    pub get_projid: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut kprojid_t) -> core::ffi::c_int,
    >,
    pub get_inode_usage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut qsize_t) -> core::ffi::c_int,
    >,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qc_dqblk {
    pub d_fieldmask: core::ffi::c_int,
    pub d_spc_hardlimit: u64_,
    pub d_spc_softlimit: u64_,
    pub d_ino_hardlimit: u64_,
    pub d_ino_softlimit: u64_,
    pub d_space: u64_,
    pub d_ino_count: u64_,
    pub d_ino_timer: s64,
    pub d_spc_timer: s64,
    pub d_ino_warns: core::ffi::c_int,
    pub d_spc_warns: core::ffi::c_int,
    pub d_rt_spc_hardlimit: u64_,
    pub d_rt_spc_softlimit: u64_,
    pub d_rt_space: u64_,
    pub d_rt_spc_timer: s64,
    pub d_rt_spc_warns: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qc_type_state {
    pub flags: core::ffi::c_uint,
    pub spc_timelimit: core::ffi::c_uint,
    pub ino_timelimit: core::ffi::c_uint,
    pub rt_spc_timelimit: core::ffi::c_uint,
    pub spc_warnlimit: core::ffi::c_uint,
    pub ino_warnlimit: core::ffi::c_uint,
    pub rt_spc_warnlimit: core::ffi::c_uint,
    pub ino: core::ffi::c_ulonglong,
    pub blocks: blkcnt_t,
    pub nextents: blkcnt_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qc_state {
    pub s_incoredqs: core::ffi::c_uint,
    pub s_state: [qc_type_state; 3usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qc_info {
    pub i_fieldmask: core::ffi::c_int,
    pub i_flags: core::ffi::c_uint,
    pub i_spc_timelimit: core::ffi::c_uint,
    pub i_ino_timelimit: core::ffi::c_uint,
    pub i_rt_spc_timelimit: core::ffi::c_uint,
    pub i_spc_warnlimit: core::ffi::c_uint,
    pub i_ino_warnlimit: core::ffi::c_uint,
    pub i_rt_spc_warnlimit: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct quotactl_ops {
    pub quota_on: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: core::ffi::c_int,
            arg3: core::ffi::c_int,
            arg4: *const path,
        ) -> core::ffi::c_int,
    >,
    pub quota_off: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub quota_enable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub quota_disable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub quota_sync: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub set_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: core::ffi::c_int,
            arg3: *mut qc_info,
        ) -> core::ffi::c_int,
    >,
    pub get_dqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> core::ffi::c_int,
    >,
    pub get_nextdqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut kqid,
            arg3: *mut qc_dqblk,
        ) -> core::ffi::c_int,
    >,
    pub set_dqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> core::ffi::c_int,
    >,
    pub get_state: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut qc_state) -> core::ffi::c_int,
    >,
    pub rm_xquota: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_uint) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_format_type {
    pub qf_fmt_id: core::ffi::c_int,
    pub qf_ops: *const quota_format_ops,
    pub qf_owner: *mut module,
    pub qf_next: *mut quota_format_type,
}
impl Default for quota_format_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const _DQUOT_USAGE_ENABLED: _bindgen_ty_91 = 0;
pub const _DQUOT_LIMITS_ENABLED: _bindgen_ty_91 = 1;
pub const _DQUOT_SUSPENDED: _bindgen_ty_91 = 2;
pub const _DQUOT_STATE_FLAGS: _bindgen_ty_91 = 3;
pub type _bindgen_ty_91 = core::ffi::c_uint;
extern "C" {
    pub fn quota_send_warning(qid: kqid, dev: dev_t, warntype: core::ffi::c_char);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_info {
    pub flags: core::ffi::c_uint,
    pub dqio_sem: rw_semaphore,
    pub files: [*mut inode; 3usize],
    pub info: [mem_dqinfo; 3usize],
    pub ops: [*const quota_format_ops; 3usize],
}
impl Default for quota_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn register_quota_format(fmt: *mut quota_format_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_quota_format(fmt: *mut quota_format_type);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_module_name {
    pub qm_fmt_id: core::ffi::c_int,
    pub qm_mod_name: *mut core::ffi::c_char,
}
impl Default for quota_module_name {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const positive_aop_returns_AOP_WRITEPAGE_ACTIVATE: positive_aop_returns = 524288;
pub const positive_aop_returns_AOP_TRUNCATED_PAGE: positive_aop_returns = 524289;
pub type positive_aop_returns = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct writeback_control {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct readahead_control {
    _unused: [u8; 0],
}
pub const rw_hint_WRITE_LIFE_NOT_SET: rw_hint = 0;
pub const rw_hint_WRITE_LIFE_NONE: rw_hint = 1;
pub const rw_hint_WRITE_LIFE_SHORT: rw_hint = 2;
pub const rw_hint_WRITE_LIFE_MEDIUM: rw_hint = 3;
pub const rw_hint_WRITE_LIFE_LONG: rw_hint = 4;
pub const rw_hint_WRITE_LIFE_EXTREME: rw_hint = 5;
pub type rw_hint = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kiocb {
    pub ki_filp: *mut file,
    pub ki_pos: loff_t,
    pub ki_complete:
        ::core::option::Option<unsafe extern "C" fn(iocb: *mut kiocb, ret: core::ffi::c_long)>,
    pub private: *mut core::ffi::c_void,
    pub ki_flags: core::ffi::c_int,
    pub ki_ioprio: u16_,
    pub __bindgen_anon_1: kiocb__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kiocb__bindgen_ty_1 {
    pub ki_waitq: *mut wait_page_queue,
    pub dio_complete:
        ::core::option::Option<unsafe extern "C" fn(data: *mut core::ffi::c_void) -> isize>,
}
impl Default for kiocb__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kiocb {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct address_space_operations {
    pub writepage: ::core::option::Option<
        unsafe extern "C" fn(page: *mut page, wbc: *mut writeback_control) -> core::ffi::c_int,
    >,
    pub read_folio: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut folio) -> core::ffi::c_int,
    >,
    pub writepages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            arg2: *mut writeback_control,
        ) -> core::ffi::c_int,
    >,
    pub dirty_folio: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut folio) -> bool_,
    >,
    pub readahead: ::core::option::Option<unsafe extern "C" fn(arg1: *mut readahead_control)>,
    pub write_begin: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            mapping: *mut address_space,
            pos: loff_t,
            len: core::ffi::c_uint,
            pagep: *mut *mut page,
            fsdata: *mut *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub write_end: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            mapping: *mut address_space,
            pos: loff_t,
            len: core::ffi::c_uint,
            copied: core::ffi::c_uint,
            page: *mut page,
            fsdata: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub bmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: sector_t) -> sector_t,
    >,
    pub invalidate_folio:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio, offset: usize, len: usize)>,
    pub release_folio:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio, arg2: gfp_t) -> bool_>,
    pub free_folio: ::core::option::Option<unsafe extern "C" fn(folio: *mut folio)>,
    pub direct_IO: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, iter: *mut iov_iter) -> isize,
    >,
    pub migrate_folio: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            dst: *mut folio,
            src: *mut folio,
            arg2: migrate_mode,
        ) -> core::ffi::c_int,
    >,
    pub launder_folio:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio) -> core::ffi::c_int>,
    pub is_partially_uptodate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut folio, from: usize, count: usize) -> bool_,
    >,
    pub is_dirty_writeback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut folio, dirty: *mut bool_, wb: *mut bool_),
    >,
    pub error_remove_folio: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut folio) -> core::ffi::c_int,
    >,
    pub swap_activate: ::core::option::Option<
        unsafe extern "C" fn(
            sis: *mut swap_info_struct,
            file: *mut file,
            span: *mut sector_t,
        ) -> core::ffi::c_int,
    >,
    pub swap_deactivate: ::core::option::Option<unsafe extern "C" fn(file: *mut file)>,
    pub swap_rw: ::core::option::Option<
        unsafe extern "C" fn(iocb: *mut kiocb, iter: *mut iov_iter) -> core::ffi::c_int,
    >,
}
extern "C" {
    pub static empty_aops: address_space_operations;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct address_space {
    pub host: *mut inode,
    pub i_pages: xarray,
    pub invalidate_lock: rw_semaphore,
    pub gfp_mask: gfp_t,
    pub i_mmap_writable: atomic_t,
    pub i_mmap: rb_root_cached,
    pub nrpages: core::ffi::c_ulong,
    pub writeback_index: core::ffi::c_ulong,
    pub a_ops: *const address_space_operations,
    pub flags: core::ffi::c_ulong,
    pub i_mmap_rwsem: rw_semaphore,
    pub wb_err: errseq_t,
    pub i_private_lock: spinlock_t,
    pub i_private_list: list_head,
    pub i_private_data: *mut core::ffi::c_void,
}
impl Default for address_space {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct posix_acl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsnotify_mark_connector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inode {
    pub i_mode: umode_t,
    pub i_opflags: core::ffi::c_ushort,
    pub i_uid: kuid_t,
    pub i_gid: kgid_t,
    pub i_flags: core::ffi::c_uint,
    pub i_acl: *mut posix_acl,
    pub i_default_acl: *mut posix_acl,
    pub i_op: *const inode_operations,
    pub i_sb: *mut super_block,
    pub i_mapping: *mut address_space,
    pub i_security: *mut core::ffi::c_void,
    pub i_ino: core::ffi::c_ulong,
    pub __bindgen_anon_1: inode__bindgen_ty_1,
    pub i_rdev: dev_t,
    pub i_size: loff_t,
    pub __i_atime: timespec64,
    pub __i_mtime: timespec64,
    pub __i_ctime: timespec64,
    pub i_lock: spinlock_t,
    pub i_bytes: core::ffi::c_ushort,
    pub i_blkbits: u8_,
    pub i_write_hint: u8_,
    pub i_blocks: blkcnt_t,
    pub i_state: core::ffi::c_ulong,
    pub i_rwsem: rw_semaphore,
    pub dirtied_when: core::ffi::c_ulong,
    pub dirtied_time_when: core::ffi::c_ulong,
    pub i_hash: hlist_node,
    pub i_io_list: list_head,
    pub i_wb: *mut bdi_writeback,
    pub i_wb_frn_winner: core::ffi::c_int,
    pub i_wb_frn_avg_time: u16_,
    pub i_wb_frn_history: u16_,
    pub i_lru: list_head,
    pub i_sb_list: list_head,
    pub i_wb_list: list_head,
    pub __bindgen_anon_2: inode__bindgen_ty_2,
    pub i_version: atomic64_t,
    pub i_sequence: atomic64_t,
    pub i_count: atomic_t,
    pub i_dio_count: atomic_t,
    pub i_writecount: atomic_t,
    pub i_readcount: atomic_t,
    pub __bindgen_anon_3: inode__bindgen_ty_3,
    pub i_flctx: *mut file_lock_context,
    pub i_data: address_space,
    pub i_devices: list_head,
    pub __bindgen_anon_4: inode__bindgen_ty_4,
    pub i_generation: __u32,
    pub i_fsnotify_mask: __u32,
    pub i_fsnotify_marks: *mut fsnotify_mark_connector,
    pub i_crypt_info: *mut fscrypt_inode_info,
    pub i_verity_info: *mut fsverity_info,
    pub i_private: *mut core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_1 {
    pub i_nlink: core::ffi::c_uint,
    pub __i_nlink: core::ffi::c_uint,
}
impl Default for inode__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_2 {
    pub i_dentry: hlist_head,
    pub i_rcu: callback_head,
}
impl Default for inode__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_3 {
    pub i_fop: *const file_operations,
    pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
}
impl Default for inode__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_4 {
    pub i_pipe: *mut pipe_inode_info,
    pub i_cdev: *mut cdev,
    pub i_link: *mut core::ffi::c_char,
    pub i_dir_seq: core::ffi::c_uint,
}
impl Default for inode__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for inode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn timestamp_truncate(t: timespec64, inode: *mut inode) -> timespec64;
}
pub const inode_i_mutex_lock_class_I_MUTEX_NORMAL: inode_i_mutex_lock_class = 0;
pub const inode_i_mutex_lock_class_I_MUTEX_PARENT: inode_i_mutex_lock_class = 1;
pub const inode_i_mutex_lock_class_I_MUTEX_CHILD: inode_i_mutex_lock_class = 2;
pub const inode_i_mutex_lock_class_I_MUTEX_XATTR: inode_i_mutex_lock_class = 3;
pub const inode_i_mutex_lock_class_I_MUTEX_NONDIR2: inode_i_mutex_lock_class = 4;
pub const inode_i_mutex_lock_class_I_MUTEX_PARENT2: inode_i_mutex_lock_class = 5;
pub type inode_i_mutex_lock_class = core::ffi::c_uint;
extern "C" {
    pub fn lock_two_nondirectories(arg1: *mut inode, arg2: *mut inode);
}
extern "C" {
    pub fn unlock_two_nondirectories(arg1: *mut inode, arg2: *mut inode);
}
extern "C" {
    pub fn filemap_invalidate_lock_two(mapping1: *mut address_space, mapping2: *mut address_space);
}
extern "C" {
    pub fn filemap_invalidate_unlock_two(
        mapping1: *mut address_space,
        mapping2: *mut address_space,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fown_struct {
    pub lock: rwlock_t,
    pub pid: *mut pid,
    pub pid_type: pid_type,
    pub uid: kuid_t,
    pub euid: kuid_t,
    pub signum: core::ffi::c_int,
}
impl Default for fown_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct file_ra_state {
    pub start: core::ffi::c_ulong,
    pub size: core::ffi::c_uint,
    pub async_size: core::ffi::c_uint,
    pub ra_pages: core::ffi::c_uint,
    pub mmap_miss: core::ffi::c_uint,
    pub prev_pos: loff_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file {
    pub __bindgen_anon_1: file__bindgen_ty_1,
    pub f_lock: spinlock_t,
    pub f_mode: fmode_t,
    pub f_count: atomic_long_t,
    pub f_pos_lock: mutex,
    pub f_pos: loff_t,
    pub f_flags: core::ffi::c_uint,
    pub f_owner: fown_struct,
    pub f_cred: *const cred,
    pub f_ra: file_ra_state,
    pub f_path: path,
    pub f_inode: *mut inode,
    pub f_op: *const file_operations,
    pub f_version: u64_,
    pub f_security: *mut core::ffi::c_void,
    pub private_data: *mut core::ffi::c_void,
    pub f_ep: *mut hlist_head,
    pub f_mapping: *mut address_space,
    pub f_wb_err: errseq_t,
    pub f_sb_err: errseq_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file__bindgen_ty_1 {
    pub f_task_work: callback_head,
    pub f_llist: llist_node,
    pub f_iocb_flags: core::ffi::c_uint,
}
impl Default for file__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for file {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct file_handle {
    pub handle_bytes: __u32,
    pub handle_type: core::ffi::c_int,
    pub f_handle: __IncompleteArrayField<core::ffi::c_uchar>,
}
extern "C" {
    pub fn get_file_rcu(f: *mut *mut file) -> *mut file;
}
extern "C" {
    pub fn get_file_active(f: *mut *mut file) -> *mut file;
}
pub type fl_owner_t = *mut core::ffi::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock {
    _unused: [u8; 0],
}
extern "C" {
    pub fn send_sigio(fown: *mut fown_struct, fd: core::ffi::c_int, band: core::ffi::c_int);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fasync_struct {
    pub fa_lock: rwlock_t,
    pub magic: core::ffi::c_int,
    pub fa_fd: core::ffi::c_int,
    pub fa_next: *mut fasync_struct,
    pub fa_file: *mut file,
    pub fa_rcu: callback_head,
}
impl Default for fasync_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn fasync_helper(
        arg1: core::ffi::c_int,
        arg2: *mut file,
        arg3: core::ffi::c_int,
        arg4: *mut *mut fasync_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fasync_insert_entry(
        arg1: core::ffi::c_int,
        arg2: *mut file,
        arg3: *mut *mut fasync_struct,
        arg4: *mut fasync_struct,
    ) -> *mut fasync_struct;
}
extern "C" {
    pub fn fasync_remove_entry(arg1: *mut file, arg2: *mut *mut fasync_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn fasync_alloc() -> *mut fasync_struct;
}
extern "C" {
    pub fn fasync_free(arg1: *mut fasync_struct);
}
extern "C" {
    pub fn kill_fasync(
        arg1: *mut *mut fasync_struct,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_int,
    );
}
extern "C" {
    pub fn __f_setown(filp: *mut file, arg1: *mut pid, arg2: pid_type, force: core::ffi::c_int);
}
extern "C" {
    pub fn f_setown(
        filp: *mut file,
        who: core::ffi::c_int,
        force: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn f_delown(filp: *mut file);
}
extern "C" {
    pub fn f_getown(filp: *mut file) -> pid_t;
}
extern "C" {
    pub fn send_sigurg(fown: *mut fown_struct) -> core::ffi::c_int;
}
pub const SB_UNFROZEN: _bindgen_ty_92 = 0;
pub const SB_FREEZE_WRITE: _bindgen_ty_92 = 1;
pub const SB_FREEZE_PAGEFAULT: _bindgen_ty_92 = 2;
pub const SB_FREEZE_FS: _bindgen_ty_92 = 3;
pub const SB_FREEZE_COMPLETE: _bindgen_ty_92 = 4;
pub type _bindgen_ty_92 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sb_writers {
    pub frozen: core::ffi::c_ushort,
    pub freeze_kcount: core::ffi::c_int,
    pub freeze_ucount: core::ffi::c_int,
    pub rw_sem: [percpu_rw_semaphore; 3usize],
}
impl Default for sb_writers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct super_block {
    pub s_list: list_head,
    pub s_dev: dev_t,
    pub s_blocksize_bits: core::ffi::c_uchar,
    pub s_blocksize: core::ffi::c_ulong,
    pub s_maxbytes: loff_t,
    pub s_type: *mut file_system_type,
    pub s_op: *const super_operations,
    pub dq_op: *const dquot_operations,
    pub s_qcop: *const quotactl_ops,
    pub s_export_op: *const export_operations,
    pub s_flags: core::ffi::c_ulong,
    pub s_iflags: core::ffi::c_ulong,
    pub s_magic: core::ffi::c_ulong,
    pub s_root: *mut dentry,
    pub s_umount: rw_semaphore,
    pub s_count: core::ffi::c_int,
    pub s_active: atomic_t,
    pub s_security: *mut core::ffi::c_void,
    pub s_xattr: *const *mut xattr_handler,
    pub s_cop: *const fscrypt_operations,
    pub s_master_keys: *mut fscrypt_keyring,
    pub s_vop: *const fsverity_operations,
    pub s_encoding: *mut unicode_map,
    pub s_encoding_flags: __u16,
    pub s_roots: hlist_bl_head,
    pub s_mounts: list_head,
    pub s_bdev: *mut block_device,
    pub s_bdev_handle: *mut bdev_handle,
    pub s_bdi: *mut backing_dev_info,
    pub s_mtd: *mut mtd_info,
    pub s_instances: hlist_node,
    pub s_quota_types: core::ffi::c_uint,
    pub s_dquot: quota_info,
    pub s_writers: sb_writers,
    pub s_fs_info: *mut core::ffi::c_void,
    pub s_time_gran: u32_,
    pub s_time_min: time64_t,
    pub s_time_max: time64_t,
    pub s_fsnotify_mask: __u32,
    pub s_fsnotify_marks: *mut fsnotify_mark_connector,
    pub s_id: [core::ffi::c_char; 32usize],
    pub s_uuid: uuid_t,
    pub s_max_links: core::ffi::c_uint,
    pub s_vfs_rename_mutex: mutex,
    pub s_subtype: *const core::ffi::c_char,
    pub s_d_op: *const dentry_operations,
    pub s_shrink: *mut shrinker,
    pub s_remove_count: atomic_long_t,
    pub s_fsnotify_connectors: atomic_long_t,
    pub s_readonly_remount: core::ffi::c_int,
    pub s_wb_err: errseq_t,
    pub s_dio_done_wq: *mut workqueue_struct,
    pub s_pins: hlist_head,
    pub s_user_ns: *mut user_namespace,
    pub s_dentry_lru: list_lru,
    pub s_inode_lru: list_lru,
    pub rcu: callback_head,
    pub destroy_work: work_struct,
    pub s_sync_lock: mutex,
    pub s_stack_depth: core::ffi::c_int,
    pub __bindgen_padding_0: [u32; 11usize],
    pub s_inode_list_lock: spinlock_t,
    pub s_inodes: list_head,
    pub s_inode_wblist_lock: spinlock_t,
    pub s_inodes_wb: list_head,
}
impl Default for super_block {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn current_time(inode: *mut inode) -> timespec64;
}
extern "C" {
    pub fn inode_set_ctime_current(inode: *mut inode) -> timespec64;
}
extern "C" {
    pub fn simple_inode_init_ts(inode: *mut inode) -> timespec64;
}
extern "C" {
    pub fn inode_owner_or_capable(idmap: *mut mnt_idmap, inode: *const inode) -> bool_;
}
extern "C" {
    pub fn vfs_create(
        arg1: *mut mnt_idmap,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: umode_t,
        arg5: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_mkdir(
        arg1: *mut mnt_idmap,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: umode_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_mknod(
        arg1: *mut mnt_idmap,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: umode_t,
        arg5: dev_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_symlink(
        arg1: *mut mnt_idmap,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_link(
        arg1: *mut dentry,
        arg2: *mut mnt_idmap,
        arg3: *mut inode,
        arg4: *mut dentry,
        arg5: *mut *mut inode,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_rmdir(arg1: *mut mnt_idmap, arg2: *mut inode, arg3: *mut dentry)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_unlink(
        arg1: *mut mnt_idmap,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: *mut *mut inode,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct renamedata {
    pub old_mnt_idmap: *mut mnt_idmap,
    pub old_dir: *mut inode,
    pub old_dentry: *mut dentry,
    pub new_mnt_idmap: *mut mnt_idmap,
    pub new_dir: *mut inode,
    pub new_dentry: *mut dentry,
    pub delegated_inode: *mut *mut inode,
    pub flags: core::ffi::c_uint,
}
impl Default for renamedata {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn vfs_rename(arg1: *mut renamedata) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_tmpfile_open(
        idmap: *mut mnt_idmap,
        parentpath: *const path,
        mode: umode_t,
        open_flag: core::ffi::c_int,
        cred: *const cred,
    ) -> *mut file;
}
extern "C" {
    pub fn kernel_file_open(
        path: *const path,
        flags: core::ffi::c_int,
        inode: *mut inode,
        cred: *const cred,
    ) -> *mut file;
}
extern "C" {
    pub fn vfs_mkobj(
        arg1: *mut dentry,
        arg2: umode_t,
        f: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dentry,
                arg2: umode_t,
                arg3: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        arg3: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_fchown(file: *mut file, user: uid_t, group: gid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_fchmod(file: *mut file, mode: umode_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_utimes(path: *const path, times: *mut timespec64) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_ioctl(
        file: *mut file,
        cmd: core::ffi::c_uint,
        arg: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_ptr_ioctl(
        file: *mut file,
        cmd: core::ffi::c_uint,
        arg: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn inode_init_owner(
        idmap: *mut mnt_idmap,
        inode: *mut inode,
        dir: *const inode,
        mode: umode_t,
    );
}
extern "C" {
    pub fn may_open_dev(path: *const path) -> bool_;
}
extern "C" {
    pub fn mode_strip_sgid(idmap: *mut mnt_idmap, dir: *const inode, mode: umode_t) -> umode_t;
}
pub type filldir_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut dir_context,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_int,
        arg4: loff_t,
        arg5: u64_,
        arg6: core::ffi::c_uint,
    ) -> bool_,
>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dir_context {
    pub actor: filldir_t,
    pub pos: loff_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_uring_cmd {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wrap_directory_iterator(
        arg1: *mut file,
        arg2: *mut dir_context,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct inode_operations {
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: core::ffi::c_uint,
        ) -> *mut dentry,
    >,
    pub get_link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut delayed_call,
        ) -> *const core::ffi::c_char,
    >,
    pub permission: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub get_inode_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: core::ffi::c_int,
            arg3: bool_,
        ) -> *mut posix_acl,
    >,
    pub readlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut core::ffi::c_char,
            arg3: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
            arg5: bool_,
        ) -> core::ffi::c_int,
    >,
    pub link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut dentry,
        ) -> core::ffi::c_int,
    >,
    pub unlink: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub symlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: *const core::ffi::c_char,
        ) -> core::ffi::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
        ) -> core::ffi::c_int,
    >,
    pub rmdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub mknod: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
            arg5: dev_t,
        ) -> core::ffi::c_int,
    >,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: *mut inode,
            arg5: *mut dentry,
            arg6: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub setattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut dentry,
            arg3: *mut iattr,
        ) -> core::ffi::c_int,
    >,
    pub getattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *const path,
            arg3: *mut kstat,
            arg4: u32_,
            arg5: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub listxattr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut core::ffi::c_char, arg3: usize) -> isize,
    >,
    pub fiemap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut fiemap_extent_info,
            start: u64_,
            len: u64_,
        ) -> core::ffi::c_int,
    >,
    pub update_time: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub atomic_open: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut file,
            open_flag: core::ffi::c_uint,
            create_mode: umode_t,
        ) -> core::ffi::c_int,
    >,
    pub tmpfile: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut file,
            arg4: umode_t,
        ) -> core::ffi::c_int,
    >,
    pub get_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut dentry,
            arg3: core::ffi::c_int,
        ) -> *mut posix_acl,
    >,
    pub set_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut dentry,
            arg3: *mut posix_acl,
            arg4: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub fileattr_set: ::core::option::Option<
        unsafe extern "C" fn(
            idmap: *mut mnt_idmap,
            dentry: *mut dentry,
            fa: *mut fileattr,
        ) -> core::ffi::c_int,
    >,
    pub fileattr_get: ::core::option::Option<
        unsafe extern "C" fn(dentry: *mut dentry, fa: *mut fileattr) -> core::ffi::c_int,
    >,
    pub get_offset_ctx:
        ::core::option::Option<unsafe extern "C" fn(inode: *mut inode) -> *mut offset_ctx>,
}
impl Default for inode_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn vfs_read(
        arg1: *mut file,
        arg2: *mut core::ffi::c_char,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn vfs_write(
        arg1: *mut file,
        arg2: *const core::ffi::c_char,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn vfs_copy_file_range(
        arg1: *mut file,
        arg2: loff_t,
        arg3: *mut file,
        arg4: loff_t,
        arg5: usize,
        arg6: core::ffi::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn __generic_remap_file_range_prep(
        file_in: *mut file,
        pos_in: loff_t,
        file_out: *mut file,
        pos_out: loff_t,
        len: *mut loff_t,
        remap_flags: core::ffi::c_uint,
        dax_read_ops: *const iomap_ops,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_remap_file_range_prep(
        file_in: *mut file,
        pos_in: loff_t,
        file_out: *mut file,
        pos_out: loff_t,
        count: *mut loff_t,
        remap_flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_clone_file_range(
        file_in: *mut file,
        pos_in: loff_t,
        file_out: *mut file,
        pos_out: loff_t,
        len: loff_t,
        remap_flags: core::ffi::c_uint,
    ) -> loff_t;
}
extern "C" {
    pub fn vfs_dedupe_file_range(file: *mut file, same: *mut file_dedupe_range)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_dedupe_file_range_one(
        src_file: *mut file,
        src_pos: loff_t,
        dst_file: *mut file,
        dst_pos: loff_t,
        len: loff_t,
        remap_flags: core::ffi::c_uint,
    ) -> loff_t;
}
pub const freeze_holder_FREEZE_HOLDER_KERNEL: freeze_holder = 1;
pub const freeze_holder_FREEZE_HOLDER_USERSPACE: freeze_holder = 2;
pub const freeze_holder_FREEZE_MAY_NEST: freeze_holder = 4;
pub type freeze_holder = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct super_operations {
    pub alloc_inode:
        ::core::option::Option<unsafe extern "C" fn(sb: *mut super_block) -> *mut inode>,
    pub destroy_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub dirty_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode, flags: core::ffi::c_int)>,
    pub write_inode: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, wbc: *mut writeback_control) -> core::ffi::c_int,
    >,
    pub drop_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> core::ffi::c_int>,
    pub evict_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub put_super: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub sync_fs: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, wait: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub freeze_super: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, who: freeze_holder) -> core::ffi::c_int,
    >,
    pub freeze_fs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> core::ffi::c_int>,
    pub thaw_super: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, who: freeze_holder) -> core::ffi::c_int,
    >,
    pub unfreeze_fs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> core::ffi::c_int>,
    pub statfs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut kstatfs) -> core::ffi::c_int,
    >,
    pub remount_fs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut core::ffi::c_int,
            arg3: *mut core::ffi::c_char,
        ) -> core::ffi::c_int,
    >,
    pub umount_begin: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub show_devname: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub show_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub quota_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: core::ffi::c_int,
            arg3: *mut core::ffi::c_char,
            arg4: usize,
            arg5: loff_t,
        ) -> isize,
    >,
    pub quota_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: core::ffi::c_int,
            arg3: *const core::ffi::c_char,
            arg4: usize,
            arg5: loff_t,
        ) -> isize,
    >,
    pub get_dquots:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut *mut dquot>,
    pub nr_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut shrink_control,
        ) -> core::ffi::c_long,
    >,
    pub free_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut shrink_control,
        ) -> core::ffi::c_long,
    >,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(sb: *mut super_block)>,
}
extern "C" {
    pub fn __mark_inode_dirty(arg1: *mut inode, arg2: core::ffi::c_int);
}
extern "C" {
    pub fn inc_nlink(inode: *mut inode);
}
extern "C" {
    pub fn drop_nlink(inode: *mut inode);
}
extern "C" {
    pub fn clear_nlink(inode: *mut inode);
}
extern "C" {
    pub fn set_nlink(inode: *mut inode, nlink: core::ffi::c_uint);
}
pub const file_time_flags_S_ATIME: file_time_flags = 1;
pub const file_time_flags_S_MTIME: file_time_flags = 2;
pub const file_time_flags_S_CTIME: file_time_flags = 4;
pub const file_time_flags_S_VERSION: file_time_flags = 8;
pub type file_time_flags = core::ffi::c_uint;
extern "C" {
    pub fn atime_needs_update(arg1: *const path, arg2: *mut inode) -> bool_;
}
extern "C" {
    pub fn touch_atime(arg1: *const path);
}
extern "C" {
    pub fn inode_update_time(inode: *mut inode, flags: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn file_modified(file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn kiocb_modified(iocb: *mut kiocb) -> core::ffi::c_int;
}
extern "C" {
    pub fn sync_inode_metadata(inode: *mut inode, wait: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn mount_bdev(
        fs_type: *mut file_system_type,
        flags: core::ffi::c_int,
        dev_name: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut core::ffi::c_void,
                arg3: core::ffi::c_int,
            ) -> core::ffi::c_int,
        >,
    ) -> *mut dentry;
}
extern "C" {
    pub fn mount_single(
        fs_type: *mut file_system_type,
        flags: core::ffi::c_int,
        data: *mut core::ffi::c_void,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut core::ffi::c_void,
                arg3: core::ffi::c_int,
            ) -> core::ffi::c_int,
        >,
    ) -> *mut dentry;
}
extern "C" {
    pub fn mount_nodev(
        fs_type: *mut file_system_type,
        flags: core::ffi::c_int,
        data: *mut core::ffi::c_void,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut core::ffi::c_void,
                arg3: core::ffi::c_int,
            ) -> core::ffi::c_int,
        >,
    ) -> *mut dentry;
}
extern "C" {
    pub fn mount_subtree(mnt: *mut vfsmount, path: *const core::ffi::c_char) -> *mut dentry;
}
extern "C" {
    pub fn retire_super(sb: *mut super_block);
}
extern "C" {
    pub fn generic_shutdown_super(sb: *mut super_block);
}
extern "C" {
    pub fn kill_block_super(sb: *mut super_block);
}
extern "C" {
    pub fn kill_anon_super(sb: *mut super_block);
}
extern "C" {
    pub fn kill_litter_super(sb: *mut super_block);
}
extern "C" {
    pub fn deactivate_super(sb: *mut super_block);
}
extern "C" {
    pub fn deactivate_locked_super(sb: *mut super_block);
}
extern "C" {
    pub fn set_anon_super(s: *mut super_block, data: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_anon_super_fc(s: *mut super_block, fc: *mut fs_context) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_anon_bdev(arg1: *mut dev_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn free_anon_bdev(arg1: dev_t);
}
extern "C" {
    pub fn sget_fc(
        fc: *mut fs_context,
        test: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut fs_context) -> core::ffi::c_int,
        >,
        set: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut fs_context) -> core::ffi::c_int,
        >,
    ) -> *mut super_block;
}
extern "C" {
    pub fn sget(
        type_: *mut file_system_type,
        test: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        set: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        flags: core::ffi::c_int,
        data: *mut core::ffi::c_void,
    ) -> *mut super_block;
}
extern "C" {
    pub fn sget_dev(fc: *mut fs_context, dev: dev_t) -> *mut super_block;
}
extern "C" {
    pub fn register_filesystem(arg1: *mut file_system_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_filesystem(arg1: *mut file_system_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_statfs(arg1: *const path, arg2: *mut kstatfs) -> core::ffi::c_int;
}
extern "C" {
    pub fn user_statfs(arg1: *const core::ffi::c_char, arg2: *mut kstatfs) -> core::ffi::c_int;
}
extern "C" {
    pub fn fd_statfs(arg1: core::ffi::c_int, arg2: *mut kstatfs) -> core::ffi::c_int;
}
extern "C" {
    pub fn freeze_super(super_: *mut super_block, who: freeze_holder) -> core::ffi::c_int;
}
extern "C" {
    pub fn thaw_super(super_: *mut super_block, who: freeze_holder) -> core::ffi::c_int;
}
extern "C" {
    pub fn super_setup_bdi_name(
        sb: *mut super_block,
        fmt: *mut core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn super_setup_bdi(sb: *mut super_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn current_umask() -> core::ffi::c_int;
}
extern "C" {
    pub fn ihold(inode: *mut inode);
}
extern "C" {
    pub fn iput(arg1: *mut inode);
}
extern "C" {
    pub fn inode_update_timestamps(inode: *mut inode, flags: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_update_time(arg1: *mut inode, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub static mut fs_kobj: *mut kobject;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_names {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct filename {
    pub name: *const core::ffi::c_char,
    pub uptr: *const core::ffi::c_char,
    pub refcnt: atomic_t,
    pub aname: *mut audit_names,
    pub iname: __IncompleteArrayField<core::ffi::c_char>,
}
impl Default for filename {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn vfs_truncate(arg1: *const path, arg2: loff_t) -> core::ffi::c_long;
}
extern "C" {
    pub fn do_truncate(
        arg1: *mut mnt_idmap,
        arg2: *mut dentry,
        start: loff_t,
        time_attrs: core::ffi::c_uint,
        filp: *mut file,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_fallocate(
        file: *mut file,
        mode: core::ffi::c_int,
        offset: loff_t,
        len: loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_sys_open(
        dfd: core::ffi::c_int,
        filename: *const core::ffi::c_char,
        flags: core::ffi::c_int,
        mode: umode_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn file_open_name(arg1: *mut filename, arg2: core::ffi::c_int, arg3: umode_t) -> *mut file;
}
extern "C" {
    pub fn filp_open(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
        arg3: umode_t,
    ) -> *mut file;
}
extern "C" {
    pub fn file_open_root(
        arg1: *const path,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_int,
        arg4: umode_t,
    ) -> *mut file;
}
extern "C" {
    pub fn dentry_open(path: *const path, flags: core::ffi::c_int, creds: *const cred)
        -> *mut file;
}
extern "C" {
    pub fn dentry_create(
        path: *const path,
        flags: core::ffi::c_int,
        mode: umode_t,
        cred: *const cred,
    ) -> *mut file;
}
extern "C" {
    pub fn backing_file_user_path(f: *mut file) -> *mut path;
}
extern "C" {
    pub fn filp_close(arg1: *mut file, id: fl_owner_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn getname_flags(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_int,
    ) -> *mut filename;
}
extern "C" {
    pub fn getname_uflags(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int) -> *mut filename;
}
extern "C" {
    pub fn getname(arg1: *const core::ffi::c_char) -> *mut filename;
}
extern "C" {
    pub fn getname_kernel(arg1: *const core::ffi::c_char) -> *mut filename;
}
extern "C" {
    pub fn putname(name: *mut filename);
}
extern "C" {
    pub fn finish_open(
        file: *mut file,
        dentry: *mut dentry,
        open: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn finish_no_open(file: *mut file, dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_caches_init_early();
}
extern "C" {
    pub fn vfs_caches_init();
}
extern "C" {
    pub static mut names_cachep: *mut kmem_cache;
}
extern "C" {
    pub static mut blockdev_superblock: *mut super_block;
}
extern "C" {
    pub fn emergency_thaw_all();
}
extern "C" {
    pub fn sync_filesystem(arg1: *mut super_block) -> core::ffi::c_int;
}
extern "C" {
    pub static def_blk_fops: file_operations;
}
extern "C" {
    pub static def_chr_fops: file_operations;
}
extern "C" {
    pub fn alloc_chrdev_region(
        arg1: *mut dev_t,
        arg2: core::ffi::c_uint,
        arg3: core::ffi::c_uint,
        arg4: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn register_chrdev_region(
        arg1: dev_t,
        arg2: core::ffi::c_uint,
        arg3: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __register_chrdev(
        major: core::ffi::c_uint,
        baseminor: core::ffi::c_uint,
        count: core::ffi::c_uint,
        name: *const core::ffi::c_char,
        fops: *const file_operations,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __unregister_chrdev(
        major: core::ffi::c_uint,
        baseminor: core::ffi::c_uint,
        count: core::ffi::c_uint,
        name: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn unregister_chrdev_region(arg1: dev_t, arg2: core::ffi::c_uint);
}
extern "C" {
    pub fn chrdev_show(arg1: *mut seq_file, arg2: off_t);
}
extern "C" {
    pub fn init_special_inode(arg1: *mut inode, arg2: umode_t, arg3: dev_t);
}
extern "C" {
    pub fn make_bad_inode(arg1: *mut inode);
}
extern "C" {
    pub fn is_bad_inode(arg1: *mut inode) -> bool_;
}
extern "C" {
    pub fn file_fdatawait_range(file: *mut file, lstart: loff_t, lend: loff_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn file_check_and_advance_wb_err(file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn file_write_and_wait_range(
        file: *mut file,
        start: loff_t,
        end: loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_fsync_range(
        file: *mut file,
        start: loff_t,
        end: loff_t,
        datasync: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_fsync(file: *mut file, datasync: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn sync_file_range(
        file: *mut file,
        offset: loff_t,
        nbytes: loff_t,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn emergency_sync();
}
extern "C" {
    pub fn emergency_remount();
}
extern "C" {
    pub fn bmap(inode: *mut inode, block: *mut sector_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn notify_change(
        arg1: *mut mnt_idmap,
        arg2: *mut dentry,
        arg3: *mut iattr,
        arg4: *mut *mut inode,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn inode_permission(
        arg1: *mut mnt_idmap,
        arg2: *mut inode,
        arg3: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_permission(
        arg1: *mut mnt_idmap,
        arg2: *mut inode,
        arg3: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __check_sticky(
        idmap: *mut mnt_idmap,
        dir: *mut inode,
        inode: *mut inode,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_pipe_flags(arg1: *mut core::ffi::c_int, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_read(
        arg1: *mut file,
        arg2: *mut core::ffi::c_void,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn __kernel_read(
        file: *mut file,
        buf: *mut core::ffi::c_void,
        count: usize,
        pos: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn kernel_write(
        arg1: *mut file,
        arg2: *const core::ffi::c_void,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn __kernel_write(
        arg1: *mut file,
        arg2: *const core::ffi::c_void,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn open_exec(arg1: *const core::ffi::c_char) -> *mut file;
}
extern "C" {
    pub fn is_subdir(arg1: *mut dentry, arg2: *mut dentry) -> bool_;
}
extern "C" {
    pub fn path_is_under(arg1: *const path, arg2: *const path) -> bool_;
}
extern "C" {
    pub fn file_path(
        arg1: *mut file,
        arg2: *mut core::ffi::c_char,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn default_llseek(file: *mut file, offset: loff_t, whence: core::ffi::c_int) -> loff_t;
}
extern "C" {
    pub fn vfs_llseek(file: *mut file, offset: loff_t, whence: core::ffi::c_int) -> loff_t;
}
extern "C" {
    pub fn inode_init_always(arg1: *mut super_block, arg2: *mut inode) -> core::ffi::c_int;
}
extern "C" {
    pub fn inode_init_once(arg1: *mut inode);
}
extern "C" {
    pub fn address_space_init_once(mapping: *mut address_space);
}
extern "C" {
    pub fn igrab(arg1: *mut inode) -> *mut inode;
}
extern "C" {
    pub fn iunique(arg1: *mut super_block, arg2: ino_t) -> ino_t;
}
extern "C" {
    pub fn inode_needs_sync(inode: *mut inode) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_delete_inode(inode: *mut inode) -> core::ffi::c_int;
}
extern "C" {
    pub fn d_mark_dontcache(inode: *mut inode);
}
extern "C" {
    pub fn ilookup5_nowait(
        sb: *mut super_block,
        hashval: core::ffi::c_ulong,
        test: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn ilookup5(
        sb: *mut super_block,
        hashval: core::ffi::c_ulong,
        test: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn ilookup(sb: *mut super_block, ino: core::ffi::c_ulong) -> *mut inode;
}
extern "C" {
    pub fn inode_insert5(
        inode: *mut inode,
        hashval: core::ffi::c_ulong,
        test: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        set: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn iget5_locked(
        arg1: *mut super_block,
        arg2: core::ffi::c_ulong,
        test: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        set: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        arg3: *mut core::ffi::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn iget_locked(arg1: *mut super_block, arg2: core::ffi::c_ulong) -> *mut inode;
}
extern "C" {
    pub fn find_inode_nowait(
        arg1: *mut super_block,
        arg2: core::ffi::c_ulong,
        match_: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: core::ffi::c_ulong,
                arg3: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn find_inode_rcu(
        arg1: *mut super_block,
        arg2: core::ffi::c_ulong,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        arg4: *mut core::ffi::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn find_inode_by_ino_rcu(arg1: *mut super_block, arg2: core::ffi::c_ulong) -> *mut inode;
}
extern "C" {
    pub fn insert_inode_locked4(
        arg1: *mut inode,
        arg2: core::ffi::c_ulong,
        test: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        arg3: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn insert_inode_locked(arg1: *mut inode) -> core::ffi::c_int;
}
extern "C" {
    pub fn unlock_new_inode(arg1: *mut inode);
}
extern "C" {
    pub fn discard_new_inode(arg1: *mut inode);
}
extern "C" {
    pub fn get_next_ino() -> core::ffi::c_uint;
}
extern "C" {
    pub fn evict_inodes(sb: *mut super_block);
}
extern "C" {
    pub fn dump_mapping(arg1: *const address_space);
}
extern "C" {
    pub fn __iget(inode: *mut inode);
}
extern "C" {
    pub fn iget_failed(arg1: *mut inode);
}
extern "C" {
    pub fn clear_inode(arg1: *mut inode);
}
extern "C" {
    pub fn __destroy_inode(arg1: *mut inode);
}
extern "C" {
    pub fn new_inode_pseudo(sb: *mut super_block) -> *mut inode;
}
extern "C" {
    pub fn new_inode(sb: *mut super_block) -> *mut inode;
}
extern "C" {
    pub fn free_inode_nonrcu(inode: *mut inode);
}
extern "C" {
    pub fn setattr_should_drop_suidgid(arg1: *mut mnt_idmap, arg2: *mut inode) -> core::ffi::c_int;
}
extern "C" {
    pub fn file_remove_privs(arg1: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn setattr_should_drop_sgid(idmap: *mut mnt_idmap, inode: *const inode)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn __insert_inode_hash(arg1: *mut inode, hashval: core::ffi::c_ulong);
}
extern "C" {
    pub fn __remove_inode_hash(arg1: *mut inode);
}
extern "C" {
    pub fn inode_sb_list_add(inode: *mut inode);
}
extern "C" {
    pub fn inode_add_lru(inode: *mut inode);
}
extern "C" {
    pub fn sb_set_blocksize(arg1: *mut super_block, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn sb_min_blocksize(arg1: *mut super_block, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_file_mmap(arg1: *mut file, arg2: *mut vm_area_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_file_readonly_mmap(
        arg1: *mut file,
        arg2: *mut vm_area_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_write_checks(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn generic_write_checks_count(iocb: *mut kiocb, count: *mut loff_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_write_check_limits(
        file: *mut file,
        pos: loff_t,
        count: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_file_rw_checks(file_in: *mut file, file_out: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn filemap_read(iocb: *mut kiocb, to: *mut iov_iter, already_read: isize) -> isize;
}
extern "C" {
    pub fn generic_file_read_iter(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn __generic_file_write_iter(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn generic_file_write_iter(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn generic_file_direct_write(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn generic_perform_write(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn direct_write_fallback(
        iocb: *mut kiocb,
        iter: *mut iov_iter,
        direct_written: isize,
        buffered_written: isize,
    ) -> isize;
}
extern "C" {
    pub fn vfs_iter_read(
        file: *mut file,
        iter: *mut iov_iter,
        ppos: *mut loff_t,
        flags: rwf_t,
    ) -> isize;
}
extern "C" {
    pub fn vfs_iter_write(
        file: *mut file,
        iter: *mut iov_iter,
        ppos: *mut loff_t,
        flags: rwf_t,
    ) -> isize;
}
extern "C" {
    pub fn vfs_iocb_iter_read(file: *mut file, iocb: *mut kiocb, iter: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn vfs_iocb_iter_write(file: *mut file, iocb: *mut kiocb, iter: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn filemap_splice_read(
        in_: *mut file,
        ppos: *mut loff_t,
        pipe: *mut pipe_inode_info,
        len: usize,
        flags: core::ffi::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn copy_splice_read(
        in_: *mut file,
        ppos: *mut loff_t,
        pipe: *mut pipe_inode_info,
        len: usize,
        flags: core::ffi::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn iter_file_splice_write(
        arg1: *mut pipe_inode_info,
        arg2: *mut file,
        arg3: *mut loff_t,
        arg4: usize,
        arg5: core::ffi::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn file_ra_state_init(ra: *mut file_ra_state, mapping: *mut address_space);
}
extern "C" {
    pub fn noop_llseek(file: *mut file, offset: loff_t, whence: core::ffi::c_int) -> loff_t;
}
extern "C" {
    pub fn vfs_setpos(file: *mut file, offset: loff_t, maxsize: loff_t) -> loff_t;
}
extern "C" {
    pub fn generic_file_llseek(file: *mut file, offset: loff_t, whence: core::ffi::c_int)
        -> loff_t;
}
extern "C" {
    pub fn generic_file_llseek_size(
        file: *mut file,
        offset: loff_t,
        whence: core::ffi::c_int,
        maxsize: loff_t,
        eof: loff_t,
    ) -> loff_t;
}
extern "C" {
    pub fn fixed_size_llseek(
        file: *mut file,
        offset: loff_t,
        whence: core::ffi::c_int,
        size: loff_t,
    ) -> loff_t;
}
extern "C" {
    pub fn no_seek_end_llseek_size(
        arg1: *mut file,
        arg2: loff_t,
        arg3: core::ffi::c_int,
        arg4: loff_t,
    ) -> loff_t;
}
extern "C" {
    pub fn no_seek_end_llseek(arg1: *mut file, arg2: loff_t, arg3: core::ffi::c_int) -> loff_t;
}
extern "C" {
    pub fn rw_verify_area(
        arg1: core::ffi::c_int,
        arg2: *mut file,
        arg3: *const loff_t,
        arg4: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_file_open(inode: *mut inode, filp: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn nonseekable_open(inode: *mut inode, filp: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn stream_open(inode: *mut inode, filp: *mut file) -> core::ffi::c_int;
}
pub type dio_submit_t = ::core::option::Option<
    unsafe extern "C" fn(bio: *mut bio, inode: *mut inode, file_offset: loff_t),
>;
pub const DIO_LOCKING: _bindgen_ty_93 = 1;
pub const DIO_SKIP_HOLES: _bindgen_ty_93 = 2;
pub type _bindgen_ty_93 = core::ffi::c_uint;
extern "C" {
    pub fn __blockdev_direct_IO(
        iocb: *mut kiocb,
        inode: *mut inode,
        bdev: *mut block_device,
        iter: *mut iov_iter,
        get_block: get_block_t,
        end_io: dio_iodone_t,
        flags: core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    pub fn inode_dio_wait(inode: *mut inode);
}
extern "C" {
    pub fn inode_set_flags(inode: *mut inode, flags: core::ffi::c_uint, mask: core::ffi::c_uint);
}
extern "C" {
    pub static generic_ro_fops: file_operations;
}
extern "C" {
    pub fn readlink_copy(
        arg1: *mut core::ffi::c_char,
        arg2: core::ffi::c_int,
        arg3: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn page_readlink(
        arg1: *mut dentry,
        arg2: *mut core::ffi::c_char,
        arg3: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn page_get_link(
        arg1: *mut dentry,
        arg2: *mut inode,
        arg3: *mut delayed_call,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn page_put_link(arg1: *mut core::ffi::c_void);
}
extern "C" {
    pub fn page_symlink(
        inode: *mut inode,
        symname: *const core::ffi::c_char,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static page_symlink_inode_operations: inode_operations;
}
extern "C" {
    pub fn kfree_link(arg1: *mut core::ffi::c_void);
}
extern "C" {
    pub fn generic_fillattr(arg1: *mut mnt_idmap, arg2: u32_, arg3: *mut inode, arg4: *mut kstat);
}
extern "C" {
    pub fn generic_fill_statx_attr(inode: *mut inode, stat: *mut kstat);
}
extern "C" {
    pub fn vfs_getattr_nosec(
        arg1: *const path,
        arg2: *mut kstat,
        arg3: u32_,
        arg4: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_getattr(
        arg1: *const path,
        arg2: *mut kstat,
        arg3: u32_,
        arg4: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __inode_add_bytes(inode: *mut inode, bytes: loff_t);
}
extern "C" {
    pub fn inode_add_bytes(inode: *mut inode, bytes: loff_t);
}
extern "C" {
    pub fn __inode_sub_bytes(inode: *mut inode, bytes: loff_t);
}
extern "C" {
    pub fn inode_sub_bytes(inode: *mut inode, bytes: loff_t);
}
extern "C" {
    pub fn inode_get_bytes(inode: *mut inode) -> loff_t;
}
extern "C" {
    pub fn inode_set_bytes(inode: *mut inode, bytes: loff_t);
}
extern "C" {
    pub fn simple_get_link(
        arg1: *mut dentry,
        arg2: *mut inode,
        arg3: *mut delayed_call,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub static simple_symlink_inode_operations: inode_operations;
}
extern "C" {
    pub fn iterate_dir(arg1: *mut file, arg2: *mut dir_context) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_fstatat(
        dfd: core::ffi::c_int,
        filename: *const core::ffi::c_char,
        stat: *mut kstat,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_fstat(fd: core::ffi::c_int, stat: *mut kstat) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_get_link(arg1: *mut dentry, arg2: *mut delayed_call) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn vfs_readlink(
        arg1: *mut dentry,
        arg2: *mut core::ffi::c_char,
        arg3: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_filesystem(fs: *mut file_system_type) -> *mut file_system_type;
}
extern "C" {
    pub fn put_filesystem(fs: *mut file_system_type);
}
extern "C" {
    pub fn get_fs_type(name: *const core::ffi::c_char) -> *mut file_system_type;
}
extern "C" {
    pub fn drop_super(sb: *mut super_block);
}
extern "C" {
    pub fn drop_super_exclusive(sb: *mut super_block);
}
extern "C" {
    pub fn iterate_supers(
        arg1: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut core::ffi::c_void),
        >,
        arg2: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn iterate_supers_type(
        arg1: *mut file_system_type,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut core::ffi::c_void),
        >,
        arg3: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn dcache_dir_open(arg1: *mut inode, arg2: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn dcache_dir_close(arg1: *mut inode, arg2: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn dcache_dir_lseek(arg1: *mut file, arg2: loff_t, arg3: core::ffi::c_int) -> loff_t;
}
extern "C" {
    pub fn dcache_readdir(arg1: *mut file, arg2: *mut dir_context) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_setattr(
        arg1: *mut mnt_idmap,
        arg2: *mut dentry,
        arg3: *mut iattr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_getattr(
        arg1: *mut mnt_idmap,
        arg2: *const path,
        arg3: *mut kstat,
        arg4: u32_,
        arg5: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_statfs(arg1: *mut dentry, arg2: *mut kstatfs) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_open(inode: *mut inode, file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_link(arg1: *mut dentry, arg2: *mut inode, arg3: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_unlink(arg1: *mut inode, arg2: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_rmdir(arg1: *mut inode, arg2: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_rename_timestamp(
        old_dir: *mut inode,
        old_dentry: *mut dentry,
        new_dir: *mut inode,
        new_dentry: *mut dentry,
    );
}
extern "C" {
    pub fn simple_rename_exchange(
        old_dir: *mut inode,
        old_dentry: *mut dentry,
        new_dir: *mut inode,
        new_dentry: *mut dentry,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_rename(
        arg1: *mut mnt_idmap,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: *mut inode,
        arg5: *mut dentry,
        arg6: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_recursive_removal(
        arg1: *mut dentry,
        callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    );
}
extern "C" {
    pub fn noop_fsync(
        arg1: *mut file,
        arg2: loff_t,
        arg3: loff_t,
        arg4: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn noop_direct_IO(iocb: *mut kiocb, iter: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn simple_empty(arg1: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_write_begin(
        file: *mut file,
        mapping: *mut address_space,
        pos: loff_t,
        len: core::ffi::c_uint,
        pagep: *mut *mut page,
        fsdata: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static ram_aops: address_space_operations;
}
extern "C" {
    pub fn always_delete_dentry(arg1: *const dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn alloc_anon_inode(arg1: *mut super_block) -> *mut inode;
}
extern "C" {
    pub fn simple_nosetlease(
        arg1: *mut file,
        arg2: core::ffi::c_int,
        arg3: *mut *mut file_lock,
        arg4: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static simple_dentry_operations: dentry_operations;
}
extern "C" {
    pub fn simple_lookup(
        arg1: *mut inode,
        arg2: *mut dentry,
        flags: core::ffi::c_uint,
    ) -> *mut dentry;
}
extern "C" {
    pub fn generic_read_dir(
        arg1: *mut file,
        arg2: *mut core::ffi::c_char,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub static simple_dir_operations: file_operations;
}
extern "C" {
    pub static simple_dir_inode_operations: inode_operations;
}
extern "C" {
    pub fn make_empty_dir_inode(inode: *mut inode);
}
extern "C" {
    pub fn is_empty_dir_inode(inode: *mut inode) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tree_descr {
    pub name: *const core::ffi::c_char,
    pub ops: *const file_operations,
    pub mode: core::ffi::c_int,
}
impl Default for tree_descr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn d_alloc_name(arg1: *mut dentry, arg2: *const core::ffi::c_char) -> *mut dentry;
}
extern "C" {
    pub fn simple_fill_super(
        arg1: *mut super_block,
        arg2: core::ffi::c_ulong,
        arg3: *const tree_descr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_pin_fs(
        arg1: *mut file_system_type,
        mount: *mut *mut vfsmount,
        count: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_release_fs(mount: *mut *mut vfsmount, count: *mut core::ffi::c_int);
}
extern "C" {
    pub fn simple_read_from_buffer(
        to: *mut core::ffi::c_void,
        count: usize,
        ppos: *mut loff_t,
        from: *const core::ffi::c_void,
        available: usize,
    ) -> isize;
}
extern "C" {
    pub fn simple_write_to_buffer(
        to: *mut core::ffi::c_void,
        available: usize,
        ppos: *mut loff_t,
        from: *const core::ffi::c_void,
        count: usize,
    ) -> isize;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct offset_ctx {
    pub mt: maple_tree,
    pub next_offset: core::ffi::c_ulong,
}
impl Default for offset_ctx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn simple_offset_init(octx: *mut offset_ctx);
}
extern "C" {
    pub fn simple_offset_add(octx: *mut offset_ctx, dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_offset_remove(octx: *mut offset_ctx, dentry: *mut dentry);
}
extern "C" {
    pub fn simple_offset_empty(dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_offset_rename(
        old_dir: *mut inode,
        old_dentry: *mut dentry,
        new_dir: *mut inode,
        new_dentry: *mut dentry,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_offset_rename_exchange(
        old_dir: *mut inode,
        old_dentry: *mut dentry,
        new_dir: *mut inode,
        new_dentry: *mut dentry,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_offset_destroy(octx: *mut offset_ctx);
}
extern "C" {
    pub static simple_offset_dir_operations: file_operations;
}
extern "C" {
    pub fn __generic_file_fsync(
        arg1: *mut file,
        arg2: loff_t,
        arg3: loff_t,
        arg4: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_file_fsync(
        arg1: *mut file,
        arg2: loff_t,
        arg3: loff_t,
        arg4: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_check_addressable(arg1: core::ffi::c_uint, arg2: u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_set_encrypted_ci_d_ops(dentry: *mut dentry);
}
extern "C" {
    pub fn may_setattr(
        idmap: *mut mnt_idmap,
        inode: *mut inode,
        ia_valid: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn setattr_prepare(
        arg1: *mut mnt_idmap,
        arg2: *mut dentry,
        arg3: *mut iattr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn inode_newsize_ok(arg1: *const inode, offset: loff_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn setattr_copy(arg1: *mut mnt_idmap, inode: *mut inode, attr: *const iattr);
}
extern "C" {
    pub fn file_update_time(file: *mut file) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default)]
pub struct simple_transaction_argresp {
    pub size: isize,
    pub data: __IncompleteArrayField<core::ffi::c_char>,
}
extern "C" {
    pub fn simple_transaction_get(
        file: *mut file,
        buf: *const core::ffi::c_char,
        size: usize,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn simple_transaction_read(
        file: *mut file,
        buf: *mut core::ffi::c_char,
        size: usize,
        pos: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn simple_transaction_release(inode: *mut inode, file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_transaction_set(file: *mut file, n: usize);
}
extern "C" {
    pub fn simple_attr_open(
        inode: *mut inode,
        file: *mut file,
        get: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void, arg2: *mut u64_) -> core::ffi::c_int,
        >,
        set: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void, arg2: u64_) -> core::ffi::c_int,
        >,
        fmt: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_attr_release(inode: *mut inode, file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_attr_read(
        file: *mut file,
        buf: *mut core::ffi::c_char,
        len: usize,
        ppos: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn simple_attr_write(
        file: *mut file,
        buf: *const core::ffi::c_char,
        len: usize,
        ppos: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn simple_attr_write_signed(
        file: *mut file,
        buf: *const core::ffi::c_char,
        len: usize,
        ppos: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn list_bdev_fs_names(buf: *mut core::ffi::c_char, size: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn path_noexec(path: *const path) -> bool_;
}
extern "C" {
    pub fn inode_nohighmem(inode: *mut inode);
}
extern "C" {
    pub fn vfs_fadvise(
        file: *mut file,
        offset: loff_t,
        len: loff_t,
        advice: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_fadvise(
        file: *mut file,
        offset: loff_t,
        len: loff_t,
        advice: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
pub type aio_context_t = __kernel_ulong_t;
pub const IOCB_CMD_PREAD: _bindgen_ty_94 = 0;
pub const IOCB_CMD_PWRITE: _bindgen_ty_94 = 1;
pub const IOCB_CMD_FSYNC: _bindgen_ty_94 = 2;
pub const IOCB_CMD_FDSYNC: _bindgen_ty_94 = 3;
pub const IOCB_CMD_POLL: _bindgen_ty_94 = 5;
pub const IOCB_CMD_NOOP: _bindgen_ty_94 = 6;
pub const IOCB_CMD_PREADV: _bindgen_ty_94 = 7;
pub const IOCB_CMD_PWRITEV: _bindgen_ty_94 = 8;
pub type _bindgen_ty_94 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct io_event {
    pub data: __u64,
    pub obj: __u64,
    pub res: __s64,
    pub res2: __s64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct iocb {
    pub aio_data: __u64,
    pub aio_key: __u32,
    pub aio_rw_flags: __kernel_rwf_t,
    pub aio_lio_opcode: __u16,
    pub aio_reqprio: __s16,
    pub aio_fildes: __u32,
    pub aio_buf: __u64,
    pub aio_nbytes: __u64,
    pub aio_offset: __s64,
    pub aio_reserved2: __u64,
    pub aio_flags: __u32,
    pub aio_resfd: __u32,
}
extern "C" {
    pub fn put_task_stack(tsk: *mut task_struct);
}
extern "C" {
    pub fn exit_task_stack_account(tsk: *mut task_struct);
}
extern "C" {
    pub fn thread_stack_cache_init();
}
extern "C" {
    pub fn set_task_stack_end_magic(tsk: *mut task_struct);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct user_i387_ia32_struct {
    pub cwd: u32_,
    pub swd: u32_,
    pub twd: u32_,
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
    pub st_space: [u32_; 20usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user32_fxsr_struct {
    pub cwd: core::ffi::c_ushort,
    pub swd: core::ffi::c_ushort,
    pub twd: core::ffi::c_ushort,
    pub fop: core::ffi::c_ushort,
    pub fip: core::ffi::c_int,
    pub fcs: core::ffi::c_int,
    pub foo: core::ffi::c_int,
    pub fos: core::ffi::c_int,
    pub mxcsr: core::ffi::c_int,
    pub reserved: core::ffi::c_int,
    pub st_space: [core::ffi::c_int; 32usize],
    pub xmm_space: [core::ffi::c_int; 32usize],
    pub padding: [core::ffi::c_int; 56usize],
}
impl Default for user32_fxsr_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct user_regs_struct32 {
    pub ebx: __u32,
    pub ecx: __u32,
    pub edx: __u32,
    pub esi: __u32,
    pub edi: __u32,
    pub ebp: __u32,
    pub eax: __u32,
    pub ds: core::ffi::c_ushort,
    pub __ds: core::ffi::c_ushort,
    pub es: core::ffi::c_ushort,
    pub __es: core::ffi::c_ushort,
    pub fs: core::ffi::c_ushort,
    pub __fs: core::ffi::c_ushort,
    pub gs: core::ffi::c_ushort,
    pub __gs: core::ffi::c_ushort,
    pub orig_eax: __u32,
    pub eip: __u32,
    pub cs: core::ffi::c_ushort,
    pub __cs: core::ffi::c_ushort,
    pub eflags: __u32,
    pub esp: __u32,
    pub ss: core::ffi::c_ushort,
    pub __ss: core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct user32 {
    pub regs: user_regs_struct32,
    pub u_fpvalid: core::ffi::c_int,
    pub i387: user_i387_ia32_struct,
    pub u_tsize: __u32,
    pub u_dsize: __u32,
    pub u_ssize: __u32,
    pub start_code: __u32,
    pub start_stack: __u32,
    pub signal: __u32,
    pub reserved: core::ffi::c_int,
    pub u_ar0: __u32,
    pub u_fpstate: __u32,
    pub magic: __u32,
    pub u_comm: [core::ffi::c_char; 32usize],
    pub u_debugreg: [core::ffi::c_int; 8usize],
}
pub type compat_mode_t = u16_;
pub type __compat_uid_t = u16_;
pub type __compat_gid_t = u16_;
pub type compat_dev_t = u16_;
pub type compat_ipc_pid_t = u16_;
pub type compat_size_t = u32_;
pub type compat_ssize_t = s32;
pub type compat_clock_t = s32;
pub type compat_pid_t = s32;
pub type compat_ino_t = u32_;
pub type compat_off_t = s32;
pub type compat_loff_t = s64;
pub type compat_daddr_t = s32;
pub type compat_timer_t = s32;
pub type compat_key_t = s32;
pub type compat_short_t = s16;
pub type compat_int_t = s32;
pub type compat_long_t = s32;
pub type compat_ushort_t = u16_;
pub type compat_uint_t = u32_;
pub type compat_ulong_t = u32_;
pub type compat_uptr_t = u32_;
pub type compat_caddr_t = u32_;
pub type compat_aio_context_t = u32_;
pub type compat_old_sigset_t = u32_;
pub type __compat_uid32_t = u32_;
pub type __compat_gid32_t = u32_;
pub type compat_s64 = s64;
pub type compat_u64 = u64_;
pub type compat_sigset_word = u32_;
pub type compat_fsid_t = __kernel_fsid_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_ipc64_perm {
    pub key: compat_key_t,
    pub uid: __compat_uid32_t,
    pub gid: __compat_gid32_t,
    pub cuid: __compat_uid32_t,
    pub cgid: __compat_gid32_t,
    pub mode: compat_mode_t,
    pub __pad1: [core::ffi::c_uchar; 2usize],
    pub seq: compat_ushort_t,
    pub __pad2: compat_ushort_t,
    pub unused1: compat_ulong_t,
    pub unused2: compat_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_semid64_ds {
    pub sem_perm: compat_ipc64_perm,
    pub sem_otime: compat_ulong_t,
    pub sem_otime_high: compat_ulong_t,
    pub sem_ctime: compat_ulong_t,
    pub sem_ctime_high: compat_ulong_t,
    pub sem_nsems: compat_ulong_t,
    pub __unused3: compat_ulong_t,
    pub __unused4: compat_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_msqid64_ds {
    pub msg_perm: compat_ipc64_perm,
    pub msg_stime: compat_ulong_t,
    pub msg_stime_high: compat_ulong_t,
    pub msg_rtime: compat_ulong_t,
    pub msg_rtime_high: compat_ulong_t,
    pub msg_ctime: compat_ulong_t,
    pub msg_ctime_high: compat_ulong_t,
    pub msg_cbytes: compat_ulong_t,
    pub msg_qnum: compat_ulong_t,
    pub msg_qbytes: compat_ulong_t,
    pub msg_lspid: compat_pid_t,
    pub msg_lrpid: compat_pid_t,
    pub __unused4: compat_ulong_t,
    pub __unused5: compat_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_shmid64_ds {
    pub shm_perm: compat_ipc64_perm,
    pub shm_segsz: compat_size_t,
    pub shm_atime: compat_ulong_t,
    pub shm_atime_high: compat_ulong_t,
    pub shm_dtime: compat_ulong_t,
    pub shm_dtime_high: compat_ulong_t,
    pub shm_ctime: compat_ulong_t,
    pub shm_ctime_high: compat_ulong_t,
    pub shm_cpid: compat_pid_t,
    pub shm_lpid: compat_pid_t,
    pub shm_nattch: compat_ulong_t,
    pub __unused4: compat_ulong_t,
    pub __unused5: compat_ulong_t,
}
pub type compat_nlink_t = u16_;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_stat {
    pub st_dev: u32_,
    pub st_ino: compat_ino_t,
    pub st_mode: compat_mode_t,
    pub st_nlink: compat_nlink_t,
    pub st_uid: __compat_uid_t,
    pub st_gid: __compat_gid_t,
    pub st_rdev: u32_,
    pub st_size: u32_,
    pub st_blksize: u32_,
    pub st_blocks: u32_,
    pub st_atime: u32_,
    pub st_atime_nsec: u32_,
    pub st_mtime: u32_,
    pub st_mtime_nsec: u32_,
    pub st_ctime: u32_,
    pub st_ctime_nsec: u32_,
    pub __unused4: u32_,
    pub __unused5: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_statfs {
    pub f_type: core::ffi::c_int,
    pub f_bsize: core::ffi::c_int,
    pub f_blocks: core::ffi::c_int,
    pub f_bfree: core::ffi::c_int,
    pub f_bavail: core::ffi::c_int,
    pub f_files: core::ffi::c_int,
    pub f_ffree: core::ffi::c_int,
    pub f_fsid: compat_fsid_t,
    pub f_namelen: core::ffi::c_int,
    pub f_frsize: core::ffi::c_int,
    pub f_flags: core::ffi::c_int,
    pub f_spare: [core::ffi::c_int; 4usize],
}
extern "C" {
    pub fn __x64_sys_ni_syscall(regs: *const pt_regs) -> core::ffi::c_long;
}
extern "C" {
    pub fn __ia32_sys_ni_syscall(regs: *const pt_regs) -> core::ffi::c_long;
}
extern "C" {
    pub fn __x64_sys_getcpu(regs: *const pt_regs) -> core::ffi::c_long;
}
extern "C" {
    pub fn __x64_sys_gettimeofday(regs: *const pt_regs) -> core::ffi::c_long;
}
extern "C" {
    pub fn __x64_sys_time(regs: *const pt_regs) -> core::ffi::c_long;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_iovec {
    pub iov_base: compat_uptr_t,
    pub iov_len: compat_size_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_sigaltstack {
    pub ss_sp: compat_uptr_t,
    pub ss_flags: core::ffi::c_int,
    pub ss_size: compat_size_t,
}
pub type compat_stack_t = compat_sigaltstack;
pub type compat_uid_t = __compat_uid32_t;
pub type compat_gid_t = __compat_gid32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_sel_arg_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct old_itimerval32 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_tms {
    pub tms_utime: compat_clock_t,
    pub tms_stime: compat_clock_t,
    pub tms_cutime: compat_clock_t,
    pub tms_cstime: compat_clock_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_sigset_t {
    pub sig: [compat_sigset_word; 2usize],
}
extern "C" {
    pub fn set_compat_user_sigmask(
        umask: *const compat_sigset_t,
        sigsetsize: usize,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_sigaction {
    pub sa_handler: compat_uptr_t,
    pub sa_flags: compat_ulong_t,
    pub sa_restorer: compat_uptr_t,
    pub sa_mask: compat_sigset_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union compat_sigval {
    pub sival_int: compat_int_t,
    pub sival_ptr: compat_uptr_t,
}
impl Default for compat_sigval {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type compat_sigval_t = compat_sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_siginfo {
    pub si_signo: core::ffi::c_int,
    pub si_errno: core::ffi::c_int,
    pub si_code: core::ffi::c_int,
    pub _sifields: compat_siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union compat_siginfo__bindgen_ty_1 {
    pub _pad: [core::ffi::c_int; 29usize],
    pub _kill: compat_siginfo__bindgen_ty_1__bindgen_ty_1,
    pub _timer: compat_siginfo__bindgen_ty_1__bindgen_ty_2,
    pub _rt: compat_siginfo__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: compat_siginfo__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: compat_siginfo__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: compat_siginfo__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: compat_siginfo__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub _pid: compat_pid_t,
    pub _uid: __compat_uid32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_2 {
    pub _tid: compat_timer_t,
    pub _overrun: core::ffi::c_int,
    pub _sigval: compat_sigval_t,
}
impl Default for compat_siginfo__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_3 {
    pub _pid: compat_pid_t,
    pub _uid: __compat_uid32_t,
    pub _sigval: compat_sigval_t,
}
impl Default for compat_siginfo__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_4 {
    pub _pid: compat_pid_t,
    pub _uid: __compat_uid32_t,
    pub _status: core::ffi::c_int,
    pub _utime: compat_clock_t,
    pub _stime: compat_clock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_5 {
    pub _addr: compat_uptr_t,
    pub __bindgen_anon_1: compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _trapno: core::ffi::c_int,
    pub _addr_lsb: core::ffi::c_short,
    pub _addr_bnd: compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _addr_pkey: compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
    pub _perf: compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _dummy_bnd: [core::ffi::c_char; 4usize],
    pub _lower: compat_uptr_t,
    pub _upper: compat_uptr_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub _dummy_pkey: [core::ffi::c_char; 4usize],
    pub _pkey: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3 {
    pub _data: compat_ulong_t,
    pub _type: u32_,
    pub _flags: u32_,
}
impl Default for compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for compat_siginfo__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_6 {
    pub _band: compat_long_t,
    pub _fd: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: compat_uptr_t,
    pub _syscall: core::ffi::c_int,
    pub _arch: core::ffi::c_uint,
}
impl Default for compat_siginfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for compat_siginfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type compat_siginfo_t = compat_siginfo;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_rlimit {
    pub rlim_cur: compat_ulong_t,
    pub rlim_max: compat_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_flock {
    pub l_type: core::ffi::c_short,
    pub l_whence: core::ffi::c_short,
    pub l_start: compat_off_t,
    pub l_len: compat_off_t,
    pub l_pid: compat_pid_t,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct compat_flock64 {
    pub l_type: core::ffi::c_short,
    pub l_whence: core::ffi::c_short,
    pub l_start: compat_loff_t,
    pub l_len: compat_loff_t,
    pub l_pid: compat_pid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_rusage {
    pub ru_utime: old_timeval32,
    pub ru_stime: old_timeval32,
    pub ru_maxrss: compat_long_t,
    pub ru_ixrss: compat_long_t,
    pub ru_idrss: compat_long_t,
    pub ru_isrss: compat_long_t,
    pub ru_minflt: compat_long_t,
    pub ru_majflt: compat_long_t,
    pub ru_nswap: compat_long_t,
    pub ru_inblock: compat_long_t,
    pub ru_oublock: compat_long_t,
    pub ru_msgsnd: compat_long_t,
    pub ru_msgrcv: compat_long_t,
    pub ru_nsignals: compat_long_t,
    pub ru_nvcsw: compat_long_t,
    pub ru_nivcsw: compat_long_t,
}
extern "C" {
    pub fn put_compat_rusage(arg1: *const rusage, arg2: *mut compat_rusage) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __compat_aio_sigset {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_dirent {
    pub d_ino: u32_,
    pub d_off: compat_off_t,
    pub d_reclen: u16_,
    pub d_name: [core::ffi::c_char; 256usize],
}
impl Default for compat_dirent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_ustat {
    pub f_tfree: compat_daddr_t,
    pub f_tinode: compat_ino_t,
    pub f_fname: [core::ffi::c_char; 6usize],
    pub f_fpack: [core::ffi::c_char; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_sigevent {
    pub sigev_value: compat_sigval_t,
    pub sigev_signo: compat_int_t,
    pub sigev_notify: compat_int_t,
    pub _sigev_un: compat_sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union compat_sigevent__bindgen_ty_1 {
    pub _pad: [compat_int_t; 13usize],
    pub _tid: compat_int_t,
    pub _sigev_thread: compat_sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: compat_uptr_t,
    pub _attribute: compat_uptr_t,
}
impl Default for compat_sigevent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for compat_sigevent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type compat_sigevent_t = compat_sigevent;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_ifmap {
    pub mem_start: compat_ulong_t,
    pub mem_end: compat_ulong_t,
    pub base_addr: core::ffi::c_ushort,
    pub irq: core::ffi::c_uchar,
    pub dma: core::ffi::c_uchar,
    pub port: core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_if_settings {
    pub type_: core::ffi::c_uint,
    pub size: core::ffi::c_uint,
    pub ifs_ifsu: compat_uptr_t,
}
#[repr(C)]
pub struct compat_ifreq {
    pub ifr_ifrn: compat_ifreq__bindgen_ty_1,
    pub ifr_ifru: compat_ifreq__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union compat_ifreq__bindgen_ty_1 {
    pub ifrn_name: [core::ffi::c_char; 16usize],
}
impl Default for compat_ifreq__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct compat_ifreq__bindgen_ty_2 {
    pub ifru_addr: __BindgenUnionField<sockaddr>,
    pub ifru_dstaddr: __BindgenUnionField<sockaddr>,
    pub ifru_broadaddr: __BindgenUnionField<sockaddr>,
    pub ifru_netmask: __BindgenUnionField<sockaddr>,
    pub ifru_hwaddr: __BindgenUnionField<sockaddr>,
    pub ifru_flags: __BindgenUnionField<core::ffi::c_short>,
    pub ifru_ivalue: __BindgenUnionField<compat_int_t>,
    pub ifru_mtu: __BindgenUnionField<compat_int_t>,
    pub ifru_map: __BindgenUnionField<compat_ifmap>,
    pub ifru_slave: __BindgenUnionField<[core::ffi::c_char; 16usize]>,
    pub ifru_newname: __BindgenUnionField<[core::ffi::c_char; 16usize]>,
    pub ifru_data: __BindgenUnionField<compat_caddr_t>,
    pub ifru_settings: __BindgenUnionField<compat_if_settings>,
    pub bindgen_union_field: [u32; 4usize],
}
impl Default for compat_ifreq__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for compat_ifreq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_ifconf {
    pub ifc_len: compat_int_t,
    pub ifcbuf: compat_caddr_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_robust_list {
    pub next: compat_uptr_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_robust_list_head {
    pub list: compat_robust_list,
    pub futex_offset: compat_long_t,
    pub list_op_pending: compat_uptr_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_old_sigaction {
    pub sa_handler: compat_uptr_t,
    pub sa_mask: compat_old_sigset_t,
    pub sa_flags: compat_ulong_t,
    pub sa_restorer: compat_uptr_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_keyctl_kdf_params {
    pub hashname: compat_uptr_t,
    pub otherinfo: compat_uptr_t,
    pub otherinfolen: __u32,
    pub __spare: [__u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_statfs64 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_old_linux_dirent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_linux_dirent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct linux_dirent64 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_sysinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_sysctl_args {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_kexec_segment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_mq_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_msgbuf {
    _unused: [u8; 0],
}
extern "C" {
    pub fn copy_siginfo_to_external32(to: *mut compat_siginfo, from: *const kernel_siginfo);
}
extern "C" {
    pub fn copy_siginfo_from_user32(
        to: *mut kernel_siginfo_t,
        from: *const compat_siginfo,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __copy_siginfo_to_user32(
        to: *mut compat_siginfo,
        from: *const kernel_siginfo_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_compat_sigevent(
        event: *mut sigevent,
        u_event: *const compat_sigevent,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_compat_sigset(
        set: *mut sigset_t,
        compat: *const compat_sigset_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn compat_ptrace_request(
        child: *mut task_struct,
        request: compat_long_t,
        addr: compat_ulong_t,
        data: compat_ulong_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn compat_arch_ptrace(
        child: *mut task_struct,
        request: compat_long_t,
        addr: compat_ulong_t,
        data: compat_ulong_t,
    ) -> core::ffi::c_long;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct epoll_event {
    _unused: [u8; 0],
}
extern "C" {
    pub fn compat_restore_altstack(uss: *const compat_stack_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn __compat_save_altstack(
        arg1: *mut compat_stack_t,
        arg2: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kcompat_sys_statfs64(
        pathname: *const core::ffi::c_char,
        sz: compat_size_t,
        buf: *mut compat_statfs64,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kcompat_sys_fstatfs64(
        fd: core::ffi::c_uint,
        sz: compat_size_t,
        buf: *mut compat_statfs64,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn compat_get_bitmap(
        mask: *mut core::ffi::c_ulong,
        umask: *const compat_ulong_t,
        bitmap_size: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_put_bitmap(
        umask: *mut compat_ulong_t,
        mask: *mut core::ffi::c_ulong,
        bitmap_size: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ucontext_ia32 {
    pub uc_flags: core::ffi::c_uint,
    pub uc_link: core::ffi::c_uint,
    pub uc_stack: compat_stack_t,
    pub uc_mcontext: sigcontext_32,
    pub uc_sigmask: compat_sigset_t,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct stat64 {
    pub st_dev: core::ffi::c_ulonglong,
    pub __pad0: [core::ffi::c_uchar; 4usize],
    pub __st_ino: core::ffi::c_uint,
    pub st_mode: core::ffi::c_uint,
    pub st_nlink: core::ffi::c_uint,
    pub st_uid: core::ffi::c_uint,
    pub st_gid: core::ffi::c_uint,
    pub st_rdev: core::ffi::c_ulonglong,
    pub __pad3: [core::ffi::c_uchar; 4usize],
    pub st_size: core::ffi::c_longlong,
    pub st_blksize: core::ffi::c_uint,
    pub st_blocks: core::ffi::c_longlong,
    pub st_atime: core::ffi::c_uint,
    pub st_atime_nsec: core::ffi::c_uint,
    pub st_mtime: core::ffi::c_uint,
    pub st_mtime_nsec: core::ffi::c_uint,
    pub st_ctime: core::ffi::c_uint,
    pub st_ctime_nsec: core::ffi::c_uint,
    pub st_ino: core::ffi::c_ulonglong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct linux_binprm {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ia32_setup_arg_pages(
        bprm: *mut linux_binprm,
        stack_top: core::ffi::c_ulong,
        exec_stack: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ia32_pick_mmap_layout(mm: *mut mm_struct);
}
extern "C" {
    pub static mut __ia32_enabled: bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_i387_struct {
    pub cwd: core::ffi::c_ushort,
    pub swd: core::ffi::c_ushort,
    pub twd: core::ffi::c_ushort,
    pub fop: core::ffi::c_ushort,
    pub rip: __u64,
    pub rdp: __u64,
    pub mxcsr: __u32,
    pub mxcsr_mask: __u32,
    pub st_space: [__u32; 32usize],
    pub xmm_space: [__u32; 64usize],
    pub padding: [__u32; 24usize],
}
impl Default for user_i387_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct user_regs_struct {
    pub r15: core::ffi::c_ulong,
    pub r14: core::ffi::c_ulong,
    pub r13: core::ffi::c_ulong,
    pub r12: core::ffi::c_ulong,
    pub bp: core::ffi::c_ulong,
    pub bx: core::ffi::c_ulong,
    pub r11: core::ffi::c_ulong,
    pub r10: core::ffi::c_ulong,
    pub r9: core::ffi::c_ulong,
    pub r8: core::ffi::c_ulong,
    pub ax: core::ffi::c_ulong,
    pub cx: core::ffi::c_ulong,
    pub dx: core::ffi::c_ulong,
    pub si: core::ffi::c_ulong,
    pub di: core::ffi::c_ulong,
    pub orig_ax: core::ffi::c_ulong,
    pub ip: core::ffi::c_ulong,
    pub cs: core::ffi::c_ulong,
    pub flags: core::ffi::c_ulong,
    pub sp: core::ffi::c_ulong,
    pub ss: core::ffi::c_ulong,
    pub fs_base: core::ffi::c_ulong,
    pub gs_base: core::ffi::c_ulong,
    pub ds: core::ffi::c_ulong,
    pub es: core::ffi::c_ulong,
    pub fs: core::ffi::c_ulong,
    pub gs: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user {
    pub regs: user_regs_struct,
    pub u_fpvalid: core::ffi::c_int,
    pub pad0: core::ffi::c_int,
    pub i387: user_i387_struct,
    pub u_tsize: core::ffi::c_ulong,
    pub u_dsize: core::ffi::c_ulong,
    pub u_ssize: core::ffi::c_ulong,
    pub start_code: core::ffi::c_ulong,
    pub start_stack: core::ffi::c_ulong,
    pub signal: core::ffi::c_long,
    pub reserved: core::ffi::c_int,
    pub pad1: core::ffi::c_int,
    pub u_ar0: core::ffi::c_ulong,
    pub u_fpstate: *mut user_i387_struct,
    pub magic: core::ffi::c_ulong,
    pub u_comm: [core::ffi::c_char; 32usize],
    pub u_debugreg: [core::ffi::c_ulong; 8usize],
    pub error_code: core::ffi::c_ulong,
    pub fault_address: core::ffi::c_ulong,
}
impl Default for user {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_ymmh_regs {
    pub ymmh_space: [__u32; 64usize],
}
impl Default for user_ymmh_regs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct user_xstate_header {
    pub xfeatures: __u64,
    pub reserved1: [__u64; 2usize],
    pub reserved2: [__u64; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_xstateregs {
    pub i387: user_xstateregs__bindgen_ty_1,
    pub header: user_xstate_header,
    pub ymmh: user_ymmh_regs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_xstateregs__bindgen_ty_1 {
    pub fpx_space: [__u64; 58usize],
    pub xstate_fx_sw: [__u64; 6usize],
}
impl Default for user_xstateregs__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for user_xstateregs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn x86_fsbase_read_task(task: *mut task_struct) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn x86_gsbase_read_task(task: *mut task_struct) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn x86_fsbase_write_task(task: *mut task_struct, fsbase: core::ffi::c_ulong);
}
extern "C" {
    pub fn x86_gsbase_write_task(task: *mut task_struct, gsbase: core::ffi::c_ulong);
}
extern "C" {
    pub fn x86_gsbase_read_cpu_inactive() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn x86_gsbase_write_cpu_inactive(gsbase: core::ffi::c_ulong);
}
extern "C" {
    pub fn x86_fsgsbase_read_task(
        task: *mut task_struct,
        selector: core::ffi::c_ushort,
    ) -> core::ffi::c_ulong;
}
pub type elf_greg_t = core::ffi::c_ulong;
pub type elf_gregset_t = [elf_greg_t; 27usize];
pub type elf_fpregset_t = user_i387_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vdso_image {
    pub data: *mut core::ffi::c_void,
    pub size: core::ffi::c_ulong,
    pub alt: core::ffi::c_ulong,
    pub alt_len: core::ffi::c_ulong,
    pub extable_base: core::ffi::c_ulong,
    pub extable_len: core::ffi::c_ulong,
    pub extable: *const core::ffi::c_void,
    pub sym_vvar_start: core::ffi::c_long,
    pub sym_vvar_page: core::ffi::c_long,
    pub sym_pvclock_page: core::ffi::c_long,
    pub sym_hvclock_page: core::ffi::c_long,
    pub sym_timens_page: core::ffi::c_long,
    pub sym_VDSO32_NOTE_MASK: core::ffi::c_long,
    pub sym___kernel_sigreturn: core::ffi::c_long,
    pub sym___kernel_rt_sigreturn: core::ffi::c_long,
    pub sym___kernel_vsyscall: core::ffi::c_long,
    pub sym_int80_landing_pad: core::ffi::c_long,
    pub sym_vdso32_sigreturn_landing_pad: core::ffi::c_long,
    pub sym_vdso32_rt_sigreturn_landing_pad: core::ffi::c_long,
}
impl Default for vdso_image {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static vdso_image_64: vdso_image;
}
extern "C" {
    pub static vdso_image_32: vdso_image;
}
extern "C" {
    pub fn init_vdso_image(image: *const vdso_image) -> core::ffi::c_int;
}
extern "C" {
    pub fn map_vdso_once(image: *const vdso_image, addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn fixup_vdso_exception(
        regs: *mut pt_regs,
        trapnr: core::ffi::c_int,
        error_code: core::ffi::c_ulong,
        fault_addr: core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub static mut vdso64_enabled: core::ffi::c_uint;
}
extern "C" {
    pub static mut vdso32_enabled: core::ffi::c_uint;
}
extern "C" {
    pub fn compat_start_thread(regs: *mut pt_regs, new_ip: u32_, new_sp: u32_, x32: bool_);
}
extern "C" {
    pub fn set_personality_ia32(arg1: bool_);
}
extern "C" {
    pub fn set_personality_64bit();
}
extern "C" {
    pub static mut force_personality32: core::ffi::c_int;
}
extern "C" {
    pub static mut elf_hwcap2: u32_;
}
extern "C" {
    pub fn task_size_32bit() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn task_size_64bit(full_addr_space: core::ffi::c_int) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn get_mmap_base(is_legacy: core::ffi::c_int) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn mmap_address_hint_valid(addr: core::ffi::c_ulong, len: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn get_sigframe_size() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn arch_setup_additional_pages(
        bprm: *mut linux_binprm,
        uses_interp: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn compat_arch_setup_additional_pages(
        bprm: *mut linux_binprm,
        uses_interp: core::ffi::c_int,
        x32: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_syscall_is_vdso_sigreturn(regs: *mut pt_regs) -> bool_;
}
pub const align_flags_ALIGN_VA_32: align_flags = 1;
pub const align_flags_ALIGN_VA_64: align_flags = 2;
pub type align_flags = core::ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct va_alignment {
    pub flags: core::ffi::c_int,
    pub mask: core::ffi::c_ulong,
    pub bits: core::ffi::c_ulong,
}
impl Default for va_alignment {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut va_align: va_alignment;
}
extern "C" {
    pub fn align_vdso_addr(arg1: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
pub type Elf32_Addr = __u32;
pub type Elf32_Half = __u16;
pub type Elf32_Off = __u32;
pub type Elf32_Sword = __s32;
pub type Elf32_Word = __u32;
pub type Elf64_Addr = __u64;
pub type Elf64_Half = __u16;
pub type Elf64_SHalf = __s16;
pub type Elf64_Off = __u64;
pub type Elf64_Sword = __s32;
pub type Elf64_Word = __u32;
pub type Elf64_Xword = __u64;
pub type Elf64_Sxword = __s64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Elf32_Dyn {
    pub d_tag: Elf32_Sword,
    pub d_un: Elf32_Dyn__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Elf32_Dyn__bindgen_ty_1 {
    pub d_val: Elf32_Sword,
    pub d_ptr: Elf32_Addr,
}
impl Default for Elf32_Dyn__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for Elf32_Dyn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Elf64_Dyn {
    pub d_tag: Elf64_Sxword,
    pub d_un: Elf64_Dyn__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Elf64_Dyn__bindgen_ty_1 {
    pub d_val: Elf64_Xword,
    pub d_ptr: Elf64_Addr,
}
impl Default for Elf64_Dyn__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for Elf64_Dyn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_rel {
    pub r_offset: Elf32_Addr,
    pub r_info: Elf32_Word,
}
pub type Elf32_Rel = elf32_rel;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_rel {
    pub r_offset: Elf64_Addr,
    pub r_info: Elf64_Xword,
}
pub type Elf64_Rel = elf64_rel;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_rela {
    pub r_offset: Elf32_Addr,
    pub r_info: Elf32_Word,
    pub r_addend: Elf32_Sword,
}
pub type Elf32_Rela = elf32_rela;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_rela {
    pub r_offset: Elf64_Addr,
    pub r_info: Elf64_Xword,
    pub r_addend: Elf64_Sxword,
}
pub type Elf64_Rela = elf64_rela;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_sym {
    pub st_name: Elf32_Word,
    pub st_value: Elf32_Addr,
    pub st_size: Elf32_Word,
    pub st_info: core::ffi::c_uchar,
    pub st_other: core::ffi::c_uchar,
    pub st_shndx: Elf32_Half,
}
pub type Elf32_Sym = elf32_sym;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_sym {
    pub st_name: Elf64_Word,
    pub st_info: core::ffi::c_uchar,
    pub st_other: core::ffi::c_uchar,
    pub st_shndx: Elf64_Half,
    pub st_value: Elf64_Addr,
    pub st_size: Elf64_Xword,
}
pub type Elf64_Sym = elf64_sym;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_hdr {
    pub e_ident: [core::ffi::c_uchar; 16usize],
    pub e_type: Elf32_Half,
    pub e_machine: Elf32_Half,
    pub e_version: Elf32_Word,
    pub e_entry: Elf32_Addr,
    pub e_phoff: Elf32_Off,
    pub e_shoff: Elf32_Off,
    pub e_flags: Elf32_Word,
    pub e_ehsize: Elf32_Half,
    pub e_phentsize: Elf32_Half,
    pub e_phnum: Elf32_Half,
    pub e_shentsize: Elf32_Half,
    pub e_shnum: Elf32_Half,
    pub e_shstrndx: Elf32_Half,
}
pub type Elf32_Ehdr = elf32_hdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_hdr {
    pub e_ident: [core::ffi::c_uchar; 16usize],
    pub e_type: Elf64_Half,
    pub e_machine: Elf64_Half,
    pub e_version: Elf64_Word,
    pub e_entry: Elf64_Addr,
    pub e_phoff: Elf64_Off,
    pub e_shoff: Elf64_Off,
    pub e_flags: Elf64_Word,
    pub e_ehsize: Elf64_Half,
    pub e_phentsize: Elf64_Half,
    pub e_phnum: Elf64_Half,
    pub e_shentsize: Elf64_Half,
    pub e_shnum: Elf64_Half,
    pub e_shstrndx: Elf64_Half,
}
pub type Elf64_Ehdr = elf64_hdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_phdr {
    pub p_type: Elf32_Word,
    pub p_offset: Elf32_Off,
    pub p_vaddr: Elf32_Addr,
    pub p_paddr: Elf32_Addr,
    pub p_filesz: Elf32_Word,
    pub p_memsz: Elf32_Word,
    pub p_flags: Elf32_Word,
    pub p_align: Elf32_Word,
}
pub type Elf32_Phdr = elf32_phdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_phdr {
    pub p_type: Elf64_Word,
    pub p_flags: Elf64_Word,
    pub p_offset: Elf64_Off,
    pub p_vaddr: Elf64_Addr,
    pub p_paddr: Elf64_Addr,
    pub p_filesz: Elf64_Xword,
    pub p_memsz: Elf64_Xword,
    pub p_align: Elf64_Xword,
}
pub type Elf64_Phdr = elf64_phdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_shdr {
    pub sh_name: Elf32_Word,
    pub sh_type: Elf32_Word,
    pub sh_flags: Elf32_Word,
    pub sh_addr: Elf32_Addr,
    pub sh_offset: Elf32_Off,
    pub sh_size: Elf32_Word,
    pub sh_link: Elf32_Word,
    pub sh_info: Elf32_Word,
    pub sh_addralign: Elf32_Word,
    pub sh_entsize: Elf32_Word,
}
pub type Elf32_Shdr = elf32_shdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_shdr {
    pub sh_name: Elf64_Word,
    pub sh_type: Elf64_Word,
    pub sh_flags: Elf64_Xword,
    pub sh_addr: Elf64_Addr,
    pub sh_offset: Elf64_Off,
    pub sh_size: Elf64_Xword,
    pub sh_link: Elf64_Word,
    pub sh_info: Elf64_Word,
    pub sh_addralign: Elf64_Xword,
    pub sh_entsize: Elf64_Xword,
}
pub type Elf64_Shdr = elf64_shdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_note {
    pub n_namesz: Elf32_Word,
    pub n_descsz: Elf32_Word,
    pub n_type: Elf32_Word,
}
pub type Elf32_Nhdr = elf32_note;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_note {
    pub n_namesz: Elf64_Word,
    pub n_descsz: Elf64_Word,
    pub n_type: Elf64_Word,
}
pub type Elf64_Nhdr = elf64_note;
extern "C" {
    pub static mut _DYNAMIC: [Elf64_Dyn; 0usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct coredump_params {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct gnu_property {
    pub pr_type: u32_,
    pub pr_datasz: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_elf_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct idr {
    pub idr_rt: xarray,
    pub idr_base: core::ffi::c_uint,
    pub idr_next: core::ffi::c_uint,
}
impl Default for idr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn idr_preload(gfp_mask: gfp_t);
}
extern "C" {
    pub fn idr_alloc(
        arg1: *mut idr,
        ptr: *mut core::ffi::c_void,
        start: core::ffi::c_int,
        end: core::ffi::c_int,
        arg2: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn idr_alloc_u32(
        arg1: *mut idr,
        ptr: *mut core::ffi::c_void,
        id: *mut u32_,
        max: core::ffi::c_ulong,
        arg2: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn idr_alloc_cyclic(
        arg1: *mut idr,
        ptr: *mut core::ffi::c_void,
        start: core::ffi::c_int,
        end: core::ffi::c_int,
        arg2: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn idr_remove(arg1: *mut idr, id: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn idr_find(arg1: *const idr, id: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn idr_for_each(
        arg1: *const idr,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                id: core::ffi::c_int,
                p: *mut core::ffi::c_void,
                data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn idr_get_next(arg1: *mut idr, nextid: *mut core::ffi::c_int) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn idr_get_next_ul(
        arg1: *mut idr,
        nextid: *mut core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn idr_replace(
        arg1: *mut idr,
        arg2: *mut core::ffi::c_void,
        id: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn idr_destroy(arg1: *mut idr);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ida_bitmap {
    pub bitmap: [core::ffi::c_ulong; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ida {
    pub xa: xarray,
}
impl Default for ida {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn ida_alloc_range(
        arg1: *mut ida,
        min: core::ffi::c_uint,
        max: core::ffi::c_uint,
        arg2: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ida_free(arg1: *mut ida, id: core::ffi::c_uint);
}
extern "C" {
    pub fn ida_destroy(ida: *mut ida);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_open_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_iattrs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_global_locks {
    pub open_file_mutex: [mutex; 1024usize],
}
impl Default for kernfs_global_locks {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const kernfs_node_type_KERNFS_DIR: kernfs_node_type = 1;
pub const kernfs_node_type_KERNFS_FILE: kernfs_node_type = 2;
pub const kernfs_node_type_KERNFS_LINK: kernfs_node_type = 4;
pub type kernfs_node_type = core::ffi::c_uint;
pub const kernfs_node_flag_KERNFS_ACTIVATED: kernfs_node_flag = 16;
pub const kernfs_node_flag_KERNFS_NS: kernfs_node_flag = 32;
pub const kernfs_node_flag_KERNFS_HAS_SEQ_SHOW: kernfs_node_flag = 64;
pub const kernfs_node_flag_KERNFS_HAS_MMAP: kernfs_node_flag = 128;
pub const kernfs_node_flag_KERNFS_LOCKDEP: kernfs_node_flag = 256;
pub const kernfs_node_flag_KERNFS_HIDDEN: kernfs_node_flag = 512;
pub const kernfs_node_flag_KERNFS_SUICIDAL: kernfs_node_flag = 1024;
pub const kernfs_node_flag_KERNFS_SUICIDED: kernfs_node_flag = 2048;
pub const kernfs_node_flag_KERNFS_EMPTY_DIR: kernfs_node_flag = 4096;
pub const kernfs_node_flag_KERNFS_HAS_RELEASE: kernfs_node_flag = 8192;
pub const kernfs_node_flag_KERNFS_REMOVING: kernfs_node_flag = 16384;
pub type kernfs_node_flag = core::ffi::c_uint;
pub const kernfs_root_flag_KERNFS_ROOT_CREATE_DEACTIVATED: kernfs_root_flag = 1;
pub const kernfs_root_flag_KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK: kernfs_root_flag = 2;
pub const kernfs_root_flag_KERNFS_ROOT_SUPPORT_EXPORTOP: kernfs_root_flag = 4;
pub const kernfs_root_flag_KERNFS_ROOT_SUPPORT_USER_XATTR: kernfs_root_flag = 8;
pub type kernfs_root_flag = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_elem_dir {
    pub subdirs: core::ffi::c_ulong,
    pub children: rb_root,
    pub root: *mut kernfs_root,
    pub rev: core::ffi::c_ulong,
}
impl Default for kernfs_elem_dir {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_elem_symlink {
    pub target_kn: *mut kernfs_node,
}
impl Default for kernfs_elem_symlink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_elem_attr {
    pub ops: *const kernfs_ops,
    pub open: *mut kernfs_open_node,
    pub size: loff_t,
    pub notify_next: *mut kernfs_node,
}
impl Default for kernfs_elem_attr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_node {
    pub count: atomic_t,
    pub active: atomic_t,
    pub parent: *mut kernfs_node,
    pub name: *const core::ffi::c_char,
    pub rb: rb_node,
    pub ns: *const core::ffi::c_void,
    pub hash: core::ffi::c_uint,
    pub __bindgen_anon_1: kernfs_node__bindgen_ty_1,
    pub priv_: *mut core::ffi::c_void,
    pub id: u64_,
    pub flags: core::ffi::c_ushort,
    pub mode: umode_t,
    pub iattr: *mut kernfs_iattrs,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernfs_node__bindgen_ty_1 {
    pub dir: kernfs_elem_dir,
    pub symlink: kernfs_elem_symlink,
    pub attr: kernfs_elem_attr,
}
impl Default for kernfs_node__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kernfs_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernfs_syscall_ops {
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, root: *mut kernfs_root) -> core::ffi::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            parent: *mut kernfs_node,
            name: *const core::ffi::c_char,
            mode: umode_t,
        ) -> core::ffi::c_int,
    >,
    pub rmdir:
        ::core::option::Option<unsafe extern "C" fn(kn: *mut kernfs_node) -> core::ffi::c_int>,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            kn: *mut kernfs_node,
            new_parent: *mut kernfs_node,
            new_name: *const core::ffi::c_char,
        ) -> core::ffi::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            kn: *mut kernfs_node,
            root: *mut kernfs_root,
        ) -> core::ffi::c_int,
    >,
}
extern "C" {
    pub fn kernfs_root_to_node(root: *mut kernfs_root) -> *mut kernfs_node;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_open_file {
    pub kn: *mut kernfs_node,
    pub file: *mut file,
    pub seq_file: *mut seq_file,
    pub priv_: *mut core::ffi::c_void,
    pub mutex: mutex,
    pub prealloc_mutex: mutex,
    pub event: core::ffi::c_int,
    pub list: list_head,
    pub prealloc_buf: *mut core::ffi::c_char,
    pub atomic_write_len: usize,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub vm_ops: *const vm_operations_struct,
}
impl Default for kernfs_open_file {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl kernfs_open_file {
    #[inline]
    pub fn mmapped(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mmapped(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn released(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_released(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mmapped: bool_, released: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mmapped: u8 = unsafe { ::core::mem::transmute(mmapped) };
            mmapped as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let released: u8 = unsafe { ::core::mem::transmute(released) };
            released as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernfs_ops {
    pub open:
        ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file) -> core::ffi::c_int>,
    pub release: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file)>,
    pub seq_show: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, v: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub seq_start: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, ppos: *mut loff_t) -> *mut core::ffi::c_void,
    >,
    pub seq_next: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            v: *mut core::ffi::c_void,
            ppos: *mut loff_t,
        ) -> *mut core::ffi::c_void,
    >,
    pub seq_stop:
        ::core::option::Option<unsafe extern "C" fn(sf: *mut seq_file, v: *mut core::ffi::c_void)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut core::ffi::c_char,
            bytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub atomic_write_len: usize,
    pub prealloc: bool_,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut core::ffi::c_char,
            bytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(of: *mut kernfs_open_file, pt: *mut poll_table_struct) -> __poll_t,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            vma: *mut vm_area_struct,
        ) -> core::ffi::c_int,
    >,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            offset: loff_t,
            whence: core::ffi::c_int,
        ) -> loff_t,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_fs_context {
    pub root: *mut kernfs_root,
    pub ns_tag: *mut core::ffi::c_void,
    pub magic: core::ffi::c_ulong,
    pub new_sb_created: bool_,
}
impl Default for kernfs_fs_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn kernfs_name(
        kn: *mut kernfs_node,
        buf: *mut core::ffi::c_char,
        buflen: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernfs_path_from_node(
        root_kn: *mut kernfs_node,
        kn: *mut kernfs_node,
        buf: *mut core::ffi::c_char,
        buflen: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pr_cont_kernfs_name(kn: *mut kernfs_node);
}
extern "C" {
    pub fn pr_cont_kernfs_path(kn: *mut kernfs_node);
}
extern "C" {
    pub fn kernfs_get_parent(kn: *mut kernfs_node) -> *mut kernfs_node;
}
extern "C" {
    pub fn kernfs_find_and_get_ns(
        parent: *mut kernfs_node,
        name: *const core::ffi::c_char,
        ns: *const core::ffi::c_void,
    ) -> *mut kernfs_node;
}
extern "C" {
    pub fn kernfs_walk_and_get_ns(
        parent: *mut kernfs_node,
        path: *const core::ffi::c_char,
        ns: *const core::ffi::c_void,
    ) -> *mut kernfs_node;
}
extern "C" {
    pub fn kernfs_get(kn: *mut kernfs_node);
}
extern "C" {
    pub fn kernfs_put(kn: *mut kernfs_node);
}
extern "C" {
    pub fn kernfs_node_from_dentry(dentry: *mut dentry) -> *mut kernfs_node;
}
extern "C" {
    pub fn kernfs_root_from_sb(sb: *mut super_block) -> *mut kernfs_root;
}
extern "C" {
    pub fn kernfs_get_inode(sb: *mut super_block, kn: *mut kernfs_node) -> *mut inode;
}
extern "C" {
    pub fn kernfs_node_dentry(kn: *mut kernfs_node, sb: *mut super_block) -> *mut dentry;
}
extern "C" {
    pub fn kernfs_create_root(
        scops: *mut kernfs_syscall_ops,
        flags: core::ffi::c_uint,
        priv_: *mut core::ffi::c_void,
    ) -> *mut kernfs_root;
}
extern "C" {
    pub fn kernfs_destroy_root(root: *mut kernfs_root);
}
extern "C" {
    pub fn kernfs_create_dir_ns(
        parent: *mut kernfs_node,
        name: *const core::ffi::c_char,
        mode: umode_t,
        uid: kuid_t,
        gid: kgid_t,
        priv_: *mut core::ffi::c_void,
        ns: *const core::ffi::c_void,
    ) -> *mut kernfs_node;
}
extern "C" {
    pub fn kernfs_create_empty_dir(
        parent: *mut kernfs_node,
        name: *const core::ffi::c_char,
    ) -> *mut kernfs_node;
}
extern "C" {
    pub fn __kernfs_create_file(
        parent: *mut kernfs_node,
        name: *const core::ffi::c_char,
        mode: umode_t,
        uid: kuid_t,
        gid: kgid_t,
        size: loff_t,
        ops: *const kernfs_ops,
        priv_: *mut core::ffi::c_void,
        ns: *const core::ffi::c_void,
        key: *mut lock_class_key,
    ) -> *mut kernfs_node;
}
extern "C" {
    pub fn kernfs_create_link(
        parent: *mut kernfs_node,
        name: *const core::ffi::c_char,
        target: *mut kernfs_node,
    ) -> *mut kernfs_node;
}
extern "C" {
    pub fn kernfs_activate(kn: *mut kernfs_node);
}
extern "C" {
    pub fn kernfs_show(kn: *mut kernfs_node, show: bool_);
}
extern "C" {
    pub fn kernfs_remove(kn: *mut kernfs_node);
}
extern "C" {
    pub fn kernfs_break_active_protection(kn: *mut kernfs_node);
}
extern "C" {
    pub fn kernfs_unbreak_active_protection(kn: *mut kernfs_node);
}
extern "C" {
    pub fn kernfs_remove_self(kn: *mut kernfs_node) -> bool_;
}
extern "C" {
    pub fn kernfs_remove_by_name_ns(
        parent: *mut kernfs_node,
        name: *const core::ffi::c_char,
        ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernfs_rename_ns(
        kn: *mut kernfs_node,
        new_parent: *mut kernfs_node,
        new_name: *const core::ffi::c_char,
        new_ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernfs_setattr(kn: *mut kernfs_node, iattr: *const iattr) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernfs_generic_poll(of: *mut kernfs_open_file, pt: *mut poll_table_struct) -> __poll_t;
}
extern "C" {
    pub fn kernfs_notify(kn: *mut kernfs_node);
}
extern "C" {
    pub fn kernfs_xattr_get(
        kn: *mut kernfs_node,
        name: *const core::ffi::c_char,
        value: *mut core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernfs_xattr_set(
        kn: *mut kernfs_node,
        name: *const core::ffi::c_char,
        value: *const core::ffi::c_void,
        size: usize,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernfs_super_ns(sb: *mut super_block) -> *const core::ffi::c_void;
}
extern "C" {
    pub fn kernfs_get_tree(fc: *mut fs_context) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernfs_free_fs_context(fc: *mut fs_context);
}
extern "C" {
    pub fn kernfs_kill_sb(sb: *mut super_block);
}
extern "C" {
    pub fn kernfs_init();
}
extern "C" {
    pub fn kernfs_find_and_get_node_by_id(root: *mut kernfs_root, id: u64_) -> *mut kernfs_node;
}
pub const kobj_ns_type_KOBJ_NS_TYPE_NONE: kobj_ns_type = 0;
pub const kobj_ns_type_KOBJ_NS_TYPE_NET: kobj_ns_type = 1;
pub const kobj_ns_type_KOBJ_NS_TYPES: kobj_ns_type = 2;
pub type kobj_ns_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_ns_type_operations {
    pub type_: kobj_ns_type,
    pub current_may_mount: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub grab_current_ns: ::core::option::Option<unsafe extern "C" fn() -> *mut core::ffi::c_void>,
    pub netlink_ns:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> *const core::ffi::c_void>,
    pub initial_ns: ::core::option::Option<unsafe extern "C" fn() -> *const core::ffi::c_void>,
    pub drop_ns: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
}
impl Default for kobj_ns_type_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn kobj_ns_type_register(ops: *const kobj_ns_type_operations) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobj_ns_type_registered(type_: kobj_ns_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobj_child_ns_ops(parent: *const kobject) -> *const kobj_ns_type_operations;
}
extern "C" {
    pub fn kobj_ns_ops(kobj: *const kobject) -> *const kobj_ns_type_operations;
}
extern "C" {
    pub fn kobj_ns_current_may_mount(type_: kobj_ns_type) -> bool_;
}
extern "C" {
    pub fn kobj_ns_grab_current(type_: kobj_ns_type) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kobj_ns_netlink(type_: kobj_ns_type, sk: *mut sock) -> *const core::ffi::c_void;
}
extern "C" {
    pub fn kobj_ns_initial(type_: kobj_ns_type) -> *const core::ffi::c_void;
}
extern "C" {
    pub fn kobj_ns_drop(type_: kobj_ns_type, ns: *mut core::ffi::c_void);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct attribute {
    pub name: *const core::ffi::c_char,
    pub mode: umode_t,
}
impl Default for attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bin_attribute {
    pub attr: attribute,
    pub size: usize,
    pub private: *mut core::ffi::c_void,
    pub f_mapping: ::core::option::Option<unsafe extern "C" fn() -> *mut address_space>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: *mut core::ffi::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: *mut core::ffi::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: loff_t,
            arg5: core::ffi::c_int,
        ) -> loff_t,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            attr: *mut bin_attribute,
            vma: *mut vm_area_struct,
        ) -> core::ffi::c_int,
    >,
}
impl Default for bin_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sysfs_ops {
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *mut core::ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *const core::ffi::c_char,
            arg4: usize,
        ) -> isize,
    >,
}
extern "C" {
    pub fn sysfs_create_dir_ns(
        kobj: *mut kobject,
        ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_remove_dir(kobj: *mut kobject);
}
extern "C" {
    pub fn sysfs_rename_dir_ns(
        kobj: *mut kobject,
        new_name: *const core::ffi::c_char,
        new_ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_move_dir_ns(
        kobj: *mut kobject,
        new_parent_kobj: *mut kobject,
        new_ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_create_mount_point(
        parent_kobj: *mut kobject,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_remove_mount_point(parent_kobj: *mut kobject, name: *const core::ffi::c_char);
}
extern "C" {
    pub fn sysfs_create_file_ns(
        kobj: *mut kobject,
        attr: *const attribute,
        ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_create_files(
        kobj: *mut kobject,
        attr: *const *const attribute,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_chmod_file(
        kobj: *mut kobject,
        attr: *const attribute,
        mode: umode_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_break_active_protection(
        kobj: *mut kobject,
        attr: *const attribute,
    ) -> *mut kernfs_node;
}
extern "C" {
    pub fn sysfs_unbreak_active_protection(kn: *mut kernfs_node);
}
extern "C" {
    pub fn sysfs_remove_file_ns(
        kobj: *mut kobject,
        attr: *const attribute,
        ns: *const core::ffi::c_void,
    );
}
extern "C" {
    pub fn sysfs_remove_file_self(kobj: *mut kobject, attr: *const attribute) -> bool_;
}
extern "C" {
    pub fn sysfs_remove_files(kobj: *mut kobject, attr: *const *const attribute);
}
extern "C" {
    pub fn sysfs_create_bin_file(
        kobj: *mut kobject,
        attr: *const bin_attribute,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_remove_bin_file(kobj: *mut kobject, attr: *const bin_attribute);
}
extern "C" {
    pub fn sysfs_create_link(
        kobj: *mut kobject,
        target: *mut kobject,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_create_link_nowarn(
        kobj: *mut kobject,
        target: *mut kobject,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_remove_link(kobj: *mut kobject, name: *const core::ffi::c_char);
}
extern "C" {
    pub fn sysfs_rename_link_ns(
        kobj: *mut kobject,
        target: *mut kobject,
        old_name: *const core::ffi::c_char,
        new_name: *const core::ffi::c_char,
        new_ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_delete_link(dir: *mut kobject, targ: *mut kobject, name: *const core::ffi::c_char);
}
extern "C" {
    pub fn sysfs_create_group(kobj: *mut kobject, grp: *const attribute_group) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_create_groups(
        kobj: *mut kobject,
        groups: *mut *const attribute_group,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_update_groups(
        kobj: *mut kobject,
        groups: *mut *const attribute_group,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_update_group(kobj: *mut kobject, grp: *const attribute_group) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_remove_group(kobj: *mut kobject, grp: *const attribute_group);
}
extern "C" {
    pub fn sysfs_remove_groups(kobj: *mut kobject, groups: *mut *const attribute_group);
}
extern "C" {
    pub fn sysfs_add_file_to_group(
        kobj: *mut kobject,
        attr: *const attribute,
        group: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_remove_file_from_group(
        kobj: *mut kobject,
        attr: *const attribute,
        group: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn sysfs_merge_group(kobj: *mut kobject, grp: *const attribute_group) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_unmerge_group(kobj: *mut kobject, grp: *const attribute_group);
}
extern "C" {
    pub fn sysfs_add_link_to_group(
        kobj: *mut kobject,
        group_name: *const core::ffi::c_char,
        target: *mut kobject,
        link_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_remove_link_from_group(
        kobj: *mut kobject,
        group_name: *const core::ffi::c_char,
        link_name: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn compat_only_sysfs_link_entry_to_kobj(
        kobj: *mut kobject,
        target_kobj: *mut kobject,
        target_name: *const core::ffi::c_char,
        symlink_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_notify(
        kobj: *mut kobject,
        dir: *const core::ffi::c_char,
        attr: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn sysfs_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_file_change_owner(
        kobj: *mut kobject,
        name: *const core::ffi::c_char,
        kuid: kuid_t,
        kgid: kgid_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_change_owner(kobj: *mut kobject, kuid: kuid_t, kgid: kgid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_link_change_owner(
        kobj: *mut kobject,
        targ: *mut kobject,
        name: *const core::ffi::c_char,
        kuid: kuid_t,
        kgid: kgid_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_groups_change_owner(
        kobj: *mut kobject,
        groups: *mut *const attribute_group,
        kuid: kuid_t,
        kgid: kgid_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_group_change_owner(
        kobj: *mut kobject,
        groups: *const attribute_group,
        kuid: kuid_t,
        kgid: kgid_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_emit(
        buf: *mut core::ffi::c_char,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_emit_at(
        buf: *mut core::ffi::c_char,
        at: core::ffi::c_int,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut uevent_helper: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut uevent_seqnum: u64_;
}
pub const kobject_action_KOBJ_ADD: kobject_action = 0;
pub const kobject_action_KOBJ_REMOVE: kobject_action = 1;
pub const kobject_action_KOBJ_CHANGE: kobject_action = 2;
pub const kobject_action_KOBJ_MOVE: kobject_action = 3;
pub const kobject_action_KOBJ_ONLINE: kobject_action = 4;
pub const kobject_action_KOBJ_OFFLINE: kobject_action = 5;
pub const kobject_action_KOBJ_BIND: kobject_action = 6;
pub const kobject_action_KOBJ_UNBIND: kobject_action = 7;
pub type kobject_action = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobject {
    pub name: *const core::ffi::c_char,
    pub entry: list_head,
    pub parent: *mut kobject,
    pub kset: *mut kset,
    pub ktype: *const kobj_type,
    pub sd: *mut kernfs_node,
    pub kref: kref,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for kobject {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl kobject {
    #[inline]
    pub fn state_initialized(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_initialized(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_in_sysfs(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_in_sysfs(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_add_uevent_sent(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_add_uevent_sent(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_remove_uevent_sent(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_remove_uevent_sent(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uevent_suppress(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uevent_suppress(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state_initialized: core::ffi::c_uint,
        state_in_sysfs: core::ffi::c_uint,
        state_add_uevent_sent: core::ffi::c_uint,
        state_remove_uevent_sent: core::ffi::c_uint,
        uevent_suppress: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let state_initialized: u32 = unsafe { ::core::mem::transmute(state_initialized) };
            state_initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let state_in_sysfs: u32 = unsafe { ::core::mem::transmute(state_in_sysfs) };
            state_in_sysfs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let state_add_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_add_uevent_sent) };
            state_add_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_remove_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_remove_uevent_sent) };
            state_remove_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let uevent_suppress: u32 = unsafe { ::core::mem::transmute(uevent_suppress) };
            uevent_suppress as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn kobject_set_name(
        kobj: *mut kobject,
        name: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobject_set_name_vargs(
        kobj: *mut kobject,
        fmt: *const core::ffi::c_char,
        vargs: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobject_init(kobj: *mut kobject, ktype: *const kobj_type);
}
extern "C" {
    pub fn kobject_add(
        kobj: *mut kobject,
        parent: *mut kobject,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobject_init_and_add(
        kobj: *mut kobject,
        ktype: *const kobj_type,
        parent: *mut kobject,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobject_del(kobj: *mut kobject);
}
extern "C" {
    pub fn kobject_create_and_add(
        name: *const core::ffi::c_char,
        parent: *mut kobject,
    ) -> *mut kobject;
}
extern "C" {
    pub fn kobject_rename(
        arg1: *mut kobject,
        new_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobject_move(arg1: *mut kobject, arg2: *mut kobject) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobject_get(kobj: *mut kobject) -> *mut kobject;
}
extern "C" {
    pub fn kobject_get_unless_zero(kobj: *mut kobject) -> *mut kobject;
}
extern "C" {
    pub fn kobject_put(kobj: *mut kobject);
}
extern "C" {
    pub fn kobject_namespace(kobj: *const kobject) -> *const core::ffi::c_void;
}
extern "C" {
    pub fn kobject_get_ownership(kobj: *const kobject, uid: *mut kuid_t, gid: *mut kgid_t);
}
extern "C" {
    pub fn kobject_get_path(kobj: *const kobject, flag: gfp_t) -> *mut core::ffi::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_type {
    pub release: ::core::option::Option<unsafe extern "C" fn(kobj: *mut kobject)>,
    pub sysfs_ops: *const sysfs_ops,
    pub default_groups: *mut *const attribute_group,
    pub child_ns_type: ::core::option::Option<
        unsafe extern "C" fn(kobj: *const kobject) -> *const kobj_ns_type_operations,
    >,
    pub namespace: ::core::option::Option<
        unsafe extern "C" fn(kobj: *const kobject) -> *const core::ffi::c_void,
    >,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(kobj: *const kobject, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
}
impl Default for kobj_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_uevent_env {
    pub argv: [*mut core::ffi::c_char; 3usize],
    pub envp: [*mut core::ffi::c_char; 64usize],
    pub envp_idx: core::ffi::c_int,
    pub buf: [core::ffi::c_char; 2048usize],
    pub buflen: core::ffi::c_int,
}
impl Default for kobj_uevent_env {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kset_uevent_ops {
    pub filter:
        ::core::option::Option<unsafe extern "C" fn(kobj: *const kobject) -> core::ffi::c_int>,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(kobj: *const kobject) -> *const core::ffi::c_char,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(kobj: *const kobject, env: *mut kobj_uevent_env) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            kobj: *mut kobject,
            attr: *mut kobj_attribute,
            buf: *mut core::ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            kobj: *mut kobject,
            attr: *mut kobj_attribute,
            buf: *const core::ffi::c_char,
            count: usize,
        ) -> isize,
    >,
}
impl Default for kobj_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static kobj_sysfs_ops: sysfs_ops;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kset {
    pub list: list_head,
    pub list_lock: spinlock_t,
    pub kobj: kobject,
    pub uevent_ops: *const kset_uevent_ops,
}
impl Default for kset {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn kset_init(kset: *mut kset);
}
extern "C" {
    pub fn kset_register(kset: *mut kset) -> core::ffi::c_int;
}
extern "C" {
    pub fn kset_unregister(kset: *mut kset);
}
extern "C" {
    pub fn kset_create_and_add(
        name: *const core::ffi::c_char,
        u: *const kset_uevent_ops,
        parent_kobj: *mut kobject,
    ) -> *mut kset;
}
extern "C" {
    pub fn kset_find_obj(arg1: *mut kset, arg2: *const core::ffi::c_char) -> *mut kobject;
}
extern "C" {
    pub static mut kernel_kobj: *mut kobject;
}
extern "C" {
    pub static mut mm_kobj: *mut kobject;
}
extern "C" {
    pub static mut hypervisor_kobj: *mut kobject;
}
extern "C" {
    pub static mut power_kobj: *mut kobject;
}
extern "C" {
    pub static mut firmware_kobj: *mut kobject;
}
extern "C" {
    pub fn kobject_uevent(kobj: *mut kobject, action: kobject_action) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobject_uevent_env(
        kobj: *mut kobject,
        action: kobject_action,
        envp: *mut *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobject_synth_uevent(
        kobj: *mut kobject,
        buf: *const core::ffi::c_char,
        count: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn add_uevent_var(
        env: *mut kobj_uevent_env,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
pub const KERNEL_PARAM_OPS_FL_NOARG: _bindgen_ty_95 = 1;
pub type _bindgen_ty_95 = core::ffi::c_uint;
pub const KERNEL_PARAM_FL_UNSAFE: _bindgen_ty_96 = 1;
pub const KERNEL_PARAM_FL_HWPARAM: _bindgen_ty_96 = 2;
pub type _bindgen_ty_96 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_param {
    pub name: *const core::ffi::c_char,
    pub mod_: *mut module,
    pub ops: *const kernel_param_ops,
    pub perm: u16_,
    pub level: s8,
    pub flags: u8_,
    pub __bindgen_anon_1: kernel_param__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernel_param__bindgen_ty_1 {
    pub arg: *mut core::ffi::c_void,
    pub str_: *const kparam_string,
    pub arr: *const kparam_array,
}
impl Default for kernel_param__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kernel_param {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static __start___param: [kernel_param; 0usize];
}
extern "C" {
    pub static __stop___param: [kernel_param; 0usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kparam_string {
    pub maxlen: core::ffi::c_uint,
    pub string: *mut core::ffi::c_char,
}
impl Default for kparam_string {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kparam_array {
    pub max: core::ffi::c_uint,
    pub elemsize: core::ffi::c_uint,
    pub num: *mut core::ffi::c_uint,
    pub ops: *const kernel_param_ops,
    pub elem: *mut core::ffi::c_void,
}
impl Default for kparam_array {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn kernel_param_lock(mod_: *mut module);
}
extern "C" {
    pub fn kernel_param_unlock(mod_: *mut module);
}
extern "C" {
    pub fn parameq(name1: *const core::ffi::c_char, name2: *const core::ffi::c_char) -> bool_;
}
extern "C" {
    pub fn parameqn(
        name1: *const core::ffi::c_char,
        name2: *const core::ffi::c_char,
        n: usize,
    ) -> bool_;
}
pub type parse_unknown_fn = ::core::option::Option<
    unsafe extern "C" fn(
        param: *mut core::ffi::c_char,
        val: *mut core::ffi::c_char,
        doing: *const core::ffi::c_char,
        arg: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
extern "C" {
    pub fn parse_args(
        name: *const core::ffi::c_char,
        args: *mut core::ffi::c_char,
        params: *const kernel_param,
        num: core::ffi::c_uint,
        level_min: s16,
        level_max: s16,
        arg: *mut core::ffi::c_void,
        unknown: parse_unknown_fn,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn destroy_params(params: *const kernel_param, num: core::ffi::c_uint);
}
extern "C" {
    pub static param_ops_byte: kernel_param_ops;
}
extern "C" {
    pub fn param_set_byte(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_byte(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_short: kernel_param_ops;
}
extern "C" {
    pub fn param_set_short(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_short(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_ushort: kernel_param_ops;
}
extern "C" {
    pub fn param_set_ushort(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_ushort(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_int: kernel_param_ops;
}
extern "C" {
    pub fn param_set_int(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_int(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_uint: kernel_param_ops;
}
extern "C" {
    pub fn param_set_uint(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_uint(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_set_uint_minmax(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
        min: core::ffi::c_uint,
        max: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_long: kernel_param_ops;
}
extern "C" {
    pub fn param_set_long(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_long(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_ulong: kernel_param_ops;
}
extern "C" {
    pub fn param_set_ulong(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_ulong(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_ullong: kernel_param_ops;
}
extern "C" {
    pub fn param_set_ullong(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_ullong(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_hexint: kernel_param_ops;
}
extern "C" {
    pub fn param_set_hexint(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_hexint(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_charp: kernel_param_ops;
}
extern "C" {
    pub fn param_set_charp(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_charp(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_free_charp(arg: *mut core::ffi::c_void);
}
extern "C" {
    pub static param_ops_bool: kernel_param_ops;
}
extern "C" {
    pub fn param_set_bool(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_bool(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_bool_enable_only: kernel_param_ops;
}
extern "C" {
    pub fn param_set_bool_enable_only(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_invbool: kernel_param_ops;
}
extern "C" {
    pub fn param_set_invbool(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_invbool(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_bint: kernel_param_ops;
}
extern "C" {
    pub fn param_set_bint(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
pub const hwparam_type_hwparam_ioport: hwparam_type = 0;
pub const hwparam_type_hwparam_iomem: hwparam_type = 1;
pub const hwparam_type_hwparam_ioport_or_iomem: hwparam_type = 2;
pub const hwparam_type_hwparam_irq: hwparam_type = 3;
pub const hwparam_type_hwparam_dma: hwparam_type = 4;
pub const hwparam_type_hwparam_dma_addr: hwparam_type = 5;
pub const hwparam_type_hwparam_other: hwparam_type = 6;
pub type hwparam_type = core::ffi::c_uint;
extern "C" {
    pub static param_array_ops: kernel_param_ops;
}
extern "C" {
    pub static param_ops_string: kernel_param_ops;
}
extern "C" {
    pub fn param_set_copystring(
        val: *const core::ffi::c_char,
        arg1: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_string(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn module_param_sysfs_setup(
        mod_: *mut module,
        kparam: *const kernel_param,
        num_params: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn module_param_sysfs_remove(mod_: *mut module);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct latch_tree_node {
    pub node: [rb_node; 2usize],
}
impl Default for latch_tree_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct latch_tree_root {
    pub seq: seqcount_latch_t,
    pub tree: [rb_root; 2usize],
}
impl Default for latch_tree_root {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct latch_tree_ops {
    pub less: ::core::option::Option<
        unsafe extern "C" fn(a: *mut latch_tree_node, b: *mut latch_tree_node) -> bool_,
    >,
    pub comp: ::core::option::Option<
        unsafe extern "C" fn(
            key: *mut core::ffi::c_void,
            b: *mut latch_tree_node,
        ) -> core::ffi::c_int,
    >,
}
pub const EI_ETYPE_NULL: _bindgen_ty_97 = 0;
pub const EI_ETYPE_ERRNO: _bindgen_ty_97 = 1;
pub const EI_ETYPE_ERRNO_NULL: _bindgen_ty_97 = 2;
pub const EI_ETYPE_TRUE: _bindgen_ty_97 = 3;
pub type _bindgen_ty_97 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct error_injection_entry {
    pub addr: core::ffi::c_ulong,
    pub etype: core::ffi::c_int,
}
extern "C" {
    pub fn override_function_with_return(regs: *mut pt_regs);
}
extern "C" {
    pub fn within_error_injection_list(addr: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn get_injectable_error_type(addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mod_arch_specific {}
#[repr(C, packed)]
pub struct modversion_info {
    pub next: u32_,
    pub crc: u32_,
    pub name: __IncompleteArrayField<core::ffi::c_char>,
}
impl Default for modversion_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_kobject {
    pub kobj: kobject,
    pub mod_: *mut module,
    pub drivers_dir: *mut kobject,
    pub mp: *mut module_param_attrs,
    pub kobj_completion: *mut completion,
}
impl Default for module_kobject {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module_attribute,
            arg2: *mut module_kobject,
            arg3: *mut core::ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module_attribute,
            arg2: *mut module_kobject,
            arg3: *const core::ffi::c_char,
            count: usize,
        ) -> isize,
    >,
    pub setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut module, arg2: *const core::ffi::c_char),
    >,
    pub test: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module) -> core::ffi::c_int>,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module)>,
}
impl Default for module_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_version_attribute {
    pub mattr: module_attribute,
    pub module_name: *const core::ffi::c_char,
    pub version: *const core::ffi::c_char,
}
impl Default for module_version_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __modver_version_show(
        arg1: *mut module_attribute,
        arg2: *mut module_kobject,
        arg3: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub static mut module_uevent: module_attribute;
}
extern "C" {
    pub fn init_module() -> core::ffi::c_int;
}
extern "C" {
    pub fn cleanup_module();
}
extern "C" {
    pub static mut modules_disabled: core::ffi::c_int;
}
extern "C" {
    pub fn __symbol_get(symbol: *const core::ffi::c_char) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __symbol_get_gpl(symbol: *const core::ffi::c_char) -> *mut core::ffi::c_void;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_use {
    pub source_list: list_head,
    pub target_list: list_head,
    pub source: *mut module,
    pub target: *mut module,
}
impl Default for module_use {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const module_state_MODULE_STATE_LIVE: module_state = 0;
pub const module_state_MODULE_STATE_COMING: module_state = 1;
pub const module_state_MODULE_STATE_GOING: module_state = 2;
pub const module_state_MODULE_STATE_UNFORMED: module_state = 3;
pub type module_state = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mod_tree_node {
    pub mod_: *mut module,
    pub node: latch_tree_node,
}
impl Default for mod_tree_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const mod_mem_type_MOD_TEXT: mod_mem_type = 0;
pub const mod_mem_type_MOD_DATA: mod_mem_type = 1;
pub const mod_mem_type_MOD_RODATA: mod_mem_type = 2;
pub const mod_mem_type_MOD_RO_AFTER_INIT: mod_mem_type = 3;
pub const mod_mem_type_MOD_INIT_TEXT: mod_mem_type = 4;
pub const mod_mem_type_MOD_INIT_DATA: mod_mem_type = 5;
pub const mod_mem_type_MOD_INIT_RODATA: mod_mem_type = 6;
pub const mod_mem_type_MOD_MEM_NUM_TYPES: mod_mem_type = 7;
pub const mod_mem_type_MOD_INVALID: mod_mem_type = -1;
pub type mod_mem_type = core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_memory {
    pub base: *mut core::ffi::c_void,
    pub size: core::ffi::c_uint,
    pub mtn: mod_tree_node,
}
impl Default for module_memory {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mod_kallsyms {
    pub symtab: *mut Elf64_Sym,
    pub num_symtab: core::ffi::c_uint,
    pub strtab: *mut core::ffi::c_char,
    pub typetab: *mut core::ffi::c_char,
}
impl Default for mod_kallsyms {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct klp_modinfo {
    pub hdr: Elf64_Ehdr,
    pub sechdrs: *mut Elf64_Shdr,
    pub secstrings: *mut core::ffi::c_char,
    pub symndx: core::ffi::c_uint,
}
impl Default for klp_modinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __module_text_address(addr: core::ffi::c_ulong) -> *mut module;
}
extern "C" {
    pub fn __module_address(addr: core::ffi::c_ulong) -> *mut module;
}
extern "C" {
    pub fn is_module_address(addr: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn __is_module_percpu_address(
        addr: core::ffi::c_ulong,
        can_addr: *mut core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn is_module_percpu_address(addr: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn is_module_text_address(addr: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn find_module(name: *const core::ffi::c_char) -> *mut module;
}
extern "C" {
    pub fn __module_put_and_kthread_exit(mod_: *mut module, code: core::ffi::c_long) -> !;
}
extern "C" {
    pub fn module_refcount(mod_: *mut module) -> core::ffi::c_int;
}
extern "C" {
    pub fn __symbol_put(symbol: *const core::ffi::c_char);
}
extern "C" {
    pub fn symbol_put_addr(addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn __module_get(module: *mut module);
}
extern "C" {
    pub fn try_module_get(module: *mut module) -> bool_;
}
extern "C" {
    pub fn module_put(module: *mut module);
}
extern "C" {
    pub fn dereference_module_function_descriptor(
        mod_: *mut module,
        ptr: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn register_module_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_module_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn print_modules();
}
extern "C" {
    pub fn set_module_sig_enforced();
}
extern "C" {
    pub static mut module_kset: *mut kset;
}
extern "C" {
    pub static module_ktype: kobj_type;
}
extern "C" {
    pub fn module_bug_finalize(arg1: *const Elf64_Ehdr, arg2: *const Elf64_Shdr, arg3: *mut module);
}
extern "C" {
    pub fn module_bug_cleanup(arg1: *mut module);
}
extern "C" {
    pub fn retpoline_module_ok(has_retpoline: bool_) -> bool_;
}
extern "C" {
    pub fn is_module_sig_enforced() -> bool_;
}
extern "C" {
    pub fn module_kallsyms_on_each_symbol(
        modname: *const core::ffi::c_char,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut core::ffi::c_void,
                arg2: *const core::ffi::c_char,
                arg3: core::ffi::c_ulong,
            ) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn module_address_lookup(
        addr: core::ffi::c_ulong,
        symbolsize: *mut core::ffi::c_ulong,
        offset: *mut core::ffi::c_ulong,
        modname: *mut *mut core::ffi::c_char,
        modbuildid: *mut *const core::ffi::c_uchar,
        namebuf: *mut core::ffi::c_char,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn lookup_module_symbol_name(
        addr: core::ffi::c_ulong,
        symname: *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lookup_module_symbol_attrs(
        addr: core::ffi::c_ulong,
        size: *mut core::ffi::c_ulong,
        offset: *mut core::ffi::c_ulong,
        modname: *mut core::ffi::c_char,
        name: *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn module_get_kallsym(
        symnum: core::ffi::c_uint,
        value: *mut core::ffi::c_ulong,
        type_: *mut core::ffi::c_char,
        name: *mut core::ffi::c_char,
        module_name: *mut core::ffi::c_char,
        exported: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn module_kallsyms_lookup_name(name: *const core::ffi::c_char) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn find_kallsyms_symbol_value(
        mod_: *mut module,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub static mut kunit_running: static_key_false;
}
pub const kunit_status_KUNIT_SUCCESS: kunit_status = 0;
pub const kunit_status_KUNIT_FAILURE: kunit_status = 1;
pub const kunit_status_KUNIT_SKIPPED: kunit_status = 2;
pub type kunit_status = core::ffi::c_uint;
pub const kunit_speed_KUNIT_SPEED_UNSET: kunit_speed = 0;
pub const kunit_speed_KUNIT_SPEED_VERY_SLOW: kunit_speed = 1;
pub const kunit_speed_KUNIT_SPEED_SLOW: kunit_speed = 2;
pub const kunit_speed_KUNIT_SPEED_NORMAL: kunit_speed = 3;
pub const kunit_speed_KUNIT_SPEED_MAX: kunit_speed = 3;
pub type kunit_speed = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_attributes {
    pub speed: kunit_speed,
}
impl Default for kunit_attributes {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_case {
    pub run_case: ::core::option::Option<unsafe extern "C" fn(test: *mut kunit)>,
    pub name: *const core::ffi::c_char,
    pub generate_params: ::core::option::Option<
        unsafe extern "C" fn(
            prev: *const core::ffi::c_void,
            desc: *mut core::ffi::c_char,
        ) -> *const core::ffi::c_void,
    >,
    pub attr: kunit_attributes,
    pub status: kunit_status,
    pub module_name: *mut core::ffi::c_char,
    pub log: *mut string_stream,
}
impl Default for kunit_case {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_suite {
    pub name: [core::ffi::c_char; 256usize],
    pub suite_init:
        ::core::option::Option<unsafe extern "C" fn(suite: *mut kunit_suite) -> core::ffi::c_int>,
    pub suite_exit: ::core::option::Option<unsafe extern "C" fn(suite: *mut kunit_suite)>,
    pub init: ::core::option::Option<unsafe extern "C" fn(test: *mut kunit) -> core::ffi::c_int>,
    pub exit: ::core::option::Option<unsafe extern "C" fn(test: *mut kunit)>,
    pub test_cases: *mut kunit_case,
    pub attr: kunit_attributes,
    pub status_comment: [core::ffi::c_char; 256usize],
    pub debugfs: *mut dentry,
    pub log: *mut string_stream,
    pub suite_init_err: core::ffi::c_int,
    pub is_init: bool_,
}
impl Default for kunit_suite {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_suite_set {
    pub start: *const *mut kunit_suite,
    pub end: *const *mut kunit_suite,
}
impl Default for kunit_suite_set {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit {
    pub priv_: *mut core::ffi::c_void,
    pub name: *const core::ffi::c_char,
    pub log: *mut string_stream,
    pub try_catch: kunit_try_catch,
    pub param_value: *const core::ffi::c_void,
    pub param_index: core::ffi::c_int,
    pub lock: spinlock_t,
    pub status: kunit_status,
    pub resources: list_head,
    pub status_comment: [core::ffi::c_char; 256usize],
}
impl Default for kunit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn kunit_enabled() -> bool_;
}
extern "C" {
    pub fn kunit_action() -> *const core::ffi::c_char;
}
extern "C" {
    pub fn kunit_filter_glob() -> *const core::ffi::c_char;
}
extern "C" {
    pub fn kunit_filter() -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn kunit_filter_action() -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn kunit_init_test(
        test: *mut kunit,
        name: *const core::ffi::c_char,
        log: *mut string_stream,
    );
}
extern "C" {
    pub fn kunit_run_tests(suite: *mut kunit_suite) -> core::ffi::c_int;
}
extern "C" {
    pub fn kunit_suite_num_test_cases(suite: *mut kunit_suite) -> usize;
}
extern "C" {
    pub fn kunit_test_case_num(
        suite: *mut kunit_suite,
        test_case: *mut kunit_case,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn kunit_filter_suites(
        suite_set: *const kunit_suite_set,
        filter_glob: *const core::ffi::c_char,
        filters: *mut core::ffi::c_char,
        filter_action: *mut core::ffi::c_char,
        err: *mut core::ffi::c_int,
    ) -> kunit_suite_set;
}
extern "C" {
    pub fn kunit_free_suite_set(suite_set: kunit_suite_set);
}
extern "C" {
    pub fn __kunit_test_suites_init(
        suites: *const *mut kunit_suite,
        num_suites: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __kunit_test_suites_exit(suites: *mut *mut kunit_suite, num_suites: core::ffi::c_int);
}
extern "C" {
    pub fn kunit_exec_run_tests(suite_set: *mut kunit_suite_set, builtin: bool_);
}
extern "C" {
    pub fn kunit_exec_list_tests(suite_set: *mut kunit_suite_set, include_attr: bool_);
}
extern "C" {
    pub fn kunit_merge_suite_sets(
        init_suite_set: kunit_suite_set,
        suite_set: kunit_suite_set,
    ) -> kunit_suite_set;
}
extern "C" {
    pub fn kunit_suite_has_succeeded(suite: *mut kunit_suite) -> kunit_status;
}
extern "C" {
    pub fn kunit_kmalloc_array(
        test: *mut kunit,
        n: usize,
        size: usize,
        gfp: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kunit_kfree(test: *mut kunit, ptr: *const core::ffi::c_void);
}
extern "C" {
    pub fn kunit_cleanup(test: *mut kunit);
}
extern "C" {
    pub fn kunit_log_append(log: *mut string_stream, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn __kunit_abort(test: *mut kunit) -> !;
}
extern "C" {
    pub fn __kunit_do_failed_assertion(
        test: *mut kunit,
        loc: *const kunit_loc,
        type_: kunit_assert_type,
        assert: *const kunit_assert,
        assert_format: assert_format_t,
        fmt: *const core::ffi::c_char,
        ...
    );
}
pub type kunit_resource_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut kunit_resource,
        arg2: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
pub type kunit_resource_free_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut kunit_resource)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_resource {
    pub data: *mut core::ffi::c_void,
    pub name: *const core::ffi::c_char,
    pub free: kunit_resource_free_t,
    pub refcount: kref,
    pub node: list_head,
    pub should_kfree: bool_,
}
impl Default for kunit_resource {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __kunit_add_resource(
        test: *mut kunit,
        init: kunit_resource_init_t,
        free: kunit_resource_free_t,
        res: *mut kunit_resource,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
pub type kunit_resource_match_t = ::core::option::Option<
    unsafe extern "C" fn(
        test: *mut kunit,
        res: *mut kunit_resource,
        match_data: *mut core::ffi::c_void,
    ) -> bool_,
>;
extern "C" {
    pub fn kunit_destroy_resource(
        test: *mut kunit,
        match_: kunit_resource_match_t,
        match_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kunit_remove_resource(test: *mut kunit, res: *mut kunit_resource);
}
pub type kunit_action_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>;
extern "C" {
    pub fn kunit_add_action(
        test: *mut kunit,
        action: kunit_action_t,
        ctx: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kunit_add_action_or_reset(
        test: *mut kunit,
        action: kunit_action_t,
        ctx: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kunit_remove_action(
        test: *mut kunit,
        action: kunit_action_t,
        ctx: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn kunit_release_action(
        test: *mut kunit,
        action: kunit_action_t,
        ctx: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn errname(err: core::ffi::c_int) -> *const core::ffi::c_char;
}
pub type stack_trace_consume_fn = ::core::option::Option<
    unsafe extern "C" fn(cookie: *mut core::ffi::c_void, addr: core::ffi::c_ulong) -> bool_,
>;
extern "C" {
    pub fn arch_stack_walk(
        consume_entry: stack_trace_consume_fn,
        cookie: *mut core::ffi::c_void,
        task: *mut task_struct,
        regs: *mut pt_regs,
    );
}
extern "C" {
    pub fn arch_stack_walk_reliable(
        consume_entry: stack_trace_consume_fn,
        cookie: *mut core::ffi::c_void,
        task: *mut task_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_stack_walk_user(
        consume_entry: stack_trace_consume_fn,
        cookie: *mut core::ffi::c_void,
        regs: *const pt_regs,
    );
}
extern "C" {
    pub fn stack_trace_print(
        trace: *const core::ffi::c_ulong,
        nr_entries: core::ffi::c_uint,
        spaces: core::ffi::c_int,
    );
}
extern "C" {
    pub fn stack_trace_snprint(
        buf: *mut core::ffi::c_char,
        size: usize,
        entries: *const core::ffi::c_ulong,
        nr_entries: core::ffi::c_uint,
        spaces: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn stack_trace_save(
        store: *mut core::ffi::c_ulong,
        size: core::ffi::c_uint,
        skipnr: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn stack_trace_save_tsk(
        task: *mut task_struct,
        store: *mut core::ffi::c_ulong,
        size: core::ffi::c_uint,
        skipnr: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn stack_trace_save_regs(
        regs: *mut pt_regs,
        store: *mut core::ffi::c_ulong,
        size: core::ffi::c_uint,
        skipnr: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn stack_trace_save_user(
        store: *mut core::ffi::c_ulong,
        size: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn filter_irq_stacks(
        entries: *mut core::ffi::c_ulong,
        nr_entries: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn stack_trace_save_tsk_reliable(
        tsk: *mut task_struct,
        store: *mut core::ffi::c_ulong,
        size: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
pub type depot_stack_handle_t = u32_;
#[repr(C)]
#[derive(Copy, Clone)]
pub union handle_parts {
    pub handle: depot_stack_handle_t,
    pub __bindgen_anon_1: handle_parts__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Default, Copy, Clone)]
pub struct handle_parts__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl handle_parts__bindgen_ty_1 {
    #[inline]
    pub fn pool_index_plus_1(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_pool_index_plus_1(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn offset(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_offset(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn extra(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_extra(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pool_index_plus_1: u32_,
        offset: u32_,
        extra: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 17u8, {
            let pool_index_plus_1: u32 = unsafe { ::core::mem::transmute(pool_index_plus_1) };
            pool_index_plus_1 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 10u8, {
            let offset: u32 = unsafe { ::core::mem::transmute(offset) };
            offset as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let extra: u32 = unsafe { ::core::mem::transmute(extra) };
            extra as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for handle_parts {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct stack_record {
    pub hash_list: list_head,
    pub hash: u32_,
    pub size: u32_,
    pub handle: handle_parts,
    pub count: refcount_t,
    pub __bindgen_anon_1: stack_record__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union stack_record__bindgen_ty_1 {
    pub entries: [core::ffi::c_ulong; 64usize],
    pub __bindgen_anon_1: stack_record__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct stack_record__bindgen_ty_1__bindgen_ty_1 {
    pub free_list: list_head,
    pub rcu_state: core::ffi::c_ulong,
}
impl Default for stack_record__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for stack_record__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for stack_record {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type depot_flags_t = u32_;
extern "C" {
    pub fn stack_depot_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn stack_depot_request_early_init();
}
extern "C" {
    pub fn stack_depot_early_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn stack_depot_save_flags(
        entries: *mut core::ffi::c_ulong,
        nr_entries: core::ffi::c_uint,
        gfp_flags: gfp_t,
        depot_flags: depot_flags_t,
    ) -> depot_stack_handle_t;
}
extern "C" {
    pub fn stack_depot_save(
        entries: *mut core::ffi::c_ulong,
        nr_entries: core::ffi::c_uint,
        gfp_flags: gfp_t,
    ) -> depot_stack_handle_t;
}
extern "C" {
    pub fn stack_depot_fetch(
        handle: depot_stack_handle_t,
        entries: *mut *mut core::ffi::c_ulong,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn stack_depot_print(stack: depot_stack_handle_t);
}
extern "C" {
    pub fn stack_depot_snprint(
        handle: depot_stack_handle_t,
        buf: *mut core::ffi::c_char,
        size: usize,
        spaces: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn stack_depot_put(handle: depot_stack_handle_t);
}
extern "C" {
    pub fn stack_depot_set_extra_bits(
        handle: depot_stack_handle_t,
        extra_bits: core::ffi::c_uint,
    ) -> depot_stack_handle_t;
}
extern "C" {
    pub fn stack_depot_get_extra_bits(handle: depot_stack_handle_t) -> core::ffi::c_uint;
}
extern "C" {
    pub static mut __tracepoint_page_ref_set: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_page_ref_mod: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_page_ref_mod_and_test: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_page_ref_mod_and_return: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_page_ref_mod_unless: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_page_ref_freeze: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_page_ref_unfreeze: tracepoint;
}
extern "C" {
    pub fn pte_free_defer(mm: *mut mm_struct, pgtable: pgtable_t);
}
extern "C" {
    pub fn ptep_clear_flush(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        ptep: *mut pte_t,
    ) -> pte_t;
}
extern "C" {
    pub fn pmdp_huge_clear_flush(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        pmdp: *mut pmd_t,
    ) -> pmd_t;
}
extern "C" {
    pub fn pudp_huge_clear_flush(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        pudp: *mut pud_t,
    ) -> pud_t;
}
extern "C" {
    pub fn pmdp_collapse_flush(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        pmdp: *mut pmd_t,
    ) -> pmd_t;
}
extern "C" {
    pub fn pgtable_trans_huge_deposit(mm: *mut mm_struct, pmdp: *mut pmd_t, pgtable: pgtable_t);
}
extern "C" {
    pub fn pgtable_trans_huge_withdraw(mm: *mut mm_struct, pmdp: *mut pmd_t) -> pgtable_t;
}
extern "C" {
    pub fn pmdp_invalidate(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        pmdp: *mut pmd_t,
    ) -> pmd_t;
}
extern "C" {
    pub fn pgd_clear_bad(arg1: *mut pgd_t);
}
extern "C" {
    pub fn p4d_clear_bad(arg1: *mut p4d_t);
}
extern "C" {
    pub fn pud_clear_bad(arg1: *mut pud_t);
}
extern "C" {
    pub fn pmd_clear_bad(arg1: *mut pmd_t);
}
extern "C" {
    pub fn track_pfn_remap(
        vma: *mut vm_area_struct,
        prot: *mut pgprot_t,
        pfn: core::ffi::c_ulong,
        addr: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn track_pfn_insert(vma: *mut vm_area_struct, prot: *mut pgprot_t, pfn: pfn_t);
}
extern "C" {
    pub fn track_pfn_copy(vma: *mut vm_area_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn untrack_pfn(
        vma: *mut vm_area_struct,
        pfn: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        mm_wr_locked: bool_,
    );
}
extern "C" {
    pub fn untrack_pfn_clear(vma: *mut vm_area_struct);
}
extern "C" {
    pub fn p4d_set_huge(p4d: *mut p4d_t, addr: phys_addr_t, prot: pgprot_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn p4d_clear_huge(p4d: *mut p4d_t);
}
extern "C" {
    pub fn pud_set_huge(pud: *mut pud_t, addr: phys_addr_t, prot: pgprot_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn pmd_set_huge(pmd: *mut pmd_t, addr: phys_addr_t, prot: pgprot_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn pud_clear_huge(pud: *mut pud_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn pmd_clear_huge(pmd: *mut pmd_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn p4d_free_pud_page(p4d: *mut p4d_t, addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn pud_free_pmd_page(pud: *mut pud_t, addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn pmd_free_pte_page(pmd: *mut pmd_t, addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn phys_mem_access_prot_allowed(
        file: *mut file,
        pfn: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        vma_prot: *mut pgprot_t,
    ) -> core::ffi::c_int;
}
pub type pgtbl_mod_mask = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct resource {
    pub start: resource_size_t,
    pub end: resource_size_t,
    pub name: *const core::ffi::c_char,
    pub flags: core::ffi::c_ulong,
    pub desc: core::ffi::c_ulong,
    pub parent: *mut resource,
    pub sibling: *mut resource,
    pub child: *mut resource,
}
impl Default for resource {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const IORES_DESC_NONE: _bindgen_ty_98 = 0;
pub const IORES_DESC_CRASH_KERNEL: _bindgen_ty_98 = 1;
pub const IORES_DESC_ACPI_TABLES: _bindgen_ty_98 = 2;
pub const IORES_DESC_ACPI_NV_STORAGE: _bindgen_ty_98 = 3;
pub const IORES_DESC_PERSISTENT_MEMORY: _bindgen_ty_98 = 4;
pub const IORES_DESC_PERSISTENT_MEMORY_LEGACY: _bindgen_ty_98 = 5;
pub const IORES_DESC_DEVICE_PRIVATE_MEMORY: _bindgen_ty_98 = 6;
pub const IORES_DESC_RESERVED: _bindgen_ty_98 = 7;
pub const IORES_DESC_SOFT_RESERVED: _bindgen_ty_98 = 8;
pub const IORES_DESC_CXL: _bindgen_ty_98 = 9;
pub type _bindgen_ty_98 = core::ffi::c_uint;
pub const IORES_MAP_SYSTEM_RAM: _bindgen_ty_99 = 1;
pub const IORES_MAP_ENCRYPTED: _bindgen_ty_99 = 2;
pub type _bindgen_ty_99 = core::ffi::c_uint;
extern "C" {
    pub static mut ioport_resource: resource;
}
extern "C" {
    pub static mut iomem_resource: resource;
}
extern "C" {
    pub fn request_resource_conflict(root: *mut resource, new: *mut resource) -> *mut resource;
}
extern "C" {
    pub fn request_resource(root: *mut resource, new: *mut resource) -> core::ffi::c_int;
}
extern "C" {
    pub fn release_resource(new: *mut resource) -> core::ffi::c_int;
}
extern "C" {
    pub fn release_child_resources(new: *mut resource);
}
extern "C" {
    pub fn reserve_region_with_split(
        root: *mut resource,
        start: resource_size_t,
        end: resource_size_t,
        name: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn insert_resource_conflict(parent: *mut resource, new: *mut resource) -> *mut resource;
}
extern "C" {
    pub fn insert_resource(parent: *mut resource, new: *mut resource) -> core::ffi::c_int;
}
extern "C" {
    pub fn insert_resource_expand_to_fit(root: *mut resource, new: *mut resource);
}
extern "C" {
    pub fn remove_resource(old: *mut resource) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_remove_reservations(avail: *mut resource);
}
extern "C" {
    pub fn allocate_resource(
        root: *mut resource,
        new: *mut resource,
        size: resource_size_t,
        min: resource_size_t,
        max: resource_size_t,
        align: resource_size_t,
        alignf: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut core::ffi::c_void,
                arg2: *const resource,
                arg3: resource_size_t,
                arg4: resource_size_t,
            ) -> resource_size_t,
        >,
        alignf_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lookup_resource(root: *mut resource, start: resource_size_t) -> *mut resource;
}
extern "C" {
    pub fn adjust_resource(
        res: *mut resource,
        start: resource_size_t,
        size: resource_size_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn resource_alignment(res: *mut resource) -> resource_size_t;
}
extern "C" {
    pub fn __request_region(
        arg1: *mut resource,
        start: resource_size_t,
        n: resource_size_t,
        name: *const core::ffi::c_char,
        flags: core::ffi::c_int,
    ) -> *mut resource;
}
extern "C" {
    pub fn __release_region(arg1: *mut resource, arg2: resource_size_t, arg3: resource_size_t);
}
extern "C" {
    pub fn release_mem_region_adjustable(arg1: resource_size_t, arg2: resource_size_t);
}
extern "C" {
    pub fn merge_system_ram_resource(res: *mut resource);
}
extern "C" {
    pub fn devm_request_resource(
        dev: *mut device,
        root: *mut resource,
        new: *mut resource,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_release_resource(dev: *mut device, new: *mut resource);
}
extern "C" {
    pub fn __devm_request_region(
        dev: *mut device,
        parent: *mut resource,
        start: resource_size_t,
        n: resource_size_t,
        name: *const core::ffi::c_char,
    ) -> *mut resource;
}
extern "C" {
    pub fn __devm_release_region(
        dev: *mut device,
        parent: *mut resource,
        start: resource_size_t,
        n: resource_size_t,
    );
}
extern "C" {
    pub fn iomem_map_sanity_check(
        addr: resource_size_t,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn iomem_is_exclusive(addr: u64_) -> bool_;
}
extern "C" {
    pub fn resource_is_exclusive(
        resource: *mut resource,
        addr: u64_,
        size: resource_size_t,
    ) -> bool_;
}
extern "C" {
    pub fn walk_system_ram_range(
        start_pfn: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        arg: *mut core::ffi::c_void,
        func: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: core::ffi::c_ulong,
                arg2: core::ffi::c_ulong,
                arg3: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn walk_mem_res(
        start: u64_,
        end: u64_,
        arg: *mut core::ffi::c_void,
        func: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut resource,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn walk_system_ram_res(
        start: u64_,
        end: u64_,
        arg: *mut core::ffi::c_void,
        func: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut resource,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn walk_system_ram_res_rev(
        start: u64_,
        end: u64_,
        arg: *mut core::ffi::c_void,
        func: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut resource,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn walk_iomem_res_desc(
        desc: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
        start: u64_,
        end: u64_,
        arg: *mut core::ffi::c_void,
        func: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut resource,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_request_free_mem_region(
        dev: *mut device,
        base: *mut resource,
        size: core::ffi::c_ulong,
    ) -> *mut resource;
}
extern "C" {
    pub fn request_free_mem_region(
        base: *mut resource,
        size: core::ffi::c_ulong,
        name: *const core::ffi::c_char,
    ) -> *mut resource;
}
extern "C" {
    pub fn alloc_free_mem_region(
        base: *mut resource,
        size: core::ffi::c_ulong,
        align: core::ffi::c_ulong,
        name: *const core::ffi::c_char,
    ) -> *mut resource;
}
extern "C" {
    pub fn iomem_get_mapping() -> *mut address_space;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vmem_altmap {
    pub base_pfn: core::ffi::c_ulong,
    pub end_pfn: core::ffi::c_ulong,
    pub reserve: core::ffi::c_ulong,
    pub free: core::ffi::c_ulong,
    pub align: core::ffi::c_ulong,
    pub alloc: core::ffi::c_ulong,
    pub inaccessible: bool_,
}
pub const memory_type_MEMORY_DEVICE_PRIVATE: memory_type = 1;
pub const memory_type_MEMORY_DEVICE_COHERENT: memory_type = 2;
pub const memory_type_MEMORY_DEVICE_FS_DAX: memory_type = 3;
pub const memory_type_MEMORY_DEVICE_GENERIC: memory_type = 4;
pub const memory_type_MEMORY_DEVICE_PCI_P2PDMA: memory_type = 5;
pub type memory_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pagemap_ops {
    pub page_free: ::core::option::Option<unsafe extern "C" fn(page: *mut page)>,
    pub migrate_to_ram:
        ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub memory_failure: ::core::option::Option<
        unsafe extern "C" fn(
            pgmap: *mut dev_pagemap,
            pfn: core::ffi::c_ulong,
            nr_pages: core::ffi::c_ulong,
            mf_flags: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
}
#[repr(C)]
pub struct dev_pagemap {
    pub altmap: vmem_altmap,
    pub ref_: percpu_ref,
    pub done: completion,
    pub type_: memory_type,
    pub flags: core::ffi::c_uint,
    pub vmemmap_shift: core::ffi::c_ulong,
    pub ops: *const dev_pagemap_ops,
    pub owner: *mut core::ffi::c_void,
    pub nr_range: core::ffi::c_int,
    pub __bindgen_anon_1: dev_pagemap__bindgen_ty_1,
}
#[repr(C)]
pub struct dev_pagemap__bindgen_ty_1 {
    pub range: __BindgenUnionField<range>,
    pub __bindgen_anon_1: __BindgenUnionField<dev_pagemap__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Default)]
pub struct dev_pagemap__bindgen_ty_1__bindgen_ty_1 {
    pub __empty_ranges: dev_pagemap__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub ranges: __IncompleteArrayField<range>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pagemap__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
impl Default for dev_pagemap__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for dev_pagemap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn zone_device_page_init(page: *mut page);
}
extern "C" {
    pub fn memremap_pages(pgmap: *mut dev_pagemap, nid: core::ffi::c_int)
        -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memunmap_pages(pgmap: *mut dev_pagemap);
}
extern "C" {
    pub fn devm_memremap_pages(dev: *mut device, pgmap: *mut dev_pagemap)
        -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_memunmap_pages(dev: *mut device, pgmap: *mut dev_pagemap);
}
extern "C" {
    pub fn get_dev_pagemap(pfn: core::ffi::c_ulong, pgmap: *mut dev_pagemap) -> *mut dev_pagemap;
}
extern "C" {
    pub fn pgmap_pfn_valid(pgmap: *mut dev_pagemap, pfn: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn memremap_compat_align() -> core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct anon_vma {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct anon_vma_chain {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut sysctl_page_lock_unfairness: core::ffi::c_int;
}
extern "C" {
    pub fn mm_core_init();
}
extern "C" {
    pub fn init_mm_internals();
}
extern "C" {
    pub static mut _totalram_pages: atomic_long_t;
}
extern "C" {
    pub static mut high_memory: *mut core::ffi::c_void;
}
extern "C" {
    pub static mut page_cluster: core::ffi::c_int;
}
extern "C" {
    pub static page_cluster_max: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_legacy_va_layout: core::ffi::c_int;
}
extern "C" {
    pub static mmap_rnd_bits_min: core::ffi::c_int;
}
extern "C" {
    pub static mmap_rnd_bits_max: core::ffi::c_int;
}
extern "C" {
    pub static mut mmap_rnd_bits: core::ffi::c_int;
}
extern "C" {
    pub static mmap_rnd_compat_bits_min: core::ffi::c_int;
}
extern "C" {
    pub static mmap_rnd_compat_bits_max: core::ffi::c_int;
}
extern "C" {
    pub static mut mmap_rnd_compat_bits: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_max_map_count: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_user_reserve_kbytes: core::ffi::c_ulong;
}
extern "C" {
    pub static mut sysctl_admin_reserve_kbytes: core::ffi::c_ulong;
}
extern "C" {
    pub static mut sysctl_overcommit_memory: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_overcommit_ratio: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_overcommit_kbytes: core::ffi::c_ulong;
}
extern "C" {
    pub fn overcommit_ratio_handler(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn overcommit_kbytes_handler(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn overcommit_policy_handler(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn setup_initial_init_mm(
        start_code: *mut core::ffi::c_void,
        end_code: *mut core::ffi::c_void,
        end_data: *mut core::ffi::c_void,
        brk: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn vm_area_alloc(arg1: *mut mm_struct) -> *mut vm_area_struct;
}
extern "C" {
    pub fn vm_area_dup(arg1: *mut vm_area_struct) -> *mut vm_area_struct;
}
extern "C" {
    pub fn vm_area_free(arg1: *mut vm_area_struct);
}
extern "C" {
    pub fn __vm_area_free(vma: *mut vm_area_struct);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_fault {
    pub __bindgen_anon_1: vm_fault__bindgen_ty_1,
    pub flags: fault_flag,
    pub pmd: *mut pmd_t,
    pub pud: *mut pud_t,
    pub __bindgen_anon_2: vm_fault__bindgen_ty_2,
    pub cow_page: *mut page,
    pub page: *mut page,
    pub pte: *mut pte_t,
    pub ptl: *mut spinlock_t,
    pub prealloc_pte: pgtable_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_fault__bindgen_ty_1 {
    pub vma: *mut vm_area_struct,
    pub gfp_mask: gfp_t,
    pub pgoff: core::ffi::c_ulong,
    pub address: core::ffi::c_ulong,
    pub real_address: core::ffi::c_ulong,
}
impl Default for vm_fault__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vm_fault__bindgen_ty_2 {
    pub orig_pte: pte_t,
    pub orig_pmd: pmd_t,
}
impl Default for vm_fault__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vm_fault {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vm_operations_struct {
    pub open: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
    pub close: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
    pub may_split: ::core::option::Option<
        unsafe extern "C" fn(
            area: *mut vm_area_struct,
            addr: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub mremap:
        ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct) -> core::ffi::c_int>,
    pub mprotect: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            start: core::ffi::c_ulong,
            end: core::ffi::c_ulong,
            newflags: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub fault: ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub huge_fault: ::core::option::Option<
        unsafe extern "C" fn(vmf: *mut vm_fault, order: core::ffi::c_uint) -> vm_fault_t,
    >,
    pub map_pages: ::core::option::Option<
        unsafe extern "C" fn(
            vmf: *mut vm_fault,
            start_pgoff: core::ffi::c_ulong,
            end_pgoff: core::ffi::c_ulong,
        ) -> vm_fault_t,
    >,
    pub pagesize: ::core::option::Option<
        unsafe extern "C" fn(area: *mut vm_area_struct) -> core::ffi::c_ulong,
    >,
    pub page_mkwrite:
        ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub pfn_mkwrite: ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub access: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            addr: core::ffi::c_ulong,
            buf: *mut core::ffi::c_void,
            len: core::ffi::c_int,
            write: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct) -> *const core::ffi::c_char,
    >,
    pub set_policy: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct, new: *mut mempolicy) -> core::ffi::c_int,
    >,
    pub get_policy: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            addr: core::ffi::c_ulong,
            ilx: *mut core::ffi::c_ulong,
        ) -> *mut mempolicy,
    >,
    pub find_special_page: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct, addr: core::ffi::c_ulong) -> *mut page,
    >,
}
extern "C" {
    pub fn lock_vma_under_rcu(
        mm: *mut mm_struct,
        address: core::ffi::c_ulong,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub static vma_dummy_vm_ops: vm_operations_struct;
}
extern "C" {
    pub fn vma_is_shmem(vma: *mut vm_area_struct) -> bool_;
}
extern "C" {
    pub fn vma_is_anon_shmem(vma: *mut vm_area_struct) -> bool_;
}
extern "C" {
    pub fn vma_is_stack_for_current(vma: *mut vm_area_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_dumpable(mm: *mut mm_struct, value: core::ffi::c_int);
}
extern "C" {
    pub fn do_huge_pmd_anonymous_page(vmf: *mut vm_fault) -> vm_fault_t;
}
extern "C" {
    pub fn copy_huge_pmd(
        dst_mm: *mut mm_struct,
        src_mm: *mut mm_struct,
        dst_pmd: *mut pmd_t,
        src_pmd: *mut pmd_t,
        addr: core::ffi::c_ulong,
        dst_vma: *mut vm_area_struct,
        src_vma: *mut vm_area_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn huge_pmd_set_accessed(vmf: *mut vm_fault);
}
extern "C" {
    pub fn copy_huge_pud(
        dst_mm: *mut mm_struct,
        src_mm: *mut mm_struct,
        dst_pud: *mut pud_t,
        src_pud: *mut pud_t,
        addr: core::ffi::c_ulong,
        vma: *mut vm_area_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn huge_pud_set_accessed(vmf: *mut vm_fault, orig_pud: pud_t);
}
extern "C" {
    pub fn do_huge_pmd_wp_page(vmf: *mut vm_fault) -> vm_fault_t;
}
extern "C" {
    pub fn madvise_free_huge_pmd(
        tlb: *mut mmu_gather,
        vma: *mut vm_area_struct,
        pmd: *mut pmd_t,
        addr: core::ffi::c_ulong,
        next: core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn zap_huge_pmd(
        tlb: *mut mmu_gather,
        vma: *mut vm_area_struct,
        pmd: *mut pmd_t,
        addr: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn zap_huge_pud(
        tlb: *mut mmu_gather,
        vma: *mut vm_area_struct,
        pud: *mut pud_t,
        addr: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn move_huge_pmd(
        vma: *mut vm_area_struct,
        old_addr: core::ffi::c_ulong,
        new_addr: core::ffi::c_ulong,
        old_pmd: *mut pmd_t,
        new_pmd: *mut pmd_t,
    ) -> bool_;
}
extern "C" {
    pub fn change_huge_pmd(
        tlb: *mut mmu_gather,
        vma: *mut vm_area_struct,
        pmd: *mut pmd_t,
        addr: core::ffi::c_ulong,
        newprot: pgprot_t,
        cp_flags: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vmf_insert_pfn_pmd(vmf: *mut vm_fault, pfn: pfn_t, write: bool_) -> vm_fault_t;
}
extern "C" {
    pub fn vmf_insert_pfn_pud(vmf: *mut vm_fault, pfn: pfn_t, write: bool_) -> vm_fault_t;
}
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_UNSUPPORTED: transparent_hugepage_flag = 0;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_FLAG: transparent_hugepage_flag = 1;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG: transparent_hugepage_flag =
    2;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG:
    transparent_hugepage_flag = 3;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG:
    transparent_hugepage_flag = 4;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG:
    transparent_hugepage_flag = 5;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG:
    transparent_hugepage_flag = 6;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG:
    transparent_hugepage_flag = 7;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG:
    transparent_hugepage_flag = 8;
pub type transparent_hugepage_flag = core::ffi::c_uint;
extern "C" {
    pub fn single_hugepage_flag_store(
        kobj: *mut kobject,
        attr: *mut kobj_attribute,
        buf: *const core::ffi::c_char,
        count: usize,
        flag: transparent_hugepage_flag,
    ) -> isize;
}
extern "C" {
    pub fn single_hugepage_flag_show(
        kobj: *mut kobject,
        attr: *mut kobj_attribute,
        buf: *mut core::ffi::c_char,
        flag: transparent_hugepage_flag,
    ) -> isize;
}
extern "C" {
    pub static mut shmem_enabled_attr: kobj_attribute;
}
extern "C" {
    pub static mut transparent_hugepage_flags: core::ffi::c_ulong;
}
extern "C" {
    pub static mut huge_anon_orders_always: core::ffi::c_ulong;
}
extern "C" {
    pub static mut huge_anon_orders_madvise: core::ffi::c_ulong;
}
extern "C" {
    pub static mut huge_anon_orders_inherit: core::ffi::c_ulong;
}
extern "C" {
    pub fn __thp_vma_allowable_orders(
        vma: *mut vm_area_struct,
        vm_flags: core::ffi::c_ulong,
        smaps: bool_,
        in_pf: bool_,
        enforce_sysfs: bool_,
        orders: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn thp_get_unmapped_area(
        filp: *mut file,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        pgoff: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn folio_prep_large_rmappable(folio: *mut folio);
}
extern "C" {
    pub fn can_split_folio(folio: *mut folio, pextra_pins: *mut core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn split_huge_page_to_list(page: *mut page, list: *mut list_head) -> core::ffi::c_int;
}
extern "C" {
    pub fn deferred_split_folio(folio: *mut folio);
}
extern "C" {
    pub fn __split_huge_pmd(
        vma: *mut vm_area_struct,
        pmd: *mut pmd_t,
        address: core::ffi::c_ulong,
        freeze: bool_,
        folio: *mut folio,
    );
}
extern "C" {
    pub fn split_huge_pmd_address(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        freeze: bool_,
        folio: *mut folio,
    );
}
extern "C" {
    pub fn __split_huge_pud(vma: *mut vm_area_struct, pud: *mut pud_t, address: core::ffi::c_ulong);
}
extern "C" {
    pub fn hugepage_madvise(
        vma: *mut vm_area_struct,
        vm_flags: *mut core::ffi::c_ulong,
        advice: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn madvise_collapse(
        vma: *mut vm_area_struct,
        prev: *mut *mut vm_area_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vma_adjust_trans_huge(
        vma: *mut vm_area_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        adjust_next: core::ffi::c_long,
    );
}
extern "C" {
    pub fn __pmd_trans_huge_lock(pmd: *mut pmd_t, vma: *mut vm_area_struct) -> *mut spinlock_t;
}
extern "C" {
    pub fn __pud_trans_huge_lock(pud: *mut pud_t, vma: *mut vm_area_struct) -> *mut spinlock_t;
}
extern "C" {
    pub fn follow_devmap_pmd(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pmd: *mut pmd_t,
        flags: core::ffi::c_int,
        pgmap: *mut *mut dev_pagemap,
    ) -> *mut page;
}
extern "C" {
    pub fn follow_devmap_pud(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pud: *mut pud_t,
        flags: core::ffi::c_int,
        pgmap: *mut *mut dev_pagemap,
    ) -> *mut page;
}
extern "C" {
    pub fn do_huge_pmd_numa_page(vmf: *mut vm_fault) -> vm_fault_t;
}
extern "C" {
    pub static mut huge_zero_page: *mut page;
}
extern "C" {
    pub static mut huge_zero_pfn: core::ffi::c_ulong;
}
extern "C" {
    pub fn mm_get_huge_zero_page(mm: *mut mm_struct) -> *mut page;
}
extern "C" {
    pub fn mm_put_huge_zero_page(mm: *mut mm_struct);
}
extern "C" {
    pub fn page_is_ram(pfn: core::ffi::c_ulong) -> core::ffi::c_int;
}
pub const REGION_INTERSECTS: _bindgen_ty_100 = 0;
pub const REGION_DISJOINT: _bindgen_ty_100 = 1;
pub const REGION_MIXED: _bindgen_ty_100 = 2;
pub type _bindgen_ty_100 = core::ffi::c_uint;
extern "C" {
    pub fn region_intersects(
        offset: resource_size_t,
        size: usize,
        flags: core::ffi::c_ulong,
        desc: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vmalloc_to_page(addr: *const core::ffi::c_void) -> *mut page;
}
extern "C" {
    pub fn vmalloc_to_pfn(addr: *const core::ffi::c_void) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn is_vmalloc_addr(x: *const core::ffi::c_void) -> bool_;
}
extern "C" {
    pub fn is_vmalloc_or_module_addr(x: *const core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn folio_total_mapcount(folio: *mut folio) -> core::ffi::c_int;
}
extern "C" {
    pub fn __folio_put(folio: *mut folio);
}
extern "C" {
    pub fn put_pages_list(pages: *mut list_head);
}
extern "C" {
    pub fn split_page(page: *mut page, order: core::ffi::c_uint);
}
extern "C" {
    pub fn folio_copy(dst: *mut folio, src: *mut folio);
}
extern "C" {
    pub fn nr_free_buffer_pages() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn destroy_large_folio(folio: *mut folio);
}
extern "C" {
    pub fn do_set_pmd(vmf: *mut vm_fault, page: *mut page) -> vm_fault_t;
}
extern "C" {
    pub fn set_pte_range(
        vmf: *mut vm_fault,
        folio: *mut folio,
        page: *mut page,
        nr: core::ffi::c_uint,
        addr: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn finish_fault(vmf: *mut vm_fault) -> vm_fault_t;
}
extern "C" {
    pub static mut devmap_managed_key: static_key_false;
}
extern "C" {
    pub fn __put_devmap_managed_page_refs(page: *mut page, refs: core::ffi::c_int) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union release_pages_arg {
    pub pages: *mut *mut page,
    pub folios: *mut *mut folio,
    pub encoded_pages: *mut *mut encoded_page,
}
impl Default for release_pages_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn release_pages(arg1: release_pages_arg, nr: core::ffi::c_int);
}
extern "C" {
    pub fn unpin_user_page(page: *mut page);
}
extern "C" {
    pub fn unpin_user_pages_dirty_lock(
        pages: *mut *mut page,
        npages: core::ffi::c_ulong,
        make_dirty: bool_,
    );
}
extern "C" {
    pub fn unpin_user_page_range_dirty_lock(
        page: *mut page,
        npages: core::ffi::c_ulong,
        make_dirty: bool_,
    );
}
extern "C" {
    pub fn unpin_user_pages(pages: *mut *mut page, npages: core::ffi::c_ulong);
}
extern "C" {
    pub fn folio_xchg_last_cpupid(folio: *mut folio, cpupid: core::ffi::c_int) -> core::ffi::c_int;
}
pub const vm_event_item_PGPGIN: vm_event_item = 0;
pub const vm_event_item_PGPGOUT: vm_event_item = 1;
pub const vm_event_item_PSWPIN: vm_event_item = 2;
pub const vm_event_item_PSWPOUT: vm_event_item = 3;
pub const vm_event_item_PGALLOC_DMA: vm_event_item = 4;
pub const vm_event_item_PGALLOC_DMA32: vm_event_item = 5;
pub const vm_event_item_PGALLOC_NORMAL: vm_event_item = 6;
pub const vm_event_item_PGALLOC_MOVABLE: vm_event_item = 7;
pub const vm_event_item_PGALLOC_DEVICE: vm_event_item = 8;
pub const vm_event_item_ALLOCSTALL_DMA: vm_event_item = 9;
pub const vm_event_item_ALLOCSTALL_DMA32: vm_event_item = 10;
pub const vm_event_item_ALLOCSTALL_NORMAL: vm_event_item = 11;
pub const vm_event_item_ALLOCSTALL_MOVABLE: vm_event_item = 12;
pub const vm_event_item_ALLOCSTALL_DEVICE: vm_event_item = 13;
pub const vm_event_item_PGSCAN_SKIP_DMA: vm_event_item = 14;
pub const vm_event_item_PGSCAN_SKIP_DMA32: vm_event_item = 15;
pub const vm_event_item_PGSCAN_SKIP_NORMAL: vm_event_item = 16;
pub const vm_event_item_PGSCAN_SKIP_MOVABLE: vm_event_item = 17;
pub const vm_event_item_PGSCAN_SKIP_DEVICE: vm_event_item = 18;
pub const vm_event_item_PGFREE: vm_event_item = 19;
pub const vm_event_item_PGACTIVATE: vm_event_item = 20;
pub const vm_event_item_PGDEACTIVATE: vm_event_item = 21;
pub const vm_event_item_PGLAZYFREE: vm_event_item = 22;
pub const vm_event_item_PGFAULT: vm_event_item = 23;
pub const vm_event_item_PGMAJFAULT: vm_event_item = 24;
pub const vm_event_item_PGLAZYFREED: vm_event_item = 25;
pub const vm_event_item_PGREFILL: vm_event_item = 26;
pub const vm_event_item_PGREUSE: vm_event_item = 27;
pub const vm_event_item_PGSTEAL_KSWAPD: vm_event_item = 28;
pub const vm_event_item_PGSTEAL_DIRECT: vm_event_item = 29;
pub const vm_event_item_PGSTEAL_KHUGEPAGED: vm_event_item = 30;
pub const vm_event_item_PGSCAN_KSWAPD: vm_event_item = 31;
pub const vm_event_item_PGSCAN_DIRECT: vm_event_item = 32;
pub const vm_event_item_PGSCAN_KHUGEPAGED: vm_event_item = 33;
pub const vm_event_item_PGSCAN_DIRECT_THROTTLE: vm_event_item = 34;
pub const vm_event_item_PGSCAN_ANON: vm_event_item = 35;
pub const vm_event_item_PGSCAN_FILE: vm_event_item = 36;
pub const vm_event_item_PGSTEAL_ANON: vm_event_item = 37;
pub const vm_event_item_PGSTEAL_FILE: vm_event_item = 38;
pub const vm_event_item_PGSCAN_ZONE_RECLAIM_FAILED: vm_event_item = 39;
pub const vm_event_item_PGINODESTEAL: vm_event_item = 40;
pub const vm_event_item_SLABS_SCANNED: vm_event_item = 41;
pub const vm_event_item_KSWAPD_INODESTEAL: vm_event_item = 42;
pub const vm_event_item_KSWAPD_LOW_WMARK_HIT_QUICKLY: vm_event_item = 43;
pub const vm_event_item_KSWAPD_HIGH_WMARK_HIT_QUICKLY: vm_event_item = 44;
pub const vm_event_item_PAGEOUTRUN: vm_event_item = 45;
pub const vm_event_item_PGROTATED: vm_event_item = 46;
pub const vm_event_item_DROP_PAGECACHE: vm_event_item = 47;
pub const vm_event_item_DROP_SLAB: vm_event_item = 48;
pub const vm_event_item_OOM_KILL: vm_event_item = 49;
pub const vm_event_item_NUMA_PTE_UPDATES: vm_event_item = 50;
pub const vm_event_item_NUMA_HUGE_PTE_UPDATES: vm_event_item = 51;
pub const vm_event_item_NUMA_HINT_FAULTS: vm_event_item = 52;
pub const vm_event_item_NUMA_HINT_FAULTS_LOCAL: vm_event_item = 53;
pub const vm_event_item_NUMA_PAGE_MIGRATE: vm_event_item = 54;
pub const vm_event_item_PGMIGRATE_SUCCESS: vm_event_item = 55;
pub const vm_event_item_PGMIGRATE_FAIL: vm_event_item = 56;
pub const vm_event_item_THP_MIGRATION_SUCCESS: vm_event_item = 57;
pub const vm_event_item_THP_MIGRATION_FAIL: vm_event_item = 58;
pub const vm_event_item_THP_MIGRATION_SPLIT: vm_event_item = 59;
pub const vm_event_item_COMPACTMIGRATE_SCANNED: vm_event_item = 60;
pub const vm_event_item_COMPACTFREE_SCANNED: vm_event_item = 61;
pub const vm_event_item_COMPACTISOLATED: vm_event_item = 62;
pub const vm_event_item_COMPACTSTALL: vm_event_item = 63;
pub const vm_event_item_COMPACTFAIL: vm_event_item = 64;
pub const vm_event_item_COMPACTSUCCESS: vm_event_item = 65;
pub const vm_event_item_KCOMPACTD_WAKE: vm_event_item = 66;
pub const vm_event_item_KCOMPACTD_MIGRATE_SCANNED: vm_event_item = 67;
pub const vm_event_item_KCOMPACTD_FREE_SCANNED: vm_event_item = 68;
pub const vm_event_item_HTLB_BUDDY_PGALLOC: vm_event_item = 69;
pub const vm_event_item_HTLB_BUDDY_PGALLOC_FAIL: vm_event_item = 70;
pub const vm_event_item_UNEVICTABLE_PGCULLED: vm_event_item = 71;
pub const vm_event_item_UNEVICTABLE_PGSCANNED: vm_event_item = 72;
pub const vm_event_item_UNEVICTABLE_PGRESCUED: vm_event_item = 73;
pub const vm_event_item_UNEVICTABLE_PGMLOCKED: vm_event_item = 74;
pub const vm_event_item_UNEVICTABLE_PGMUNLOCKED: vm_event_item = 75;
pub const vm_event_item_UNEVICTABLE_PGCLEARED: vm_event_item = 76;
pub const vm_event_item_UNEVICTABLE_PGSTRANDED: vm_event_item = 77;
pub const vm_event_item_THP_FAULT_ALLOC: vm_event_item = 78;
pub const vm_event_item_THP_FAULT_FALLBACK: vm_event_item = 79;
pub const vm_event_item_THP_FAULT_FALLBACK_CHARGE: vm_event_item = 80;
pub const vm_event_item_THP_COLLAPSE_ALLOC: vm_event_item = 81;
pub const vm_event_item_THP_COLLAPSE_ALLOC_FAILED: vm_event_item = 82;
pub const vm_event_item_THP_FILE_ALLOC: vm_event_item = 83;
pub const vm_event_item_THP_FILE_FALLBACK: vm_event_item = 84;
pub const vm_event_item_THP_FILE_FALLBACK_CHARGE: vm_event_item = 85;
pub const vm_event_item_THP_FILE_MAPPED: vm_event_item = 86;
pub const vm_event_item_THP_SPLIT_PAGE: vm_event_item = 87;
pub const vm_event_item_THP_SPLIT_PAGE_FAILED: vm_event_item = 88;
pub const vm_event_item_THP_DEFERRED_SPLIT_PAGE: vm_event_item = 89;
pub const vm_event_item_THP_SPLIT_PMD: vm_event_item = 90;
pub const vm_event_item_THP_SCAN_EXCEED_NONE_PTE: vm_event_item = 91;
pub const vm_event_item_THP_SCAN_EXCEED_SWAP_PTE: vm_event_item = 92;
pub const vm_event_item_THP_SCAN_EXCEED_SHARED_PTE: vm_event_item = 93;
pub const vm_event_item_THP_SPLIT_PUD: vm_event_item = 94;
pub const vm_event_item_THP_ZERO_PAGE_ALLOC: vm_event_item = 95;
pub const vm_event_item_THP_ZERO_PAGE_ALLOC_FAILED: vm_event_item = 96;
pub const vm_event_item_THP_SWPOUT: vm_event_item = 97;
pub const vm_event_item_THP_SWPOUT_FALLBACK: vm_event_item = 98;
pub const vm_event_item_BALLOON_INFLATE: vm_event_item = 99;
pub const vm_event_item_BALLOON_DEFLATE: vm_event_item = 100;
pub const vm_event_item_BALLOON_MIGRATE: vm_event_item = 101;
pub const vm_event_item_SWAP_RA: vm_event_item = 102;
pub const vm_event_item_SWAP_RA_HIT: vm_event_item = 103;
pub const vm_event_item_KSM_SWPIN_COPY: vm_event_item = 104;
pub const vm_event_item_COW_KSM: vm_event_item = 105;
pub const vm_event_item_ZSWPIN: vm_event_item = 106;
pub const vm_event_item_ZSWPOUT: vm_event_item = 107;
pub const vm_event_item_ZSWPWB: vm_event_item = 108;
pub const vm_event_item_DIRECT_MAP_LEVEL2_SPLIT: vm_event_item = 109;
pub const vm_event_item_DIRECT_MAP_LEVEL3_SPLIT: vm_event_item = 110;
pub const vm_event_item_NR_VM_EVENT_ITEMS: vm_event_item = 111;
pub type vm_event_item = core::ffi::c_uint;
extern "C" {
    pub static mut sysctl_stat_interval: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_vm_numa_stat: core::ffi::c_int;
}
extern "C" {
    pub static mut vm_numa_stat_key: static_key_true;
}
extern "C" {
    pub fn sysctl_vm_numa_stat_handler(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        length: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct reclaim_stat {
    pub nr_dirty: core::ffi::c_uint,
    pub nr_unqueued_dirty: core::ffi::c_uint,
    pub nr_congested: core::ffi::c_uint,
    pub nr_writeback: core::ffi::c_uint,
    pub nr_immediate: core::ffi::c_uint,
    pub nr_pageout: core::ffi::c_uint,
    pub nr_activate: [core::ffi::c_uint; 2usize],
    pub nr_ref_keep: core::ffi::c_uint,
    pub nr_unmap_fail: core::ffi::c_uint,
    pub nr_lazyfree_fail: core::ffi::c_uint,
}
pub const writeback_stat_item_NR_DIRTY_THRESHOLD: writeback_stat_item = 0;
pub const writeback_stat_item_NR_DIRTY_BG_THRESHOLD: writeback_stat_item = 1;
pub const writeback_stat_item_NR_VM_WRITEBACK_STAT_ITEMS: writeback_stat_item = 2;
pub type writeback_stat_item = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_event_state {
    pub event: [core::ffi::c_ulong; 111usize],
}
impl Default for vm_event_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut vm_event_states: vm_event_state;
}
extern "C" {
    pub fn all_vm_events(arg1: *mut core::ffi::c_ulong);
}
extern "C" {
    pub fn vm_events_fold_cpu(cpu: core::ffi::c_int);
}
extern "C" {
    pub static mut vm_zone_stat: [atomic_long_t; 12usize];
}
extern "C" {
    pub static mut vm_node_stat: [atomic_long_t; 46usize];
}
extern "C" {
    pub static mut vm_numa_event: [atomic_long_t; 6usize];
}
extern "C" {
    pub fn sum_zone_node_page_state(
        node: core::ffi::c_int,
        item: zone_stat_item,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn sum_zone_numa_event_state(
        node: core::ffi::c_int,
        item: numa_stat_item,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn node_page_state(pgdat: *mut pglist_data, item: node_stat_item) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn node_page_state_pages(
        pgdat: *mut pglist_data,
        item: node_stat_item,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn fold_vm_numa_events();
}
extern "C" {
    pub fn __mod_zone_page_state(arg1: *mut zone, item: zone_stat_item, arg2: core::ffi::c_long);
}
extern "C" {
    pub fn __inc_zone_page_state(arg1: *mut page, arg2: zone_stat_item);
}
extern "C" {
    pub fn __dec_zone_page_state(arg1: *mut page, arg2: zone_stat_item);
}
extern "C" {
    pub fn __mod_node_page_state(
        arg1: *mut pglist_data,
        item: node_stat_item,
        arg2: core::ffi::c_long,
    );
}
extern "C" {
    pub fn __inc_node_page_state(arg1: *mut page, arg2: node_stat_item);
}
extern "C" {
    pub fn __dec_node_page_state(arg1: *mut page, arg2: node_stat_item);
}
extern "C" {
    pub fn mod_zone_page_state(arg1: *mut zone, arg2: zone_stat_item, arg3: core::ffi::c_long);
}
extern "C" {
    pub fn inc_zone_page_state(arg1: *mut page, arg2: zone_stat_item);
}
extern "C" {
    pub fn dec_zone_page_state(arg1: *mut page, arg2: zone_stat_item);
}
extern "C" {
    pub fn mod_node_page_state(
        arg1: *mut pglist_data,
        arg2: node_stat_item,
        arg3: core::ffi::c_long,
    );
}
extern "C" {
    pub fn inc_node_page_state(arg1: *mut page, arg2: node_stat_item);
}
extern "C" {
    pub fn dec_node_page_state(arg1: *mut page, arg2: node_stat_item);
}
extern "C" {
    pub fn inc_node_state(arg1: *mut pglist_data, arg2: node_stat_item);
}
extern "C" {
    pub fn __inc_zone_state(arg1: *mut zone, arg2: zone_stat_item);
}
extern "C" {
    pub fn __inc_node_state(arg1: *mut pglist_data, arg2: node_stat_item);
}
extern "C" {
    pub fn dec_zone_state(arg1: *mut zone, arg2: zone_stat_item);
}
extern "C" {
    pub fn __dec_zone_state(arg1: *mut zone, arg2: zone_stat_item);
}
extern "C" {
    pub fn __dec_node_state(arg1: *mut pglist_data, arg2: node_stat_item);
}
extern "C" {
    pub fn quiet_vmstat();
}
extern "C" {
    pub fn cpu_vm_stats_fold(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn refresh_zone_stat_thresholds();
}
extern "C" {
    pub fn vmstat_refresh(
        arg1: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn drain_zonestat(zone: *mut zone, arg1: *mut per_cpu_zonestat);
}
extern "C" {
    pub fn calculate_pressure_threshold(zone: *mut zone) -> core::ffi::c_int;
}
extern "C" {
    pub fn calculate_normal_threshold(zone: *mut zone) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_pgdat_percpu_threshold(
        pgdat: *mut pg_data_t,
        calculate_pressure: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut zone) -> core::ffi::c_int,
        >,
    );
}
extern "C" {
    pub static vmstat_text: [*const core::ffi::c_char; 0usize];
}
extern "C" {
    pub fn __mod_lruvec_state(lruvec: *mut lruvec, idx: node_stat_item, val: core::ffi::c_int);
}
extern "C" {
    pub fn __lruvec_stat_mod_folio(folio: *mut folio, idx: node_stat_item, val: core::ffi::c_int);
}
extern "C" {
    pub fn __page_file_index(page: *mut page) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn pagefault_out_of_memory();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zap_details {
    pub single_folio: *mut folio,
    pub even_cows: bool_,
    pub zap_flags: zap_flags_t,
}
impl Default for zap_details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn sched_mm_cid_before_execve(t: *mut task_struct);
}
extern "C" {
    pub fn sched_mm_cid_after_execve(t: *mut task_struct);
}
extern "C" {
    pub fn sched_mm_cid_fork(t: *mut task_struct);
}
extern "C" {
    pub fn sched_mm_cid_exit_signals(t: *mut task_struct);
}
extern "C" {
    pub fn can_do_mlock() -> bool_;
}
extern "C" {
    pub fn user_shm_lock(arg1: usize, arg2: *mut ucounts) -> core::ffi::c_int;
}
extern "C" {
    pub fn user_shm_unlock(arg1: usize, arg2: *mut ucounts);
}
extern "C" {
    pub fn vm_normal_folio(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pte: pte_t,
    ) -> *mut folio;
}
extern "C" {
    pub fn vm_normal_page(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pte: pte_t,
    ) -> *mut page;
}
extern "C" {
    pub fn vm_normal_folio_pmd(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pmd: pmd_t,
    ) -> *mut folio;
}
extern "C" {
    pub fn vm_normal_page_pmd(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pmd: pmd_t,
    ) -> *mut page;
}
extern "C" {
    pub fn zap_vma_ptes(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn zap_page_range_single(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        details: *mut zap_details,
    );
}
extern "C" {
    pub fn unmap_vmas(
        tlb: *mut mmu_gather,
        mas: *mut ma_state,
        start_vma: *mut vm_area_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        tree_end: core::ffi::c_ulong,
        mm_wr_locked: bool_,
    );
}
extern "C" {
    pub fn free_pgd_range(
        tlb: *mut mmu_gather,
        addr: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        floor: core::ffi::c_ulong,
        ceiling: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn copy_page_range(
        dst_vma: *mut vm_area_struct,
        src_vma: *mut vm_area_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn follow_pte(
        mm: *mut mm_struct,
        address: core::ffi::c_ulong,
        ptepp: *mut *mut pte_t,
        ptlp: *mut *mut spinlock_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn follow_pfn(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        pfn: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn follow_phys(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        flags: core::ffi::c_uint,
        prot: *mut core::ffi::c_ulong,
        phys: *mut resource_size_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_access_phys(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        buf: *mut core::ffi::c_void,
        len: core::ffi::c_int,
        write: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn truncate_pagecache(inode: *mut inode, new: loff_t);
}
extern "C" {
    pub fn truncate_setsize(inode: *mut inode, newsize: loff_t);
}
extern "C" {
    pub fn pagecache_isize_extended(inode: *mut inode, from: loff_t, to: loff_t);
}
extern "C" {
    pub fn truncate_pagecache_range(inode: *mut inode, offset: loff_t, end: loff_t);
}
extern "C" {
    pub fn generic_error_remove_folio(
        mapping: *mut address_space,
        folio: *mut folio,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lock_mm_and_find_vma(
        mm: *mut mm_struct,
        address: core::ffi::c_ulong,
        regs: *mut pt_regs,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub fn handle_mm_fault(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        flags: core::ffi::c_uint,
        regs: *mut pt_regs,
    ) -> vm_fault_t;
}
extern "C" {
    pub fn fixup_user_fault(
        mm: *mut mm_struct,
        address: core::ffi::c_ulong,
        fault_flags: core::ffi::c_uint,
        unlocked: *mut bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn unmap_mapping_pages(
        mapping: *mut address_space,
        start: core::ffi::c_ulong,
        nr: core::ffi::c_ulong,
        even_cows: bool_,
    );
}
extern "C" {
    pub fn unmap_mapping_range(
        mapping: *mut address_space,
        holebegin: loff_t,
        holelen: loff_t,
        even_cows: core::ffi::c_int,
    );
}
extern "C" {
    pub fn access_process_vm(
        tsk: *mut task_struct,
        addr: core::ffi::c_ulong,
        buf: *mut core::ffi::c_void,
        len: core::ffi::c_int,
        gup_flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn access_remote_vm(
        mm: *mut mm_struct,
        addr: core::ffi::c_ulong,
        buf: *mut core::ffi::c_void,
        len: core::ffi::c_int,
        gup_flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_user_pages_remote(
        mm: *mut mm_struct,
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        gup_flags: core::ffi::c_uint,
        pages: *mut *mut page,
        locked: *mut core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn pin_user_pages_remote(
        mm: *mut mm_struct,
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        gup_flags: core::ffi::c_uint,
        pages: *mut *mut page,
        locked: *mut core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn get_user_pages(
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        gup_flags: core::ffi::c_uint,
        pages: *mut *mut page,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn pin_user_pages(
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        gup_flags: core::ffi::c_uint,
        pages: *mut *mut page,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn get_user_pages_unlocked(
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        pages: *mut *mut page,
        gup_flags: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn pin_user_pages_unlocked(
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        pages: *mut *mut page,
        gup_flags: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn get_user_pages_fast(
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_int,
        gup_flags: core::ffi::c_uint,
        pages: *mut *mut page,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pin_user_pages_fast(
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_int,
        gup_flags: core::ffi::c_uint,
        pages: *mut *mut page,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn folio_add_pin(folio: *mut folio);
}
extern "C" {
    pub fn account_locked_vm(
        mm: *mut mm_struct,
        pages: core::ffi::c_ulong,
        inc: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __account_locked_vm(
        mm: *mut mm_struct,
        pages: core::ffi::c_ulong,
        inc: bool_,
        task: *mut task_struct,
        bypass_rlim: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_dump_page(addr: core::ffi::c_ulong) -> *mut page;
}
extern "C" {
    pub fn folio_mark_dirty(folio: *mut folio) -> bool_;
}
extern "C" {
    pub fn set_page_dirty(page: *mut page) -> bool_;
}
extern "C" {
    pub fn set_page_dirty_lock(page: *mut page) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_cmdline(
        task: *mut task_struct,
        buffer: *mut core::ffi::c_char,
        buflen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn move_page_tables(
        vma: *mut vm_area_struct,
        old_addr: core::ffi::c_ulong,
        new_vma: *mut vm_area_struct,
        new_addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        need_rmap_locks: bool_,
        for_stack: bool_,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn vma_needs_dirty_tracking(vma: *mut vm_area_struct) -> bool_;
}
extern "C" {
    pub fn vma_wants_writenotify(
        vma: *mut vm_area_struct,
        vm_page_prot: pgprot_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn can_change_pte_writable(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pte: pte_t,
    ) -> bool_;
}
extern "C" {
    pub fn change_protection(
        tlb: *mut mmu_gather,
        vma: *mut vm_area_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        cp_flags: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn mprotect_fixup(
        vmi: *mut vma_iterator,
        tlb: *mut mmu_gather,
        vma: *mut vm_area_struct,
        pprev: *mut *mut vm_area_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        newflags: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_user_pages_fast_only(
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_int,
        gup_flags: core::ffi::c_uint,
        pages: *mut *mut page,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mm_trace_rss_stat(mm: *mut mm_struct, member: core::ffi::c_int);
}
extern "C" {
    pub fn __get_locked_pte(
        mm: *mut mm_struct,
        addr: core::ffi::c_ulong,
        ptl: *mut *mut spinlock_t,
    ) -> *mut pte_t;
}
extern "C" {
    pub fn __p4d_alloc(
        mm: *mut mm_struct,
        pgd: *mut pgd_t,
        address: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __pud_alloc(
        mm: *mut mm_struct,
        p4d: *mut p4d_t,
        address: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __pmd_alloc(
        mm: *mut mm_struct,
        pud: *mut pud_t,
        address: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __pte_alloc(mm: *mut mm_struct, pmd: *mut pmd_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn __pte_alloc_kernel(pmd: *mut pmd_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn __pte_offset_map(
        pmd: *mut pmd_t,
        addr: core::ffi::c_ulong,
        pmdvalp: *mut pmd_t,
    ) -> *mut pte_t;
}
extern "C" {
    pub fn __pte_offset_map_lock(
        mm: *mut mm_struct,
        pmd: *mut pmd_t,
        addr: core::ffi::c_ulong,
        ptlp: *mut *mut spinlock_t,
    ) -> *mut pte_t;
}
extern "C" {
    pub fn pte_offset_map_nolock(
        mm: *mut mm_struct,
        pmd: *mut pmd_t,
        addr: core::ffi::c_ulong,
        ptlp: *mut *mut spinlock_t,
    ) -> *mut pte_t;
}
extern "C" {
    pub fn pagecache_init();
}
extern "C" {
    pub fn free_initmem();
}
extern "C" {
    pub fn free_reserved_area(
        start: *mut core::ffi::c_void,
        end: *mut core::ffi::c_void,
        poison: core::ffi::c_int,
        s: *const core::ffi::c_char,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn adjust_managed_page_count(page: *mut page, count: core::ffi::c_long);
}
extern "C" {
    pub fn reserve_bootmem_region(start: phys_addr_t, end: phys_addr_t, nid: core::ffi::c_int);
}
extern "C" {
    pub fn free_area_init(max_zone_pfn: *mut core::ffi::c_ulong);
}
extern "C" {
    pub fn node_map_pfn_alignment() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __absent_pages_in_range(
        nid: core::ffi::c_int,
        start_pfn: core::ffi::c_ulong,
        end_pfn: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn absent_pages_in_range(
        start_pfn: core::ffi::c_ulong,
        end_pfn: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn get_pfn_range_for_nid(
        nid: core::ffi::c_uint,
        start_pfn: *mut core::ffi::c_ulong,
        end_pfn: *mut core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn early_pfn_to_nid(pfn: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_dma_reserve(new_dma_reserve: core::ffi::c_ulong);
}
extern "C" {
    pub fn mem_init();
}
extern "C" {
    pub fn mmap_init();
}
extern "C" {
    pub fn __show_mem(
        flags: core::ffi::c_uint,
        nodemask: *mut nodemask_t,
        max_zone_idx: core::ffi::c_int,
    );
}
extern "C" {
    pub fn si_mem_available() -> core::ffi::c_long;
}
extern "C" {
    pub fn si_meminfo(val: *mut sysinfo);
}
extern "C" {
    pub fn si_meminfo_node(val: *mut sysinfo, nid: core::ffi::c_int);
}
extern "C" {
    pub fn warn_alloc(
        gfp_mask: gfp_t,
        nodemask: *mut nodemask_t,
        fmt: *const core::ffi::c_char,
        ...
    );
}
extern "C" {
    pub fn setup_per_cpu_pageset();
}
extern "C" {
    pub static mut mmap_pages_allocated: atomic_long_t;
}
extern "C" {
    pub fn nommu_shrink_inode_mappings(
        arg1: *mut inode,
        arg2: usize,
        arg3: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vma_interval_tree_insert(node: *mut vm_area_struct, root: *mut rb_root_cached);
}
extern "C" {
    pub fn vma_interval_tree_insert_after(
        node: *mut vm_area_struct,
        prev: *mut vm_area_struct,
        root: *mut rb_root_cached,
    );
}
extern "C" {
    pub fn vma_interval_tree_remove(node: *mut vm_area_struct, root: *mut rb_root_cached);
}
extern "C" {
    pub fn vma_interval_tree_iter_first(
        root: *mut rb_root_cached,
        start: core::ffi::c_ulong,
        last: core::ffi::c_ulong,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub fn vma_interval_tree_iter_next(
        node: *mut vm_area_struct,
        start: core::ffi::c_ulong,
        last: core::ffi::c_ulong,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub fn anon_vma_interval_tree_insert(node: *mut anon_vma_chain, root: *mut rb_root_cached);
}
extern "C" {
    pub fn anon_vma_interval_tree_remove(node: *mut anon_vma_chain, root: *mut rb_root_cached);
}
extern "C" {
    pub fn anon_vma_interval_tree_iter_first(
        root: *mut rb_root_cached,
        start: core::ffi::c_ulong,
        last: core::ffi::c_ulong,
    ) -> *mut anon_vma_chain;
}
extern "C" {
    pub fn anon_vma_interval_tree_iter_next(
        node: *mut anon_vma_chain,
        start: core::ffi::c_ulong,
        last: core::ffi::c_ulong,
    ) -> *mut anon_vma_chain;
}
extern "C" {
    pub fn __vm_enough_memory(
        mm: *mut mm_struct,
        pages: core::ffi::c_long,
        cap_sys_admin: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vma_expand(
        vmi: *mut vma_iterator,
        vma: *mut vm_area_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        pgoff: core::ffi::c_ulong,
        next: *mut vm_area_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vma_shrink(
        vmi: *mut vma_iterator,
        vma: *mut vm_area_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        pgoff: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn find_mergeable_anon_vma(arg1: *mut vm_area_struct) -> *mut anon_vma;
}
extern "C" {
    pub fn insert_vm_struct(arg1: *mut mm_struct, arg2: *mut vm_area_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn unlink_file_vma(arg1: *mut vm_area_struct);
}
extern "C" {
    pub fn copy_vma(
        arg1: *mut *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        pgoff: core::ffi::c_ulong,
        need_rmap_locks: *mut bool_,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub fn exit_mmap(arg1: *mut mm_struct);
}
extern "C" {
    pub fn vma_modify(
        vmi: *mut vma_iterator,
        prev: *mut vm_area_struct,
        vma: *mut vm_area_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        vm_flags: core::ffi::c_ulong,
        policy: *mut mempolicy,
        uffd_ctx: vm_userfaultfd_ctx,
        anon_name: *mut anon_vma_name,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub fn mm_take_all_locks(mm: *mut mm_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn mm_drop_all_locks(mm: *mut mm_struct);
}
extern "C" {
    pub fn set_mm_exe_file(mm: *mut mm_struct, new_exe_file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn replace_mm_exe_file(mm: *mut mm_struct, new_exe_file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_mm_exe_file(mm: *mut mm_struct) -> *mut file;
}
extern "C" {
    pub fn get_task_exe_file(task: *mut task_struct) -> *mut file;
}
extern "C" {
    pub fn may_expand_vm(
        arg1: *mut mm_struct,
        arg2: vm_flags_t,
        npages: core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn vm_stat_account(arg1: *mut mm_struct, arg2: vm_flags_t, npages: core::ffi::c_long);
}
extern "C" {
    pub fn vma_is_special_mapping(
        vma: *const vm_area_struct,
        sm: *const vm_special_mapping,
    ) -> bool_;
}
extern "C" {
    pub fn _install_special_mapping(
        mm: *mut mm_struct,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
        spec: *const vm_special_mapping,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub fn install_special_mapping(
        mm: *mut mm_struct,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
        pages: *mut *mut page,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn randomize_stack_top(stack_top: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn randomize_page(
        start: core::ffi::c_ulong,
        range: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn get_unmapped_area(
        arg1: *mut file,
        arg2: core::ffi::c_ulong,
        arg3: core::ffi::c_ulong,
        arg4: core::ffi::c_ulong,
        arg5: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn mmap_region(
        file: *mut file,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        vm_flags: vm_flags_t,
        pgoff: core::ffi::c_ulong,
        uf: *mut list_head,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn do_mmap(
        file: *mut file,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        prot: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
        vm_flags: vm_flags_t,
        pgoff: core::ffi::c_ulong,
        populate: *mut core::ffi::c_ulong,
        uf: *mut list_head,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn do_vmi_munmap(
        vmi: *mut vma_iterator,
        mm: *mut mm_struct,
        start: core::ffi::c_ulong,
        len: usize,
        uf: *mut list_head,
        unlock: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_munmap(
        arg1: *mut mm_struct,
        arg2: core::ffi::c_ulong,
        arg3: usize,
        uf: *mut list_head,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_madvise(
        mm: *mut mm_struct,
        start: core::ffi::c_ulong,
        len_in: usize,
        behavior: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_vma_munmap(
        vmi: *mut vma_iterator,
        vma: *mut vm_area_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        uf: *mut list_head,
        unlock: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __mm_populate(
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        ignore_errors: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vm_brk_flags(
        arg1: core::ffi::c_ulong,
        arg2: core::ffi::c_ulong,
        arg3: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vm_munmap(arg1: core::ffi::c_ulong, arg2: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn vm_mmap(
        arg1: *mut file,
        arg2: core::ffi::c_ulong,
        arg3: core::ffi::c_ulong,
        arg4: core::ffi::c_ulong,
        arg5: core::ffi::c_ulong,
        arg6: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vm_unmapped_area_info {
    pub flags: core::ffi::c_ulong,
    pub length: core::ffi::c_ulong,
    pub low_limit: core::ffi::c_ulong,
    pub high_limit: core::ffi::c_ulong,
    pub align_mask: core::ffi::c_ulong,
    pub align_offset: core::ffi::c_ulong,
}
extern "C" {
    pub fn vm_unmapped_area(info: *mut vm_unmapped_area_info) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn truncate_inode_pages(arg1: *mut address_space, arg2: loff_t);
}
extern "C" {
    pub fn truncate_inode_pages_range(arg1: *mut address_space, lstart: loff_t, lend: loff_t);
}
extern "C" {
    pub fn truncate_inode_pages_final(arg1: *mut address_space);
}
extern "C" {
    pub fn filemap_fault(vmf: *mut vm_fault) -> vm_fault_t;
}
extern "C" {
    pub fn filemap_map_pages(
        vmf: *mut vm_fault,
        start_pgoff: core::ffi::c_ulong,
        end_pgoff: core::ffi::c_ulong,
    ) -> vm_fault_t;
}
extern "C" {
    pub fn filemap_page_mkwrite(vmf: *mut vm_fault) -> vm_fault_t;
}
extern "C" {
    pub static mut stack_guard_gap: core::ffi::c_ulong;
}
extern "C" {
    pub fn expand_stack_locked(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn expand_stack(mm: *mut mm_struct, addr: core::ffi::c_ulong) -> *mut vm_area_struct;
}
extern "C" {
    pub fn expand_downwards(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn find_vma(mm: *mut mm_struct, addr: core::ffi::c_ulong) -> *mut vm_area_struct;
}
extern "C" {
    pub fn find_vma_prev(
        mm: *mut mm_struct,
        addr: core::ffi::c_ulong,
        pprev: *mut *mut vm_area_struct,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub fn find_vma_intersection(
        mm: *mut mm_struct,
        start_addr: core::ffi::c_ulong,
        end_addr: core::ffi::c_ulong,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub fn vm_get_page_prot(vm_flags: core::ffi::c_ulong) -> pgprot_t;
}
extern "C" {
    pub fn vma_set_page_prot(vma: *mut vm_area_struct);
}
extern "C" {
    pub fn vma_set_file(vma: *mut vm_area_struct, file: *mut file);
}
extern "C" {
    pub fn change_prot_numa(
        vma: *mut vm_area_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn find_extend_vma_locked(
        arg1: *mut mm_struct,
        addr: core::ffi::c_ulong,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub fn remap_pfn_range(
        arg1: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pfn: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        arg2: pgprot_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn remap_pfn_range_notrack(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pfn: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        prot: pgprot_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vm_insert_page(
        arg1: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        arg2: *mut page,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vm_insert_pages(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pages: *mut *mut page,
        num: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vm_map_pages(
        vma: *mut vm_area_struct,
        pages: *mut *mut page,
        num: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vm_map_pages_zero(
        vma: *mut vm_area_struct,
        pages: *mut *mut page,
        num: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vmf_insert_pfn(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pfn: core::ffi::c_ulong,
    ) -> vm_fault_t;
}
extern "C" {
    pub fn vmf_insert_pfn_prot(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pfn: core::ffi::c_ulong,
        pgprot: pgprot_t,
    ) -> vm_fault_t;
}
extern "C" {
    pub fn vmf_insert_mixed(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pfn: pfn_t,
    ) -> vm_fault_t;
}
extern "C" {
    pub fn vmf_insert_mixed_mkwrite(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pfn: pfn_t,
    ) -> vm_fault_t;
}
extern "C" {
    pub fn vm_iomap_memory(
        vma: *mut vm_area_struct,
        start: phys_addr_t,
        len: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn follow_page(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        foll_flags: core::ffi::c_uint,
    ) -> *mut page;
}
pub type pte_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        pte: *mut pte_t,
        addr: core::ffi::c_ulong,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
extern "C" {
    pub fn apply_to_page_range(
        mm: *mut mm_struct,
        address: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        fn_: pte_fn_t,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn apply_to_existing_page_range(
        mm: *mut mm_struct,
        address: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        fn_: pte_fn_t,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __kernel_poison_pages(page: *mut page, numpages: core::ffi::c_int);
}
extern "C" {
    pub fn __kernel_unpoison_pages(page: *mut page, numpages: core::ffi::c_int);
}
extern "C" {
    pub static mut _page_poisoning_enabled_early: bool_;
}
extern "C" {
    pub static mut _page_poisoning_enabled: static_key_false;
}
extern "C" {
    pub static mut init_on_alloc: static_key_true;
}
extern "C" {
    pub static mut init_on_free: static_key_false;
}
extern "C" {
    pub static mut _debug_pagealloc_enabled_early: bool_;
}
extern "C" {
    pub static mut _debug_pagealloc_enabled: static_key_false;
}
extern "C" {
    pub fn __kernel_map_pages(
        page: *mut page,
        numpages: core::ffi::c_int,
        enable: core::ffi::c_int,
    );
}
extern "C" {
    pub fn get_gate_vma(mm: *mut mm_struct) -> *mut vm_area_struct;
}
extern "C" {
    pub fn in_gate_area_no_mm(addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn in_gate_area(mm: *mut mm_struct, addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn process_shares_mm(p: *mut task_struct, mm: *mut mm_struct) -> bool_;
}
extern "C" {
    pub static mut sysctl_drop_caches: core::ffi::c_int;
}
extern "C" {
    pub fn drop_caches_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn drop_slab();
}
extern "C" {
    pub static mut randomize_va_space: core::ffi::c_int;
}
extern "C" {
    pub fn arch_vma_name(vma: *mut vm_area_struct) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn print_vma_addr(prefix: *mut core::ffi::c_char, rip: core::ffi::c_ulong);
}
extern "C" {
    pub fn sparse_buffer_alloc(size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __populate_section_memmap(
        pfn: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        nid: core::ffi::c_int,
        altmap: *mut vmem_altmap,
        pgmap: *mut dev_pagemap,
    ) -> *mut page;
}
extern "C" {
    pub fn pmd_init(addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn pud_init(addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn vmemmap_pgd_populate(addr: core::ffi::c_ulong, node: core::ffi::c_int) -> *mut pgd_t;
}
extern "C" {
    pub fn vmemmap_p4d_populate(
        pgd: *mut pgd_t,
        addr: core::ffi::c_ulong,
        node: core::ffi::c_int,
    ) -> *mut p4d_t;
}
extern "C" {
    pub fn vmemmap_pud_populate(
        p4d: *mut p4d_t,
        addr: core::ffi::c_ulong,
        node: core::ffi::c_int,
    ) -> *mut pud_t;
}
extern "C" {
    pub fn vmemmap_pmd_populate(
        pud: *mut pud_t,
        addr: core::ffi::c_ulong,
        node: core::ffi::c_int,
    ) -> *mut pmd_t;
}
extern "C" {
    pub fn vmemmap_pte_populate(
        pmd: *mut pmd_t,
        addr: core::ffi::c_ulong,
        node: core::ffi::c_int,
        altmap: *mut vmem_altmap,
        reuse: *mut page,
    ) -> *mut pte_t;
}
extern "C" {
    pub fn vmemmap_alloc_block(
        size: core::ffi::c_ulong,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmemmap_alloc_block_buf(
        size: core::ffi::c_ulong,
        node: core::ffi::c_int,
        altmap: *mut vmem_altmap,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmemmap_verify(
        arg1: *mut pte_t,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_ulong,
        arg4: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn vmemmap_set_pmd(
        pmd: *mut pmd_t,
        p: *mut core::ffi::c_void,
        node: core::ffi::c_int,
        addr: core::ffi::c_ulong,
        next: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn vmemmap_check_pmd(
        pmd: *mut pmd_t,
        node: core::ffi::c_int,
        addr: core::ffi::c_ulong,
        next: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vmemmap_populate_basepages(
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        node: core::ffi::c_int,
        altmap: *mut vmem_altmap,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vmemmap_populate_hugepages(
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        node: core::ffi::c_int,
        altmap: *mut vmem_altmap,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vmemmap_populate(
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        node: core::ffi::c_int,
        altmap: *mut vmem_altmap,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vmemmap_populate_print_last();
}
extern "C" {
    pub fn vmemmap_free(
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        altmap: *mut vmem_altmap,
    );
}
extern "C" {
    pub fn register_page_bootmem_memmap(
        section_nr: core::ffi::c_ulong,
        map: *mut page,
        nr_pages: core::ffi::c_ulong,
    );
}
pub const mf_flags_MF_COUNT_INCREASED: mf_flags = 1;
pub const mf_flags_MF_ACTION_REQUIRED: mf_flags = 2;
pub const mf_flags_MF_MUST_KILL: mf_flags = 4;
pub const mf_flags_MF_SOFT_OFFLINE: mf_flags = 8;
pub const mf_flags_MF_UNPOISON: mf_flags = 16;
pub const mf_flags_MF_SW_SIMULATED: mf_flags = 32;
pub const mf_flags_MF_NO_RETRY: mf_flags = 64;
pub const mf_flags_MF_MEM_PRE_REMOVE: mf_flags = 128;
pub type mf_flags = core::ffi::c_uint;
extern "C" {
    pub fn mf_dax_kill_procs(
        mapping: *mut address_space,
        index: core::ffi::c_ulong,
        count: core::ffi::c_ulong,
        mf_flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memory_failure(pfn: core::ffi::c_ulong, flags: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn memory_failure_queue_kick(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn unpoison_memory(pfn: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn shake_page(p: *mut page);
}
extern "C" {
    pub static mut num_poisoned_pages: atomic_long_t;
}
extern "C" {
    pub fn soft_offline_page(pfn: core::ffi::c_ulong, flags: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub static memory_failure_attr_group: attribute_group;
}
extern "C" {
    pub fn memory_failure_queue(pfn: core::ffi::c_ulong, flags: core::ffi::c_int);
}
extern "C" {
    pub fn __get_huge_page_for_hwpoison(
        pfn: core::ffi::c_ulong,
        flags: core::ffi::c_int,
        migratable_cleared: *mut bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn num_poisoned_pages_inc(pfn: core::ffi::c_ulong);
}
extern "C" {
    pub fn num_poisoned_pages_sub(pfn: core::ffi::c_ulong, i: core::ffi::c_long);
}
extern "C" {
    pub fn task_early_kill(
        tsk: *mut task_struct,
        force_early: core::ffi::c_int,
    ) -> *mut task_struct;
}
extern "C" {
    pub fn add_to_kill_ksm(
        tsk: *mut task_struct,
        p: *mut page,
        vma: *mut vm_area_struct,
        to_kill: *mut list_head,
        ksm_addr: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn memblk_nr_poison_inc(pfn: core::ffi::c_ulong);
}
extern "C" {
    pub fn memblk_nr_poison_sub(pfn: core::ffi::c_ulong, i: core::ffi::c_long);
}
pub const mf_result_MF_IGNORED: mf_result = 0;
pub const mf_result_MF_FAILED: mf_result = 1;
pub const mf_result_MF_DELAYED: mf_result = 2;
pub const mf_result_MF_RECOVERED: mf_result = 3;
pub type mf_result = core::ffi::c_uint;
pub const mf_action_page_type_MF_MSG_KERNEL: mf_action_page_type = 0;
pub const mf_action_page_type_MF_MSG_KERNEL_HIGH_ORDER: mf_action_page_type = 1;
pub const mf_action_page_type_MF_MSG_SLAB: mf_action_page_type = 2;
pub const mf_action_page_type_MF_MSG_DIFFERENT_COMPOUND: mf_action_page_type = 3;
pub const mf_action_page_type_MF_MSG_HUGE: mf_action_page_type = 4;
pub const mf_action_page_type_MF_MSG_FREE_HUGE: mf_action_page_type = 5;
pub const mf_action_page_type_MF_MSG_UNMAP_FAILED: mf_action_page_type = 6;
pub const mf_action_page_type_MF_MSG_DIRTY_SWAPCACHE: mf_action_page_type = 7;
pub const mf_action_page_type_MF_MSG_CLEAN_SWAPCACHE: mf_action_page_type = 8;
pub const mf_action_page_type_MF_MSG_DIRTY_MLOCKED_LRU: mf_action_page_type = 9;
pub const mf_action_page_type_MF_MSG_CLEAN_MLOCKED_LRU: mf_action_page_type = 10;
pub const mf_action_page_type_MF_MSG_DIRTY_UNEVICTABLE_LRU: mf_action_page_type = 11;
pub const mf_action_page_type_MF_MSG_CLEAN_UNEVICTABLE_LRU: mf_action_page_type = 12;
pub const mf_action_page_type_MF_MSG_DIRTY_LRU: mf_action_page_type = 13;
pub const mf_action_page_type_MF_MSG_CLEAN_LRU: mf_action_page_type = 14;
pub const mf_action_page_type_MF_MSG_TRUNCATED_LRU: mf_action_page_type = 15;
pub const mf_action_page_type_MF_MSG_BUDDY: mf_action_page_type = 16;
pub const mf_action_page_type_MF_MSG_DAX: mf_action_page_type = 17;
pub const mf_action_page_type_MF_MSG_UNSPLIT_THP: mf_action_page_type = 18;
pub const mf_action_page_type_MF_MSG_UNKNOWN: mf_action_page_type = 19;
pub type mf_action_page_type = core::ffi::c_uint;
extern "C" {
    pub fn clear_huge_page(
        page: *mut page,
        addr_hint: core::ffi::c_ulong,
        pages_per_huge_page: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn copy_user_large_folio(
        dst: *mut folio,
        src: *mut folio,
        addr_hint: core::ffi::c_ulong,
        vma: *mut vm_area_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn copy_folio_from_user(
        dst_folio: *mut folio,
        usr_src: *const core::ffi::c_void,
        allow_pagefault: bool_,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn setup_nr_node_ids();
}
extern "C" {
    pub fn memcmp_pages(page1: *mut page, page2: *mut page) -> core::ffi::c_int;
}
extern "C" {
    pub fn clean_record_shared_mapping_range(
        mapping: *mut address_space,
        first_index: core::ffi::c_ulong,
        nr: core::ffi::c_ulong,
        bitmap_pgoff: core::ffi::c_ulong,
        bitmap: *mut core::ffi::c_ulong,
        start: *mut core::ffi::c_ulong,
        end: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn wp_shared_mapping_range(
        mapping: *mut address_space,
        first_index: core::ffi::c_ulong,
        nr: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub static mut sysctl_nr_trim_pages: core::ffi::c_int;
}
extern "C" {
    pub fn mem_dump_obj(object: *mut core::ffi::c_void);
}
extern "C" {
    pub fn madvise_set_anon_name(
        mm: *mut mm_struct,
        start: core::ffi::c_ulong,
        len_in: core::ffi::c_ulong,
        anon_name: *mut anon_vma_name,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn range_contains_unaccepted_memory(start: phys_addr_t, end: phys_addr_t) -> bool_;
}
extern "C" {
    pub fn accept_memory(start: phys_addr_t, end: phys_addr_t);
}
extern "C" {
    pub fn clflush_cache_range(addr: *mut core::ffi::c_void, size: core::ffi::c_uint);
}
pub const dma_data_direction_DMA_BIDIRECTIONAL: dma_data_direction = 0;
pub const dma_data_direction_DMA_TO_DEVICE: dma_data_direction = 1;
pub const dma_data_direction_DMA_FROM_DEVICE: dma_data_direction = 2;
pub const dma_data_direction_DMA_NONE: dma_data_direction = 3;
pub type dma_data_direction = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct urb {
    _unused: [u8; 0],
}
pub const ctx_state_CONTEXT_DISABLED: ctx_state = -1;
pub const ctx_state_CONTEXT_KERNEL: ctx_state = 0;
pub const ctx_state_CONTEXT_IDLE: ctx_state = 1;
pub const ctx_state_CONTEXT_USER: ctx_state = 2;
pub const ctx_state_CONTEXT_GUEST: ctx_state = 3;
pub const ctx_state_CONTEXT_MAX: ctx_state = 4;
pub type ctx_state = core::ffi::c_int;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct context_tracking {
    pub active: bool_,
    pub recursion: core::ffi::c_int,
    pub state: atomic_t,
    pub dynticks_nesting: core::ffi::c_long,
    pub dynticks_nmi_nesting: core::ffi::c_long,
}
extern "C" {
    pub static mut context_tracking: context_tracking;
}
extern "C" {
    pub static mut context_tracking_key: static_key_false;
}
extern "C" {
    pub static mut trace_hwlat_callback_enabled: bool_;
}
extern "C" {
    pub fn trace_hwlat_callback(enter: bool_);
}
extern "C" {
    pub static mut trace_osnoise_callback_enabled: bool_;
}
extern "C" {
    pub fn trace_osnoise_callback(enter: bool_);
}
extern "C" {
    pub fn vtime_account_kernel(tsk: *mut task_struct);
}
extern "C" {
    pub fn vtime_account_idle(tsk: *mut task_struct);
}
extern "C" {
    pub fn arch_vtime_task_switch(tsk: *mut task_struct);
}
extern "C" {
    pub fn vtime_user_enter(tsk: *mut task_struct);
}
extern "C" {
    pub fn vtime_user_exit(tsk: *mut task_struct);
}
extern "C" {
    pub fn vtime_guest_enter(tsk: *mut task_struct);
}
extern "C" {
    pub fn vtime_guest_exit(tsk: *mut task_struct);
}
extern "C" {
    pub fn vtime_init_idle(tsk: *mut task_struct, cpu: core::ffi::c_int);
}
extern "C" {
    pub fn vtime_task_switch_generic(prev: *mut task_struct);
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct irq_cpustat_t {
    pub kvm_cpu_l1tf_flush_l1d: u8_,
    pub __nmi_count: core::ffi::c_uint,
    pub apic_timer_irqs: core::ffi::c_uint,
    pub irq_spurious_count: core::ffi::c_uint,
    pub icr_read_retry_count: core::ffi::c_uint,
    pub kvm_posted_intr_ipis: core::ffi::c_uint,
    pub kvm_posted_intr_wakeup_ipis: core::ffi::c_uint,
    pub kvm_posted_intr_nested_ipis: core::ffi::c_uint,
    pub x86_platform_ipis: core::ffi::c_uint,
    pub apic_perf_irqs: core::ffi::c_uint,
    pub apic_irq_work_irqs: core::ffi::c_uint,
    pub irq_resched_count: core::ffi::c_uint,
    pub irq_call_count: core::ffi::c_uint,
    pub irq_tlb_count: core::ffi::c_uint,
    pub irq_thermal_count: core::ffi::c_uint,
    pub irq_threshold_count: core::ffi::c_uint,
    pub irq_deferred_error_count: core::ffi::c_uint,
    pub irq_hv_callback_count: core::ffi::c_uint,
    pub irq_hv_reenlightenment_count: core::ffi::c_uint,
    pub hyperv_stimer0_count: core::ffi::c_uint,
}
impl Default for irq_cpustat_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut irq_stat: irq_cpustat_t;
}
extern "C" {
    pub fn ack_bad_irq(irq: core::ffi::c_uint);
}
extern "C" {
    pub fn arch_irq_stat_cpu(cpu: core::ffi::c_uint) -> u64_;
}
extern "C" {
    pub fn arch_irq_stat() -> u64_;
}
extern "C" {
    pub fn synchronize_irq(irq: core::ffi::c_uint);
}
extern "C" {
    pub fn synchronize_hardirq(irq: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn __rcu_irq_enter_check_tick();
}
extern "C" {
    pub fn irq_enter();
}
extern "C" {
    pub fn irq_enter_rcu();
}
extern "C" {
    pub fn irq_exit();
}
extern "C" {
    pub fn irq_exit_rcu();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_vec {
    pub bv_page: *mut page,
    pub bv_len: core::ffi::c_uint,
    pub bv_offset: core::ffi::c_uint,
}
impl Default for bio_vec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
#[derive(Default, Copy, Clone)]
pub struct bvec_iter {
    pub bi_sector: sector_t,
    pub bi_size: core::ffi::c_uint,
    pub bi_idx: core::ffi::c_uint,
    pub bi_bvec_done: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bvec_iter_all {
    pub bv: bio_vec,
    pub idx: core::ffi::c_int,
    pub done: core::ffi::c_uint,
}
impl Default for bvec_iter_all {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn csum_partial(
        buff: *const core::ffi::c_void,
        len: core::ffi::c_int,
        sum: __wsum,
    ) -> __wsum;
}
extern "C" {
    pub fn csum_partial_copy_generic(
        src: *const core::ffi::c_void,
        dst: *mut core::ffi::c_void,
        len: core::ffi::c_int,
    ) -> __wsum;
}
extern "C" {
    pub fn csum_and_copy_from_user(
        src: *const core::ffi::c_void,
        dst: *mut core::ffi::c_void,
        len: core::ffi::c_int,
    ) -> __wsum;
}
extern "C" {
    pub fn csum_and_copy_to_user(
        src: *const core::ffi::c_void,
        dst: *mut core::ffi::c_void,
        len: core::ffi::c_int,
    ) -> __wsum;
}
extern "C" {
    pub fn csum_partial_copy_nocheck(
        src: *const core::ffi::c_void,
        dst: *mut core::ffi::c_void,
        len: core::ffi::c_int,
    ) -> __wsum;
}
extern "C" {
    pub fn ip_compute_csum(buff: *const core::ffi::c_void, len: core::ffi::c_int) -> __sum16;
}
extern "C" {
    pub fn csum_ipv6_magic(
        saddr: *const in6_addr,
        daddr: *const in6_addr,
        len: __u32,
        proto: __u8,
        sum: __wsum,
    ) -> __sum16;
}
extern "C" {
    pub fn inet_proto_csum_replace4(
        sum: *mut __sum16,
        skb: *mut sk_buff,
        from: __be32,
        to: __be32,
        pseudohdr: bool_,
    );
}
extern "C" {
    pub fn inet_proto_csum_replace16(
        sum: *mut __sum16,
        skb: *mut sk_buff,
        from: *const __be32,
        to: *const __be32,
        pseudohdr: bool_,
    );
}
extern "C" {
    pub fn inet_proto_csum_replace_by_diff(
        sum: *mut __sum16,
        skb: *mut sk_buff,
        diff: __wsum,
        pseudohdr: bool_,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_printk_info {
    pub subsystem: [core::ffi::c_char; 16usize],
    pub device: [core::ffi::c_char; 48usize],
}
impl Default for dev_printk_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn dev_vprintk_emit(
        level: core::ffi::c_int,
        dev: *const device,
        fmt: *const core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_printk_emit(
        level: core::ffi::c_int,
        dev: *const device,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn _dev_printk(
        level: *const core::ffi::c_char,
        dev: *const device,
        fmt: *const core::ffi::c_char,
        ...
    );
}
extern "C" {
    pub fn _dev_emerg(dev: *const device, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn _dev_alert(dev: *const device, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn _dev_crit(dev: *const device, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn _dev_err(dev: *const device, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn _dev_warn(dev: *const device, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn _dev_notice(dev: *const device, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn _dev_info(dev: *const device, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn dev_err_probe(
        dev: *const device,
        err: core::ffi::c_int,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpufreq_policy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct update_util_data {
    pub func: ::core::option::Option<
        unsafe extern "C" fn(data: *mut update_util_data, time: u64_, flags: core::ffi::c_uint),
    >,
}
extern "C" {
    pub fn cpufreq_add_update_util_hook(
        cpu: core::ffi::c_int,
        data: *mut update_util_data,
        func: ::core::option::Option<
            unsafe extern "C" fn(data: *mut update_util_data, time: u64_, flags: core::ffi::c_uint),
        >,
    );
}
extern "C" {
    pub fn cpufreq_remove_update_util_hook(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn cpufreq_this_cpu_can_update(policy: *mut cpufreq_policy) -> bool_;
}
pub const cpu_idle_type_CPU_IDLE: cpu_idle_type = 0;
pub const cpu_idle_type_CPU_NOT_IDLE: cpu_idle_type = 1;
pub const cpu_idle_type_CPU_NEWLY_IDLE: cpu_idle_type = 2;
pub const cpu_idle_type_CPU_MAX_IDLE_TYPES: cpu_idle_type = 3;
pub type cpu_idle_type = core::ffi::c_uint;
extern "C" {
    pub fn wake_up_if_idle(cpu: core::ffi::c_int);
}
pub const __SD_BALANCE_NEWIDLE: _bindgen_ty_101 = 0;
pub const __SD_BALANCE_EXEC: _bindgen_ty_101 = 1;
pub const __SD_BALANCE_FORK: _bindgen_ty_101 = 2;
pub const __SD_BALANCE_WAKE: _bindgen_ty_101 = 3;
pub const __SD_WAKE_AFFINE: _bindgen_ty_101 = 4;
pub const __SD_ASYM_CPUCAPACITY: _bindgen_ty_101 = 5;
pub const __SD_ASYM_CPUCAPACITY_FULL: _bindgen_ty_101 = 6;
pub const __SD_SHARE_CPUCAPACITY: _bindgen_ty_101 = 7;
pub const __SD_CLUSTER: _bindgen_ty_101 = 8;
pub const __SD_SHARE_PKG_RESOURCES: _bindgen_ty_101 = 9;
pub const __SD_SERIALIZE: _bindgen_ty_101 = 10;
pub const __SD_ASYM_PACKING: _bindgen_ty_101 = 11;
pub const __SD_PREFER_SIBLING: _bindgen_ty_101 = 12;
pub const __SD_OVERLAP: _bindgen_ty_101 = 13;
pub const __SD_NUMA: _bindgen_ty_101 = 14;
pub const __SD_FLAG_CNT: _bindgen_ty_101 = 15;
pub type _bindgen_ty_101 = core::ffi::c_uint;
pub const SD_BALANCE_NEWIDLE: _bindgen_ty_102 = 1;
pub const SD_BALANCE_EXEC: _bindgen_ty_102 = 2;
pub const SD_BALANCE_FORK: _bindgen_ty_102 = 4;
pub const SD_BALANCE_WAKE: _bindgen_ty_102 = 8;
pub const SD_WAKE_AFFINE: _bindgen_ty_102 = 16;
pub const SD_ASYM_CPUCAPACITY: _bindgen_ty_102 = 32;
pub const SD_ASYM_CPUCAPACITY_FULL: _bindgen_ty_102 = 64;
pub const SD_SHARE_CPUCAPACITY: _bindgen_ty_102 = 128;
pub const SD_CLUSTER: _bindgen_ty_102 = 256;
pub const SD_SHARE_PKG_RESOURCES: _bindgen_ty_102 = 512;
pub const SD_SERIALIZE: _bindgen_ty_102 = 1024;
pub const SD_ASYM_PACKING: _bindgen_ty_102 = 2048;
pub const SD_PREFER_SIBLING: _bindgen_ty_102 = 4096;
pub const SD_OVERLAP: _bindgen_ty_102 = 8192;
pub const SD_NUMA: _bindgen_ty_102 = 16384;
pub type _bindgen_ty_102 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sd_flag_debug {
    pub meta_flags: core::ffi::c_uint,
    pub name: *mut core::ffi::c_char,
}
impl Default for sd_flag_debug {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static sd_flag_debug: [sd_flag_debug; 0usize];
}
extern "C" {
    pub fn arch_asym_cpu_priority(cpu: core::ffi::c_int) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_domain_attr {
    pub relax_domain_level: core::ffi::c_int,
}
extern "C" {
    pub static mut sched_domain_level_max: core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_group {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_domain_shared {
    pub ref_: atomic_t,
    pub nr_busy_cpus: atomic_t,
    pub has_idle_cores: core::ffi::c_int,
    pub nr_idle_scan: core::ffi::c_int,
}
#[repr(C)]
pub struct sched_domain {
    pub parent: *mut sched_domain,
    pub child: *mut sched_domain,
    pub groups: *mut sched_group,
    pub min_interval: core::ffi::c_ulong,
    pub max_interval: core::ffi::c_ulong,
    pub busy_factor: core::ffi::c_uint,
    pub imbalance_pct: core::ffi::c_uint,
    pub cache_nice_tries: core::ffi::c_uint,
    pub imb_numa_nr: core::ffi::c_uint,
    pub nohz_idle: core::ffi::c_int,
    pub flags: core::ffi::c_int,
    pub level: core::ffi::c_int,
    pub last_balance: core::ffi::c_ulong,
    pub balance_interval: core::ffi::c_uint,
    pub nr_balance_failed: core::ffi::c_uint,
    pub max_newidle_lb_cost: u64_,
    pub last_decay_max_lb_cost: core::ffi::c_ulong,
    pub lb_count: [core::ffi::c_uint; 3usize],
    pub lb_failed: [core::ffi::c_uint; 3usize],
    pub lb_balanced: [core::ffi::c_uint; 3usize],
    pub lb_imbalance: [core::ffi::c_uint; 3usize],
    pub lb_gained: [core::ffi::c_uint; 3usize],
    pub lb_hot_gained: [core::ffi::c_uint; 3usize],
    pub lb_nobusyg: [core::ffi::c_uint; 3usize],
    pub lb_nobusyq: [core::ffi::c_uint; 3usize],
    pub alb_count: core::ffi::c_uint,
    pub alb_failed: core::ffi::c_uint,
    pub alb_pushed: core::ffi::c_uint,
    pub sbe_count: core::ffi::c_uint,
    pub sbe_balanced: core::ffi::c_uint,
    pub sbe_pushed: core::ffi::c_uint,
    pub sbf_count: core::ffi::c_uint,
    pub sbf_balanced: core::ffi::c_uint,
    pub sbf_pushed: core::ffi::c_uint,
    pub ttwu_wake_remote: core::ffi::c_uint,
    pub ttwu_move_affine: core::ffi::c_uint,
    pub ttwu_move_balance: core::ffi::c_uint,
    pub name: *mut core::ffi::c_char,
    pub __bindgen_anon_1: sched_domain__bindgen_ty_1,
    pub shared: *mut sched_domain_shared,
    pub span_weight: core::ffi::c_uint,
    pub span: __IncompleteArrayField<core::ffi::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sched_domain__bindgen_ty_1 {
    pub private: *mut core::ffi::c_void,
    pub rcu: callback_head,
}
impl Default for sched_domain__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sched_domain {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn partition_sched_domains_locked(
        ndoms_new: core::ffi::c_int,
        doms_new: *mut cpumask_var_t,
        dattr_new: *mut sched_domain_attr,
    );
}
extern "C" {
    pub fn partition_sched_domains(
        ndoms_new: core::ffi::c_int,
        doms_new: *mut cpumask_var_t,
        dattr_new: *mut sched_domain_attr,
    );
}
extern "C" {
    pub fn alloc_sched_domains(ndoms: core::ffi::c_uint) -> *mut cpumask_var_t;
}
extern "C" {
    pub fn free_sched_domains(doms: *mut cpumask_var_t, ndoms: core::ffi::c_uint);
}
extern "C" {
    pub fn cpus_share_cache(this_cpu: core::ffi::c_int, that_cpu: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn cpus_share_resources(this_cpu: core::ffi::c_int, that_cpu: core::ffi::c_int) -> bool_;
}
pub type sched_domain_mask_f =
    ::core::option::Option<unsafe extern "C" fn(cpu: core::ffi::c_int) -> *const cpumask>;
pub type sched_domain_flags_f = ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sd_data {
    pub sd: *mut *mut sched_domain,
    pub sds: *mut *mut sched_domain_shared,
    pub sg: *mut *mut sched_group,
    pub sgc: *mut *mut sched_group_capacity,
}
impl Default for sd_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_domain_topology_level {
    pub mask: sched_domain_mask_f,
    pub sd_flags: sched_domain_flags_f,
    pub flags: core::ffi::c_int,
    pub numa_level: core::ffi::c_int,
    pub data: sd_data,
    pub name: *mut core::ffi::c_char,
}
impl Default for sched_domain_topology_level {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn set_sched_topology(tl: *mut sched_domain_topology_level);
}
extern "C" {
    pub fn rebuild_sched_domains_energy();
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct em_perf_state {
    pub frequency: core::ffi::c_ulong,
    pub power: core::ffi::c_ulong,
    pub cost: core::ffi::c_ulong,
    pub flags: core::ffi::c_ulong,
}
#[repr(C)]
pub struct em_perf_domain {
    pub table: *mut em_perf_state,
    pub nr_perf_states: core::ffi::c_int,
    pub flags: core::ffi::c_ulong,
    pub cpus: __IncompleteArrayField<core::ffi::c_ulong>,
}
impl Default for em_perf_domain {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct em_data_callback {
    pub active_power: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            power: *mut core::ffi::c_ulong,
            freq: *mut core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub get_cost: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            freq: core::ffi::c_ulong,
            cost: *mut core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
}
extern "C" {
    pub fn em_cpu_get(cpu: core::ffi::c_int) -> *mut em_perf_domain;
}
extern "C" {
    pub fn em_pd_get(dev: *mut device) -> *mut em_perf_domain;
}
extern "C" {
    pub fn em_dev_register_perf_domain(
        dev: *mut device,
        nr_states: core::ffi::c_uint,
        cb: *mut em_data_callback,
        span: *mut cpumask_t,
        microwatts: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn em_dev_unregister_perf_domain(dev: *mut device);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct klist {
    pub k_lock: spinlock_t,
    pub k_list: list_head,
    pub get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut klist_node)>,
    pub put: ::core::option::Option<unsafe extern "C" fn(arg1: *mut klist_node)>,
}
impl Default for klist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn klist_init(
        k: *mut klist,
        get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut klist_node)>,
        put: ::core::option::Option<unsafe extern "C" fn(arg1: *mut klist_node)>,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct klist_node {
    pub n_klist: *mut core::ffi::c_void,
    pub n_node: list_head,
    pub n_ref: kref,
}
impl Default for klist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn klist_add_tail(n: *mut klist_node, k: *mut klist);
}
extern "C" {
    pub fn klist_add_head(n: *mut klist_node, k: *mut klist);
}
extern "C" {
    pub fn klist_add_behind(n: *mut klist_node, pos: *mut klist_node);
}
extern "C" {
    pub fn klist_add_before(n: *mut klist_node, pos: *mut klist_node);
}
extern "C" {
    pub fn klist_del(n: *mut klist_node);
}
extern "C" {
    pub fn klist_remove(n: *mut klist_node);
}
extern "C" {
    pub fn klist_node_attached(n: *mut klist_node) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct klist_iter {
    pub i_klist: *mut klist,
    pub i_cur: *mut klist_node,
}
impl Default for klist_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn klist_iter_init(k: *mut klist, i: *mut klist_iter);
}
extern "C" {
    pub fn klist_iter_init_node(k: *mut klist, i: *mut klist_iter, n: *mut klist_node);
}
extern "C" {
    pub fn klist_iter_exit(i: *mut klist_iter);
}
extern "C" {
    pub fn klist_prev(i: *mut klist_iter) -> *mut klist_node;
}
extern "C" {
    pub fn klist_next(i: *mut klist_iter) -> *mut klist_node;
}
extern "C" {
    pub static mut pm_power_off: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn pm_vt_switch_required(dev: *mut device, required: bool_);
}
extern "C" {
    pub fn pm_vt_switch_unregister(dev: *mut device);
}
extern "C" {
    pub fn cxl_mem_active() -> bool_;
}
extern "C" {
    pub static power_group_name: [core::ffi::c_char; 0usize];
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pm_message {
    pub event: core::ffi::c_int,
}
pub type pm_message_t = pm_message;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pm_ops {
    pub prepare: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub complete: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub suspend: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub freeze: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub thaw: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub poweroff:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub restore: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub suspend_late:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub resume_early:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub freeze_late:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub thaw_early:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub poweroff_late:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub restore_early:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub suspend_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub resume_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub freeze_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub thaw_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub poweroff_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub restore_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub runtime_suspend:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub runtime_resume:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub runtime_idle:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
}
pub const rpm_status_RPM_INVALID: rpm_status = -1;
pub const rpm_status_RPM_ACTIVE: rpm_status = 0;
pub const rpm_status_RPM_RESUMING: rpm_status = 1;
pub const rpm_status_RPM_SUSPENDED: rpm_status = 2;
pub const rpm_status_RPM_SUSPENDING: rpm_status = 3;
pub type rpm_status = core::ffi::c_int;
pub const rpm_request_RPM_REQ_NONE: rpm_request = 0;
pub const rpm_request_RPM_REQ_IDLE: rpm_request = 1;
pub const rpm_request_RPM_REQ_SUSPEND: rpm_request = 2;
pub const rpm_request_RPM_REQ_AUTOSUSPEND: rpm_request = 3;
pub const rpm_request_RPM_REQ_RESUME: rpm_request = 4;
pub type rpm_request = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wake_irq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_domain_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_subsys_data {
    pub lock: spinlock_t,
    pub refcount: core::ffi::c_uint,
    pub clock_op_might_sleep: core::ffi::c_uint,
    pub clock_mutex: mutex,
    pub clock_list: list_head,
    pub domain_data: *mut pm_domain_data,
}
impl Default for pm_subsys_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_info {
    pub power_state: pm_message_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub driver_flags: u32_,
    pub lock: spinlock_t,
    pub entry: list_head,
    pub completion: completion,
    pub wakeup: *mut wakeup_source,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub suspend_timer: hrtimer,
    pub timer_expires: u64_,
    pub work: work_struct,
    pub wait_queue: wait_queue_head_t,
    pub wakeirq: *mut wake_irq,
    pub usage_count: atomic_t,
    pub child_count: atomic_t,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub links_count: core::ffi::c_uint,
    pub request: rpm_request,
    pub runtime_status: rpm_status,
    pub last_status: rpm_status,
    pub runtime_error: core::ffi::c_int,
    pub autosuspend_delay: core::ffi::c_int,
    pub last_busy: u64_,
    pub active_time: u64_,
    pub suspended_time: u64_,
    pub accounting_timestamp: u64_,
    pub subsys_data: *mut pm_subsys_data,
    pub set_latency_tolerance:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: s32)>,
    pub qos: *mut dev_pm_qos,
}
impl Default for dev_pm_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl dev_pm_info {
    #[inline]
    pub fn can_wakeup(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_wakeup(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn async_suspend(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_async_suspend(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dpm_list(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_in_dpm_list(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_prepared(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_prepared(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_noirq_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_noirq_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_late_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_late_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_pm(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_pm(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn early_init(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_init(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct_complete(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_direct_complete(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        can_wakeup: core::ffi::c_uint,
        async_suspend: core::ffi::c_uint,
        in_dpm_list: bool_,
        is_prepared: bool_,
        is_suspended: bool_,
        is_noirq_suspended: bool_,
        is_late_suspended: bool_,
        no_pm: bool_,
        early_init: bool_,
        direct_complete: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let can_wakeup: u32 = unsafe { ::core::mem::transmute(can_wakeup) };
            can_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let async_suspend: u32 = unsafe { ::core::mem::transmute(async_suspend) };
            async_suspend as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let in_dpm_list: u8 = unsafe { ::core::mem::transmute(in_dpm_list) };
            in_dpm_list as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_prepared: u8 = unsafe { ::core::mem::transmute(is_prepared) };
            is_prepared as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_suspended: u8 = unsafe { ::core::mem::transmute(is_suspended) };
            is_suspended as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_noirq_suspended: u8 = unsafe { ::core::mem::transmute(is_noirq_suspended) };
            is_noirq_suspended as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is_late_suspended: u8 = unsafe { ::core::mem::transmute(is_late_suspended) };
            is_late_suspended as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let no_pm: u8 = unsafe { ::core::mem::transmute(no_pm) };
            no_pm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
            early_init as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let direct_complete: u8 = unsafe { ::core::mem::transmute(direct_complete) };
            direct_complete as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn wakeup_path(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wakeup_path(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syscore(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syscore(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_pm_callbacks(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_pm_callbacks(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn async_in_progress(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_async_in_progress(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn must_resume(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_must_resume(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn may_skip_resume(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_may_skip_resume(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        wakeup_path: bool_,
        syscore: bool_,
        no_pm_callbacks: bool_,
        async_in_progress: bool_,
        must_resume: core::ffi::c_uint,
        may_skip_resume: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wakeup_path: u8 = unsafe { ::core::mem::transmute(wakeup_path) };
            wakeup_path as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let syscore: u8 = unsafe { ::core::mem::transmute(syscore) };
            syscore as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_pm_callbacks: u8 = unsafe { ::core::mem::transmute(no_pm_callbacks) };
            no_pm_callbacks as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let async_in_progress: u8 = unsafe { ::core::mem::transmute(async_in_progress) };
            async_in_progress as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let must_resume: u32 = unsafe { ::core::mem::transmute(must_resume) };
            must_resume as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let may_skip_resume: u32 = unsafe { ::core::mem::transmute(may_skip_resume) };
            may_skip_resume as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn disable_depth(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_disable_depth(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn idle_notification(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idle_notification(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_pending(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_pending(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deferred_resume(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deferred_resume(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn needs_force_resume(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_needs_force_resume(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn runtime_auto(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_runtime_auto(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_children(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_children(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_callbacks(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_callbacks(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irq_safe(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irq_safe(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_autosuspend(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_autosuspend(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_autosuspends(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_autosuspends(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memalloc_noio(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_memalloc_noio(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        disable_depth: core::ffi::c_uint,
        idle_notification: core::ffi::c_uint,
        request_pending: core::ffi::c_uint,
        deferred_resume: core::ffi::c_uint,
        needs_force_resume: core::ffi::c_uint,
        runtime_auto: core::ffi::c_uint,
        ignore_children: bool_,
        no_callbacks: core::ffi::c_uint,
        irq_safe: core::ffi::c_uint,
        use_autosuspend: core::ffi::c_uint,
        timer_autosuspends: core::ffi::c_uint,
        memalloc_noio: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let disable_depth: u32 = unsafe { ::core::mem::transmute(disable_depth) };
            disable_depth as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let idle_notification: u32 = unsafe { ::core::mem::transmute(idle_notification) };
            idle_notification as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let request_pending: u32 = unsafe { ::core::mem::transmute(request_pending) };
            request_pending as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let deferred_resume: u32 = unsafe { ::core::mem::transmute(deferred_resume) };
            deferred_resume as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let needs_force_resume: u32 = unsafe { ::core::mem::transmute(needs_force_resume) };
            needs_force_resume as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let runtime_auto: u32 = unsafe { ::core::mem::transmute(runtime_auto) };
            runtime_auto as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ignore_children: u8 = unsafe { ::core::mem::transmute(ignore_children) };
            ignore_children as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let no_callbacks: u32 = unsafe { ::core::mem::transmute(no_callbacks) };
            no_callbacks as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let irq_safe: u32 = unsafe { ::core::mem::transmute(irq_safe) };
            irq_safe as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let use_autosuspend: u32 = unsafe { ::core::mem::transmute(use_autosuspend) };
            use_autosuspend as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let timer_autosuspends: u32 = unsafe { ::core::mem::transmute(timer_autosuspends) };
            timer_autosuspends as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let memalloc_noio: u32 = unsafe { ::core::mem::transmute(memalloc_noio) };
            memalloc_noio as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn dev_pm_get_subsys_data(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_pm_put_subsys_data(dev: *mut device);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pm_domain {
    pub ops: dev_pm_ops,
    pub start: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub detach: ::core::option::Option<unsafe extern "C" fn(dev: *mut device, power_off: bool_)>,
    pub activate:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub sync: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub dismiss: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub set_performance_state: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: core::ffi::c_uint) -> core::ffi::c_int,
    >,
}
extern "C" {
    pub fn device_pm_lock();
}
extern "C" {
    pub fn dpm_resume_start(state: pm_message_t);
}
extern "C" {
    pub fn dpm_resume_end(state: pm_message_t);
}
extern "C" {
    pub fn dpm_resume_noirq(state: pm_message_t);
}
extern "C" {
    pub fn dpm_resume_early(state: pm_message_t);
}
extern "C" {
    pub fn dpm_resume(state: pm_message_t);
}
extern "C" {
    pub fn dpm_complete(state: pm_message_t);
}
extern "C" {
    pub fn device_pm_unlock();
}
extern "C" {
    pub fn dpm_suspend_end(state: pm_message_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn dpm_suspend_start(state: pm_message_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn dpm_suspend_noirq(state: pm_message_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn dpm_suspend_late(state: pm_message_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn dpm_suspend(state: pm_message_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn dpm_prepare(state: pm_message_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn __suspend_report_result(
        function: *const core::ffi::c_char,
        dev: *mut device,
        fn_: *mut core::ffi::c_void,
        ret: core::ffi::c_int,
    );
}
extern "C" {
    pub fn device_pm_wait_for_dev(sub: *mut device, dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn dpm_for_each_dev(
        data: *mut core::ffi::c_void,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut device, arg2: *mut core::ffi::c_void),
        >,
    );
}
extern "C" {
    pub fn pm_generic_prepare(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_suspend_late(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_suspend_noirq(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_suspend(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_resume_early(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_resume_noirq(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_resume(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_freeze_noirq(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_freeze_late(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_freeze(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_thaw_noirq(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_thaw_early(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_thaw(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_restore_noirq(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_restore_early(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_restore(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_poweroff_noirq(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_poweroff_late(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_poweroff(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pm_generic_complete(dev: *mut device);
}
extern "C" {
    pub fn dev_pm_skip_resume(dev: *mut device) -> bool_;
}
extern "C" {
    pub fn dev_pm_skip_suspend(dev: *mut device) -> bool_;
}
pub const dpm_order_DPM_ORDER_NONE: dpm_order = 0;
pub const dpm_order_DPM_ORDER_DEV_AFTER_PARENT: dpm_order = 1;
pub const dpm_order_DPM_ORDER_PARENT_BEFORE_DEV: dpm_order = 2;
pub const dpm_order_DPM_ORDER_DEV_LAST: dpm_order = 3;
pub type dpm_order = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bus_type {
    pub name: *const core::ffi::c_char,
    pub dev_name: *const core::ffi::c_char,
    pub bus_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub drv_groups: *mut *const attribute_group,
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, drv: *mut device_driver) -> core::ffi::c_int,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, env: *mut kobj_uevent_env) -> core::ffi::c_int,
    >,
    pub probe: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub sync_state: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub online: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub offline: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: pm_message_t) -> core::ffi::c_int,
    >,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub num_vf: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub dma_configure:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub dma_cleanup: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub pm: *const dev_pm_ops,
    pub need_parent_lock: bool_,
}
impl Default for bus_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn bus_register(bus: *const bus_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn bus_unregister(bus: *const bus_type);
}
extern "C" {
    pub fn bus_rescan_devices(bus: *const bus_type) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bus_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(bus: *const bus_type, buf: *mut core::ffi::c_char) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            bus: *const bus_type,
            buf: *const core::ffi::c_char,
            count: usize,
        ) -> isize,
    >,
}
impl Default for bus_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn bus_create_file(bus: *const bus_type, attr: *mut bus_attribute) -> core::ffi::c_int;
}
extern "C" {
    pub fn bus_remove_file(bus: *const bus_type, attr: *mut bus_attribute);
}
extern "C" {
    pub fn device_match_name(dev: *mut device, name: *const core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_match_of_node(dev: *mut device, np: *const core::ffi::c_void)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn device_match_fwnode(
        dev: *mut device,
        fwnode: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_match_devt(dev: *mut device, pdevt: *const core::ffi::c_void)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn device_match_acpi_dev(
        dev: *mut device,
        adev: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_match_acpi_handle(
        dev: *mut device,
        handle: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_match_any(dev: *mut device, unused: *const core::ffi::c_void)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn bus_for_each_dev(
        bus: *const bus_type,
        start: *mut device,
        data: *mut core::ffi::c_void,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut device,
                data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bus_find_device(
        bus: *const bus_type,
        start: *mut device,
        data: *const core::ffi::c_void,
        match_: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut device,
                data: *const core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> *mut device;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct acpi_device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn bus_for_each_drv(
        bus: *const bus_type,
        start: *mut device_driver,
        data: *mut core::ffi::c_void,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device_driver,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bus_sort_breadthfirst(
        bus: *const bus_type,
        compare: ::core::option::Option<
            unsafe extern "C" fn(a: *const device, b: *const device) -> core::ffi::c_int,
        >,
    );
}
extern "C" {
    pub fn bus_register_notifier(bus: *const bus_type, nb: *mut notifier_block)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn bus_unregister_notifier(
        bus: *const bus_type,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
pub const bus_notifier_event_BUS_NOTIFY_ADD_DEVICE: bus_notifier_event = 0;
pub const bus_notifier_event_BUS_NOTIFY_DEL_DEVICE: bus_notifier_event = 1;
pub const bus_notifier_event_BUS_NOTIFY_REMOVED_DEVICE: bus_notifier_event = 2;
pub const bus_notifier_event_BUS_NOTIFY_BIND_DRIVER: bus_notifier_event = 3;
pub const bus_notifier_event_BUS_NOTIFY_BOUND_DRIVER: bus_notifier_event = 4;
pub const bus_notifier_event_BUS_NOTIFY_UNBIND_DRIVER: bus_notifier_event = 5;
pub const bus_notifier_event_BUS_NOTIFY_UNBOUND_DRIVER: bus_notifier_event = 6;
pub const bus_notifier_event_BUS_NOTIFY_DRIVER_NOT_BOUND: bus_notifier_event = 7;
pub type bus_notifier_event = core::ffi::c_uint;
extern "C" {
    pub fn bus_get_kset(bus: *const bus_type) -> *mut kset;
}
extern "C" {
    pub fn bus_get_dev_root(bus: *const bus_type) -> *mut device;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class {
    pub name: *const core::ffi::c_char,
    pub class_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub dev_uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, env: *mut kobj_uevent_env) -> core::ffi::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, mode: *mut umode_t) -> *mut core::ffi::c_char,
    >,
    pub class_release: ::core::option::Option<unsafe extern "C" fn(class: *const class)>,
    pub dev_release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub shutdown_pre:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub ns_type: *const kobj_ns_type_operations,
    pub namespace: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device) -> *const core::ffi::c_void,
    >,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
    pub pm: *const dev_pm_ops,
}
impl Default for class {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_dev_iter {
    pub ki: klist_iter,
    pub type_: *const device_type,
    pub sp: *mut subsys_private,
}
impl Default for class_dev_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn class_register(class: *const class) -> core::ffi::c_int;
}
extern "C" {
    pub fn class_unregister(class: *const class);
}
extern "C" {
    pub fn class_is_registered(class: *const class) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_compat {
    _unused: [u8; 0],
}
extern "C" {
    pub fn class_compat_register(name: *const core::ffi::c_char) -> *mut class_compat;
}
extern "C" {
    pub fn class_compat_unregister(cls: *mut class_compat);
}
extern "C" {
    pub fn class_compat_create_link(
        cls: *mut class_compat,
        dev: *mut device,
        device_link: *mut device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn class_compat_remove_link(
        cls: *mut class_compat,
        dev: *mut device,
        device_link: *mut device,
    );
}
extern "C" {
    pub fn class_dev_iter_init(
        iter: *mut class_dev_iter,
        class: *const class,
        start: *const device,
        type_: *const device_type,
    );
}
extern "C" {
    pub fn class_dev_iter_next(iter: *mut class_dev_iter) -> *mut device;
}
extern "C" {
    pub fn class_dev_iter_exit(iter: *mut class_dev_iter);
}
extern "C" {
    pub fn class_for_each_device(
        class: *const class,
        start: *const device,
        data: *mut core::ffi::c_void,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut device,
                data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn class_find_device(
        class: *const class,
        start: *const device,
        data: *const core::ffi::c_void,
        match_: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *const core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> *mut device;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            class: *const class,
            attr: *const class_attribute,
            buf: *mut core::ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            class: *const class,
            attr: *const class_attribute,
            buf: *const core::ffi::c_char,
            count: usize,
        ) -> isize,
    >,
}
impl Default for class_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn class_create_file_ns(
        class: *const class,
        attr: *const class_attribute,
        ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn class_remove_file_ns(
        class: *const class,
        attr: *const class_attribute,
        ns: *const core::ffi::c_void,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_attribute_string {
    pub attr: class_attribute,
    pub str_: *mut core::ffi::c_char,
}
impl Default for class_attribute_string {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn show_class_attr_string(
        class: *const class,
        attr: *const class_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_interface {
    pub node: list_head,
    pub class: *const class,
    pub add_dev: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub remove_dev: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
}
impl Default for class_interface {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn class_interface_register(arg1: *mut class_interface) -> core::ffi::c_int;
}
extern "C" {
    pub fn class_interface_unregister(arg1: *mut class_interface);
}
extern "C" {
    pub fn class_create(name: *const core::ffi::c_char) -> *mut class;
}
extern "C" {
    pub fn class_destroy(cls: *const class);
}
pub const probe_type_PROBE_DEFAULT_STRATEGY: probe_type = 0;
pub const probe_type_PROBE_PREFER_ASYNCHRONOUS: probe_type = 1;
pub const probe_type_PROBE_FORCE_SYNCHRONOUS: probe_type = 2;
pub type probe_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_driver {
    pub name: *const core::ffi::c_char,
    pub bus: *const bus_type,
    pub owner: *mut module,
    pub mod_name: *const core::ffi::c_char,
    pub suppress_bind_attrs: bool_,
    pub probe_type: probe_type,
    pub of_match_table: *const of_device_id,
    pub acpi_match_table: *const acpi_device_id,
    pub probe: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub sync_state: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: pm_message_t) -> core::ffi::c_int,
    >,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub pm: *const dev_pm_ops,
    pub coredump: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub p: *mut driver_private,
}
impl Default for device_driver {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn driver_register(drv: *mut device_driver) -> core::ffi::c_int;
}
extern "C" {
    pub fn driver_unregister(drv: *mut device_driver);
}
extern "C" {
    pub fn driver_find(name: *const core::ffi::c_char, bus: *const bus_type) -> *mut device_driver;
}
extern "C" {
    pub fn driver_probe_done() -> bool_;
}
extern "C" {
    pub fn wait_for_device_probe();
}
extern "C" {
    pub fn wait_for_init_devices_probe();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct driver_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(driver: *mut device_driver, buf: *mut core::ffi::c_char) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut device_driver,
            buf: *const core::ffi::c_char,
            count: usize,
        ) -> isize,
    >,
}
impl Default for driver_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn driver_create_file(
        driver: *mut device_driver,
        attr: *const driver_attribute,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn driver_remove_file(driver: *mut device_driver, attr: *const driver_attribute);
}
extern "C" {
    pub fn driver_set_override(
        dev: *mut device,
        override_: *mut *const core::ffi::c_char,
        s: *const core::ffi::c_char,
        len: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn driver_for_each_device(
        drv: *mut device_driver,
        start: *mut device,
        data: *mut core::ffi::c_void,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut device,
                arg1: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn driver_find_device(
        drv: *mut device_driver,
        start: *mut device,
        data: *const core::ffi::c_void,
        match_: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut device,
                data: *const core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> *mut device;
}
extern "C" {
    pub fn driver_deferred_probe_add(dev: *mut device);
}
extern "C" {
    pub fn driver_deferred_probe_check_state(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn driver_init();
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_archdata {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pdev_archdata {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct driver_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subsys_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_group {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pin_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_iommu {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_device_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subsys_interface {
    pub name: *const core::ffi::c_char,
    pub subsys: *const bus_type,
    pub node: list_head,
    pub add_dev: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, sif: *mut subsys_interface) -> core::ffi::c_int,
    >,
    pub remove_dev:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device, sif: *mut subsys_interface)>,
}
impl Default for subsys_interface {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn subsys_interface_register(sif: *mut subsys_interface) -> core::ffi::c_int;
}
extern "C" {
    pub fn subsys_interface_unregister(sif: *mut subsys_interface);
}
extern "C" {
    pub fn subsys_system_register(
        subsys: *const bus_type,
        groups: *mut *const attribute_group,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn subsys_virtual_register(
        subsys: *const bus_type,
        groups: *mut *const attribute_group,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_type {
    pub name: *const core::ffi::c_char,
    pub groups: *mut *const attribute_group,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, env: *mut kobj_uevent_env) -> core::ffi::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *const device,
            mode: *mut umode_t,
            uid: *mut kuid_t,
            gid: *mut kgid_t,
        ) -> *mut core::ffi::c_char,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub pm: *const dev_pm_ops,
}
impl Default for device_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            attr: *mut device_attribute,
            buf: *mut core::ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            attr: *mut device_attribute,
            buf: *const core::ffi::c_char,
            count: usize,
        ) -> isize,
    >,
}
impl Default for device_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_ext_attribute {
    pub attr: device_attribute,
    pub var: *mut core::ffi::c_void,
}
impl Default for dev_ext_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn device_show_ulong(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn device_store_ulong(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *const core::ffi::c_char,
        count: usize,
    ) -> isize;
}
extern "C" {
    pub fn device_show_int(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn device_store_int(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *const core::ffi::c_char,
        count: usize,
    ) -> isize;
}
extern "C" {
    pub fn device_show_bool(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn device_store_bool(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *const core::ffi::c_char,
        count: usize,
    ) -> isize;
}
extern "C" {
    pub fn device_create_file(
        device: *mut device,
        entry: *const device_attribute,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_remove_file(dev: *mut device, attr: *const device_attribute);
}
extern "C" {
    pub fn device_remove_file_self(dev: *mut device, attr: *const device_attribute) -> bool_;
}
extern "C" {
    pub fn device_create_bin_file(dev: *mut device, attr: *const bin_attribute)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn device_remove_bin_file(dev: *mut device, attr: *const bin_attribute);
}
pub type dr_release_t =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut device, res: *mut core::ffi::c_void)>;
pub type dr_match_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut device,
        res: *mut core::ffi::c_void,
        match_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
extern "C" {
    pub fn __devres_alloc_node(
        release: dr_release_t,
        size: usize,
        gfp: gfp_t,
        nid: core::ffi::c_int,
        name: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devres_for_each_res(
        dev: *mut device,
        release: dr_release_t,
        match_: dr_match_t,
        match_data: *mut core::ffi::c_void,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut core::ffi::c_void,
                arg3: *mut core::ffi::c_void,
            ),
        >,
        data: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn devres_free(res: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devres_add(dev: *mut device, res: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devres_find(
        dev: *mut device,
        release: dr_release_t,
        match_: dr_match_t,
        match_data: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devres_get(
        dev: *mut device,
        new_res: *mut core::ffi::c_void,
        match_: dr_match_t,
        match_data: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devres_remove(
        dev: *mut device,
        release: dr_release_t,
        match_: dr_match_t,
        match_data: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devres_destroy(
        dev: *mut device,
        release: dr_release_t,
        match_: dr_match_t,
        match_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devres_release(
        dev: *mut device,
        release: dr_release_t,
        match_: dr_match_t,
        match_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devres_open_group(
        dev: *mut device,
        id: *mut core::ffi::c_void,
        gfp: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devres_close_group(dev: *mut device, id: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devres_remove_group(dev: *mut device, id: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devres_release_group(dev: *mut device, id: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_kmalloc(dev: *mut device, size: usize, gfp: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_krealloc(
        dev: *mut device,
        ptr: *mut core::ffi::c_void,
        size: usize,
        gfp: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_kvasprintf(
        dev: *mut device,
        gfp: gfp_t,
        fmt: *const core::ffi::c_char,
        ap: *mut __va_list_tag,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn devm_kasprintf(
        dev: *mut device,
        gfp: gfp_t,
        fmt: *const core::ffi::c_char,
        ...
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn devm_kfree(dev: *mut device, p: *const core::ffi::c_void);
}
extern "C" {
    pub fn devm_kstrdup(
        dev: *mut device,
        s: *const core::ffi::c_char,
        gfp: gfp_t,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn devm_kstrdup_const(
        dev: *mut device,
        s: *const core::ffi::c_char,
        gfp: gfp_t,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn devm_kmemdup(
        dev: *mut device,
        src: *const core::ffi::c_void,
        len: usize,
        gfp: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_get_free_pages(
        dev: *mut device,
        gfp_mask: gfp_t,
        order: core::ffi::c_uint,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn devm_free_pages(dev: *mut device, addr: core::ffi::c_ulong);
}
extern "C" {
    pub fn devm_ioremap_resource(dev: *mut device, res: *const resource) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_ioremap_resource_wc(
        dev: *mut device,
        res: *const resource,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_of_iomap(
        dev: *mut device,
        node: *mut device_node,
        index: core::ffi::c_int,
        size: *mut resource_size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_remove_action(
        dev: *mut device,
        action: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
        data: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn devm_release_action(
        dev: *mut device,
        action: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
        data: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn __devm_add_action(
        dev: *mut device,
        action: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
        data: *mut core::ffi::c_void,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __devm_alloc_percpu(
        dev: *mut device,
        size: usize,
        align: usize,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_free_percpu(dev: *mut device, pdata: *mut core::ffi::c_void);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct device_dma_parameters {
    pub max_segment_size: core::ffi::c_uint,
    pub min_align_mask: core::ffi::c_uint,
    pub segment_boundary_mask: core::ffi::c_ulong,
}
pub const device_link_state_DL_STATE_NONE: device_link_state = -1;
pub const device_link_state_DL_STATE_DORMANT: device_link_state = 0;
pub const device_link_state_DL_STATE_AVAILABLE: device_link_state = 1;
pub const device_link_state_DL_STATE_CONSUMER_PROBE: device_link_state = 2;
pub const device_link_state_DL_STATE_ACTIVE: device_link_state = 3;
pub const device_link_state_DL_STATE_SUPPLIER_UNBIND: device_link_state = 4;
pub type device_link_state = core::ffi::c_int;
pub const dl_dev_state_DL_DEV_NO_DRIVER: dl_dev_state = 0;
pub const dl_dev_state_DL_DEV_PROBING: dl_dev_state = 1;
pub const dl_dev_state_DL_DEV_DRIVER_BOUND: dl_dev_state = 2;
pub const dl_dev_state_DL_DEV_UNBINDING: dl_dev_state = 3;
pub type dl_dev_state = core::ffi::c_uint;
pub const device_removable_DEVICE_REMOVABLE_NOT_SUPPORTED: device_removable = 0;
pub const device_removable_DEVICE_REMOVABLE_UNKNOWN: device_removable = 1;
pub const device_removable_DEVICE_FIXED: device_removable = 2;
pub const device_removable_DEVICE_REMOVABLE: device_removable = 3;
pub type device_removable = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_links_info {
    pub suppliers: list_head,
    pub consumers: list_head,
    pub defer_sync: list_head,
    pub status: dl_dev_state,
}
impl Default for dev_links_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_msi_info {
    pub domain: *mut irq_domain,
    pub data: *mut msi_device_data,
}
impl Default for dev_msi_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const device_physical_location_panel_DEVICE_PANEL_TOP: device_physical_location_panel = 0;
pub const device_physical_location_panel_DEVICE_PANEL_BOTTOM: device_physical_location_panel = 1;
pub const device_physical_location_panel_DEVICE_PANEL_LEFT: device_physical_location_panel = 2;
pub const device_physical_location_panel_DEVICE_PANEL_RIGHT: device_physical_location_panel = 3;
pub const device_physical_location_panel_DEVICE_PANEL_FRONT: device_physical_location_panel = 4;
pub const device_physical_location_panel_DEVICE_PANEL_BACK: device_physical_location_panel = 5;
pub const device_physical_location_panel_DEVICE_PANEL_UNKNOWN: device_physical_location_panel = 6;
pub type device_physical_location_panel = core::ffi::c_uint;
pub const device_physical_location_vertical_position_DEVICE_VERT_POS_UPPER:
    device_physical_location_vertical_position = 0;
pub const device_physical_location_vertical_position_DEVICE_VERT_POS_CENTER:
    device_physical_location_vertical_position = 1;
pub const device_physical_location_vertical_position_DEVICE_VERT_POS_LOWER:
    device_physical_location_vertical_position = 2;
pub type device_physical_location_vertical_position = core::ffi::c_uint;
pub const device_physical_location_horizontal_position_DEVICE_HORI_POS_LEFT:
    device_physical_location_horizontal_position = 0;
pub const device_physical_location_horizontal_position_DEVICE_HORI_POS_CENTER:
    device_physical_location_horizontal_position = 1;
pub const device_physical_location_horizontal_position_DEVICE_HORI_POS_RIGHT:
    device_physical_location_horizontal_position = 2;
pub type device_physical_location_horizontal_position = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_physical_location {
    pub panel: device_physical_location_panel,
    pub vertical_position: device_physical_location_vertical_position,
    pub horizontal_position: device_physical_location_horizontal_position,
    pub dock: bool_,
    pub lid: bool_,
}
impl Default for device_physical_location {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device {
    pub kobj: kobject,
    pub parent: *mut device,
    pub p: *mut device_private,
    pub init_name: *const core::ffi::c_char,
    pub type_: *const device_type,
    pub bus: *const bus_type,
    pub driver: *mut device_driver,
    pub platform_data: *mut core::ffi::c_void,
    pub driver_data: *mut core::ffi::c_void,
    pub mutex: mutex,
    pub links: dev_links_info,
    pub power: dev_pm_info,
    pub pm_domain: *mut dev_pm_domain,
    pub em_pd: *mut em_perf_domain,
    pub pins: *mut dev_pin_info,
    pub msi: dev_msi_info,
    pub dma_ops: *mut dma_map_ops,
    pub dma_mask: *mut u64_,
    pub coherent_dma_mask: u64_,
    pub bus_dma_limit: u64_,
    pub dma_range_map: *mut bus_dma_region,
    pub dma_parms: *mut device_dma_parameters,
    pub dma_pools: list_head,
    pub dma_io_tlb_mem: *mut io_tlb_mem,
    pub dma_io_tlb_pools: list_head,
    pub dma_io_tlb_lock: spinlock_t,
    pub dma_uses_io_tlb: bool_,
    pub archdata: dev_archdata,
    pub of_node: *mut device_node,
    pub fwnode: *mut fwnode_handle,
    pub numa_node: core::ffi::c_int,
    pub devt: dev_t,
    pub id: u32_,
    pub devres_lock: spinlock_t,
    pub devres_head: list_head,
    pub class: *const class,
    pub groups: *mut *const attribute_group,
    pub release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub iommu_group: *mut iommu_group,
    pub iommu: *mut dev_iommu,
    pub physical_location: *mut device_physical_location,
    pub removable: device_removable,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl device {
    #[inline]
    pub fn offline_disabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline_disabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offline(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn of_node_reused(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_of_node_reused(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_synced(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_state_synced(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_match(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_can_match(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        offline_disabled: bool_,
        offline: bool_,
        of_node_reused: bool_,
        state_synced: bool_,
        can_match: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let offline_disabled: u8 = unsafe { ::core::mem::transmute(offline_disabled) };
            offline_disabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let offline: u8 = unsafe { ::core::mem::transmute(offline) };
            offline as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let of_node_reused: u8 = unsafe { ::core::mem::transmute(of_node_reused) };
            of_node_reused as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_synced: u8 = unsafe { ::core::mem::transmute(state_synced) };
            state_synced as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let can_match: u8 = unsafe { ::core::mem::transmute(can_match) };
            can_match as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_link {
    pub supplier: *mut device,
    pub s_node: list_head,
    pub consumer: *mut device,
    pub c_node: list_head,
    pub link_dev: device,
    pub status: device_link_state,
    pub flags: u32_,
    pub rpm_active: refcount_t,
    pub kref: kref,
    pub rm_work: work_struct,
    pub supplier_preactivated: bool_,
}
impl Default for device_link {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wakeup_source {
    pub name: *const core::ffi::c_char,
    pub id: core::ffi::c_int,
    pub entry: list_head,
    pub lock: spinlock_t,
    pub wakeirq: *mut wake_irq,
    pub timer: timer_list,
    pub timer_expires: core::ffi::c_ulong,
    pub total_time: ktime_t,
    pub max_time: ktime_t,
    pub last_time: ktime_t,
    pub start_prevent_time: ktime_t,
    pub prevent_sleep_time: ktime_t,
    pub event_count: core::ffi::c_ulong,
    pub active_count: core::ffi::c_ulong,
    pub relax_count: core::ffi::c_ulong,
    pub expire_count: core::ffi::c_ulong,
    pub wakeup_count: core::ffi::c_ulong,
    pub dev: *mut device,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl Default for wakeup_source {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl wakeup_source {
    #[inline]
    pub fn active(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_active(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autosleep_enabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_autosleep_enabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active: bool_,
        autosleep_enabled: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let active: u8 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let autosleep_enabled: u8 = unsafe { ::core::mem::transmute(autosleep_enabled) };
            autosleep_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn wakeup_source_create(name: *const core::ffi::c_char) -> *mut wakeup_source;
}
extern "C" {
    pub fn wakeup_source_destroy(ws: *mut wakeup_source);
}
extern "C" {
    pub fn wakeup_source_add(ws: *mut wakeup_source);
}
extern "C" {
    pub fn wakeup_source_remove(ws: *mut wakeup_source);
}
extern "C" {
    pub fn wakeup_source_register(
        dev: *mut device,
        name: *const core::ffi::c_char,
    ) -> *mut wakeup_source;
}
extern "C" {
    pub fn wakeup_source_unregister(ws: *mut wakeup_source);
}
extern "C" {
    pub fn wakeup_sources_read_lock() -> core::ffi::c_int;
}
extern "C" {
    pub fn wakeup_sources_read_unlock(idx: core::ffi::c_int);
}
extern "C" {
    pub fn wakeup_sources_walk_start() -> *mut wakeup_source;
}
extern "C" {
    pub fn wakeup_sources_walk_next(ws: *mut wakeup_source) -> *mut wakeup_source;
}
extern "C" {
    pub fn device_wakeup_enable(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_wakeup_disable(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_set_wakeup_capable(dev: *mut device, capable: bool_);
}
extern "C" {
    pub fn device_set_wakeup_enable(dev: *mut device, enable: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn __pm_stay_awake(ws: *mut wakeup_source);
}
extern "C" {
    pub fn pm_stay_awake(dev: *mut device);
}
extern "C" {
    pub fn __pm_relax(ws: *mut wakeup_source);
}
extern "C" {
    pub fn pm_relax(dev: *mut device);
}
extern "C" {
    pub fn pm_wakeup_ws_event(ws: *mut wakeup_source, msec: core::ffi::c_uint, hard: bool_);
}
extern "C" {
    pub fn pm_wakeup_dev_event(dev: *mut device, msec: core::ffi::c_uint, hard: bool_);
}
extern "C" {
    pub fn dev_set_name(dev: *mut device, name: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
pub type class_device_t = *mut device;
extern "C" {
    pub fn device_register(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_unregister(dev: *mut device);
}
extern "C" {
    pub fn device_initialize(dev: *mut device);
}
extern "C" {
    pub fn device_add(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_del(dev: *mut device);
}
extern "C" {
    pub fn device_for_each_child(
        dev: *mut device,
        data: *mut core::ffi::c_void,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut device,
                data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_for_each_child_reverse(
        dev: *mut device,
        data: *mut core::ffi::c_void,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut device,
                data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_find_child(
        dev: *mut device,
        data: *mut core::ffi::c_void,
        match_: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut device,
                data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> *mut device;
}
extern "C" {
    pub fn device_find_child_by_name(
        parent: *mut device,
        name: *const core::ffi::c_char,
    ) -> *mut device;
}
extern "C" {
    pub fn device_find_any_child(parent: *mut device) -> *mut device;
}
extern "C" {
    pub fn device_rename(dev: *mut device, new_name: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_move(
        dev: *mut device,
        new_parent: *mut device,
        dpm_order: dpm_order,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_change_owner(dev: *mut device, kuid: kuid_t, kgid: kgid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn lock_device_hotplug();
}
extern "C" {
    pub fn unlock_device_hotplug();
}
extern "C" {
    pub fn lock_device_hotplug_sysfs() -> core::ffi::c_int;
}
extern "C" {
    pub fn device_offline(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_online(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_primary_fwnode(dev: *mut device, fwnode: *mut fwnode_handle);
}
extern "C" {
    pub fn set_secondary_fwnode(dev: *mut device, fwnode: *mut fwnode_handle);
}
extern "C" {
    pub fn device_set_of_node_from_dev(dev: *mut device, dev2: *const device);
}
extern "C" {
    pub fn device_set_node(dev: *mut device, fwnode: *mut fwnode_handle);
}
extern "C" {
    pub fn __root_device_register(
        name: *const core::ffi::c_char,
        owner: *mut module,
    ) -> *mut device;
}
extern "C" {
    pub fn root_device_unregister(root: *mut device);
}
extern "C" {
    pub fn device_driver_attach(drv: *mut device_driver, dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_bind_driver(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_release_driver(dev: *mut device);
}
extern "C" {
    pub fn device_attach(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn driver_attach(drv: *mut device_driver) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_initial_probe(dev: *mut device);
}
extern "C" {
    pub fn device_reprobe(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_is_bound(dev: *mut device) -> bool_;
}
extern "C" {
    pub fn device_create(
        cls: *const class,
        parent: *mut device,
        devt: dev_t,
        drvdata: *mut core::ffi::c_void,
        fmt: *const core::ffi::c_char,
        ...
    ) -> *mut device;
}
extern "C" {
    pub fn device_create_with_groups(
        cls: *const class,
        parent: *mut device,
        devt: dev_t,
        drvdata: *mut core::ffi::c_void,
        groups: *mut *const attribute_group,
        fmt: *const core::ffi::c_char,
        ...
    ) -> *mut device;
}
extern "C" {
    pub fn device_destroy(cls: *const class, devt: dev_t);
}
extern "C" {
    pub fn device_add_groups(
        dev: *mut device,
        groups: *mut *const attribute_group,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_remove_groups(dev: *mut device, groups: *mut *const attribute_group);
}
extern "C" {
    pub fn devm_device_add_groups(
        dev: *mut device,
        groups: *mut *const attribute_group,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_device_add_group(dev: *mut device, grp: *const attribute_group)
        -> core::ffi::c_int;
}
extern "C" {
    pub static mut platform_notify:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>;
}
extern "C" {
    pub static mut platform_notify_remove:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>;
}
extern "C" {
    pub fn get_device(dev: *mut device) -> *mut device;
}
extern "C" {
    pub fn put_device(dev: *mut device);
}
extern "C" {
    pub fn kill_device(dev: *mut device) -> bool_;
}
extern "C" {
    pub fn devtmpfs_mount() -> core::ffi::c_int;
}
extern "C" {
    pub fn device_shutdown();
}
extern "C" {
    pub fn dev_driver_string(dev: *const device) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn device_link_add(
        consumer: *mut device,
        supplier: *mut device,
        flags: u32_,
    ) -> *mut device_link;
}
extern "C" {
    pub fn device_link_del(link: *mut device_link);
}
extern "C" {
    pub fn device_link_remove(consumer: *mut core::ffi::c_void, supplier: *mut device);
}
extern "C" {
    pub fn device_links_supplier_sync_state_pause();
}
extern "C" {
    pub fn device_links_supplier_sync_state_resume();
}
extern "C" {
    pub fn device_link_wait_removal();
}
extern "C" {
    pub fn early_ioremap(
        phys_addr: resource_size_t,
        size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn early_memremap(
        phys_addr: resource_size_t,
        size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn early_memremap_ro(
        phys_addr: resource_size_t,
        size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn early_memremap_prot(
        phys_addr: resource_size_t,
        size: core::ffi::c_ulong,
        prot_val: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn early_iounmap(addr: *mut core::ffi::c_void, size: core::ffi::c_ulong);
}
extern "C" {
    pub fn early_memunmap(addr: *mut core::ffi::c_void, size: core::ffi::c_ulong);
}
extern "C" {
    pub fn early_ioremap_init();
}
extern "C" {
    pub fn early_ioremap_setup();
}
extern "C" {
    pub fn early_ioremap_reset();
}
extern "C" {
    pub fn copy_from_early_mem(
        dest: *mut core::ffi::c_void,
        src: phys_addr_t,
        size: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn valid_phys_addr_range(addr: phys_addr_t, size: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn valid_mmap_phys_addr_range(pfn: core::ffi::c_ulong, size: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn ioremap_uc(offset: resource_size_t, size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn ioremap_cache(
        offset: resource_size_t,
        size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn ioremap_prot(
        offset: resource_size_t,
        size: core::ffi::c_ulong,
        prot_val: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn ioremap_encrypted(
        phys_addr: resource_size_t,
        size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn ioremap(offset: resource_size_t, size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn iounmap(addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn memcpy_fromio(arg1: *mut core::ffi::c_void, arg2: *const core::ffi::c_void, arg3: usize);
}
extern "C" {
    pub fn memcpy_toio(arg1: *mut core::ffi::c_void, arg2: *const core::ffi::c_void, arg3: usize);
}
extern "C" {
    pub fn memset_io(arg1: *mut core::ffi::c_void, arg2: core::ffi::c_int, arg3: usize);
}
extern "C" {
    pub fn native_io_delay();
}
extern "C" {
    pub static mut io_delay_type: core::ffi::c_int;
}
extern "C" {
    pub fn io_delay_init();
}
extern "C" {
    pub fn xlate_dev_mem_ptr(phys: phys_addr_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn unxlate_dev_mem_ptr(phys: phys_addr_t, addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn ioremap_change_attr(
        vaddr: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        pcm: page_cache_mode,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ioremap_wc(offset: resource_size_t, size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn ioremap_wt(offset: resource_size_t, size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn is_early_ioremap_ptep(ptep: *mut pte_t) -> bool_;
}
extern "C" {
    pub fn ioread8(arg1: *const core::ffi::c_void) -> core::ffi::c_uint;
}
extern "C" {
    pub fn ioread16(arg1: *const core::ffi::c_void) -> core::ffi::c_uint;
}
extern "C" {
    pub fn ioread16be(arg1: *const core::ffi::c_void) -> core::ffi::c_uint;
}
extern "C" {
    pub fn ioread32(arg1: *const core::ffi::c_void) -> core::ffi::c_uint;
}
extern "C" {
    pub fn ioread32be(arg1: *const core::ffi::c_void) -> core::ffi::c_uint;
}
extern "C" {
    pub fn ioread64(arg1: *const core::ffi::c_void) -> u64_;
}
extern "C" {
    pub fn ioread64be(arg1: *const core::ffi::c_void) -> u64_;
}
extern "C" {
    pub fn ioread64_lo_hi(addr: *const core::ffi::c_void) -> u64_;
}
extern "C" {
    pub fn ioread64_hi_lo(addr: *const core::ffi::c_void) -> u64_;
}
extern "C" {
    pub fn ioread64be_lo_hi(addr: *const core::ffi::c_void) -> u64_;
}
extern "C" {
    pub fn ioread64be_hi_lo(addr: *const core::ffi::c_void) -> u64_;
}
extern "C" {
    pub fn iowrite8(arg1: u8_, arg2: *mut core::ffi::c_void);
}
extern "C" {
    pub fn iowrite16(arg1: u16_, arg2: *mut core::ffi::c_void);
}
extern "C" {
    pub fn iowrite16be(arg1: u16_, arg2: *mut core::ffi::c_void);
}
extern "C" {
    pub fn iowrite32(arg1: u32_, arg2: *mut core::ffi::c_void);
}
extern "C" {
    pub fn iowrite32be(arg1: u32_, arg2: *mut core::ffi::c_void);
}
extern "C" {
    pub fn iowrite64(arg1: u64_, arg2: *mut core::ffi::c_void);
}
extern "C" {
    pub fn iowrite64be(arg1: u64_, arg2: *mut core::ffi::c_void);
}
extern "C" {
    pub fn iowrite64_lo_hi(val: u64_, addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn iowrite64_hi_lo(val: u64_, addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn iowrite64be_lo_hi(val: u64_, addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn iowrite64be_hi_lo(val: u64_, addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn ioread8_rep(
        port: *const core::ffi::c_void,
        buf: *mut core::ffi::c_void,
        count: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn ioread16_rep(
        port: *const core::ffi::c_void,
        buf: *mut core::ffi::c_void,
        count: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn ioread32_rep(
        port: *const core::ffi::c_void,
        buf: *mut core::ffi::c_void,
        count: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn iowrite8_rep(
        port: *mut core::ffi::c_void,
        buf: *const core::ffi::c_void,
        count: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn iowrite16_rep(
        port: *mut core::ffi::c_void,
        buf: *const core::ffi::c_void,
        count: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn iowrite32_rep(
        port: *mut core::ffi::c_void,
        buf: *const core::ffi::c_void,
        count: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn ioport_map(port: core::ffi::c_ulong, nr: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn ioport_unmap(arg1: *mut core::ffi::c_void);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_dev {
    _unused: [u8; 0],
}
extern "C" {
    pub fn pci_iomap(
        dev: *mut pci_dev,
        bar: core::ffi::c_int,
        max: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn pci_iomap_wc(
        dev: *mut pci_dev,
        bar: core::ffi::c_int,
        max: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn pci_iomap_range(
        dev: *mut pci_dev,
        bar: core::ffi::c_int,
        offset: core::ffi::c_ulong,
        maxlen: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn pci_iomap_wc_range(
        dev: *mut pci_dev,
        bar: core::ffi::c_int,
        offset: core::ffi::c_ulong,
        maxlen: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn pci_iounmap(dev: *mut pci_dev, arg1: *mut core::ffi::c_void);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_handle {
    pub secondary: *mut fwnode_handle,
    pub ops: *const fwnode_operations,
    pub dev: *mut device,
    pub suppliers: list_head,
    pub consumers: list_head,
    pub flags: u8_,
}
impl Default for fwnode_handle {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_link {
    pub supplier: *mut fwnode_handle,
    pub s_hook: list_head,
    pub consumer: *mut fwnode_handle,
    pub c_hook: list_head,
    pub flags: u8_,
}
impl Default for fwnode_link {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_endpoint {
    pub port: core::ffi::c_uint,
    pub id: core::ffi::c_uint,
    pub local_fwnode: *const fwnode_handle,
}
impl Default for fwnode_endpoint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_reference_args {
    pub fwnode: *mut fwnode_handle,
    pub nargs: core::ffi::c_uint,
    pub args: [u64_; 8usize],
}
impl Default for fwnode_reference_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fwnode_operations {
    pub get: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub put: ::core::option::Option<unsafe extern "C" fn(fwnode: *mut fwnode_handle)>,
    pub device_is_available:
        ::core::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> bool_>,
    pub device_get_match_data: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            dev: *const device,
        ) -> *const core::ffi::c_void,
    >,
    pub device_dma_supported:
        ::core::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> bool_>,
    pub device_get_dma_attr:
        ::core::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> dev_dma_attr>,
    pub property_present: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            propname: *const core::ffi::c_char,
        ) -> bool_,
    >,
    pub property_read_int_array: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            propname: *const core::ffi::c_char,
            elem_size: core::ffi::c_uint,
            val: *mut core::ffi::c_void,
            nval: usize,
        ) -> core::ffi::c_int,
    >,
    pub property_read_string_array: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode_handle: *const fwnode_handle,
            propname: *const core::ffi::c_char,
            val: *mut *const core::ffi::c_char,
            nval: usize,
        ) -> core::ffi::c_int,
    >,
    pub get_name: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *const core::ffi::c_char,
    >,
    pub get_name_prefix: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *const core::ffi::c_char,
    >,
    pub get_parent: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub get_next_child_node: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            child: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub get_named_child_node: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            name: *const core::ffi::c_char,
        ) -> *mut fwnode_handle,
    >,
    pub get_reference_args: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            prop: *const core::ffi::c_char,
            nargs_prop: *const core::ffi::c_char,
            nargs: core::ffi::c_uint,
            index: core::ffi::c_uint,
            args: *mut fwnode_reference_args,
        ) -> core::ffi::c_int,
    >,
    pub graph_get_next_endpoint: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            prev: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub graph_get_remote_endpoint: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_get_port_parent: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_parse_endpoint: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            endpoint: *mut fwnode_endpoint,
        ) -> core::ffi::c_int,
    >,
    pub iomap: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *mut fwnode_handle,
            index: core::ffi::c_int,
        ) -> *mut core::ffi::c_void,
    >,
    pub irq_get: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            index: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub add_links: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> core::ffi::c_int,
    >,
}
extern "C" {
    pub fn fw_devlink_is_strict() -> bool_;
}
extern "C" {
    pub fn fwnode_link_add(con: *mut fwnode_handle, sup: *mut fwnode_handle) -> core::ffi::c_int;
}
extern "C" {
    pub fn fwnode_links_purge(fwnode: *mut fwnode_handle);
}
extern "C" {
    pub fn fw_devlink_purge_absent_suppliers(fwnode: *mut fwnode_handle);
}
pub const LOGIC_PIO_INDIRECT: _bindgen_ty_103 = 0;
pub const LOGIC_PIO_CPU_MMIO: _bindgen_ty_103 = 1;
pub type _bindgen_ty_103 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct logic_pio_hwaddr {
    pub list: list_head,
    pub fwnode: *mut fwnode_handle,
    pub hw_start: resource_size_t,
    pub io_start: resource_size_t,
    pub size: resource_size_t,
    pub flags: core::ffi::c_ulong,
    pub hostdata: *mut core::ffi::c_void,
    pub ops: *const logic_pio_host_ops,
}
impl Default for logic_pio_hwaddr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct logic_pio_host_ops {
    pub in_: ::core::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut core::ffi::c_void,
            addr: core::ffi::c_ulong,
            dwidth: usize,
        ) -> u32_,
    >,
    pub out: ::core::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut core::ffi::c_void,
            addr: core::ffi::c_ulong,
            val: u32_,
            dwidth: usize,
        ),
    >,
    pub ins: ::core::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut core::ffi::c_void,
            addr: core::ffi::c_ulong,
            buffer: *mut core::ffi::c_void,
            dwidth: usize,
            count: core::ffi::c_uint,
        ) -> u32_,
    >,
    pub outs: ::core::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut core::ffi::c_void,
            addr: core::ffi::c_ulong,
            buffer: *const core::ffi::c_void,
            dwidth: usize,
            count: core::ffi::c_uint,
        ),
    >,
}
extern "C" {
    pub fn find_io_range_by_fwnode(fwnode: *mut fwnode_handle) -> *mut logic_pio_hwaddr;
}
extern "C" {
    pub fn logic_pio_trans_hwaddr(
        fwnode: *mut fwnode_handle,
        hw_addr: resource_size_t,
        size: resource_size_t,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn logic_pio_register_range(newrange: *mut logic_pio_hwaddr) -> core::ffi::c_int;
}
extern "C" {
    pub fn logic_pio_unregister_range(range: *mut logic_pio_hwaddr);
}
extern "C" {
    pub fn logic_pio_to_hwaddr(pio: core::ffi::c_ulong) -> resource_size_t;
}
extern "C" {
    pub fn logic_pio_trans_cpuaddr(hw_addr: resource_size_t) -> core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_struct {
    pub next: *mut vm_struct,
    pub addr: *mut core::ffi::c_void,
    pub size: core::ffi::c_ulong,
    pub flags: core::ffi::c_ulong,
    pub pages: *mut *mut page,
    pub page_order: core::ffi::c_uint,
    pub nr_pages: core::ffi::c_uint,
    pub phys_addr: phys_addr_t,
    pub caller: *const core::ffi::c_void,
}
impl Default for vm_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vmap_area {
    pub va_start: core::ffi::c_ulong,
    pub va_end: core::ffi::c_ulong,
    pub rb_node: rb_node,
    pub list: list_head,
    pub __bindgen_anon_1: vmap_area__bindgen_ty_1,
    pub flags: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vmap_area__bindgen_ty_1 {
    pub subtree_max_size: core::ffi::c_ulong,
    pub vm: *mut vm_struct,
}
impl Default for vmap_area__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vmap_area {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn vm_unmap_ram(mem: *const core::ffi::c_void, count: core::ffi::c_uint);
}
extern "C" {
    pub fn vm_map_ram(
        pages: *mut *mut page,
        count: core::ffi::c_uint,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vm_unmap_aliases();
}
extern "C" {
    pub fn vmalloc_nr_pages() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn vmalloc(size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vzalloc(size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmalloc_user(size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmalloc_node(size: core::ffi::c_ulong, node: core::ffi::c_int)
        -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vzalloc_node(size: core::ffi::c_ulong, node: core::ffi::c_int)
        -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmalloc_32(size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmalloc_32_user(size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __vmalloc(size: core::ffi::c_ulong, gfp_mask: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __vmalloc_node_range(
        size: core::ffi::c_ulong,
        align: core::ffi::c_ulong,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        gfp_mask: gfp_t,
        prot: pgprot_t,
        vm_flags: core::ffi::c_ulong,
        node: core::ffi::c_int,
        caller: *const core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __vmalloc_node(
        size: core::ffi::c_ulong,
        align: core::ffi::c_ulong,
        gfp_mask: gfp_t,
        node: core::ffi::c_int,
        caller: *const core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmalloc_huge(size: core::ffi::c_ulong, gfp_mask: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __vmalloc_array(n: usize, size: usize, flags: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmalloc_array(n: usize, size: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __vcalloc(n: usize, size: usize, flags: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vcalloc(n: usize, size: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vfree(addr: *const core::ffi::c_void);
}
extern "C" {
    pub fn vfree_atomic(addr: *const core::ffi::c_void);
}
extern "C" {
    pub fn vmap(
        pages: *mut *mut page,
        count: core::ffi::c_uint,
        flags: core::ffi::c_ulong,
        prot: pgprot_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmap_pfn(
        pfns: *mut core::ffi::c_ulong,
        count: core::ffi::c_uint,
        prot: pgprot_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vunmap(addr: *const core::ffi::c_void);
}
extern "C" {
    pub fn remap_vmalloc_range_partial(
        vma: *mut vm_area_struct,
        uaddr: core::ffi::c_ulong,
        kaddr: *mut core::ffi::c_void,
        pgoff: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn remap_vmalloc_range(
        vma: *mut vm_area_struct,
        addr: *mut core::ffi::c_void,
        pgoff: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_sync_kernel_mappings(start: core::ffi::c_ulong, end: core::ffi::c_ulong);
}
extern "C" {
    pub fn get_vm_area(size: core::ffi::c_ulong, flags: core::ffi::c_ulong) -> *mut vm_struct;
}
extern "C" {
    pub fn get_vm_area_caller(
        size: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
        caller: *const core::ffi::c_void,
    ) -> *mut vm_struct;
}
extern "C" {
    pub fn __get_vm_area_caller(
        size: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        caller: *const core::ffi::c_void,
    ) -> *mut vm_struct;
}
extern "C" {
    pub fn free_vm_area(area: *mut vm_struct);
}
extern "C" {
    pub fn remove_vm_area(addr: *const core::ffi::c_void) -> *mut vm_struct;
}
extern "C" {
    pub fn find_vm_area(addr: *const core::ffi::c_void) -> *mut vm_struct;
}
extern "C" {
    pub fn find_vmap_area(addr: core::ffi::c_ulong) -> *mut vmap_area;
}
extern "C" {
    pub fn vunmap_range(addr: core::ffi::c_ulong, end: core::ffi::c_ulong);
}
extern "C" {
    pub fn vread_iter(
        iter: *mut iov_iter,
        addr: *const core::ffi::c_char,
        count: usize,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub static mut vmap_area_list: list_head;
}
extern "C" {
    pub fn vm_area_add_early(vm: *mut vm_struct);
}
extern "C" {
    pub fn vm_area_register_early(vm: *mut vm_struct, align: usize);
}
extern "C" {
    pub fn pcpu_get_vm_areas(
        offsets: *const core::ffi::c_ulong,
        sizes: *const usize,
        nr_vms: core::ffi::c_int,
        align: usize,
    ) -> *mut *mut vm_struct;
}
extern "C" {
    pub fn pcpu_free_vm_areas(vms: *mut *mut vm_struct, nr_vms: core::ffi::c_int);
}
extern "C" {
    pub fn register_vmap_purge_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_vmap_purge_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn vmalloc_dump_obj(object: *mut core::ffi::c_void) -> bool_;
}
extern "C" {
    pub fn arch_phys_wc_index(handle: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_phys_wc_add(base: core::ffi::c_ulong, size: core::ffi::c_ulong)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_phys_wc_del(handle: core::ffi::c_int);
}
extern "C" {
    pub fn arch_io_reserve_memtype_wc(
        start: resource_size_t,
        size: resource_size_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_io_free_memtype_wc(start: resource_size_t, size: resource_size_t);
}
extern "C" {
    pub fn arch_memremap_can_ram_remap(
        offset: resource_size_t,
        size: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn phys_mem_access_encrypted(
        phys_addr: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> bool_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct scatterlist {
    pub page_link: core::ffi::c_ulong,
    pub offset: core::ffi::c_uint,
    pub length: core::ffi::c_uint,
    pub dma_address: dma_addr_t,
    pub dma_length: core::ffi::c_uint,
    pub dma_flags: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_table {
    pub sgl: *mut scatterlist,
    pub nents: core::ffi::c_uint,
    pub orig_nents: core::ffi::c_uint,
}
impl Default for sg_table {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_append_table {
    pub sgt: sg_table,
    pub prv: *mut scatterlist,
    pub total_nents: core::ffi::c_uint,
}
impl Default for sg_append_table {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn sg_nents(sg: *mut scatterlist) -> core::ffi::c_int;
}
extern "C" {
    pub fn sg_nents_for_len(sg: *mut scatterlist, len: u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn sg_next(arg1: *mut scatterlist) -> *mut scatterlist;
}
extern "C" {
    pub fn sg_last(s: *mut scatterlist, arg1: core::ffi::c_uint) -> *mut scatterlist;
}
extern "C" {
    pub fn sg_init_table(arg1: *mut scatterlist, arg2: core::ffi::c_uint);
}
extern "C" {
    pub fn sg_init_one(
        arg1: *mut scatterlist,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn sg_split(
        in_: *mut scatterlist,
        in_mapped_nents: core::ffi::c_int,
        skip: off_t,
        nb_splits: core::ffi::c_int,
        split_sizes: *const usize,
        out: *mut *mut scatterlist,
        out_mapped_nents: *mut core::ffi::c_int,
        gfp_mask: gfp_t,
    ) -> core::ffi::c_int;
}
pub type sg_alloc_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: core::ffi::c_uint, arg2: gfp_t) -> *mut scatterlist,
>;
pub type sg_free_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut scatterlist, arg2: core::ffi::c_uint)>;
extern "C" {
    pub fn __sg_free_table(
        arg1: *mut sg_table,
        arg2: core::ffi::c_uint,
        arg3: core::ffi::c_uint,
        arg4: sg_free_fn,
        arg5: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn sg_free_table(arg1: *mut sg_table);
}
extern "C" {
    pub fn sg_free_append_table(sgt: *mut sg_append_table);
}
extern "C" {
    pub fn __sg_alloc_table(
        arg1: *mut sg_table,
        arg2: core::ffi::c_uint,
        arg3: core::ffi::c_uint,
        arg4: *mut scatterlist,
        arg5: core::ffi::c_uint,
        arg6: gfp_t,
        arg7: sg_alloc_fn,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sg_alloc_table(
        arg1: *mut sg_table,
        arg2: core::ffi::c_uint,
        arg3: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sg_alloc_append_table_from_pages(
        sgt: *mut sg_append_table,
        pages: *mut *mut page,
        n_pages: core::ffi::c_uint,
        offset: core::ffi::c_uint,
        size: core::ffi::c_ulong,
        max_segment: core::ffi::c_uint,
        left_pages: core::ffi::c_uint,
        gfp_mask: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sg_alloc_table_from_pages_segment(
        sgt: *mut sg_table,
        pages: *mut *mut page,
        n_pages: core::ffi::c_uint,
        offset: core::ffi::c_uint,
        size: core::ffi::c_ulong,
        max_segment: core::ffi::c_uint,
        gfp_mask: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sgl_alloc_order(
        length: core::ffi::c_ulonglong,
        order: core::ffi::c_uint,
        chainable: bool_,
        gfp: gfp_t,
        nent_p: *mut core::ffi::c_uint,
    ) -> *mut scatterlist;
}
extern "C" {
    pub fn sgl_alloc(
        length: core::ffi::c_ulonglong,
        gfp: gfp_t,
        nent_p: *mut core::ffi::c_uint,
    ) -> *mut scatterlist;
}
extern "C" {
    pub fn sgl_free_n_order(
        sgl: *mut scatterlist,
        nents: core::ffi::c_int,
        order: core::ffi::c_int,
    );
}
extern "C" {
    pub fn sgl_free_order(sgl: *mut scatterlist, order: core::ffi::c_int);
}
extern "C" {
    pub fn sgl_free(sgl: *mut scatterlist);
}
extern "C" {
    pub fn sg_copy_buffer(
        sgl: *mut scatterlist,
        nents: core::ffi::c_uint,
        buf: *mut core::ffi::c_void,
        buflen: usize,
        skip: off_t,
        to_buffer: bool_,
    ) -> usize;
}
extern "C" {
    pub fn sg_copy_from_buffer(
        sgl: *mut scatterlist,
        nents: core::ffi::c_uint,
        buf: *const core::ffi::c_void,
        buflen: usize,
    ) -> usize;
}
extern "C" {
    pub fn sg_copy_to_buffer(
        sgl: *mut scatterlist,
        nents: core::ffi::c_uint,
        buf: *mut core::ffi::c_void,
        buflen: usize,
    ) -> usize;
}
extern "C" {
    pub fn sg_pcopy_from_buffer(
        sgl: *mut scatterlist,
        nents: core::ffi::c_uint,
        buf: *const core::ffi::c_void,
        buflen: usize,
        skip: off_t,
    ) -> usize;
}
extern "C" {
    pub fn sg_pcopy_to_buffer(
        sgl: *mut scatterlist,
        nents: core::ffi::c_uint,
        buf: *mut core::ffi::c_void,
        buflen: usize,
        skip: off_t,
    ) -> usize;
}
extern "C" {
    pub fn sg_zero_buffer(
        sgl: *mut scatterlist,
        nents: core::ffi::c_uint,
        buflen: usize,
        skip: off_t,
    ) -> usize;
}
extern "C" {
    pub fn sg_free_table_chained(table: *mut sg_table, nents_first_chunk: core::ffi::c_uint);
}
extern "C" {
    pub fn sg_alloc_table_chained(
        table: *mut sg_table,
        nents: core::ffi::c_int,
        first_chunk: *mut scatterlist,
        nents_first_chunk: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_page_iter {
    pub sg: *mut scatterlist,
    pub sg_pgoffset: core::ffi::c_uint,
    pub __nents: core::ffi::c_uint,
    pub __pg_advance: core::ffi::c_int,
}
impl Default for sg_page_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_dma_page_iter {
    pub base: sg_page_iter,
}
impl Default for sg_dma_page_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __sg_page_iter_next(piter: *mut sg_page_iter) -> bool_;
}
extern "C" {
    pub fn __sg_page_iter_dma_next(dma_iter: *mut sg_dma_page_iter) -> bool_;
}
extern "C" {
    pub fn __sg_page_iter_start(
        piter: *mut sg_page_iter,
        sglist: *mut scatterlist,
        nents: core::ffi::c_uint,
        pgoffset: core::ffi::c_ulong,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_mapping_iter {
    pub page: *mut page,
    pub addr: *mut core::ffi::c_void,
    pub length: usize,
    pub consumed: usize,
    pub piter: sg_page_iter,
    pub __offset: core::ffi::c_uint,
    pub __remaining: core::ffi::c_uint,
    pub __flags: core::ffi::c_uint,
}
impl Default for sg_mapping_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn sg_miter_start(
        miter: *mut sg_mapping_iter,
        sgl: *mut scatterlist,
        nents: core::ffi::c_uint,
        flags: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn sg_miter_skip(miter: *mut sg_mapping_iter, offset: off_t) -> bool_;
}
extern "C" {
    pub fn sg_miter_next(miter: *mut sg_mapping_iter) -> bool_;
}
extern "C" {
    pub fn sg_miter_stop(miter: *mut sg_mapping_iter);
}
extern "C" {
    pub fn dma_map_page_attrs(
        dev: *mut device,
        page: *mut page,
        offset: usize,
        size: usize,
        dir: dma_data_direction,
        attrs: core::ffi::c_ulong,
    ) -> dma_addr_t;
}
extern "C" {
    pub fn dma_unmap_page_attrs(
        dev: *mut device,
        addr: dma_addr_t,
        size: usize,
        dir: dma_data_direction,
        attrs: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn dma_map_sg_attrs(
        dev: *mut device,
        sg: *mut scatterlist,
        nents: core::ffi::c_int,
        dir: dma_data_direction,
        attrs: core::ffi::c_ulong,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn dma_unmap_sg_attrs(
        dev: *mut device,
        sg: *mut scatterlist,
        nents: core::ffi::c_int,
        dir: dma_data_direction,
        attrs: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn dma_map_sgtable(
        dev: *mut device,
        sgt: *mut sg_table,
        dir: dma_data_direction,
        attrs: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dma_map_resource(
        dev: *mut device,
        phys_addr: phys_addr_t,
        size: usize,
        dir: dma_data_direction,
        attrs: core::ffi::c_ulong,
    ) -> dma_addr_t;
}
extern "C" {
    pub fn dma_unmap_resource(
        dev: *mut device,
        addr: dma_addr_t,
        size: usize,
        dir: dma_data_direction,
        attrs: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn dma_sync_single_for_cpu(
        dev: *mut device,
        addr: dma_addr_t,
        size: usize,
        dir: dma_data_direction,
    );
}
extern "C" {
    pub fn dma_sync_single_for_device(
        dev: *mut device,
        addr: dma_addr_t,
        size: usize,
        dir: dma_data_direction,
    );
}
extern "C" {
    pub fn dma_sync_sg_for_cpu(
        dev: *mut device,
        sg: *mut scatterlist,
        nelems: core::ffi::c_int,
        dir: dma_data_direction,
    );
}
extern "C" {
    pub fn dma_sync_sg_for_device(
        dev: *mut device,
        sg: *mut scatterlist,
        nelems: core::ffi::c_int,
        dir: dma_data_direction,
    );
}
extern "C" {
    pub fn dma_alloc_attrs(
        dev: *mut device,
        size: usize,
        dma_handle: *mut dma_addr_t,
        flag: gfp_t,
        attrs: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn dma_free_attrs(
        dev: *mut device,
        size: usize,
        cpu_addr: *mut core::ffi::c_void,
        dma_handle: dma_addr_t,
        attrs: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn dmam_alloc_attrs(
        dev: *mut device,
        size: usize,
        dma_handle: *mut dma_addr_t,
        gfp: gfp_t,
        attrs: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn dmam_free_coherent(
        dev: *mut device,
        size: usize,
        vaddr: *mut core::ffi::c_void,
        dma_handle: dma_addr_t,
    );
}
extern "C" {
    pub fn dma_get_sgtable_attrs(
        dev: *mut device,
        sgt: *mut sg_table,
        cpu_addr: *mut core::ffi::c_void,
        dma_addr: dma_addr_t,
        size: usize,
        attrs: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dma_mmap_attrs(
        dev: *mut device,
        vma: *mut vm_area_struct,
        cpu_addr: *mut core::ffi::c_void,
        dma_addr: dma_addr_t,
        size: usize,
        attrs: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dma_can_mmap(dev: *mut device) -> bool_;
}
extern "C" {
    pub fn dma_pci_p2pdma_supported(dev: *mut device) -> bool_;
}
extern "C" {
    pub fn dma_set_mask(dev: *mut device, mask: u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn dma_set_coherent_mask(dev: *mut device, mask: u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn dma_get_required_mask(dev: *mut device) -> u64_;
}
extern "C" {
    pub fn dma_addressing_limited(dev: *mut device) -> bool_;
}
extern "C" {
    pub fn dma_max_mapping_size(dev: *mut device) -> usize;
}
extern "C" {
    pub fn dma_opt_mapping_size(dev: *mut device) -> usize;
}
extern "C" {
    pub fn dma_need_sync(dev: *mut device, dma_addr: dma_addr_t) -> bool_;
}
extern "C" {
    pub fn dma_get_merge_boundary(dev: *mut device) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn dma_alloc_noncontiguous(
        dev: *mut device,
        size: usize,
        dir: dma_data_direction,
        gfp: gfp_t,
        attrs: core::ffi::c_ulong,
    ) -> *mut sg_table;
}
extern "C" {
    pub fn dma_free_noncontiguous(
        dev: *mut device,
        size: usize,
        sgt: *mut sg_table,
        dir: dma_data_direction,
    );
}
extern "C" {
    pub fn dma_vmap_noncontiguous(
        dev: *mut device,
        size: usize,
        sgt: *mut sg_table,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn dma_vunmap_noncontiguous(dev: *mut device, vaddr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn dma_mmap_noncontiguous(
        dev: *mut device,
        vma: *mut vm_area_struct,
        size: usize,
        sgt: *mut sg_table,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dma_alloc_pages(
        dev: *mut device,
        size: usize,
        dma_handle: *mut dma_addr_t,
        dir: dma_data_direction,
        gfp: gfp_t,
    ) -> *mut page;
}
extern "C" {
    pub fn dma_free_pages(
        dev: *mut device,
        size: usize,
        page: *mut page,
        dma_handle: dma_addr_t,
        dir: dma_data_direction,
    );
}
extern "C" {
    pub fn dma_mmap_pages(
        dev: *mut device,
        vma: *mut vm_area_struct,
        size: usize,
        page: *mut page,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dma_coherent_ok(dev: *mut device, phys: phys_addr_t, size: usize) -> bool_;
}
pub type netdev_features_t = u64_;
pub const NETIF_F_SG_BIT: _bindgen_ty_104 = 0;
pub const NETIF_F_IP_CSUM_BIT: _bindgen_ty_104 = 1;
pub const __UNUSED_NETIF_F_1: _bindgen_ty_104 = 2;
pub const NETIF_F_HW_CSUM_BIT: _bindgen_ty_104 = 3;
pub const NETIF_F_IPV6_CSUM_BIT: _bindgen_ty_104 = 4;
pub const NETIF_F_HIGHDMA_BIT: _bindgen_ty_104 = 5;
pub const NETIF_F_FRAGLIST_BIT: _bindgen_ty_104 = 6;
pub const NETIF_F_HW_VLAN_CTAG_TX_BIT: _bindgen_ty_104 = 7;
pub const NETIF_F_HW_VLAN_CTAG_RX_BIT: _bindgen_ty_104 = 8;
pub const NETIF_F_HW_VLAN_CTAG_FILTER_BIT: _bindgen_ty_104 = 9;
pub const NETIF_F_VLAN_CHALLENGED_BIT: _bindgen_ty_104 = 10;
pub const NETIF_F_GSO_BIT: _bindgen_ty_104 = 11;
pub const NETIF_F_LLTX_BIT: _bindgen_ty_104 = 12;
pub const NETIF_F_NETNS_LOCAL_BIT: _bindgen_ty_104 = 13;
pub const NETIF_F_GRO_BIT: _bindgen_ty_104 = 14;
pub const NETIF_F_LRO_BIT: _bindgen_ty_104 = 15;
pub const NETIF_F_GSO_SHIFT: _bindgen_ty_104 = 16;
pub const NETIF_F_TSO_BIT: _bindgen_ty_104 = 16;
pub const NETIF_F_GSO_ROBUST_BIT: _bindgen_ty_104 = 17;
pub const NETIF_F_TSO_ECN_BIT: _bindgen_ty_104 = 18;
pub const NETIF_F_TSO_MANGLEID_BIT: _bindgen_ty_104 = 19;
pub const NETIF_F_TSO6_BIT: _bindgen_ty_104 = 20;
pub const NETIF_F_FSO_BIT: _bindgen_ty_104 = 21;
pub const NETIF_F_GSO_GRE_BIT: _bindgen_ty_104 = 22;
pub const NETIF_F_GSO_GRE_CSUM_BIT: _bindgen_ty_104 = 23;
pub const NETIF_F_GSO_IPXIP4_BIT: _bindgen_ty_104 = 24;
pub const NETIF_F_GSO_IPXIP6_BIT: _bindgen_ty_104 = 25;
pub const NETIF_F_GSO_UDP_TUNNEL_BIT: _bindgen_ty_104 = 26;
pub const NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT: _bindgen_ty_104 = 27;
pub const NETIF_F_GSO_PARTIAL_BIT: _bindgen_ty_104 = 28;
pub const NETIF_F_GSO_TUNNEL_REMCSUM_BIT: _bindgen_ty_104 = 29;
pub const NETIF_F_GSO_SCTP_BIT: _bindgen_ty_104 = 30;
pub const NETIF_F_GSO_ESP_BIT: _bindgen_ty_104 = 31;
pub const NETIF_F_GSO_UDP_BIT: _bindgen_ty_104 = 32;
pub const NETIF_F_GSO_UDP_L4_BIT: _bindgen_ty_104 = 33;
pub const NETIF_F_GSO_FRAGLIST_BIT: _bindgen_ty_104 = 34;
pub const NETIF_F_GSO_LAST: _bindgen_ty_104 = 34;
pub const NETIF_F_FCOE_CRC_BIT: _bindgen_ty_104 = 35;
pub const NETIF_F_SCTP_CRC_BIT: _bindgen_ty_104 = 36;
pub const NETIF_F_FCOE_MTU_BIT: _bindgen_ty_104 = 37;
pub const NETIF_F_NTUPLE_BIT: _bindgen_ty_104 = 38;
pub const NETIF_F_RXHASH_BIT: _bindgen_ty_104 = 39;
pub const NETIF_F_RXCSUM_BIT: _bindgen_ty_104 = 40;
pub const NETIF_F_NOCACHE_COPY_BIT: _bindgen_ty_104 = 41;
pub const NETIF_F_LOOPBACK_BIT: _bindgen_ty_104 = 42;
pub const NETIF_F_RXFCS_BIT: _bindgen_ty_104 = 43;
pub const NETIF_F_RXALL_BIT: _bindgen_ty_104 = 44;
pub const NETIF_F_HW_VLAN_STAG_TX_BIT: _bindgen_ty_104 = 45;
pub const NETIF_F_HW_VLAN_STAG_RX_BIT: _bindgen_ty_104 = 46;
pub const NETIF_F_HW_VLAN_STAG_FILTER_BIT: _bindgen_ty_104 = 47;
pub const NETIF_F_HW_L2FW_DOFFLOAD_BIT: _bindgen_ty_104 = 48;
pub const NETIF_F_HW_TC_BIT: _bindgen_ty_104 = 49;
pub const NETIF_F_HW_ESP_BIT: _bindgen_ty_104 = 50;
pub const NETIF_F_HW_ESP_TX_CSUM_BIT: _bindgen_ty_104 = 51;
pub const NETIF_F_RX_UDP_TUNNEL_PORT_BIT: _bindgen_ty_104 = 52;
pub const NETIF_F_HW_TLS_TX_BIT: _bindgen_ty_104 = 53;
pub const NETIF_F_HW_TLS_RX_BIT: _bindgen_ty_104 = 54;
pub const NETIF_F_GRO_HW_BIT: _bindgen_ty_104 = 55;
pub const NETIF_F_HW_TLS_RECORD_BIT: _bindgen_ty_104 = 56;
pub const NETIF_F_GRO_FRAGLIST_BIT: _bindgen_ty_104 = 57;
pub const NETIF_F_HW_MACSEC_BIT: _bindgen_ty_104 = 58;
pub const NETIF_F_GRO_UDP_FWD_BIT: _bindgen_ty_104 = 59;
pub const NETIF_F_HW_HSR_TAG_INS_BIT: _bindgen_ty_104 = 60;
pub const NETIF_F_HW_HSR_TAG_RM_BIT: _bindgen_ty_104 = 61;
pub const NETIF_F_HW_HSR_FWD_BIT: _bindgen_ty_104 = 62;
pub const NETIF_F_HW_HSR_DUP_BIT: _bindgen_ty_104 = 63;
pub const NETDEV_FEATURE_COUNT: _bindgen_ty_104 = 64;
pub type _bindgen_ty_104 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub u6_addr8: [__u8; 16usize],
    pub u6_addr16: [__be16; 8usize],
    pub u6_addr32: [__be32; 4usize],
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for in6_addr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: core::ffi::c_ushort,
    pub sin6_port: __be16,
    pub sin6_flowinfo: __be32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: __u32,
}
impl Default for sockaddr_in6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_ifindex: core::ffi::c_int,
}
impl Default for ipv6_mreq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_flowlabel_req {
    pub flr_dst: in6_addr,
    pub flr_label: __be32,
    pub flr_action: __u8,
    pub flr_share: __u8,
    pub flr_flags: __u16,
    pub flr_expires: __u16,
    pub flr_linger: __u16,
    pub __flr_pad: __u32,
}
impl Default for in6_flowlabel_req {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allrouters: in6_addr;
}
extern "C" {
    pub static in6addr_interfacelocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_interfacelocal_allrouters: in6_addr;
}
extern "C" {
    pub static in6addr_sitelocal_allrouters: in6_addr;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct siphash_key_t {
    pub key: [u64_; 2usize],
}
extern "C" {
    pub fn __siphash_aligned(
        data: *const core::ffi::c_void,
        len: usize,
        key: *const siphash_key_t,
    ) -> u64_;
}
extern "C" {
    pub fn __siphash_unaligned(
        data: *const core::ffi::c_void,
        len: usize,
        key: *const siphash_key_t,
    ) -> u64_;
}
extern "C" {
    pub fn siphash_1u64(a: u64_, key: *const siphash_key_t) -> u64_;
}
extern "C" {
    pub fn siphash_2u64(a: u64_, b: u64_, key: *const siphash_key_t) -> u64_;
}
extern "C" {
    pub fn siphash_3u64(a: u64_, b: u64_, c: u64_, key: *const siphash_key_t) -> u64_;
}
extern "C" {
    pub fn siphash_4u64(a: u64_, b: u64_, c: u64_, d: u64_, key: *const siphash_key_t) -> u64_;
}
extern "C" {
    pub fn siphash_1u32(a: u32_, key: *const siphash_key_t) -> u64_;
}
extern "C" {
    pub fn siphash_3u32(a: u32_, b: u32_, c: u32_, key: *const siphash_key_t) -> u64_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hsiphash_key_t {
    pub key: [core::ffi::c_ulong; 2usize],
}
extern "C" {
    pub fn __hsiphash_aligned(
        data: *const core::ffi::c_void,
        len: usize,
        key: *const hsiphash_key_t,
    ) -> u32_;
}
extern "C" {
    pub fn __hsiphash_unaligned(
        data: *const core::ffi::c_void,
        len: usize,
        key: *const hsiphash_key_t,
    ) -> u32_;
}
extern "C" {
    pub fn hsiphash_1u32(a: u32_, key: *const hsiphash_key_t) -> u32_;
}
extern "C" {
    pub fn hsiphash_2u32(a: u32_, b: u32_, key: *const hsiphash_key_t) -> u32_;
}
extern "C" {
    pub fn hsiphash_3u32(a: u32_, b: u32_, c: u32_, key: *const hsiphash_key_t) -> u32_;
}
extern "C" {
    pub fn hsiphash_4u32(a: u32_, b: u32_, c: u32_, d: u32_, key: *const hsiphash_key_t) -> u32_;
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct ethhdr {
    pub h_dest: [core::ffi::c_uchar; 6usize],
    pub h_source: [core::ffi::c_uchar; 6usize],
    pub h_proto: __be16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_prog {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_control {
    pub thoff: u16_,
    pub addr_type: u16_,
    pub flags: u32_,
}
pub const flow_dissect_ret_FLOW_DISSECT_RET_OUT_GOOD: flow_dissect_ret = 0;
pub const flow_dissect_ret_FLOW_DISSECT_RET_OUT_BAD: flow_dissect_ret = 1;
pub const flow_dissect_ret_FLOW_DISSECT_RET_PROTO_AGAIN: flow_dissect_ret = 2;
pub const flow_dissect_ret_FLOW_DISSECT_RET_IPPROTO_AGAIN: flow_dissect_ret = 3;
pub const flow_dissect_ret_FLOW_DISSECT_RET_CONTINUE: flow_dissect_ret = 4;
pub type flow_dissect_ret = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_basic {
    pub n_proto: __be16,
    pub ip_proto: u8_,
    pub padding: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_tags {
    pub flow_label: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_vlan {
    pub __bindgen_anon_1: flow_dissector_key_vlan__bindgen_ty_1,
    pub vlan_tpid: __be16,
    pub vlan_eth_type: __be16,
    pub padding: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flow_dissector_key_vlan__bindgen_ty_1 {
    pub __bindgen_anon_1: flow_dissector_key_vlan__bindgen_ty_1__bindgen_ty_1,
    pub vlan_tci: __be16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_vlan__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl flow_dissector_key_vlan__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn vlan_id(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_vlan_id(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn vlan_dei(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_vlan_dei(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vlan_priority(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_vlan_priority(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vlan_id: u16_,
        vlan_dei: u16_,
        vlan_priority: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let vlan_id: u16 = unsafe { ::core::mem::transmute(vlan_id) };
            vlan_id as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let vlan_dei: u16 = unsafe { ::core::mem::transmute(vlan_dei) };
            vlan_dei as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let vlan_priority: u16 = unsafe { ::core::mem::transmute(vlan_priority) };
            vlan_priority as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for flow_dissector_key_vlan__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for flow_dissector_key_vlan {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_mpls_lse {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl flow_dissector_mpls_lse {
    #[inline]
    pub fn mpls_ttl(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mpls_ttl(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn mpls_bos(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mpls_bos(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mpls_tc(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mpls_tc(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mpls_label(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_mpls_label(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mpls_ttl: u32_,
        mpls_bos: u32_,
        mpls_tc: u32_,
        mpls_label: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mpls_ttl: u32 = unsafe { ::core::mem::transmute(mpls_ttl) };
            mpls_ttl as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mpls_bos: u32 = unsafe { ::core::mem::transmute(mpls_bos) };
            mpls_bos as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let mpls_tc: u32 = unsafe { ::core::mem::transmute(mpls_tc) };
            mpls_tc as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let mpls_label: u32 = unsafe { ::core::mem::transmute(mpls_label) };
            mpls_label as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_mpls {
    pub ls: [flow_dissector_mpls_lse; 7usize],
    pub used_lses: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_enc_opts {
    pub data: [u8_; 255usize],
    pub len: u8_,
    pub dst_opt_type: __be16,
}
impl Default for flow_dissector_key_enc_opts {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_keyid {
    pub keyid: __be32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_ipv4_addrs {
    pub src: __be32,
    pub dst: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_ipv6_addrs {
    pub src: in6_addr,
    pub dst: in6_addr,
}
impl Default for flow_dissector_key_ipv6_addrs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_tipc {
    pub key: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_addrs {
    pub __bindgen_anon_1: flow_dissector_key_addrs__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flow_dissector_key_addrs__bindgen_ty_1 {
    pub v4addrs: flow_dissector_key_ipv4_addrs,
    pub v6addrs: flow_dissector_key_ipv6_addrs,
    pub tipckey: flow_dissector_key_tipc,
}
impl Default for flow_dissector_key_addrs__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for flow_dissector_key_addrs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_arp {
    pub sip: __u32,
    pub tip: __u32,
    pub op: __u8,
    pub sha: [core::ffi::c_uchar; 6usize],
    pub tha: [core::ffi::c_uchar; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_ports {
    pub __bindgen_anon_1: flow_dissector_key_ports__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flow_dissector_key_ports__bindgen_ty_1 {
    pub ports: __be32,
    pub __bindgen_anon_1: flow_dissector_key_ports__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_ports__bindgen_ty_1__bindgen_ty_1 {
    pub src: __be16,
    pub dst: __be16,
}
impl Default for flow_dissector_key_ports__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for flow_dissector_key_ports {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_ports_range {
    pub __bindgen_anon_1: flow_dissector_key_ports_range__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flow_dissector_key_ports_range__bindgen_ty_1 {
    pub tp: flow_dissector_key_ports,
    pub __bindgen_anon_1: flow_dissector_key_ports_range__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_ports_range__bindgen_ty_1__bindgen_ty_1 {
    pub tp_min: flow_dissector_key_ports,
    pub tp_max: flow_dissector_key_ports,
}
impl Default for flow_dissector_key_ports_range__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for flow_dissector_key_ports_range__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for flow_dissector_key_ports_range {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_icmp {
    pub __bindgen_anon_1: flow_dissector_key_icmp__bindgen_ty_1,
    pub id: u16_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_icmp__bindgen_ty_1 {
    pub type_: u8_,
    pub code: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_eth_addrs {
    pub dst: [core::ffi::c_uchar; 6usize],
    pub src: [core::ffi::c_uchar; 6usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_tcp {
    pub flags: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_ip {
    pub tos: __u8,
    pub ttl: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_meta {
    pub ingress_ifindex: core::ffi::c_int,
    pub ingress_iftype: u16_,
    pub l2_miss: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_ct {
    pub ct_state: u16_,
    pub ct_zone: u16_,
    pub ct_mark: u32_,
    pub ct_labels: [u32_; 4usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_hash {
    pub hash: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_num_of_vlans {
    pub num_of_vlans: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_pppoe {
    pub session_id: __be16,
    pub ppp_proto: __be16,
    pub type_: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_l2tpv3 {
    pub session_id: __be32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_ipsec {
    pub spi: __be32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_cfm {
    pub mdl_ver: u8_,
    pub opcode: u8_,
}
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_CONTROL: flow_dissector_key_id = 0;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_BASIC: flow_dissector_key_id = 1;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_IPV4_ADDRS: flow_dissector_key_id = 2;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_IPV6_ADDRS: flow_dissector_key_id = 3;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_PORTS: flow_dissector_key_id = 4;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_PORTS_RANGE: flow_dissector_key_id = 5;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ICMP: flow_dissector_key_id = 6;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ETH_ADDRS: flow_dissector_key_id = 7;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_TIPC: flow_dissector_key_id = 8;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ARP: flow_dissector_key_id = 9;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_VLAN: flow_dissector_key_id = 10;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_FLOW_LABEL: flow_dissector_key_id = 11;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_GRE_KEYID: flow_dissector_key_id = 12;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_MPLS_ENTROPY: flow_dissector_key_id = 13;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_KEYID: flow_dissector_key_id = 14;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS: flow_dissector_key_id = 15;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS: flow_dissector_key_id = 16;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_CONTROL: flow_dissector_key_id = 17;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_PORTS: flow_dissector_key_id = 18;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_MPLS: flow_dissector_key_id = 19;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_TCP: flow_dissector_key_id = 20;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_IP: flow_dissector_key_id = 21;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_CVLAN: flow_dissector_key_id = 22;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_IP: flow_dissector_key_id = 23;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_OPTS: flow_dissector_key_id = 24;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_META: flow_dissector_key_id = 25;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_CT: flow_dissector_key_id = 26;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_HASH: flow_dissector_key_id = 27;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_NUM_OF_VLANS: flow_dissector_key_id = 28;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_PPPOE: flow_dissector_key_id = 29;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_L2TPV3: flow_dissector_key_id = 30;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_CFM: flow_dissector_key_id = 31;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_IPSEC: flow_dissector_key_id = 32;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_MAX: flow_dissector_key_id = 33;
pub type flow_dissector_key_id = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key {
    pub key_id: flow_dissector_key_id,
    pub offset: usize,
}
impl Default for flow_dissector_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector {
    pub used_keys: core::ffi::c_ulonglong,
    pub offset: [core::ffi::c_ushort; 33usize],
}
impl Default for flow_dissector {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_keys_basic {
    pub control: flow_dissector_key_control,
    pub basic: flow_dissector_key_basic,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct flow_keys {
    pub control: flow_dissector_key_control,
    pub basic: flow_dissector_key_basic,
    pub tags: flow_dissector_key_tags,
    pub vlan: flow_dissector_key_vlan,
    pub cvlan: flow_dissector_key_vlan,
    pub keyid: flow_dissector_key_keyid,
    pub ports: flow_dissector_key_ports,
    pub icmp: flow_dissector_key_icmp,
    pub addrs: flow_dissector_key_addrs,
}
impl Default for flow_keys {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn flow_get_u32_src(flow: *const flow_keys) -> __be32;
}
extern "C" {
    pub fn flow_get_u32_dst(flow: *const flow_keys) -> __be32;
}
extern "C" {
    pub static mut flow_keys_dissector: flow_dissector;
}
extern "C" {
    pub static mut flow_keys_basic_dissector: flow_dissector;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_keys_digest {
    pub data: [u8_; 16usize],
}
extern "C" {
    pub fn make_flow_keys_digest(digest: *mut flow_keys_digest, flow: *const flow_keys);
}
extern "C" {
    pub fn flow_hash_from_keys(keys: *mut flow_keys) -> u32_;
}
extern "C" {
    pub fn skb_flow_get_icmp_tci(
        skb: *const sk_buff,
        key_icmp: *mut flow_dissector_key_icmp,
        data: *const core::ffi::c_void,
        thoff: core::ffi::c_int,
        hlen: core::ffi::c_int,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_flow_dissector {
    pub flow_keys: *mut bpf_flow_keys,
    pub skb: *const sk_buff,
    pub data: *const core::ffi::c_void,
    pub data_end: *const core::ffi::c_void,
}
impl Default for bpf_flow_dissector {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn flow_dissector_bpf_prog_attach_check(
        net: *mut net,
        prog: *mut bpf_prog,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sockaddr_pkt {
    pub spkt_family: core::ffi::c_ushort,
    pub spkt_device: [core::ffi::c_uchar; 14usize],
    pub spkt_protocol: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sockaddr_ll {
    pub sll_family: core::ffi::c_ushort,
    pub sll_protocol: __be16,
    pub sll_ifindex: core::ffi::c_int,
    pub sll_hatype: core::ffi::c_ushort,
    pub sll_pkttype: core::ffi::c_uchar,
    pub sll_halen: core::ffi::c_uchar,
    pub sll_addr: [core::ffi::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_stats {
    pub tp_packets: core::ffi::c_uint,
    pub tp_drops: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_stats_v3 {
    pub tp_packets: core::ffi::c_uint,
    pub tp_drops: core::ffi::c_uint,
    pub tp_freeze_q_cnt: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_rollover_stats {
    pub tp_all: __u64,
    pub tp_huge: __u64,
    pub tp_failed: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tpacket_stats_u {
    pub stats1: tpacket_stats,
    pub stats3: tpacket_stats_v3,
}
impl Default for tpacket_stats_u {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_auxdata {
    pub tp_status: __u32,
    pub tp_len: __u32,
    pub tp_snaplen: __u32,
    pub tp_mac: __u16,
    pub tp_net: __u16,
    pub tp_vlan_tci: __u16,
    pub tp_vlan_tpid: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_hdr {
    pub tp_status: core::ffi::c_ulong,
    pub tp_len: core::ffi::c_uint,
    pub tp_snaplen: core::ffi::c_uint,
    pub tp_mac: core::ffi::c_ushort,
    pub tp_net: core::ffi::c_ushort,
    pub tp_sec: core::ffi::c_uint,
    pub tp_usec: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket2_hdr {
    pub tp_status: __u32,
    pub tp_len: __u32,
    pub tp_snaplen: __u32,
    pub tp_mac: __u16,
    pub tp_net: __u16,
    pub tp_sec: __u32,
    pub tp_nsec: __u32,
    pub tp_vlan_tci: __u16,
    pub tp_vlan_tpid: __u16,
    pub tp_padding: [__u8; 4usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_hdr_variant1 {
    pub tp_rxhash: __u32,
    pub tp_vlan_tci: __u32,
    pub tp_vlan_tpid: __u16,
    pub tp_padding: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tpacket3_hdr {
    pub tp_next_offset: __u32,
    pub tp_sec: __u32,
    pub tp_nsec: __u32,
    pub tp_snaplen: __u32,
    pub tp_len: __u32,
    pub tp_status: __u32,
    pub tp_mac: __u16,
    pub tp_net: __u16,
    pub __bindgen_anon_1: tpacket3_hdr__bindgen_ty_1,
    pub tp_padding: [__u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tpacket3_hdr__bindgen_ty_1 {
    pub hv1: tpacket_hdr_variant1,
}
impl Default for tpacket3_hdr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tpacket3_hdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tpacket_bd_ts {
    pub ts_sec: core::ffi::c_uint,
    pub __bindgen_anon_1: tpacket_bd_ts__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tpacket_bd_ts__bindgen_ty_1 {
    pub ts_usec: core::ffi::c_uint,
    pub ts_nsec: core::ffi::c_uint,
}
impl Default for tpacket_bd_ts__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tpacket_bd_ts {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tpacket_hdr_v1 {
    pub block_status: __u32,
    pub num_pkts: __u32,
    pub offset_to_first_pkt: __u32,
    pub blk_len: __u32,
    pub seq_num: __u64,
    pub ts_first_pkt: tpacket_bd_ts,
    pub ts_last_pkt: tpacket_bd_ts,
}
impl Default for tpacket_hdr_v1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tpacket_bd_header_u {
    pub bh1: tpacket_hdr_v1,
}
impl Default for tpacket_bd_header_u {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tpacket_block_desc {
    pub version: __u32,
    pub offset_to_priv: __u32,
    pub hdr: tpacket_bd_header_u,
}
impl Default for tpacket_block_desc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const tpacket_versions_TPACKET_V1: tpacket_versions = 0;
pub const tpacket_versions_TPACKET_V2: tpacket_versions = 1;
pub const tpacket_versions_TPACKET_V3: tpacket_versions = 2;
pub type tpacket_versions = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_req {
    pub tp_block_size: core::ffi::c_uint,
    pub tp_block_nr: core::ffi::c_uint,
    pub tp_frame_size: core::ffi::c_uint,
    pub tp_frame_nr: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_req3 {
    pub tp_block_size: core::ffi::c_uint,
    pub tp_block_nr: core::ffi::c_uint,
    pub tp_frame_size: core::ffi::c_uint,
    pub tp_frame_nr: core::ffi::c_uint,
    pub tp_retire_blk_tov: core::ffi::c_uint,
    pub tp_sizeof_priv: core::ffi::c_uint,
    pub tp_feature_req_word: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tpacket_req_u {
    pub req: tpacket_req,
    pub req3: tpacket_req3,
}
impl Default for tpacket_req_u {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct packet_mreq {
    pub mr_ifindex: core::ffi::c_int,
    pub mr_type: core::ffi::c_ushort,
    pub mr_alen: core::ffi::c_ushort,
    pub mr_address: [core::ffi::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fanout_args {
    pub id: __u16,
    pub type_flags: __u16,
    pub max_num_members: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flowi_tunnel {
    pub tun_id: __be64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flowi_common {
    pub flowic_oif: core::ffi::c_int,
    pub flowic_iif: core::ffi::c_int,
    pub flowic_l3mdev: core::ffi::c_int,
    pub flowic_mark: __u32,
    pub flowic_tos: __u8,
    pub flowic_scope: __u8,
    pub flowic_proto: __u8,
    pub flowic_flags: __u8,
    pub flowic_secid: __u32,
    pub flowic_uid: kuid_t,
    pub flowic_multipath_hash: __u32,
    pub flowic_tun_key: flowi_tunnel,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flowi_uli {
    pub ports: flowi_uli__bindgen_ty_1,
    pub icmpt: flowi_uli__bindgen_ty_2,
    pub gre_key: __be32,
    pub mht: flowi_uli__bindgen_ty_3,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_1 {
    pub dport: __be16,
    pub sport: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_2 {
    pub type_: __u8,
    pub code: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_3 {
    pub type_: __u8,
}
impl Default for flowi_uli {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi4 {
    pub __fl_common: flowi_common,
    pub saddr: __be32,
    pub daddr: __be32,
    pub uli: flowi_uli,
}
impl Default for flowi4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi6 {
    pub __fl_common: flowi_common,
    pub daddr: in6_addr,
    pub saddr: in6_addr,
    pub flowlabel: __be32,
    pub uli: flowi_uli,
    pub mp_hash: __u32,
}
impl Default for flowi6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi {
    pub u: flowi__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flowi__bindgen_ty_1 {
    pub __fl_common: flowi_common,
    pub ip4: flowi4,
    pub ip6: flowi6,
}
impl Default for flowi__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for flowi {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __get_hash_from_flowi6(fl6: *const flowi6, keys: *mut flow_keys) -> __u32;
}
pub const ip_conntrack_info_IP_CT_ESTABLISHED: ip_conntrack_info = 0;
pub const ip_conntrack_info_IP_CT_RELATED: ip_conntrack_info = 1;
pub const ip_conntrack_info_IP_CT_NEW: ip_conntrack_info = 2;
pub const ip_conntrack_info_IP_CT_IS_REPLY: ip_conntrack_info = 3;
pub const ip_conntrack_info_IP_CT_ESTABLISHED_REPLY: ip_conntrack_info = 3;
pub const ip_conntrack_info_IP_CT_RELATED_REPLY: ip_conntrack_info = 4;
pub const ip_conntrack_info_IP_CT_NUMBER: ip_conntrack_info = 5;
pub const ip_conntrack_info_IP_CT_UNTRACKED: ip_conntrack_info = 7;
pub type ip_conntrack_info = core::ffi::c_uint;
pub const ip_conntrack_status_IPS_EXPECTED_BIT: ip_conntrack_status = 0;
pub const ip_conntrack_status_IPS_EXPECTED: ip_conntrack_status = 1;
pub const ip_conntrack_status_IPS_SEEN_REPLY_BIT: ip_conntrack_status = 1;
pub const ip_conntrack_status_IPS_SEEN_REPLY: ip_conntrack_status = 2;
pub const ip_conntrack_status_IPS_ASSURED_BIT: ip_conntrack_status = 2;
pub const ip_conntrack_status_IPS_ASSURED: ip_conntrack_status = 4;
pub const ip_conntrack_status_IPS_CONFIRMED_BIT: ip_conntrack_status = 3;
pub const ip_conntrack_status_IPS_CONFIRMED: ip_conntrack_status = 8;
pub const ip_conntrack_status_IPS_SRC_NAT_BIT: ip_conntrack_status = 4;
pub const ip_conntrack_status_IPS_SRC_NAT: ip_conntrack_status = 16;
pub const ip_conntrack_status_IPS_DST_NAT_BIT: ip_conntrack_status = 5;
pub const ip_conntrack_status_IPS_DST_NAT: ip_conntrack_status = 32;
pub const ip_conntrack_status_IPS_NAT_MASK: ip_conntrack_status = 48;
pub const ip_conntrack_status_IPS_SEQ_ADJUST_BIT: ip_conntrack_status = 6;
pub const ip_conntrack_status_IPS_SEQ_ADJUST: ip_conntrack_status = 64;
pub const ip_conntrack_status_IPS_SRC_NAT_DONE_BIT: ip_conntrack_status = 7;
pub const ip_conntrack_status_IPS_SRC_NAT_DONE: ip_conntrack_status = 128;
pub const ip_conntrack_status_IPS_DST_NAT_DONE_BIT: ip_conntrack_status = 8;
pub const ip_conntrack_status_IPS_DST_NAT_DONE: ip_conntrack_status = 256;
pub const ip_conntrack_status_IPS_NAT_DONE_MASK: ip_conntrack_status = 384;
pub const ip_conntrack_status_IPS_DYING_BIT: ip_conntrack_status = 9;
pub const ip_conntrack_status_IPS_DYING: ip_conntrack_status = 512;
pub const ip_conntrack_status_IPS_FIXED_TIMEOUT_BIT: ip_conntrack_status = 10;
pub const ip_conntrack_status_IPS_FIXED_TIMEOUT: ip_conntrack_status = 1024;
pub const ip_conntrack_status_IPS_TEMPLATE_BIT: ip_conntrack_status = 11;
pub const ip_conntrack_status_IPS_TEMPLATE: ip_conntrack_status = 2048;
pub const ip_conntrack_status_IPS_UNTRACKED_BIT: ip_conntrack_status = 12;
pub const ip_conntrack_status_IPS_UNTRACKED: ip_conntrack_status = 4096;
pub const ip_conntrack_status_IPS_NAT_CLASH_BIT: ip_conntrack_status = 12;
pub const ip_conntrack_status_IPS_NAT_CLASH: ip_conntrack_status = 4096;
pub const ip_conntrack_status_IPS_HELPER_BIT: ip_conntrack_status = 13;
pub const ip_conntrack_status_IPS_HELPER: ip_conntrack_status = 8192;
pub const ip_conntrack_status_IPS_OFFLOAD_BIT: ip_conntrack_status = 14;
pub const ip_conntrack_status_IPS_OFFLOAD: ip_conntrack_status = 16384;
pub const ip_conntrack_status_IPS_HW_OFFLOAD_BIT: ip_conntrack_status = 15;
pub const ip_conntrack_status_IPS_HW_OFFLOAD: ip_conntrack_status = 32768;
pub const ip_conntrack_status_IPS_UNCHANGEABLE_MASK: ip_conntrack_status = 56313;
pub const ip_conntrack_status___IPS_MAX_BIT: ip_conntrack_status = 16;
pub type ip_conntrack_status = core::ffi::c_uint;
pub const ip_conntrack_events_IPCT_NEW: ip_conntrack_events = 0;
pub const ip_conntrack_events_IPCT_RELATED: ip_conntrack_events = 1;
pub const ip_conntrack_events_IPCT_DESTROY: ip_conntrack_events = 2;
pub const ip_conntrack_events_IPCT_REPLY: ip_conntrack_events = 3;
pub const ip_conntrack_events_IPCT_ASSURED: ip_conntrack_events = 4;
pub const ip_conntrack_events_IPCT_PROTOINFO: ip_conntrack_events = 5;
pub const ip_conntrack_events_IPCT_HELPER: ip_conntrack_events = 6;
pub const ip_conntrack_events_IPCT_MARK: ip_conntrack_events = 7;
pub const ip_conntrack_events_IPCT_SEQADJ: ip_conntrack_events = 8;
pub const ip_conntrack_events_IPCT_NATSEQADJ: ip_conntrack_events = 8;
pub const ip_conntrack_events_IPCT_SECMARK: ip_conntrack_events = 9;
pub const ip_conntrack_events_IPCT_LABEL: ip_conntrack_events = 10;
pub const ip_conntrack_events_IPCT_SYNPROXY: ip_conntrack_events = 11;
pub const ip_conntrack_events___IPCT_MAX: ip_conntrack_events = 12;
pub type ip_conntrack_events = core::ffi::c_uint;
pub const ip_conntrack_expect_events_IPEXP_NEW: ip_conntrack_expect_events = 0;
pub const ip_conntrack_expect_events_IPEXP_DESTROY: ip_conntrack_expect_events = 1;
pub type ip_conntrack_expect_events = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ip_conntrack_stat {
    pub found: core::ffi::c_uint,
    pub invalid: core::ffi::c_uint,
    pub insert: core::ffi::c_uint,
    pub insert_failed: core::ffi::c_uint,
    pub clash_resolve: core::ffi::c_uint,
    pub drop: core::ffi::c_uint,
    pub early_drop: core::ffi::c_uint,
    pub error: core::ffi::c_uint,
    pub expect_new: core::ffi::c_uint,
    pub expect_create: core::ffi::c_uint,
    pub expect_delete: core::ffi::c_uint,
    pub search_restart: core::ffi::c_uint,
    pub chaintoolong: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_conntrack {
    pub use_: refcount_t,
}
extern "C" {
    pub fn nf_conntrack_destroy(nfct: *mut nf_conntrack);
}
extern "C" {
    pub fn netdev_printk(
        level: *const core::ffi::c_char,
        dev: *const net_device,
        format: *const core::ffi::c_char,
        ...
    );
}
extern "C" {
    pub fn netdev_emerg(dev: *const net_device, format: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn netdev_alert(dev: *const net_device, format: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn netdev_crit(dev: *const net_device, format: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn netdev_err(dev: *const net_device, format: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn netdev_warn(dev: *const net_device, format: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn netdev_notice(dev: *const net_device, format: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn netdev_info(dev: *const net_device, format: *const core::ffi::c_char, ...);
}
pub const skb_drop_reason_SKB_NOT_DROPPED_YET: skb_drop_reason = 0;
pub const skb_drop_reason_SKB_CONSUMED: skb_drop_reason = 1;
pub const skb_drop_reason_SKB_DROP_REASON_NOT_SPECIFIED: skb_drop_reason = 2;
pub const skb_drop_reason_SKB_DROP_REASON_NO_SOCKET: skb_drop_reason = 3;
pub const skb_drop_reason_SKB_DROP_REASON_PKT_TOO_SMALL: skb_drop_reason = 4;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_CSUM: skb_drop_reason = 5;
pub const skb_drop_reason_SKB_DROP_REASON_SOCKET_FILTER: skb_drop_reason = 6;
pub const skb_drop_reason_SKB_DROP_REASON_UDP_CSUM: skb_drop_reason = 7;
pub const skb_drop_reason_SKB_DROP_REASON_NETFILTER_DROP: skb_drop_reason = 8;
pub const skb_drop_reason_SKB_DROP_REASON_OTHERHOST: skb_drop_reason = 9;
pub const skb_drop_reason_SKB_DROP_REASON_IP_CSUM: skb_drop_reason = 10;
pub const skb_drop_reason_SKB_DROP_REASON_IP_INHDR: skb_drop_reason = 11;
pub const skb_drop_reason_SKB_DROP_REASON_IP_RPFILTER: skb_drop_reason = 12;
pub const skb_drop_reason_SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST: skb_drop_reason = 13;
pub const skb_drop_reason_SKB_DROP_REASON_XFRM_POLICY: skb_drop_reason = 14;
pub const skb_drop_reason_SKB_DROP_REASON_IP_NOPROTO: skb_drop_reason = 15;
pub const skb_drop_reason_SKB_DROP_REASON_SOCKET_RCVBUFF: skb_drop_reason = 16;
pub const skb_drop_reason_SKB_DROP_REASON_PROTO_MEM: skb_drop_reason = 17;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_AUTH_HDR: skb_drop_reason = 18;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_MD5NOTFOUND: skb_drop_reason = 19;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_MD5UNEXPECTED: skb_drop_reason = 20;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_MD5FAILURE: skb_drop_reason = 21;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_AONOTFOUND: skb_drop_reason = 22;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_AOUNEXPECTED: skb_drop_reason = 23;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_AOKEYNOTFOUND: skb_drop_reason = 24;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_AOFAILURE: skb_drop_reason = 25;
pub const skb_drop_reason_SKB_DROP_REASON_SOCKET_BACKLOG: skb_drop_reason = 26;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_FLAGS: skb_drop_reason = 27;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_ZEROWINDOW: skb_drop_reason = 28;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OLD_DATA: skb_drop_reason = 29;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OVERWINDOW: skb_drop_reason = 30;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OFOMERGE: skb_drop_reason = 31;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_RFC7323_PAWS: skb_drop_reason = 32;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OLD_SEQUENCE: skb_drop_reason = 33;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_INVALID_SEQUENCE: skb_drop_reason = 34;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_RESET: skb_drop_reason = 35;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_INVALID_SYN: skb_drop_reason = 36;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_CLOSE: skb_drop_reason = 37;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_FASTOPEN: skb_drop_reason = 38;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OLD_ACK: skb_drop_reason = 39;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_TOO_OLD_ACK: skb_drop_reason = 40;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_ACK_UNSENT_DATA: skb_drop_reason = 41;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OFO_QUEUE_PRUNE: skb_drop_reason = 42;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OFO_DROP: skb_drop_reason = 43;
pub const skb_drop_reason_SKB_DROP_REASON_IP_OUTNOROUTES: skb_drop_reason = 44;
pub const skb_drop_reason_SKB_DROP_REASON_BPF_CGROUP_EGRESS: skb_drop_reason = 45;
pub const skb_drop_reason_SKB_DROP_REASON_IPV6DISABLED: skb_drop_reason = 46;
pub const skb_drop_reason_SKB_DROP_REASON_NEIGH_CREATEFAIL: skb_drop_reason = 47;
pub const skb_drop_reason_SKB_DROP_REASON_NEIGH_FAILED: skb_drop_reason = 48;
pub const skb_drop_reason_SKB_DROP_REASON_NEIGH_QUEUEFULL: skb_drop_reason = 49;
pub const skb_drop_reason_SKB_DROP_REASON_NEIGH_DEAD: skb_drop_reason = 50;
pub const skb_drop_reason_SKB_DROP_REASON_TC_EGRESS: skb_drop_reason = 51;
pub const skb_drop_reason_SKB_DROP_REASON_QDISC_DROP: skb_drop_reason = 52;
pub const skb_drop_reason_SKB_DROP_REASON_CPU_BACKLOG: skb_drop_reason = 53;
pub const skb_drop_reason_SKB_DROP_REASON_XDP: skb_drop_reason = 54;
pub const skb_drop_reason_SKB_DROP_REASON_TC_INGRESS: skb_drop_reason = 55;
pub const skb_drop_reason_SKB_DROP_REASON_UNHANDLED_PROTO: skb_drop_reason = 56;
pub const skb_drop_reason_SKB_DROP_REASON_SKB_CSUM: skb_drop_reason = 57;
pub const skb_drop_reason_SKB_DROP_REASON_SKB_GSO_SEG: skb_drop_reason = 58;
pub const skb_drop_reason_SKB_DROP_REASON_SKB_UCOPY_FAULT: skb_drop_reason = 59;
pub const skb_drop_reason_SKB_DROP_REASON_DEV_HDR: skb_drop_reason = 60;
pub const skb_drop_reason_SKB_DROP_REASON_DEV_READY: skb_drop_reason = 61;
pub const skb_drop_reason_SKB_DROP_REASON_FULL_RING: skb_drop_reason = 62;
pub const skb_drop_reason_SKB_DROP_REASON_NOMEM: skb_drop_reason = 63;
pub const skb_drop_reason_SKB_DROP_REASON_HDR_TRUNC: skb_drop_reason = 64;
pub const skb_drop_reason_SKB_DROP_REASON_TAP_FILTER: skb_drop_reason = 65;
pub const skb_drop_reason_SKB_DROP_REASON_TAP_TXFILTER: skb_drop_reason = 66;
pub const skb_drop_reason_SKB_DROP_REASON_ICMP_CSUM: skb_drop_reason = 67;
pub const skb_drop_reason_SKB_DROP_REASON_INVALID_PROTO: skb_drop_reason = 68;
pub const skb_drop_reason_SKB_DROP_REASON_IP_INADDRERRORS: skb_drop_reason = 69;
pub const skb_drop_reason_SKB_DROP_REASON_IP_INNOROUTES: skb_drop_reason = 70;
pub const skb_drop_reason_SKB_DROP_REASON_PKT_TOO_BIG: skb_drop_reason = 71;
pub const skb_drop_reason_SKB_DROP_REASON_DUP_FRAG: skb_drop_reason = 72;
pub const skb_drop_reason_SKB_DROP_REASON_FRAG_REASM_TIMEOUT: skb_drop_reason = 73;
pub const skb_drop_reason_SKB_DROP_REASON_FRAG_TOO_FAR: skb_drop_reason = 74;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_MINTTL: skb_drop_reason = 75;
pub const skb_drop_reason_SKB_DROP_REASON_IPV6_BAD_EXTHDR: skb_drop_reason = 76;
pub const skb_drop_reason_SKB_DROP_REASON_IPV6_NDISC_FRAG: skb_drop_reason = 77;
pub const skb_drop_reason_SKB_DROP_REASON_IPV6_NDISC_HOP_LIMIT: skb_drop_reason = 78;
pub const skb_drop_reason_SKB_DROP_REASON_IPV6_NDISC_BAD_CODE: skb_drop_reason = 79;
pub const skb_drop_reason_SKB_DROP_REASON_IPV6_NDISC_BAD_OPTIONS: skb_drop_reason = 80;
pub const skb_drop_reason_SKB_DROP_REASON_IPV6_NDISC_NS_OTHERHOST: skb_drop_reason = 81;
pub const skb_drop_reason_SKB_DROP_REASON_QUEUE_PURGE: skb_drop_reason = 82;
pub const skb_drop_reason_SKB_DROP_REASON_TC_COOKIE_ERROR: skb_drop_reason = 83;
pub const skb_drop_reason_SKB_DROP_REASON_PACKET_SOCK_ERROR: skb_drop_reason = 84;
pub const skb_drop_reason_SKB_DROP_REASON_TC_CHAIN_NOTFOUND: skb_drop_reason = 85;
pub const skb_drop_reason_SKB_DROP_REASON_TC_RECLASSIFY_LOOP: skb_drop_reason = 86;
pub const skb_drop_reason_SKB_DROP_REASON_MAX: skb_drop_reason = 87;
pub const skb_drop_reason_SKB_DROP_REASON_SUBSYS_MASK: skb_drop_reason = 4294901760;
pub type skb_drop_reason = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ahash_request {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct napi_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ts_config {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_bridge_info {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub frag_max_size: __u16,
    pub physinif: core::ffi::c_int,
    pub physoutdev: *mut net_device,
    pub __bindgen_anon_1: nf_bridge_info__bindgen_ty_2,
}
pub const nf_bridge_info_BRNF_PROTO_UNCHANGED: nf_bridge_info__bindgen_ty_1 = 0;
pub const nf_bridge_info_BRNF_PROTO_8021Q: nf_bridge_info__bindgen_ty_1 = 1;
pub const nf_bridge_info_BRNF_PROTO_PPPOE: nf_bridge_info__bindgen_ty_1 = 2;
pub type nf_bridge_info__bindgen_ty_1 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_bridge_info__bindgen_ty_2 {
    pub ipv4_daddr: __be32,
    pub ipv6_daddr: in6_addr,
    pub neigh_header: [core::ffi::c_char; 8usize],
}
impl Default for nf_bridge_info__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nf_bridge_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl nf_bridge_info {
    #[inline]
    pub fn orig_proto(&self) -> nf_bridge_info__bindgen_ty_1 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_orig_proto(&mut self, val: nf_bridge_info__bindgen_ty_1) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pkt_otherhost(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pkt_otherhost(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_prerouting(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_in_prerouting(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bridged_dnat(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bridged_dnat(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sabotage_in_done(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sabotage_in_done(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        orig_proto: nf_bridge_info__bindgen_ty_1,
        pkt_otherhost: u8_,
        in_prerouting: u8_,
        bridged_dnat: u8_,
        sabotage_in_done: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let orig_proto: u32 = unsafe { ::core::mem::transmute(orig_proto) };
            orig_proto as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let pkt_otherhost: u8 = unsafe { ::core::mem::transmute(pkt_otherhost) };
            pkt_otherhost as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let in_prerouting: u8 = unsafe { ::core::mem::transmute(in_prerouting) };
            in_prerouting as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let bridged_dnat: u8 = unsafe { ::core::mem::transmute(bridged_dnat) };
            bridged_dnat as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let sabotage_in_done: u8 = unsafe { ::core::mem::transmute(sabotage_in_done) };
            sabotage_in_done as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tc_skb_ext {
    pub __bindgen_anon_1: tc_skb_ext__bindgen_ty_1,
    pub mru: __u16,
    pub zone: __u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tc_skb_ext__bindgen_ty_1 {
    pub act_miss_cookie: u64_,
    pub chain: __u32,
}
impl Default for tc_skb_ext__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tc_skb_ext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl tc_skb_ext {
    #[inline]
    pub fn post_ct(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_post_ct(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn post_ct_snat(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_post_ct_snat(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn post_ct_dnat(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_post_ct_dnat(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn act_miss(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_act_miss(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l2_miss(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_l2_miss(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        post_ct: u8_,
        post_ct_snat: u8_,
        post_ct_dnat: u8_,
        act_miss: u8_,
        l2_miss: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let post_ct: u8 = unsafe { ::core::mem::transmute(post_ct) };
            post_ct as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let post_ct_snat: u8 = unsafe { ::core::mem::transmute(post_ct_snat) };
            post_ct_snat as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let post_ct_dnat: u8 = unsafe { ::core::mem::transmute(post_ct_dnat) };
            post_ct_dnat as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let act_miss: u8 = unsafe { ::core::mem::transmute(act_miss) };
            act_miss as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let l2_miss: u8 = unsafe { ::core::mem::transmute(l2_miss) };
            l2_miss as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff_head {
    pub __bindgen_anon_1: sk_buff_head__bindgen_ty_1,
    pub qlen: __u32,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff_head__bindgen_ty_1 {
    pub __bindgen_anon_1: sk_buff_head__bindgen_ty_1__bindgen_ty_1,
    pub list: sk_buff_head__bindgen_ty_1_sk_buff_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff_head__bindgen_ty_1__bindgen_ty_1 {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
}
impl Default for sk_buff_head__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff_head__bindgen_ty_1_sk_buff_list {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
}
impl Default for sk_buff_head__bindgen_ty_1_sk_buff_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sk_buff_head__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sk_buff_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut sysctl_max_skb_frags: core::ffi::c_int;
}
pub type skb_frag_t = bio_vec;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skb_shared_hwtstamps {
    pub __bindgen_anon_1: skb_shared_hwtstamps__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union skb_shared_hwtstamps__bindgen_ty_1 {
    pub hwtstamp: ktime_t,
    pub netdev_data: *mut core::ffi::c_void,
}
impl Default for skb_shared_hwtstamps__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for skb_shared_hwtstamps {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SKBTX_HW_TSTAMP: _bindgen_ty_105 = 1;
pub const SKBTX_SW_TSTAMP: _bindgen_ty_105 = 2;
pub const SKBTX_IN_PROGRESS: _bindgen_ty_105 = 4;
pub const SKBTX_HW_TSTAMP_USE_CYCLES: _bindgen_ty_105 = 8;
pub const SKBTX_WIFI_STATUS: _bindgen_ty_105 = 16;
pub const SKBTX_HW_TSTAMP_NETDEV: _bindgen_ty_105 = 32;
pub const SKBTX_SCHED_TSTAMP: _bindgen_ty_105 = 64;
pub type _bindgen_ty_105 = core::ffi::c_uint;
pub const SKBFL_ZEROCOPY_ENABLE: _bindgen_ty_106 = 1;
pub const SKBFL_SHARED_FRAG: _bindgen_ty_106 = 2;
pub const SKBFL_PURE_ZEROCOPY: _bindgen_ty_106 = 4;
pub const SKBFL_DONT_ORPHAN: _bindgen_ty_106 = 8;
pub const SKBFL_MANAGED_FRAG_REFS: _bindgen_ty_106 = 16;
pub type _bindgen_ty_106 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ubuf_info {
    pub callback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut ubuf_info, zerocopy_success: bool_),
    >,
    pub refcnt: refcount_t,
    pub flags: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ubuf_info_msgzc {
    pub ubuf: ubuf_info,
    pub __bindgen_anon_1: ubuf_info_msgzc__bindgen_ty_1,
    pub mmp: ubuf_info_msgzc_mmpin,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ubuf_info_msgzc__bindgen_ty_1 {
    pub __bindgen_anon_1: ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_1 {
    pub desc: core::ffi::c_ulong,
    pub ctx: *mut core::ffi::c_void,
}
impl Default for ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_2 {
    pub id: u32_,
    pub len: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub bytelen: u32_,
}
impl ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn zerocopy(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_zerocopy(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(zerocopy: u16_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let zerocopy: u16 = unsafe { ::core::mem::transmute(zerocopy) };
            zerocopy as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for ubuf_info_msgzc__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ubuf_info_msgzc_mmpin {
    pub user: *mut user_struct,
    pub num_pg: core::ffi::c_uint,
}
impl Default for ubuf_info_msgzc_mmpin {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ubuf_info_msgzc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn mm_account_pinned_pages(
        mmp: *mut ubuf_info_msgzc_mmpin,
        size: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mm_unaccount_pinned_pages(mmp: *mut ubuf_info_msgzc_mmpin);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xsk_tx_metadata_compl {
    pub tx_timestamp: *mut __u64,
}
impl Default for xsk_tx_metadata_compl {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skb_shared_info {
    pub flags: __u8,
    pub meta_len: __u8,
    pub nr_frags: __u8,
    pub tx_flags: __u8,
    pub gso_size: core::ffi::c_ushort,
    pub gso_segs: core::ffi::c_ushort,
    pub frag_list: *mut sk_buff,
    pub __bindgen_anon_1: skb_shared_info__bindgen_ty_1,
    pub gso_type: core::ffi::c_uint,
    pub tskey: u32_,
    pub dataref: atomic_t,
    pub xdp_frags_size: core::ffi::c_uint,
    pub destructor_arg: *mut core::ffi::c_void,
    pub frags: [skb_frag_t; 17usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union skb_shared_info__bindgen_ty_1 {
    pub hwtstamps: skb_shared_hwtstamps,
    pub xsk_meta: xsk_tx_metadata_compl,
}
impl Default for skb_shared_info__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for skb_shared_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SKB_FCLONE_UNAVAILABLE: _bindgen_ty_107 = 0;
pub const SKB_FCLONE_ORIG: _bindgen_ty_107 = 1;
pub const SKB_FCLONE_CLONE: _bindgen_ty_107 = 2;
pub type _bindgen_ty_107 = core::ffi::c_uint;
pub const SKB_GSO_TCPV4: _bindgen_ty_108 = 1;
pub const SKB_GSO_DODGY: _bindgen_ty_108 = 2;
pub const SKB_GSO_TCP_ECN: _bindgen_ty_108 = 4;
pub const SKB_GSO_TCP_FIXEDID: _bindgen_ty_108 = 8;
pub const SKB_GSO_TCPV6: _bindgen_ty_108 = 16;
pub const SKB_GSO_FCOE: _bindgen_ty_108 = 32;
pub const SKB_GSO_GRE: _bindgen_ty_108 = 64;
pub const SKB_GSO_GRE_CSUM: _bindgen_ty_108 = 128;
pub const SKB_GSO_IPXIP4: _bindgen_ty_108 = 256;
pub const SKB_GSO_IPXIP6: _bindgen_ty_108 = 512;
pub const SKB_GSO_UDP_TUNNEL: _bindgen_ty_108 = 1024;
pub const SKB_GSO_UDP_TUNNEL_CSUM: _bindgen_ty_108 = 2048;
pub const SKB_GSO_PARTIAL: _bindgen_ty_108 = 4096;
pub const SKB_GSO_TUNNEL_REMCSUM: _bindgen_ty_108 = 8192;
pub const SKB_GSO_SCTP: _bindgen_ty_108 = 16384;
pub const SKB_GSO_ESP: _bindgen_ty_108 = 32768;
pub const SKB_GSO_UDP: _bindgen_ty_108 = 65536;
pub const SKB_GSO_UDP_L4: _bindgen_ty_108 = 131072;
pub const SKB_GSO_FRAGLIST: _bindgen_ty_108 = 262144;
pub type _bindgen_ty_108 = core::ffi::c_uint;
pub type sk_buff_data_t = core::ffi::c_uint;
#[repr(C)]
pub struct sk_buff {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1,
    pub sk: *mut sock,
    pub __bindgen_anon_2: sk_buff__bindgen_ty_2,
    pub cb: [core::ffi::c_char; 48usize],
    pub __bindgen_anon_3: sk_buff__bindgen_ty_3,
    pub _nfct: core::ffi::c_ulong,
    pub len: core::ffi::c_uint,
    pub data_len: core::ffi::c_uint,
    pub mac_len: __u16,
    pub hdr_len: __u16,
    pub queue_mapping: __u16,
    pub __cloned_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub active_extensions: __u8,
    pub __bindgen_anon_4: sk_buff__bindgen_ty_4,
    pub tail: sk_buff_data_t,
    pub end: sk_buff_data_t,
    pub head: *mut core::ffi::c_uchar,
    pub data: *mut core::ffi::c_uchar,
    pub truesize: core::ffi::c_uint,
    pub users: refcount_t,
    pub extensions: *mut skb_ext,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_1 {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1,
    pub rbnode: rb_node,
    pub list: list_head,
    pub ll_node: llist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff__bindgen_ty_1__bindgen_ty_1 {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub dev: *mut net_device,
    pub dev_scratch: core::ffi::c_ulong,
}
impl Default for sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sk_buff__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sk_buff__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_2 {
    pub tstamp: ktime_t,
    pub skb_mstamp_ns: u64_,
}
impl Default for sk_buff__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_3 {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_3__bindgen_ty_1,
    pub tcp_tsorted_anchor: list_head,
    pub _sk_redir: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_3__bindgen_ty_1 {
    pub _skb_refdst: core::ffi::c_ulong,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff)>,
}
impl Default for sk_buff__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct sk_buff__bindgen_ty_4 {
    pub __bindgen_anon_1: __BindgenUnionField<sk_buff__bindgen_ty_4__bindgen_ty_1>,
    pub headers: __BindgenUnionField<sk_buff__bindgen_ty_4__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 15usize],
}
#[repr(C)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_1 {
    pub __pkt_type_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __mono_tc_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub tc_index: __u16,
    pub alloc_cpu: u16_,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    pub priority: __u32,
    pub skb_iif: core::ffi::c_int,
    pub hash: __u32,
    pub __bindgen_anon_2: sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_3,
    pub secmark: __u32,
    pub __bindgen_anon_4: sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_5,
    pub inner_transport_header: __u16,
    pub inner_network_header: __u16,
    pub inner_mac_header: __u16,
    pub protocol: __be16,
    pub transport_header: __u16,
    pub network_header: __u16,
    pub mac_header: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub csum: __wsum,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub csum_start: __u16,
    pub csum_offset: __u16,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    pub vlan_all: u32_,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub vlan_proto: __be16,
    pub vlan_tci: __u16,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_3 {
    pub napi_id: core::ffi::c_uint,
    pub sender_cpu: core::ffi::c_uint,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_4 {
    pub mark: __u32,
    pub reserved_tailroom: __u32,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_5 {
    pub inner_protocol: __be16,
    pub inner_ipproto: __u8,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sk_buff__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn pkt_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pkt_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_df(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_df(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_pending_confirm(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_pending_confirm(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_summed(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ip_summed(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ooo_okay(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ooo_okay(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pkt_type: __u8,
        ignore_df: __u8,
        dst_pending_confirm: __u8,
        ip_summed: __u8,
        ooo_okay: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pkt_type: u8 = unsafe { ::core::mem::transmute(pkt_type) };
            pkt_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ignore_df: u8 = unsafe { ::core::mem::transmute(ignore_df) };
            ignore_df as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dst_pending_confirm: u8 = unsafe { ::core::mem::transmute(dst_pending_confirm) };
            dst_pending_confirm as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let ip_summed: u8 = unsafe { ::core::mem::transmute(ip_summed) };
            ip_summed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ooo_okay: u8 = unsafe { ::core::mem::transmute(ooo_okay) };
            ooo_okay as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn mono_delivery_time(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mono_delivery_time(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_at_ingress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_at_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_skip_classify(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_skip_classify(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remcsum_offload(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remcsum_offload(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_complete_sw(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_complete_sw(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_level(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_csum_level(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_protocol_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inner_protocol_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_l4_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sw_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_fcs(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_fcs(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encapsulation(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encapsulation(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encap_hdr_csum(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encap_hdr_csum(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ndisc_nodetype(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(16usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ndisc_nodetype(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ipvs_property(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ipvs_property(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nf_trace(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nf_trace(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_fwd_mark(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_fwd_mark(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_l3_fwd_mark(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_l3_fwd_mark(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirected(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_redirected(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn from_ingress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_from_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nf_skip_egress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nf_skip_egress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn decrypted(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_decrypted(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slow_gro(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slow_gro(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_not_inet(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_not_inet(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        mono_delivery_time: __u8,
        tc_at_ingress: __u8,
        tc_skip_classify: __u8,
        remcsum_offload: __u8,
        csum_complete_sw: __u8,
        csum_level: __u8,
        inner_protocol_type: __u8,
        l4_hash: __u8,
        sw_hash: __u8,
        wifi_acked_valid: __u8,
        wifi_acked: __u8,
        no_fcs: __u8,
        encapsulation: __u8,
        encap_hdr_csum: __u8,
        csum_valid: __u8,
        ndisc_nodetype: __u8,
        ipvs_property: __u8,
        nf_trace: __u8,
        offload_fwd_mark: __u8,
        offload_l3_fwd_mark: __u8,
        redirected: __u8,
        from_ingress: __u8,
        nf_skip_egress: __u8,
        decrypted: __u8,
        slow_gro: __u8,
        csum_not_inet: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mono_delivery_time: u8 = unsafe { ::core::mem::transmute(mono_delivery_time) };
            mono_delivery_time as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tc_at_ingress: u8 = unsafe { ::core::mem::transmute(tc_at_ingress) };
            tc_at_ingress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tc_skip_classify: u8 = unsafe { ::core::mem::transmute(tc_skip_classify) };
            tc_skip_classify as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let remcsum_offload: u8 = unsafe { ::core::mem::transmute(remcsum_offload) };
            remcsum_offload as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let csum_complete_sw: u8 = unsafe { ::core::mem::transmute(csum_complete_sw) };
            csum_complete_sw as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let csum_level: u8 = unsafe { ::core::mem::transmute(csum_level) };
            csum_level as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let inner_protocol_type: u8 = unsafe { ::core::mem::transmute(inner_protocol_type) };
            inner_protocol_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let l4_hash: u8 = unsafe { ::core::mem::transmute(l4_hash) };
            l4_hash as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_hash: u8 = unsafe { ::core::mem::transmute(sw_hash) };
            sw_hash as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wifi_acked_valid: u8 = unsafe { ::core::mem::transmute(wifi_acked_valid) };
            wifi_acked_valid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let wifi_acked: u8 = unsafe { ::core::mem::transmute(wifi_acked) };
            wifi_acked as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let no_fcs: u8 = unsafe { ::core::mem::transmute(no_fcs) };
            no_fcs as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let encapsulation: u8 = unsafe { ::core::mem::transmute(encapsulation) };
            encapsulation as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let encap_hdr_csum: u8 = unsafe { ::core::mem::transmute(encap_hdr_csum) };
            encap_hdr_csum as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let csum_valid: u8 = unsafe { ::core::mem::transmute(csum_valid) };
            csum_valid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let ndisc_nodetype: u8 = unsafe { ::core::mem::transmute(ndisc_nodetype) };
            ndisc_nodetype as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ipvs_property: u8 = unsafe { ::core::mem::transmute(ipvs_property) };
            ipvs_property as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let nf_trace: u8 = unsafe { ::core::mem::transmute(nf_trace) };
            nf_trace as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let offload_fwd_mark: u8 = unsafe { ::core::mem::transmute(offload_fwd_mark) };
            offload_fwd_mark as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let offload_l3_fwd_mark: u8 = unsafe { ::core::mem::transmute(offload_l3_fwd_mark) };
            offload_l3_fwd_mark as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let redirected: u8 = unsafe { ::core::mem::transmute(redirected) };
            redirected as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let from_ingress: u8 = unsafe { ::core::mem::transmute(from_ingress) };
            from_ingress as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let nf_skip_egress: u8 = unsafe { ::core::mem::transmute(nf_skip_egress) };
            nf_skip_egress as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let decrypted: u8 = unsafe { ::core::mem::transmute(decrypted) };
            decrypted as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let slow_gro: u8 = unsafe { ::core::mem::transmute(slow_gro) };
            slow_gro as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let csum_not_inet: u8 = unsafe { ::core::mem::transmute(csum_not_inet) };
            csum_not_inet as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_2 {
    pub __pkt_type_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __mono_tc_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub tc_index: __u16,
    pub alloc_cpu: u16_,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1,
    pub priority: __u32,
    pub skb_iif: core::ffi::c_int,
    pub hash: __u32,
    pub __bindgen_anon_2: sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2,
    pub __bindgen_anon_3: sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_3,
    pub secmark: __u32,
    pub __bindgen_anon_4: sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_4,
    pub __bindgen_anon_5: sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_5,
    pub inner_transport_header: __u16,
    pub inner_network_header: __u16,
    pub inner_mac_header: __u16,
    pub protocol: __be16,
    pub transport_header: __u16,
    pub network_header: __u16,
    pub mac_header: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1 {
    pub csum: __wsum,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub csum_start: __u16,
    pub csum_offset: __u16,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2 {
    pub vlan_all: u32_,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    pub vlan_proto: __be16,
    pub vlan_tci: __u16,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_3 {
    pub napi_id: core::ffi::c_uint,
    pub sender_cpu: core::ffi::c_uint,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_4 {
    pub mark: __u32,
    pub reserved_tailroom: __u32,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_5 {
    pub inner_protocol: __be16,
    pub inner_ipproto: __u8,
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_2__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sk_buff__bindgen_ty_4__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sk_buff__bindgen_ty_4__bindgen_ty_2 {
    #[inline]
    pub fn pkt_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pkt_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_df(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_df(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_pending_confirm(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_pending_confirm(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_summed(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ip_summed(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ooo_okay(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ooo_okay(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pkt_type: __u8,
        ignore_df: __u8,
        dst_pending_confirm: __u8,
        ip_summed: __u8,
        ooo_okay: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pkt_type: u8 = unsafe { ::core::mem::transmute(pkt_type) };
            pkt_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ignore_df: u8 = unsafe { ::core::mem::transmute(ignore_df) };
            ignore_df as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dst_pending_confirm: u8 = unsafe { ::core::mem::transmute(dst_pending_confirm) };
            dst_pending_confirm as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let ip_summed: u8 = unsafe { ::core::mem::transmute(ip_summed) };
            ip_summed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ooo_okay: u8 = unsafe { ::core::mem::transmute(ooo_okay) };
            ooo_okay as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn mono_delivery_time(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mono_delivery_time(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_at_ingress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_at_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_skip_classify(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_skip_classify(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remcsum_offload(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remcsum_offload(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_complete_sw(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_complete_sw(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_level(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_csum_level(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_protocol_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inner_protocol_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_l4_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sw_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_fcs(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_fcs(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encapsulation(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encapsulation(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encap_hdr_csum(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encap_hdr_csum(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ndisc_nodetype(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(16usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ndisc_nodetype(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ipvs_property(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ipvs_property(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nf_trace(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nf_trace(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_fwd_mark(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_fwd_mark(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_l3_fwd_mark(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_l3_fwd_mark(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirected(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_redirected(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn from_ingress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_from_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nf_skip_egress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nf_skip_egress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn decrypted(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_decrypted(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slow_gro(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slow_gro(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_not_inet(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_not_inet(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        mono_delivery_time: __u8,
        tc_at_ingress: __u8,
        tc_skip_classify: __u8,
        remcsum_offload: __u8,
        csum_complete_sw: __u8,
        csum_level: __u8,
        inner_protocol_type: __u8,
        l4_hash: __u8,
        sw_hash: __u8,
        wifi_acked_valid: __u8,
        wifi_acked: __u8,
        no_fcs: __u8,
        encapsulation: __u8,
        encap_hdr_csum: __u8,
        csum_valid: __u8,
        ndisc_nodetype: __u8,
        ipvs_property: __u8,
        nf_trace: __u8,
        offload_fwd_mark: __u8,
        offload_l3_fwd_mark: __u8,
        redirected: __u8,
        from_ingress: __u8,
        nf_skip_egress: __u8,
        decrypted: __u8,
        slow_gro: __u8,
        csum_not_inet: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mono_delivery_time: u8 = unsafe { ::core::mem::transmute(mono_delivery_time) };
            mono_delivery_time as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tc_at_ingress: u8 = unsafe { ::core::mem::transmute(tc_at_ingress) };
            tc_at_ingress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tc_skip_classify: u8 = unsafe { ::core::mem::transmute(tc_skip_classify) };
            tc_skip_classify as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let remcsum_offload: u8 = unsafe { ::core::mem::transmute(remcsum_offload) };
            remcsum_offload as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let csum_complete_sw: u8 = unsafe { ::core::mem::transmute(csum_complete_sw) };
            csum_complete_sw as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let csum_level: u8 = unsafe { ::core::mem::transmute(csum_level) };
            csum_level as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let inner_protocol_type: u8 = unsafe { ::core::mem::transmute(inner_protocol_type) };
            inner_protocol_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let l4_hash: u8 = unsafe { ::core::mem::transmute(l4_hash) };
            l4_hash as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_hash: u8 = unsafe { ::core::mem::transmute(sw_hash) };
            sw_hash as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wifi_acked_valid: u8 = unsafe { ::core::mem::transmute(wifi_acked_valid) };
            wifi_acked_valid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let wifi_acked: u8 = unsafe { ::core::mem::transmute(wifi_acked) };
            wifi_acked as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let no_fcs: u8 = unsafe { ::core::mem::transmute(no_fcs) };
            no_fcs as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let encapsulation: u8 = unsafe { ::core::mem::transmute(encapsulation) };
            encapsulation as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let encap_hdr_csum: u8 = unsafe { ::core::mem::transmute(encap_hdr_csum) };
            encap_hdr_csum as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let csum_valid: u8 = unsafe { ::core::mem::transmute(csum_valid) };
            csum_valid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let ndisc_nodetype: u8 = unsafe { ::core::mem::transmute(ndisc_nodetype) };
            ndisc_nodetype as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ipvs_property: u8 = unsafe { ::core::mem::transmute(ipvs_property) };
            ipvs_property as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let nf_trace: u8 = unsafe { ::core::mem::transmute(nf_trace) };
            nf_trace as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let offload_fwd_mark: u8 = unsafe { ::core::mem::transmute(offload_fwd_mark) };
            offload_fwd_mark as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let offload_l3_fwd_mark: u8 = unsafe { ::core::mem::transmute(offload_l3_fwd_mark) };
            offload_l3_fwd_mark as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let redirected: u8 = unsafe { ::core::mem::transmute(redirected) };
            redirected as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let from_ingress: u8 = unsafe { ::core::mem::transmute(from_ingress) };
            from_ingress as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let nf_skip_egress: u8 = unsafe { ::core::mem::transmute(nf_skip_egress) };
            nf_skip_egress as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let decrypted: u8 = unsafe { ::core::mem::transmute(decrypted) };
            decrypted as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let slow_gro: u8 = unsafe { ::core::mem::transmute(slow_gro) };
            slow_gro as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let csum_not_inet: u8 = unsafe { ::core::mem::transmute(csum_not_inet) };
            csum_not_inet as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for sk_buff__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sk_buff {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sk_buff {
    #[inline]
    pub fn cloned(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cloned(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nohdr(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nohdr(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fclone(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fclone(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn peeked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_peeked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn head_frag(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_head_frag(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pfmemalloc(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pfmemalloc(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pp_recycle(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pp_recycle(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cloned: __u8,
        nohdr: __u8,
        fclone: __u8,
        peeked: __u8,
        head_frag: __u8,
        pfmemalloc: __u8,
        pp_recycle: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cloned: u8 = unsafe { ::core::mem::transmute(cloned) };
            cloned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nohdr: u8 = unsafe { ::core::mem::transmute(nohdr) };
            nohdr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let fclone: u8 = unsafe { ::core::mem::transmute(fclone) };
            fclone as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let peeked: u8 = unsafe { ::core::mem::transmute(peeked) };
            peeked as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let head_frag: u8 = unsafe { ::core::mem::transmute(head_frag) };
            head_frag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pfmemalloc: u8 = unsafe { ::core::mem::transmute(pfmemalloc) };
            pfmemalloc as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let pp_recycle: u8 = unsafe { ::core::mem::transmute(pp_recycle) };
            pp_recycle as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dst_entry {
    _unused: [u8; 0],
}
extern "C" {
    pub fn kfree_skb_reason(skb: *mut sk_buff, reason: skb_drop_reason);
}
extern "C" {
    pub fn skb_release_head_state(skb: *mut sk_buff);
}
extern "C" {
    pub fn kfree_skb_list_reason(segs: *mut sk_buff, reason: skb_drop_reason);
}
extern "C" {
    pub fn skb_dump(level: *const core::ffi::c_char, skb: *const sk_buff, full_pkt: bool_);
}
extern "C" {
    pub fn skb_tx_error(skb: *mut sk_buff);
}
extern "C" {
    pub fn consume_skb(skb: *mut sk_buff);
}
extern "C" {
    pub fn __consume_stateless_skb(skb: *mut sk_buff);
}
extern "C" {
    pub fn __kfree_skb(skb: *mut sk_buff);
}
extern "C" {
    pub static mut skbuff_cache: *mut kmem_cache;
}
extern "C" {
    pub fn kfree_skb_partial(skb: *mut sk_buff, head_stolen: bool_);
}
extern "C" {
    pub fn skb_try_coalesce(
        to: *mut sk_buff,
        from: *mut sk_buff,
        fragstolen: *mut bool_,
        delta_truesize: *mut core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn __alloc_skb(
        size: core::ffi::c_uint,
        priority: gfp_t,
        flags: core::ffi::c_int,
        node: core::ffi::c_int,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn __build_skb(data: *mut core::ffi::c_void, frag_size: core::ffi::c_uint) -> *mut sk_buff;
}
extern "C" {
    pub fn build_skb(data: *mut core::ffi::c_void, frag_size: core::ffi::c_uint) -> *mut sk_buff;
}
extern "C" {
    pub fn build_skb_around(
        skb: *mut sk_buff,
        data: *mut core::ffi::c_void,
        frag_size: core::ffi::c_uint,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_attempt_defer_free(skb: *mut sk_buff);
}
extern "C" {
    pub fn napi_build_skb(
        data: *mut core::ffi::c_void,
        frag_size: core::ffi::c_uint,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn slab_build_skb(data: *mut core::ffi::c_void) -> *mut sk_buff;
}
extern "C" {
    pub fn alloc_skb_with_frags(
        header_len: core::ffi::c_ulong,
        data_len: core::ffi::c_ulong,
        max_page_order: core::ffi::c_int,
        errcode: *mut core::ffi::c_int,
        gfp_mask: gfp_t,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn alloc_skb_for_msg(first: *mut sk_buff) -> *mut sk_buff;
}
#[repr(C)]
pub struct sk_buff_fclones {
    pub skb1: sk_buff,
    pub skb2: sk_buff,
    pub fclone_ref: refcount_t,
}
impl Default for sk_buff_fclones {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn skb_morph(dst: *mut sk_buff, src: *mut sk_buff) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_headers_offset_update(skb: *mut sk_buff, off: core::ffi::c_int);
}
extern "C" {
    pub fn skb_copy_ubufs(skb: *mut sk_buff, gfp_mask: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_clone(skb: *mut sk_buff, priority: gfp_t) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_copy_header(new: *mut sk_buff, old: *const sk_buff);
}
extern "C" {
    pub fn skb_copy(skb: *const sk_buff, priority: gfp_t) -> *mut sk_buff;
}
extern "C" {
    pub fn __pskb_copy_fclone(
        skb: *mut sk_buff,
        headroom: core::ffi::c_int,
        gfp_mask: gfp_t,
        fclone: bool_,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn pskb_expand_head(
        skb: *mut sk_buff,
        nhead: core::ffi::c_int,
        ntail: core::ffi::c_int,
        gfp_mask: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_realloc_headroom(skb: *mut sk_buff, headroom: core::ffi::c_uint) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_expand_head(skb: *mut sk_buff, headroom: core::ffi::c_uint) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_copy_expand(
        skb: *const sk_buff,
        newheadroom: core::ffi::c_int,
        newtailroom: core::ffi::c_int,
        priority: gfp_t,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_to_sgvec_nomark(
        skb: *mut sk_buff,
        sg: *mut scatterlist,
        offset: core::ffi::c_int,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_to_sgvec(
        skb: *mut sk_buff,
        sg: *mut scatterlist,
        offset: core::ffi::c_int,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_cow_data(
        skb: *mut sk_buff,
        tailbits: core::ffi::c_int,
        trailer: *mut *mut sk_buff,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __skb_pad(
        skb: *mut sk_buff,
        pad: core::ffi::c_int,
        free_on_error: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_append_pagefrags(
        skb: *mut sk_buff,
        page: *mut page,
        offset: core::ffi::c_int,
        size: usize,
        max_frags: usize,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skb_seq_state {
    pub lower_offset: __u32,
    pub upper_offset: __u32,
    pub frag_idx: __u32,
    pub stepped_offset: __u32,
    pub root_skb: *mut sk_buff,
    pub cur_skb: *mut sk_buff,
    pub frag_data: *mut __u8,
    pub frag_off: __u32,
}
impl Default for skb_seq_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn skb_prepare_seq_read(
        skb: *mut sk_buff,
        from: core::ffi::c_uint,
        to: core::ffi::c_uint,
        st: *mut skb_seq_state,
    );
}
extern "C" {
    pub fn skb_seq_read(
        consumed: core::ffi::c_uint,
        data: *mut *const u8_,
        st: *mut skb_seq_state,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn skb_abort_seq_read(st: *mut skb_seq_state);
}
extern "C" {
    pub fn skb_find_text(
        skb: *mut sk_buff,
        from: core::ffi::c_uint,
        to: core::ffi::c_uint,
        config: *mut ts_config,
    ) -> core::ffi::c_uint;
}
pub const pkt_hash_types_PKT_HASH_TYPE_NONE: pkt_hash_types = 0;
pub const pkt_hash_types_PKT_HASH_TYPE_L2: pkt_hash_types = 1;
pub const pkt_hash_types_PKT_HASH_TYPE_L3: pkt_hash_types = 2;
pub const pkt_hash_types_PKT_HASH_TYPE_L4: pkt_hash_types = 3;
pub type pkt_hash_types = core::ffi::c_uint;
extern "C" {
    pub fn __skb_get_hash(skb: *mut sk_buff);
}
extern "C" {
    pub fn __skb_get_hash_symmetric(skb: *const sk_buff) -> u32_;
}
extern "C" {
    pub fn skb_get_poff(skb: *const sk_buff) -> u32_;
}
extern "C" {
    pub fn __skb_get_poff(
        skb: *const sk_buff,
        data: *const core::ffi::c_void,
        keys: *const flow_keys_basic,
        hlen: core::ffi::c_int,
    ) -> u32_;
}
extern "C" {
    pub fn __skb_flow_get_ports(
        skb: *const sk_buff,
        thoff: core::ffi::c_int,
        ip_proto: u8_,
        data: *const core::ffi::c_void,
        hlen_proto: core::ffi::c_int,
    ) -> __be32;
}
extern "C" {
    pub fn skb_flow_dissector_init(
        flow_dissector: *mut flow_dissector,
        key: *const flow_dissector_key,
        key_count: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bpf_flow_dissect(
        prog: *mut bpf_prog,
        ctx: *mut bpf_flow_dissector,
        proto: __be16,
        nhoff: core::ffi::c_int,
        hlen: core::ffi::c_int,
        flags: core::ffi::c_uint,
    ) -> u32_;
}
extern "C" {
    pub fn __skb_flow_dissect(
        net: *const net,
        skb: *const sk_buff,
        flow_dissector: *mut flow_dissector,
        target_container: *mut core::ffi::c_void,
        data: *const core::ffi::c_void,
        proto: __be16,
        nhoff: core::ffi::c_int,
        hlen: core::ffi::c_int,
        flags: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn skb_flow_dissect_meta(
        skb: *const sk_buff,
        flow_dissector: *mut flow_dissector,
        target_container: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn skb_flow_dissect_ct(
        skb: *const sk_buff,
        flow_dissector: *mut flow_dissector,
        target_container: *mut core::ffi::c_void,
        ctinfo_map: *mut u16_,
        mapsize: usize,
        post_ct: bool_,
        zone: u16_,
    );
}
extern "C" {
    pub fn skb_flow_dissect_tunnel_info(
        skb: *const sk_buff,
        flow_dissector: *mut flow_dissector,
        target_container: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn skb_flow_dissect_hash(
        skb: *const sk_buff,
        flow_dissector: *mut flow_dissector,
        target_container: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn skb_get_hash_perturb(skb: *const sk_buff, perturb: *const siphash_key_t) -> __u32;
}
extern "C" {
    pub fn msg_zerocopy_realloc(sk: *mut sock, size: usize, uarg: *mut ubuf_info)
        -> *mut ubuf_info;
}
extern "C" {
    pub fn msg_zerocopy_put_abort(uarg: *mut ubuf_info, have_uref: bool_);
}
extern "C" {
    pub fn msg_zerocopy_callback(skb: *mut sk_buff, uarg: *mut ubuf_info, success: bool_);
}
extern "C" {
    pub fn __zerocopy_sg_from_iter(
        msg: *mut msghdr,
        sk: *mut sock,
        skb: *mut sk_buff,
        from: *mut iov_iter,
        length: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_zerocopy_iter_stream(
        sk: *mut sock,
        skb: *mut sk_buff,
        msg: *mut msghdr,
        len: core::ffi::c_int,
        uarg: *mut ubuf_info,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __skb_zcopy_downgrade_managed(skb: *mut sk_buff);
}
extern "C" {
    pub fn __skb_unclone_keeptruesize(skb: *mut sk_buff, pri: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_append(old: *mut sk_buff, newsk: *mut sk_buff, list: *mut sk_buff_head);
}
extern "C" {
    pub fn skb_queue_head(list: *mut sk_buff_head, newsk: *mut sk_buff);
}
extern "C" {
    pub fn skb_queue_tail(list: *mut sk_buff_head, newsk: *mut sk_buff);
}
extern "C" {
    pub fn skb_unlink(skb: *mut sk_buff, list: *mut sk_buff_head);
}
extern "C" {
    pub fn skb_dequeue(list: *mut sk_buff_head) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_dequeue_tail(list: *mut sk_buff_head) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_add_rx_frag(
        skb: *mut sk_buff,
        i: core::ffi::c_int,
        page: *mut page,
        off: core::ffi::c_int,
        size: core::ffi::c_int,
        truesize: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn skb_coalesce_rx_frag(
        skb: *mut sk_buff,
        i: core::ffi::c_int,
        size: core::ffi::c_int,
        truesize: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn pskb_put(
        skb: *mut sk_buff,
        tail: *mut sk_buff,
        len: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn skb_put(skb: *mut sk_buff, len: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn skb_push(skb: *mut sk_buff, len: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn skb_pull(skb: *mut sk_buff, len: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn skb_pull_data(skb: *mut sk_buff, len: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __pskb_pull_tail(skb: *mut sk_buff, delta: core::ffi::c_int) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn skb_condense(skb: *mut sk_buff);
}
extern "C" {
    pub fn ___pskb_trim(skb: *mut sk_buff, len: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_trim(skb: *mut sk_buff, len: core::ffi::c_uint);
}
extern "C" {
    pub fn skb_queue_purge_reason(list: *mut sk_buff_head, reason: skb_drop_reason);
}
extern "C" {
    pub fn skb_rbtree_purge(root: *mut rb_root) -> core::ffi::c_uint;
}
extern "C" {
    pub fn skb_errqueue_purge(list: *mut sk_buff_head);
}
extern "C" {
    pub fn __netdev_alloc_frag_align(
        fragsz: core::ffi::c_uint,
        align_mask: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __netdev_alloc_skb(
        dev: *mut net_device,
        length: core::ffi::c_uint,
        gfp_mask: gfp_t,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn __napi_alloc_frag_align(
        fragsz: core::ffi::c_uint,
        align_mask: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __napi_alloc_skb(
        napi: *mut napi_struct,
        length: core::ffi::c_uint,
        gfp_mask: gfp_t,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn napi_consume_skb(skb: *mut sk_buff, budget: core::ffi::c_int);
}
extern "C" {
    pub fn napi_skb_free_stolen_head(skb: *mut sk_buff);
}
extern "C" {
    pub fn __napi_kfree_skb(skb: *mut sk_buff, reason: skb_drop_reason);
}
extern "C" {
    pub fn napi_pp_put_page(page: *mut page, napi_safe: bool_) -> bool_;
}
extern "C" {
    pub fn skb_page_frag_refill(sz: core::ffi::c_uint, pfrag: *mut page_frag, prio: gfp_t)
        -> bool_;
}
extern "C" {
    pub fn csum_and_copy_from_iter_full(
        addr: *mut core::ffi::c_void,
        bytes: usize,
        csum: *mut __wsum,
        i: *mut iov_iter,
    ) -> bool_;
}
extern "C" {
    pub fn skb_pull_rcsum(skb: *mut sk_buff, len: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn pskb_trim_rcsum_slow(skb: *mut sk_buff, len: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn __skb_wait_for_more_packets(
        sk: *mut sock,
        queue: *mut sk_buff_head,
        err: *mut core::ffi::c_int,
        timeo_p: *mut core::ffi::c_long,
        skb: *const sk_buff,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __skb_try_recv_from_queue(
        sk: *mut sock,
        queue: *mut sk_buff_head,
        flags: core::ffi::c_uint,
        off: *mut core::ffi::c_int,
        err: *mut core::ffi::c_int,
        last: *mut *mut sk_buff,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn __skb_try_recv_datagram(
        sk: *mut sock,
        queue: *mut sk_buff_head,
        flags: core::ffi::c_uint,
        off: *mut core::ffi::c_int,
        err: *mut core::ffi::c_int,
        last: *mut *mut sk_buff,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn __skb_recv_datagram(
        sk: *mut sock,
        sk_queue: *mut sk_buff_head,
        flags: core::ffi::c_uint,
        off: *mut core::ffi::c_int,
        err: *mut core::ffi::c_int,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_recv_datagram(
        sk: *mut sock,
        flags: core::ffi::c_uint,
        err: *mut core::ffi::c_int,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn datagram_poll(
        file: *mut file,
        sock: *mut socket,
        wait: *mut poll_table_struct,
    ) -> __poll_t;
}
extern "C" {
    pub fn skb_copy_datagram_iter(
        from: *const sk_buff,
        offset: core::ffi::c_int,
        to: *mut iov_iter,
        size: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_copy_and_csum_datagram_msg(
        skb: *mut sk_buff,
        hlen: core::ffi::c_int,
        msg: *mut msghdr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_copy_and_hash_datagram_iter(
        skb: *const sk_buff,
        offset: core::ffi::c_int,
        to: *mut iov_iter,
        len: core::ffi::c_int,
        hash: *mut ahash_request,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_copy_datagram_from_iter(
        skb: *mut sk_buff,
        offset: core::ffi::c_int,
        from: *mut iov_iter,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn zerocopy_sg_from_iter(skb: *mut sk_buff, frm: *mut iov_iter) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_free_datagram(sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn __skb_free_datagram_locked(sk: *mut sock, skb: *mut sk_buff, len: core::ffi::c_int);
}
extern "C" {
    pub fn skb_kill_datagram(
        sk: *mut sock,
        skb: *mut sk_buff,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_copy_bits(
        skb: *const sk_buff,
        offset: core::ffi::c_int,
        to: *mut core::ffi::c_void,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_store_bits(
        skb: *mut sk_buff,
        offset: core::ffi::c_int,
        from: *const core::ffi::c_void,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_copy_and_csum_bits(
        skb: *const sk_buff,
        offset: core::ffi::c_int,
        to: *mut u8_,
        len: core::ffi::c_int,
    ) -> __wsum;
}
extern "C" {
    pub fn skb_splice_bits(
        skb: *mut sk_buff,
        sk: *mut sock,
        offset: core::ffi::c_uint,
        pipe: *mut pipe_inode_info,
        len: core::ffi::c_uint,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_send_sock_locked(
        sk: *mut sock,
        skb: *mut sk_buff,
        offset: core::ffi::c_int,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_send_sock(
        sk: *mut sock,
        skb: *mut sk_buff,
        offset: core::ffi::c_int,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_copy_and_csum_dev(skb: *const sk_buff, to: *mut u8_);
}
extern "C" {
    pub fn skb_zerocopy_headlen(from: *const sk_buff) -> core::ffi::c_uint;
}
extern "C" {
    pub fn skb_zerocopy(
        to: *mut sk_buff,
        from: *mut sk_buff,
        len: core::ffi::c_int,
        hlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_split(skb: *mut sk_buff, skb1: *mut sk_buff, len: u32_);
}
extern "C" {
    pub fn skb_shift(
        tgt: *mut sk_buff,
        skb: *mut sk_buff,
        shiftlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_scrub_packet(skb: *mut sk_buff, xnet: bool_);
}
extern "C" {
    pub fn skb_segment(skb: *mut sk_buff, features: netdev_features_t) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_segment_list(
        skb: *mut sk_buff,
        features: netdev_features_t,
        offset: core::ffi::c_uint,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_vlan_untag(skb: *mut sk_buff) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_ensure_writable(skb: *mut sk_buff, write_len: core::ffi::c_uint)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_ensure_writable_head_tail(
        skb: *mut sk_buff,
        dev: *mut net_device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __skb_vlan_pop(skb: *mut sk_buff, vlan_tci: *mut u16_) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_vlan_pop(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_vlan_push(skb: *mut sk_buff, vlan_proto: __be16, vlan_tci: u16_)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_eth_pop(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_eth_push(
        skb: *mut sk_buff,
        dst: *const core::ffi::c_uchar,
        src: *const core::ffi::c_uchar,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_mpls_push(
        skb: *mut sk_buff,
        mpls_lse: __be32,
        mpls_proto: __be16,
        mac_len: core::ffi::c_int,
        ethernet: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_mpls_pop(
        skb: *mut sk_buff,
        next_proto: __be16,
        mac_len: core::ffi::c_int,
        ethernet: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_mpls_update_lse(skb: *mut sk_buff, mpls_lse: __be32) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_mpls_dec_ttl(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn pskb_extract(
        skb: *mut sk_buff,
        off: core::ffi::c_int,
        to_copy: core::ffi::c_int,
        gfp: gfp_t,
    ) -> *mut sk_buff;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct skb_checksum_ops {
    pub update: ::core::option::Option<
        unsafe extern "C" fn(
            mem: *const core::ffi::c_void,
            len: core::ffi::c_int,
            wsum: __wsum,
        ) -> __wsum,
    >,
    pub combine: ::core::option::Option<
        unsafe extern "C" fn(
            csum: __wsum,
            csum2: __wsum,
            offset: core::ffi::c_int,
            len: core::ffi::c_int,
        ) -> __wsum,
    >,
}
extern "C" {
    pub static mut crc32c_csum_stub: *const skb_checksum_ops;
}
extern "C" {
    pub fn __skb_checksum(
        skb: *const sk_buff,
        offset: core::ffi::c_int,
        len: core::ffi::c_int,
        csum: __wsum,
        ops: *const skb_checksum_ops,
    ) -> __wsum;
}
extern "C" {
    pub fn skb_checksum(
        skb: *const sk_buff,
        offset: core::ffi::c_int,
        len: core::ffi::c_int,
        csum: __wsum,
    ) -> __wsum;
}
extern "C" {
    pub fn skb_init();
}
extern "C" {
    pub static mut netstamp_needed_key: static_key_false;
}
extern "C" {
    pub fn skb_clone_sk(skb: *mut sk_buff) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_clone_tx_timestamp(skb: *mut sk_buff);
}
extern "C" {
    pub fn skb_defer_rx_timestamp(skb: *mut sk_buff) -> bool_;
}
extern "C" {
    pub fn skb_complete_tx_timestamp(skb: *mut sk_buff, hwtstamps: *mut skb_shared_hwtstamps);
}
extern "C" {
    pub fn __skb_tstamp_tx(
        orig_skb: *mut sk_buff,
        ack_skb: *const sk_buff,
        hwtstamps: *mut skb_shared_hwtstamps,
        sk: *mut sock,
        tstype: core::ffi::c_int,
    );
}
extern "C" {
    pub fn skb_tstamp_tx(orig_skb: *mut sk_buff, hwtstamps: *mut skb_shared_hwtstamps);
}
extern "C" {
    pub fn skb_complete_wifi_ack(skb: *mut sk_buff, acked: bool_);
}
extern "C" {
    pub fn __skb_checksum_complete_head(skb: *mut sk_buff, len: core::ffi::c_int) -> __sum16;
}
extern "C" {
    pub fn __skb_checksum_complete(skb: *mut sk_buff) -> __sum16;
}
pub const skb_ext_id_SKB_EXT_BRIDGE_NF: skb_ext_id = 0;
pub const skb_ext_id_SKB_EXT_SEC_PATH: skb_ext_id = 1;
pub const skb_ext_id_TC_SKB_EXT: skb_ext_id = 2;
pub const skb_ext_id_SKB_EXT_MPTCP: skb_ext_id = 3;
pub const skb_ext_id_SKB_EXT_NUM: skb_ext_id = 4;
pub type skb_ext_id = core::ffi::c_uint;
#[repr(C)]
#[repr(align(8))]
#[derive(Default)]
pub struct skb_ext {
    pub refcnt: refcount_t,
    pub offset: [u8_; 4usize],
    pub chunks: u8_,
    pub __bindgen_padding_0: [u8; 7usize],
    pub data: __IncompleteArrayField<core::ffi::c_char>,
}
extern "C" {
    pub fn __skb_ext_alloc(flags: gfp_t) -> *mut skb_ext;
}
extern "C" {
    pub fn __skb_ext_set(
        skb: *mut sk_buff,
        id: skb_ext_id,
        ext: *mut skb_ext,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn skb_ext_add(skb: *mut sk_buff, id: skb_ext_id) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __skb_ext_del(skb: *mut sk_buff, id: skb_ext_id);
}
extern "C" {
    pub fn __skb_ext_put(ext: *mut skb_ext);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sec_path {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __skb_warn_lro_forwarding(skb: *const sk_buff);
}
extern "C" {
    pub fn skb_partial_csum_set(skb: *mut sk_buff, start: u16_, off: u16_) -> bool_;
}
extern "C" {
    pub fn skb_checksum_setup(skb: *mut sk_buff, recalculate: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_checksum_trimmed(
        skb: *mut sk_buff,
        transport_len: core::ffi::c_uint,
        skb_chkf: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff) -> __sum16>,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_splice_from_iter(
        skb: *mut sk_buff,
        iter: *mut iov_iter,
        maxsize: isize,
        gfp: gfp_t,
    ) -> isize;
}
extern "C" {
    pub fn eth_header_parse(
        skb: *const sk_buff,
        haddr: *mut core::ffi::c_uchar,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_format_mac(
        buf: *mut core::ffi::c_char,
        addr: *const core::ffi::c_uchar,
        len: core::ffi::c_int,
    ) -> isize;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockptr_t {
    pub __bindgen_anon_1: sockptr_t__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sockptr_t__bindgen_ty_1 {
    pub kernel: *mut core::ffi::c_void,
    pub user: *mut core::ffi::c_void,
}
impl Default for sockptr_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sockptr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sockptr_t {
    #[inline]
    pub fn is_kernel(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_kernel(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_kernel: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_kernel: u8 = unsafe { ::core::mem::transmute(is_kernel) };
            is_kernel as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const socket_state_SS_FREE: socket_state = 0;
pub const socket_state_SS_UNCONNECTED: socket_state = 1;
pub const socket_state_SS_CONNECTING: socket_state = 2;
pub const socket_state_SS_CONNECTED: socket_state = 3;
pub const socket_state_SS_DISCONNECTING: socket_state = 4;
pub type socket_state = core::ffi::c_uint;
pub const sock_type_SOCK_STREAM: sock_type = 1;
pub const sock_type_SOCK_DGRAM: sock_type = 2;
pub const sock_type_SOCK_RAW: sock_type = 3;
pub const sock_type_SOCK_RDM: sock_type = 4;
pub const sock_type_SOCK_SEQPACKET: sock_type = 5;
pub const sock_type_SOCK_DCCP: sock_type = 6;
pub const sock_type_SOCK_PACKET: sock_type = 10;
pub type sock_type = core::ffi::c_uint;
pub const sock_shutdown_cmd_SHUT_RD: sock_shutdown_cmd = 0;
pub const sock_shutdown_cmd_SHUT_WR: sock_shutdown_cmd = 1;
pub const sock_shutdown_cmd_SHUT_RDWR: sock_shutdown_cmd = 2;
pub type sock_shutdown_cmd = core::ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct socket_wq {
    pub wait: wait_queue_head_t,
    pub fasync_list: *mut fasync_struct,
    pub flags: core::ffi::c_ulong,
    pub rcu: callback_head,
}
impl Default for socket_wq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct socket {
    pub state: socket_state,
    pub type_: core::ffi::c_short,
    pub flags: core::ffi::c_ulong,
    pub file: *mut file,
    pub sk: *mut sock,
    pub ops: *const proto_ops,
    pub __bindgen_padding_0: [u64; 3usize],
    pub wq: socket_wq,
}
impl Default for socket {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct read_descriptor_t {
    pub written: usize,
    pub count: usize,
    pub arg: read_descriptor_t__bindgen_ty_1,
    pub error: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union read_descriptor_t__bindgen_ty_1 {
    pub buf: *mut core::ffi::c_char,
    pub data: *mut core::ffi::c_void,
}
impl Default for read_descriptor_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for read_descriptor_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sk_read_actor_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut read_descriptor_t,
        arg2: *mut sk_buff,
        arg3: core::ffi::c_uint,
        arg4: usize,
    ) -> core::ffi::c_int,
>;
pub type skb_read_actor_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct proto_ops {
    pub family: core::ffi::c_int,
    pub owner: *mut module,
    pub release:
        ::core::option::Option<unsafe extern "C" fn(sock: *mut socket) -> core::ffi::c_int>,
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            myaddr: *mut sockaddr,
            sockaddr_len: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub connect: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            vaddr: *mut sockaddr,
            sockaddr_len: core::ffi::c_int,
            flags: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub socketpair: ::core::option::Option<
        unsafe extern "C" fn(sock1: *mut socket, sock2: *mut socket) -> core::ffi::c_int,
    >,
    pub accept: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            newsock: *mut socket,
            flags: core::ffi::c_int,
            kern: bool_,
        ) -> core::ffi::c_int,
    >,
    pub getname: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            addr: *mut sockaddr,
            peer: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            sock: *mut socket,
            wait: *mut poll_table_struct,
        ) -> __poll_t,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            cmd: core::ffi::c_uint,
            arg: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            cmd: core::ffi::c_uint,
            arg: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub gettstamp: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            userstamp: *mut core::ffi::c_void,
            timeval: bool_,
            time32: bool_,
        ) -> core::ffi::c_int,
    >,
    pub listen: ::core::option::Option<
        unsafe extern "C" fn(sock: *mut socket, len: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub shutdown: ::core::option::Option<
        unsafe extern "C" fn(sock: *mut socket, flags: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub setsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            level: core::ffi::c_int,
            optname: core::ffi::c_int,
            optval: sockptr_t,
            optlen: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub getsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            level: core::ffi::c_int,
            optname: core::ffi::c_int,
            optval: *mut core::ffi::c_char,
            optlen: *mut core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub show_fdinfo:
        ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, sock: *mut socket)>,
    pub sendmsg: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            m: *mut msghdr,
            total_len: usize,
        ) -> core::ffi::c_int,
    >,
    pub recvmsg: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            m: *mut msghdr,
            total_len: usize,
            flags: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            sock: *mut socket,
            vma: *mut vm_area_struct,
        ) -> core::ffi::c_int,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            ppos: *mut loff_t,
            pipe: *mut pipe_inode_info,
            len: usize,
            flags: core::ffi::c_uint,
        ) -> isize,
    >,
    pub splice_eof: ::core::option::Option<unsafe extern "C" fn(sock: *mut socket)>,
    pub set_peek_off: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, val: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub peek_len:
        ::core::option::Option<unsafe extern "C" fn(sock: *mut socket) -> core::ffi::c_int>,
    pub read_sock: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            desc: *mut read_descriptor_t,
            recv_actor: sk_read_actor_t,
        ) -> core::ffi::c_int,
    >,
    pub read_skb: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, recv_actor: skb_read_actor_t) -> core::ffi::c_int,
    >,
    pub sendmsg_locked: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, msg: *mut msghdr, size: usize) -> core::ffi::c_int,
    >,
    pub set_rcvlowat: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, val: core::ffi::c_int) -> core::ffi::c_int,
    >,
}
impl Default for proto_ops {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_proto_family {
    pub family: core::ffi::c_int,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            sock: *mut socket,
            protocol: core::ffi::c_int,
            kern: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub owner: *mut module,
}
impl Default for net_proto_family {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SOCK_WAKE_IO: _bindgen_ty_109 = 0;
pub const SOCK_WAKE_WAITD: _bindgen_ty_109 = 1;
pub const SOCK_WAKE_SPACE: _bindgen_ty_109 = 2;
pub const SOCK_WAKE_URG: _bindgen_ty_109 = 3;
pub type _bindgen_ty_109 = core::ffi::c_uint;
extern "C" {
    pub fn sock_wake_async(
        sk_wq: *mut socket_wq,
        how: core::ffi::c_int,
        band: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_register(fam: *const net_proto_family) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_unregister(family: core::ffi::c_int);
}
extern "C" {
    pub fn sock_is_registered(family: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn __sock_create(
        net: *mut net,
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        proto: core::ffi::c_int,
        res: *mut *mut socket,
        kern: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_create(
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        proto: core::ffi::c_int,
        res: *mut *mut socket,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_create_kern(
        net: *mut net,
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        proto: core::ffi::c_int,
        res: *mut *mut socket,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_create_lite(
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        proto: core::ffi::c_int,
        res: *mut *mut socket,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_alloc() -> *mut socket;
}
extern "C" {
    pub fn sock_release(sock: *mut socket);
}
extern "C" {
    pub fn sock_sendmsg(sock: *mut socket, msg: *mut msghdr) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_recvmsg(
        sock: *mut socket,
        msg: *mut msghdr,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_alloc_file(
        sock: *mut socket,
        flags: core::ffi::c_int,
        dname: *const core::ffi::c_char,
    ) -> *mut file;
}
extern "C" {
    pub fn sockfd_lookup(fd: core::ffi::c_int, err: *mut core::ffi::c_int) -> *mut socket;
}
extern "C" {
    pub fn sock_from_file(file: *mut file) -> *mut socket;
}
extern "C" {
    pub fn net_ratelimit() -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_sendmsg(
        sock: *mut socket,
        msg: *mut msghdr,
        vec: *mut kvec,
        num: usize,
        len: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_sendmsg_locked(
        sk: *mut sock,
        msg: *mut msghdr,
        vec: *mut kvec,
        num: usize,
        len: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_recvmsg(
        sock: *mut socket,
        msg: *mut msghdr,
        vec: *mut kvec,
        num: usize,
        len: usize,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_bind(
        sock: *mut socket,
        addr: *mut sockaddr,
        addrlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_listen(sock: *mut socket, backlog: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_accept(
        sock: *mut socket,
        newsock: *mut *mut socket,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_connect(
        sock: *mut socket,
        addr: *mut sockaddr,
        addrlen: core::ffi::c_int,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_getsockname(sock: *mut socket, addr: *mut sockaddr) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_getpeername(sock: *mut socket, addr: *mut sockaddr) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_sock_shutdown(sock: *mut socket, how: sock_shutdown_cmd) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_sock_ip_overhead(sk: *mut sock) -> u32_;
}
extern "C" {
    pub fn fput(arg1: *mut file);
}
extern "C" {
    pub fn alloc_file_pseudo(
        arg1: *mut inode,
        arg2: *mut vfsmount,
        arg3: *const core::ffi::c_char,
        flags: core::ffi::c_int,
        arg4: *const file_operations,
    ) -> *mut file;
}
extern "C" {
    pub fn alloc_file_clone(
        arg1: *mut file,
        flags: core::ffi::c_int,
        arg2: *const file_operations,
    ) -> *mut file;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fd {
    pub file: *mut file,
    pub flags: core::ffi::c_uint,
}
impl Default for fd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn fget(fd: core::ffi::c_uint) -> *mut file;
}
extern "C" {
    pub fn fget_raw(fd: core::ffi::c_uint) -> *mut file;
}
extern "C" {
    pub fn fget_task(task: *mut task_struct, fd: core::ffi::c_uint) -> *mut file;
}
extern "C" {
    pub fn __fdget(fd: core::ffi::c_uint) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __fdget_raw(fd: core::ffi::c_uint) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __fdget_pos(fd: core::ffi::c_uint) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __f_unlock_pos(arg1: *mut file);
}
pub type class_fd_t = fd;
extern "C" {
    pub fn f_dupfd(
        from: core::ffi::c_uint,
        file: *mut file,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn replace_fd(
        fd: core::ffi::c_uint,
        file: *mut file,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_close_on_exec(fd: core::ffi::c_uint, flag: core::ffi::c_int);
}
extern "C" {
    pub fn get_close_on_exec(fd: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn __get_unused_fd_flags(
        flags: core::ffi::c_uint,
        nofile: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_unused_fd_flags(flags: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_unused_fd(fd: core::ffi::c_uint);
}
pub type class_get_unused_fd_t = core::ffi::c_int;
extern "C" {
    pub fn fd_install(fd: core::ffi::c_uint, file: *mut file);
}
extern "C" {
    pub fn receive_fd(
        file: *mut file,
        ufd: *mut core::ffi::c_int,
        o_flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn receive_fd_replace(
        new_fd: core::ffi::c_int,
        file: *mut file,
        o_flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn flush_delayed_fput();
}
extern "C" {
    pub fn __fput_sync(arg1: *mut file);
}
extern "C" {
    pub static mut sysctl_nr_open_min: core::ffi::c_uint;
}
extern "C" {
    pub static mut sysctl_nr_open_max: core::ffi::c_uint;
}
pub const kernel_read_file_id_READING_UNKNOWN: kernel_read_file_id = 0;
pub const kernel_read_file_id_READING_FIRMWARE: kernel_read_file_id = 1;
pub const kernel_read_file_id_READING_MODULE: kernel_read_file_id = 2;
pub const kernel_read_file_id_READING_KEXEC_IMAGE: kernel_read_file_id = 3;
pub const kernel_read_file_id_READING_KEXEC_INITRAMFS: kernel_read_file_id = 4;
pub const kernel_read_file_id_READING_POLICY: kernel_read_file_id = 5;
pub const kernel_read_file_id_READING_X509_CERTIFICATE: kernel_read_file_id = 6;
pub const kernel_read_file_id_READING_MAX_ID: kernel_read_file_id = 7;
pub type kernel_read_file_id = core::ffi::c_uint;
extern "C" {
    pub static kernel_read_file_str: [*const core::ffi::c_char; 8usize];
}
extern "C" {
    pub fn kernel_read_file(
        file: *mut file,
        offset: loff_t,
        buf: *mut *mut core::ffi::c_void,
        buf_size: usize,
        file_size: *mut usize,
        id: kernel_read_file_id,
    ) -> isize;
}
extern "C" {
    pub fn kernel_read_file_from_path(
        path: *const core::ffi::c_char,
        offset: loff_t,
        buf: *mut *mut core::ffi::c_void,
        buf_size: usize,
        file_size: *mut usize,
        id: kernel_read_file_id,
    ) -> isize;
}
extern "C" {
    pub fn kernel_read_file_from_path_initns(
        path: *const core::ffi::c_char,
        offset: loff_t,
        buf: *mut *mut core::ffi::c_void,
        buf_size: usize,
        file_size: *mut usize,
        id: kernel_read_file_id,
    ) -> isize;
}
extern "C" {
    pub fn kernel_read_file_from_fd(
        fd: core::ffi::c_int,
        offset: loff_t,
        buf: *mut *mut core::ffi::c_void,
        buf_size: usize,
        file_size: *mut usize,
        id: kernel_read_file_id,
    ) -> isize;
}
#[repr(C)]
#[derive(Default)]
pub struct lsm_ctx {
    pub id: __u64,
    pub flags: __u64,
    pub len: __u64,
    pub ctx_len: __u64,
    pub ctx: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lsmblob_selinux {
    pub secid: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct smack_known {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lsmblob_smack {
    pub skp: *mut smack_known,
}
impl Default for lsmblob_smack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aa_label {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lsmblob_apparmor {
    pub label: *mut aa_label,
}
impl Default for lsmblob_apparmor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lsmblob_bpf {
    pub secid: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msg_msg {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_sec_ctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_parameter {
    _unused: [u8; 0],
}
pub type fs_value_type = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct watch {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct watch_notification {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_krule {
    _unused: [u8; 0],
}
pub const lsm_event_LSM_POLICY_CHANGE: lsm_event = 0;
pub type lsm_event = core::ffi::c_uint;
pub const lockdown_reason_LOCKDOWN_NONE: lockdown_reason = 0;
pub const lockdown_reason_LOCKDOWN_MODULE_SIGNATURE: lockdown_reason = 1;
pub const lockdown_reason_LOCKDOWN_DEV_MEM: lockdown_reason = 2;
pub const lockdown_reason_LOCKDOWN_EFI_TEST: lockdown_reason = 3;
pub const lockdown_reason_LOCKDOWN_KEXEC: lockdown_reason = 4;
pub const lockdown_reason_LOCKDOWN_HIBERNATION: lockdown_reason = 5;
pub const lockdown_reason_LOCKDOWN_PCI_ACCESS: lockdown_reason = 6;
pub const lockdown_reason_LOCKDOWN_IOPORT: lockdown_reason = 7;
pub const lockdown_reason_LOCKDOWN_MSR: lockdown_reason = 8;
pub const lockdown_reason_LOCKDOWN_ACPI_TABLES: lockdown_reason = 9;
pub const lockdown_reason_LOCKDOWN_DEVICE_TREE: lockdown_reason = 10;
pub const lockdown_reason_LOCKDOWN_PCMCIA_CIS: lockdown_reason = 11;
pub const lockdown_reason_LOCKDOWN_TIOCSSERIAL: lockdown_reason = 12;
pub const lockdown_reason_LOCKDOWN_MODULE_PARAMETERS: lockdown_reason = 13;
pub const lockdown_reason_LOCKDOWN_MMIOTRACE: lockdown_reason = 14;
pub const lockdown_reason_LOCKDOWN_DEBUGFS: lockdown_reason = 15;
pub const lockdown_reason_LOCKDOWN_XMON_WR: lockdown_reason = 16;
pub const lockdown_reason_LOCKDOWN_BPF_WRITE_USER: lockdown_reason = 17;
pub const lockdown_reason_LOCKDOWN_DBG_WRITE_KERNEL: lockdown_reason = 18;
pub const lockdown_reason_LOCKDOWN_RTAS_ERROR_INJECTION: lockdown_reason = 19;
pub const lockdown_reason_LOCKDOWN_INTEGRITY_MAX: lockdown_reason = 20;
pub const lockdown_reason_LOCKDOWN_KCORE: lockdown_reason = 21;
pub const lockdown_reason_LOCKDOWN_KPROBES: lockdown_reason = 22;
pub const lockdown_reason_LOCKDOWN_BPF_READ_KERNEL: lockdown_reason = 23;
pub const lockdown_reason_LOCKDOWN_DBG_READ_KERNEL: lockdown_reason = 24;
pub const lockdown_reason_LOCKDOWN_PERF: lockdown_reason = 25;
pub const lockdown_reason_LOCKDOWN_TRACEFS: lockdown_reason = 26;
pub const lockdown_reason_LOCKDOWN_XMON_RW: lockdown_reason = 27;
pub const lockdown_reason_LOCKDOWN_XFRM_SECRET: lockdown_reason = 28;
pub const lockdown_reason_LOCKDOWN_CONFIDENTIALITY_MAX: lockdown_reason = 29;
pub type lockdown_reason = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lsmcontext {
    pub context: *mut core::ffi::c_char,
    pub len: u32_,
    pub id: core::ffi::c_int,
}
impl Default for lsmcontext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lsmblob {
    pub selinux: lsmblob_selinux,
    pub smack: lsmblob_smack,
    pub apparmor: lsmblob_apparmor,
    pub bpf: lsmblob_bpf,
}
impl Default for lsmblob {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static lockdown_reasons: [*const core::ffi::c_char; 30usize];
}
extern "C" {
    pub static mut lsm_active_cnt: u32_;
}
extern "C" {
    pub static mut lsm_blob_cnt: u32_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lsm_id {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut lsm_idlist: [*const lsm_id; 0usize];
}
extern "C" {
    pub fn cap_capable(
        cred: *const cred,
        ns: *mut user_namespace,
        cap: core::ffi::c_int,
        opts: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_settime(ts: *const timespec64, tz: *const timezone) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_ptrace_access_check(
        child: *mut task_struct,
        mode: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_ptrace_traceme(parent: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_capget(
        target: *const task_struct,
        effective: *mut kernel_cap_t,
        inheritable: *mut kernel_cap_t,
        permitted: *mut kernel_cap_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_capset(
        new: *mut cred,
        old: *const cred,
        effective: *const kernel_cap_t,
        inheritable: *const kernel_cap_t,
        permitted: *const kernel_cap_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_bprm_creds_from_file(bprm: *mut linux_binprm, file: *const file)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_inode_setxattr(
        dentry: *mut dentry,
        name: *const core::ffi::c_char,
        value: *const core::ffi::c_void,
        size: usize,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_inode_removexattr(
        idmap: *mut mnt_idmap,
        dentry: *mut dentry,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_inode_need_killpriv(dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_inode_killpriv(idmap: *mut mnt_idmap, dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_inode_getsecurity(
        idmap: *mut mnt_idmap,
        inode: *mut inode,
        name: *const core::ffi::c_char,
        buffer: *mut *mut core::ffi::c_void,
        alloc: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_mmap_addr(addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_mmap_file(
        file: *mut file,
        reqprot: core::ffi::c_ulong,
        prot: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_task_fix_setuid(
        new: *mut cred,
        old: *const cred,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_task_prctl(
        option: core::ffi::c_int,
        arg2: core::ffi::c_ulong,
        arg3: core::ffi::c_ulong,
        arg4: core::ffi::c_ulong,
        arg5: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_task_setscheduler(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_task_setioprio(p: *mut task_struct, ioprio: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_task_setnice(p: *mut task_struct, nice: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_vm_enough_memory(mm: *mut mm_struct, pages: core::ffi::c_long) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_selector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_policy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_user_sec_ctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_association {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut mmap_min_addr: core::ffi::c_ulong;
}
extern "C" {
    pub static mut dac_mmap_min_addr: core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request_sock {
    _unused: [u8; 0],
}
extern "C" {
    pub fn mmap_min_addr_handler(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
pub type initxattrs = ::core::option::Option<
    unsafe extern "C" fn(
        inode: *mut inode,
        xattr_array: *const xattr,
        fs_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
pub const kernel_load_data_id_LOADING_UNKNOWN: kernel_load_data_id = 0;
pub const kernel_load_data_id_LOADING_FIRMWARE: kernel_load_data_id = 1;
pub const kernel_load_data_id_LOADING_MODULE: kernel_load_data_id = 2;
pub const kernel_load_data_id_LOADING_KEXEC_IMAGE: kernel_load_data_id = 3;
pub const kernel_load_data_id_LOADING_KEXEC_INITRAMFS: kernel_load_data_id = 4;
pub const kernel_load_data_id_LOADING_POLICY: kernel_load_data_id = 5;
pub const kernel_load_data_id_LOADING_X509_CERTIFICATE: kernel_load_data_id = 6;
pub const kernel_load_data_id_LOADING_MAX_ID: kernel_load_data_id = 7;
pub type kernel_load_data_id = core::ffi::c_uint;
extern "C" {
    pub static kernel_load_data_str: [*const core::ffi::c_char; 8usize];
}
extern "C" {
    pub fn call_blocking_lsm_notifier(
        event: lsm_event,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn register_blocking_lsm_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_blocking_lsm_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn early_security_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn lsm_name_to_attr(name: *const core::ffi::c_char) -> u64_;
}
extern "C" {
    pub fn lsm_name_to_id(name: *const core::ffi::c_char) -> u64_;
}
extern "C" {
    pub fn lsm_id_to_name(id: u64_) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn security_binder_set_context_mgr(mgr: *const cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_binder_transaction(from: *const cred, to: *const cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_binder_transfer_binder(from: *const cred, to: *const cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_binder_transfer_file(
        from: *const cred,
        to: *const cred,
        file: *const file,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_ptrace_access_check(
        child: *mut task_struct,
        mode: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_ptrace_traceme(parent: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_capget(
        target: *const task_struct,
        effective: *mut kernel_cap_t,
        inheritable: *mut kernel_cap_t,
        permitted: *mut kernel_cap_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_capset(
        new: *mut cred,
        old: *const cred,
        effective: *const kernel_cap_t,
        inheritable: *const kernel_cap_t,
        permitted: *const kernel_cap_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_capable(
        cred: *const cred,
        ns: *mut user_namespace,
        cap: core::ffi::c_int,
        opts: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_quotactl(
        cmds: core::ffi::c_int,
        type_: core::ffi::c_int,
        id: core::ffi::c_int,
        sb: *const super_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_quota_on(dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_syslog(type_: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_settime64(ts: *const timespec64, tz: *const timezone) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_vm_enough_memory_mm(
        mm: *mut mm_struct,
        pages: core::ffi::c_long,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bprm_creds_for_exec(bprm: *mut linux_binprm) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bprm_creds_from_file(
        bprm: *mut linux_binprm,
        file: *const file,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bprm_check(bprm: *mut linux_binprm) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bprm_committing_creds(bprm: *const linux_binprm);
}
extern "C" {
    pub fn security_bprm_committed_creds(bprm: *const linux_binprm);
}
extern "C" {
    pub fn security_fs_context_submount(
        fc: *mut fs_context,
        reference: *mut super_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_fs_context_dup(
        fc: *mut fs_context,
        src_fc: *mut fs_context,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_fs_context_parse_param(
        fc: *mut fs_context,
        param: *mut fs_parameter,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_alloc(sb: *mut super_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_delete(sb: *mut super_block);
}
extern "C" {
    pub fn security_sb_free(sb: *mut super_block);
}
extern "C" {
    pub fn security_free_mnt_opts(mnt_opts: *mut *mut core::ffi::c_void);
}
extern "C" {
    pub fn security_sb_eat_lsm_opts(
        options: *mut core::ffi::c_char,
        mnt_opts: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_mnt_opts_compat(
        sb: *mut super_block,
        mnt_opts: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_remount(
        sb: *mut super_block,
        mnt_opts: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_kern_mount(sb: *const super_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_show_options(m: *mut seq_file, sb: *mut super_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_statfs(dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_mount(
        dev_name: *const core::ffi::c_char,
        path: *const path,
        type_: *const core::ffi::c_char,
        flags: core::ffi::c_ulong,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_umount(mnt: *mut vfsmount, flags: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_pivotroot(old_path: *const path, new_path: *const path) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_set_mnt_opts(
        sb: *mut super_block,
        mnt_opts: *mut core::ffi::c_void,
        kern_flags: core::ffi::c_ulong,
        set_kern_flags: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_clone_mnt_opts(
        oldsb: *const super_block,
        newsb: *mut super_block,
        kern_flags: core::ffi::c_ulong,
        set_kern_flags: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_move_mount(from_path: *const path, to_path: *const path) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_dentry_init_security(
        dentry: *mut dentry,
        mode: core::ffi::c_int,
        name: *const qstr,
        xattr_name: *mut *const core::ffi::c_char,
        lsmcxt: *mut lsmcontext,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_dentry_create_files_as(
        dentry: *mut dentry,
        mode: core::ffi::c_int,
        name: *mut qstr,
        old: *const cred,
        new: *mut cred,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_notify(
        path: *const path,
        mask: u64_,
        obj_type: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_alloc(inode: *mut inode) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_free(inode: *mut inode);
}
extern "C" {
    pub fn security_inode_init_security(
        inode: *mut inode,
        dir: *mut inode,
        qstr: *const qstr,
        initxattrs: initxattrs,
        fs_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_init_security_anon(
        inode: *mut inode,
        name: *const qstr,
        context_inode: *const inode,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_create(
        dir: *mut inode,
        dentry: *mut dentry,
        mode: umode_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_link(
        old_dentry: *mut dentry,
        dir: *mut inode,
        new_dentry: *mut dentry,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_unlink(dir: *mut inode, dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_symlink(
        dir: *mut inode,
        dentry: *mut dentry,
        old_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_mkdir(
        dir: *mut inode,
        dentry: *mut dentry,
        mode: umode_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_rmdir(dir: *mut inode, dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_mknod(
        dir: *mut inode,
        dentry: *mut dentry,
        mode: umode_t,
        dev: dev_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_rename(
        old_dir: *mut inode,
        old_dentry: *mut dentry,
        new_dir: *mut inode,
        new_dentry: *mut dentry,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_readlink(dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_follow_link(
        dentry: *mut dentry,
        inode: *mut inode,
        rcu: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_permission(inode: *mut inode, mask: core::ffi::c_int)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_setattr(
        idmap: *mut mnt_idmap,
        dentry: *mut dentry,
        attr: *mut iattr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_getattr(path: *const path) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_setxattr(
        idmap: *mut mnt_idmap,
        dentry: *mut dentry,
        name: *const core::ffi::c_char,
        value: *const core::ffi::c_void,
        size: usize,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_set_acl(
        idmap: *mut mnt_idmap,
        dentry: *mut dentry,
        acl_name: *const core::ffi::c_char,
        kacl: *mut posix_acl,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_get_acl(
        idmap: *mut mnt_idmap,
        dentry: *mut dentry,
        acl_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_remove_acl(
        idmap: *mut mnt_idmap,
        dentry: *mut dentry,
        acl_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_post_setxattr(
        dentry: *mut dentry,
        name: *const core::ffi::c_char,
        value: *const core::ffi::c_void,
        size: usize,
        flags: core::ffi::c_int,
    );
}
extern "C" {
    pub fn security_inode_getxattr(
        dentry: *mut dentry,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_listxattr(dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_removexattr(
        idmap: *mut mnt_idmap,
        dentry: *mut dentry,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_need_killpriv(dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_killpriv(idmap: *mut mnt_idmap, dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_getsecurity(
        idmap: *mut mnt_idmap,
        inode: *mut inode,
        name: *const core::ffi::c_char,
        buffer: *mut *mut core::ffi::c_void,
        alloc: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_setsecurity(
        inode: *mut inode,
        name: *const core::ffi::c_char,
        value: *const core::ffi::c_void,
        size: usize,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_listsecurity(
        inode: *mut inode,
        buffer: *mut core::ffi::c_char,
        buffer_size: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_getlsmblob(inode: *mut inode, blob: *mut lsmblob);
}
extern "C" {
    pub fn security_inode_copy_up(src: *mut dentry, new: *mut *mut cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_copy_up_xattr(name: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_kernfs_init_security(
        kn_dir: *mut kernfs_node,
        kn: *mut kernfs_node,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_permission(file: *mut file, mask: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_alloc(file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_free(file: *mut file);
}
extern "C" {
    pub fn security_file_ioctl(
        file: *mut file,
        cmd: core::ffi::c_uint,
        arg: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_ioctl_compat(
        file: *mut file,
        cmd: core::ffi::c_uint,
        arg: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_mmap_file(
        file: *mut file,
        prot: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_mmap_addr(addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_mprotect(
        vma: *mut vm_area_struct,
        reqprot: core::ffi::c_ulong,
        prot: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_lock(file: *mut file, cmd: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_fcntl(
        file: *mut file,
        cmd: core::ffi::c_uint,
        arg: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_set_fowner(file: *mut file);
}
extern "C" {
    pub fn security_file_send_sigiotask(
        tsk: *mut task_struct,
        fown: *mut fown_struct,
        sig: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_receive(file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_open(file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_truncate(file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_alloc(
        task: *mut task_struct,
        clone_flags: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_free(task: *mut task_struct);
}
extern "C" {
    pub fn security_cred_alloc_blank(cred: *mut cred, gfp: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_cred_free(cred: *mut cred);
}
extern "C" {
    pub fn security_prepare_creds(new: *mut cred, old: *const cred, gfp: gfp_t)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn security_transfer_creds(new: *mut cred, old: *const cred);
}
extern "C" {
    pub fn security_cred_getsecid(c: *const cred, secid: *mut u32_);
}
extern "C" {
    pub fn security_cred_getlsmblob(c: *const cred, blob: *mut lsmblob);
}
extern "C" {
    pub fn security_kernel_act_as(new: *mut cred, secid: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_kernel_create_files_as(new: *mut cred, inode: *mut inode) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_kernel_module_request(kmod_name: *mut core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_kernel_load_data(id: kernel_load_data_id, contents: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_kernel_post_load_data(
        buf: *mut core::ffi::c_char,
        size: loff_t,
        id: kernel_load_data_id,
        description: *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_kernel_read_file(
        file: *mut file,
        id: kernel_read_file_id,
        contents: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_kernel_post_read_file(
        file: *mut file,
        buf: *mut core::ffi::c_char,
        size: loff_t,
        id: kernel_read_file_id,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_fix_setuid(
        new: *mut cred,
        old: *const cred,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_fix_setgid(
        new: *mut cred,
        old: *const cred,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_fix_setgroups(new: *mut cred, old: *const cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_setpgid(p: *mut task_struct, pgid: pid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_getpgid(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_getsid(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_current_getlsmblob_subj(blob: *mut lsmblob);
}
extern "C" {
    pub fn security_task_getlsmblob_obj(p: *mut task_struct, blob: *mut lsmblob);
}
extern "C" {
    pub fn security_task_setnice(p: *mut task_struct, nice: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_setioprio(
        p: *mut task_struct,
        ioprio: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_getioprio(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_prlimit(
        cred: *const cred,
        tcred: *const cred,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_setrlimit(
        p: *mut task_struct,
        resource: core::ffi::c_uint,
        new_rlim: *mut rlimit,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_setscheduler(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_getscheduler(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_movememory(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_kill(
        p: *mut task_struct,
        info: *mut kernel_siginfo,
        sig: core::ffi::c_int,
        cred: *const cred,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_prctl(
        option: core::ffi::c_int,
        arg2: core::ffi::c_ulong,
        arg3: core::ffi::c_ulong,
        arg4: core::ffi::c_ulong,
        arg5: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_to_inode(p: *mut task_struct, inode: *mut inode);
}
extern "C" {
    pub fn security_create_user_ns(cred: *const cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_ipc_permission(
        ipcp: *mut kern_ipc_perm,
        flag: core::ffi::c_short,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_ipc_getlsmblob(ipcp: *mut kern_ipc_perm, blob: *mut lsmblob);
}
extern "C" {
    pub fn security_msg_msg_alloc(msg: *mut msg_msg) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_msg_msg_free(msg: *mut msg_msg);
}
extern "C" {
    pub fn security_msg_queue_alloc(msq: *mut kern_ipc_perm) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_msg_queue_free(msq: *mut kern_ipc_perm);
}
extern "C" {
    pub fn security_msg_queue_associate(
        msq: *mut kern_ipc_perm,
        msqflg: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_msg_queue_msgctl(
        msq: *mut kern_ipc_perm,
        cmd: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_msg_queue_msgsnd(
        msq: *mut kern_ipc_perm,
        msg: *mut msg_msg,
        msqflg: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_msg_queue_msgrcv(
        msq: *mut kern_ipc_perm,
        msg: *mut msg_msg,
        target: *mut task_struct,
        type_: core::ffi::c_long,
        mode: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_shm_alloc(shp: *mut kern_ipc_perm) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_shm_free(shp: *mut kern_ipc_perm);
}
extern "C" {
    pub fn security_shm_associate(
        shp: *mut kern_ipc_perm,
        shmflg: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_shm_shmctl(shp: *mut kern_ipc_perm, cmd: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_shm_shmat(
        shp: *mut kern_ipc_perm,
        shmaddr: *mut core::ffi::c_char,
        shmflg: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sem_alloc(sma: *mut kern_ipc_perm) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sem_free(sma: *mut kern_ipc_perm);
}
extern "C" {
    pub fn security_sem_associate(
        sma: *mut kern_ipc_perm,
        semflg: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sem_semctl(sma: *mut kern_ipc_perm, cmd: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sem_semop(
        sma: *mut kern_ipc_perm,
        sops: *mut sembuf,
        nsops: core::ffi::c_uint,
        alter: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_d_instantiate(dentry: *mut dentry, inode: *mut inode);
}
extern "C" {
    pub fn security_getselfattr(
        attr: core::ffi::c_uint,
        ctx: *mut lsm_ctx,
        size: *mut u32_,
        flags: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_setselfattr(
        attr: core::ffi::c_uint,
        ctx: *mut lsm_ctx,
        size: u32_,
        flags: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_getprocattr(
        p: *mut task_struct,
        lsmid: core::ffi::c_int,
        name: *const core::ffi::c_char,
        value: *mut *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_setprocattr(
        lsmid: core::ffi::c_int,
        name: *const core::ffi::c_char,
        value: *mut core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_netlink_send(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_ismaclabel(name: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_secid_to_secctx(secid: u32_, cp: *mut lsmcontext) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_lsmblob_to_secctx(
        blob: *mut lsmblob,
        cp: *mut lsmcontext,
        lsmid: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_secctx_to_secid(
        secdata: *const core::ffi::c_char,
        seclen: u32_,
        secid: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_release_secctx(cp: *mut lsmcontext);
}
extern "C" {
    pub fn security_inode_invalidate_secctx(inode: *mut inode);
}
extern "C" {
    pub fn security_inode_notifysecctx(
        inode: *mut inode,
        ctx: *mut core::ffi::c_void,
        ctxlen: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_setsecctx(
        dentry: *mut dentry,
        ctx: *mut core::ffi::c_void,
        ctxlen: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_getsecctx(inode: *mut inode, cp: *mut lsmcontext) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_locked_down(what: lockdown_reason) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_lock_kernel_down(
        where_: *const core::ffi::c_char,
        level: lockdown_reason,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lsm_fill_user_ctx(
        uctx: *mut lsm_ctx,
        uctx_len: *mut u32_,
        val: *mut core::ffi::c_void,
        val_len: usize,
        id: u64_,
        flags: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_post_notification(
        w_cred: *const cred,
        cred: *const cred,
        n: *mut watch_notification,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_watch_key(key: *mut key) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_unix_stream_connect(
        sock: *mut sock,
        other: *mut sock,
        newsk: *mut sock,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_unix_may_send(sock: *mut socket, other: *mut socket) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_create(
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        protocol: core::ffi::c_int,
        kern: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_post_create(
        sock: *mut socket,
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        protocol: core::ffi::c_int,
        kern: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_socketpair(socka: *mut socket, sockb: *mut socket) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_bind(
        sock: *mut socket,
        address: *mut sockaddr,
        addrlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_connect(
        sock: *mut socket,
        address: *mut sockaddr,
        addrlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_listen(sock: *mut socket, backlog: core::ffi::c_int)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_accept(sock: *mut socket, newsock: *mut socket) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_sendmsg(
        sock: *mut socket,
        msg: *mut msghdr,
        size: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_recvmsg(
        sock: *mut socket,
        msg: *mut msghdr,
        size: core::ffi::c_int,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_getsockname(sock: *mut socket) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_getpeername(sock: *mut socket) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_getsockopt(
        sock: *mut socket,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_setsockopt(
        sock: *mut socket,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_shutdown(sock: *mut socket, how: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sock_rcv_skb(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_getpeersec_stream(
        sock: *mut socket,
        optval: sockptr_t,
        optlen: sockptr_t,
        len: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_getpeersec_dgram(
        sock: *mut socket,
        skb: *mut sk_buff,
        secid: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sk_alloc(
        sk: *mut sock,
        family: core::ffi::c_int,
        priority: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sk_free(sk: *mut sock);
}
extern "C" {
    pub fn security_sk_clone(sk: *const sock, newsk: *mut sock);
}
extern "C" {
    pub fn security_sk_classify_flow(sk: *const sock, flic: *mut flowi_common);
}
extern "C" {
    pub fn security_req_classify_flow(req: *const request_sock, flic: *mut flowi_common);
}
extern "C" {
    pub fn security_sock_graft(sk: *mut sock, parent: *mut socket);
}
extern "C" {
    pub fn security_inet_conn_request(
        sk: *const sock,
        skb: *mut sk_buff,
        req: *mut request_sock,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inet_csk_clone(newsk: *mut sock, req: *const request_sock);
}
extern "C" {
    pub fn security_inet_conn_established(sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn security_secmark_relabel_packet(secid: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_secmark_refcount_inc();
}
extern "C" {
    pub fn security_secmark_refcount_dec();
}
extern "C" {
    pub fn security_tun_dev_alloc_security(
        security: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_tun_dev_free_security(security: *mut core::ffi::c_void);
}
extern "C" {
    pub fn security_tun_dev_create() -> core::ffi::c_int;
}
extern "C" {
    pub fn security_tun_dev_attach_queue(security: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_tun_dev_attach(
        sk: *mut sock,
        security: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_tun_dev_open(security: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sctp_assoc_request(
        asoc: *mut sctp_association,
        skb: *mut sk_buff,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sctp_bind_connect(
        sk: *mut sock,
        optname: core::ffi::c_int,
        address: *mut sockaddr,
        addrlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sctp_sk_clone(asoc: *mut sctp_association, sk: *mut sock, newsk: *mut sock);
}
extern "C" {
    pub fn security_sctp_assoc_established(
        asoc: *mut sctp_association,
        skb: *mut sk_buff,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_mptcp_add_subflow(sk: *mut sock, ssk: *mut sock) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_ib_pkey_access(
        sec: *mut core::ffi::c_void,
        subnet_prefix: u64_,
        pkey: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_ib_endport_manage_subnet(
        sec: *mut core::ffi::c_void,
        name: *const core::ffi::c_char,
        port_num: u8_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_ib_alloc_security(sec: *mut *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_ib_free_security(sec: *mut core::ffi::c_void);
}
extern "C" {
    pub fn security_xfrm_policy_alloc(
        ctxp: *mut *mut xfrm_sec_ctx,
        sec_ctx: *mut xfrm_user_sec_ctx,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_xfrm_policy_clone(
        old_ctx: *mut xfrm_sec_ctx,
        new_ctxp: *mut *mut xfrm_sec_ctx,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_xfrm_policy_free(ctx: *mut xfrm_sec_ctx);
}
extern "C" {
    pub fn security_xfrm_policy_delete(ctx: *mut xfrm_sec_ctx) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_xfrm_state_alloc(
        x: *mut xfrm_state,
        sec_ctx: *mut xfrm_user_sec_ctx,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_xfrm_state_alloc_acquire(
        x: *mut xfrm_state,
        polsec: *mut xfrm_sec_ctx,
        secid: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_xfrm_state_delete(x: *mut xfrm_state) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_xfrm_state_free(x: *mut xfrm_state);
}
extern "C" {
    pub fn security_xfrm_policy_lookup(ctx: *mut xfrm_sec_ctx, fl_secid: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_xfrm_state_pol_flow_match(
        x: *mut xfrm_state,
        xp: *mut xfrm_policy,
        flic: *const flowi_common,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_xfrm_decode_session(skb: *mut sk_buff, secid: *mut u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_skb_classify_flow(skb: *mut sk_buff, flic: *mut flowi_common);
}
extern "C" {
    pub fn security_path_unlink(dir: *const path, dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_mkdir(
        dir: *const path,
        dentry: *mut dentry,
        mode: umode_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_rmdir(dir: *const path, dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_mknod(
        dir: *const path,
        dentry: *mut dentry,
        mode: umode_t,
        dev: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_truncate(path: *const path) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_symlink(
        dir: *const path,
        dentry: *mut dentry,
        old_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_link(
        old_dentry: *mut dentry,
        new_dir: *const path,
        new_dentry: *mut dentry,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_rename(
        old_dir: *const path,
        old_dentry: *mut dentry,
        new_dir: *const path,
        new_dentry: *mut dentry,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_chmod(path: *const path, mode: umode_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_chown(path: *const path, uid: kuid_t, gid: kgid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_chroot(path: *const path) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_key_alloc(
        key: *mut key,
        cred: *const cred,
        flags: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_key_free(key: *mut key);
}
extern "C" {
    pub fn security_key_permission(
        key_ref: key_ref_t,
        cred: *const cred,
        need_perm: key_need_perm,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_key_getsecurity(
        key: *mut key,
        _buffer: *mut *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_audit_rule_init(
        field: u32_,
        op: u32_,
        rulestr: *mut core::ffi::c_char,
        lsmrule: *mut *mut core::ffi::c_void,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_audit_rule_known(krule: *mut audit_krule) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_audit_rule_match(
        blob: *mut lsmblob,
        field: u32_,
        op: u32_,
        lsmrule: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_audit_rule_free(lsmrule: *mut core::ffi::c_void);
}
extern "C" {
    pub fn ima_filter_rule_init(
        field: u32_,
        op: u32_,
        rulestr: *mut core::ffi::c_char,
        lsmrule: *mut *mut core::ffi::c_void,
        lsmid: core::ffi::c_int,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ima_filter_rule_match(
        blob: *mut lsmblob,
        field: u32_,
        op: u32_,
        lsmrule: *mut core::ffi::c_void,
        lsmid: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ima_filter_rule_free(lsmrule: *mut core::ffi::c_void, lsmid: core::ffi::c_int);
}
extern "C" {
    pub fn securityfs_create_file(
        name: *const core::ffi::c_char,
        mode: umode_t,
        parent: *mut dentry,
        data: *mut core::ffi::c_void,
        fops: *const file_operations,
    ) -> *mut dentry;
}
extern "C" {
    pub fn securityfs_create_dir(
        name: *const core::ffi::c_char,
        parent: *mut dentry,
    ) -> *mut dentry;
}
extern "C" {
    pub fn securityfs_create_symlink(
        name: *const core::ffi::c_char,
        parent: *mut dentry,
        target: *const core::ffi::c_char,
        iops: *const inode_operations,
    ) -> *mut dentry;
}
extern "C" {
    pub fn securityfs_remove(dentry: *mut dentry);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_map {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_prog_aux {
    _unused: [u8; 0],
}
extern "C" {
    pub fn security_bpf(
        cmd: core::ffi::c_int,
        attr: *mut bpf_attr,
        size: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bpf_map(map: *mut bpf_map, fmode: fmode_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bpf_prog(prog: *mut bpf_prog) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bpf_map_alloc(map: *mut bpf_map) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bpf_map_free(map: *mut bpf_map);
}
extern "C" {
    pub fn security_bpf_prog_alloc(aux: *mut bpf_prog_aux) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bpf_prog_free(aux: *mut bpf_prog_aux);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event_attr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn security_perf_event_open(
        attr: *mut perf_event_attr,
        type_: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_perf_event_alloc(event: *mut perf_event) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_perf_event_free(event: *mut perf_event);
}
extern "C" {
    pub fn security_perf_event_read(event: *mut perf_event) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_perf_event_write(event: *mut perf_event) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_uring_override_creds(new: *const cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_uring_sqpoll() -> core::ffi::c_int;
}
extern "C" {
    pub fn security_uring_cmd(ioucmd: *mut io_uring_cmd) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mnt_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uts_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipc_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsproxy {
    pub count: refcount_t,
    pub uts_ns: *mut uts_namespace,
    pub ipc_ns: *mut ipc_namespace,
    pub mnt_ns: *mut mnt_namespace,
    pub pid_ns_for_children: *mut pid_namespace,
    pub net_ns: *mut net,
    pub time_ns: *mut time_namespace,
    pub time_ns_for_children: *mut time_namespace,
    pub cgroup_ns: *mut cgroup_namespace,
}
impl Default for nsproxy {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut init_nsproxy: nsproxy;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsset {
    pub flags: core::ffi::c_uint,
    pub nsproxy: *mut nsproxy,
    pub fs: *mut fs_struct,
    pub cred: *const cred,
}
impl Default for nsset {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn copy_namespaces(flags: core::ffi::c_ulong, tsk: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn exit_task_namespaces(tsk: *mut task_struct);
}
extern "C" {
    pub fn switch_task_namespaces(tsk: *mut task_struct, new: *mut nsproxy);
}
extern "C" {
    pub fn exec_task_namespaces() -> core::ffi::c_int;
}
extern "C" {
    pub fn free_nsproxy(ns: *mut nsproxy);
}
extern "C" {
    pub fn unshare_nsproxy_namespaces(
        arg1: core::ffi::c_ulong,
        arg2: *mut *mut nsproxy,
        arg3: *mut cred,
        arg4: *mut fs_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn nsproxy_cache_init() -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_msghdr {
    pub msg_name: compat_uptr_t,
    pub msg_namelen: compat_int_t,
    pub msg_iov: compat_uptr_t,
    pub msg_iovlen: compat_size_t,
    pub msg_control: compat_uptr_t,
    pub msg_controllen: compat_size_t,
    pub msg_flags: compat_uint_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_mmsghdr {
    pub msg_hdr: compat_msghdr,
    pub msg_len: compat_uint_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_cmsghdr {
    pub cmsg_len: compat_size_t,
    pub cmsg_level: compat_int_t,
    pub cmsg_type: compat_int_t,
}
#[repr(C)]
pub struct compat_rtentry {
    pub rt_pad1: u32_,
    pub rt_dst: sockaddr,
    pub rt_gateway: sockaddr,
    pub rt_genmask: sockaddr,
    pub rt_flags: core::ffi::c_ushort,
    pub rt_pad2: core::ffi::c_short,
    pub rt_pad3: u32_,
    pub rt_tos: core::ffi::c_uchar,
    pub rt_class: core::ffi::c_uchar,
    pub rt_pad4: core::ffi::c_short,
    pub rt_metric: core::ffi::c_short,
    pub rt_dev: compat_uptr_t,
    pub rt_mtu: u32_,
    pub rt_window: u32_,
    pub rt_irtt: core::ffi::c_ushort,
}
impl Default for compat_rtentry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __get_compat_msghdr(
        kmsg: *mut msghdr,
        msg: *mut compat_msghdr,
        save_addr: *mut *mut sockaddr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_compat_msghdr(
        arg1: *mut msghdr,
        arg2: *mut compat_msghdr,
        arg3: *mut *mut sockaddr,
        arg4: *mut *mut iovec,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_cmsg_compat(
        arg1: *mut msghdr,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_int,
        arg4: core::ffi::c_int,
        arg5: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cmsghdr_from_user_compat_to_kern(
        arg1: *mut msghdr,
        arg2: *mut sock,
        arg3: *mut core::ffi::c_uchar,
        arg4: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct compat_group_req {
    pub gr_interface: __u32,
    pub gr_group: __kernel_sockaddr_storage,
}
impl Default for compat_group_req {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct compat_group_source_req {
    pub gsr_interface: __u32,
    pub gsr_group: __kernel_sockaddr_storage,
    pub gsr_source: __kernel_sockaddr_storage,
}
impl Default for compat_group_source_req {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct compat_group_filter {
    pub __bindgen_anon_1: compat_group_filter__bindgen_ty_1,
}
#[repr(C)]
pub struct compat_group_filter__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<compat_group_filter__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<compat_group_filter__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 67usize],
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct compat_group_filter__bindgen_ty_1__bindgen_ty_1 {
    pub gf_interface_aux: __u32,
    pub gf_group_aux: __kernel_sockaddr_storage,
    pub gf_fmode_aux: __u32,
    pub gf_numsrc_aux: __u32,
    pub gf_slist: [__kernel_sockaddr_storage; 1usize],
}
impl Default for compat_group_filter__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct compat_group_filter__bindgen_ty_1__bindgen_ty_2 {
    pub gf_interface: __u32,
    pub gf_group: __kernel_sockaddr_storage,
    pub gf_fmode: __u32,
    pub gf_numsrc: __u32,
    pub gf_slist_flex: __IncompleteArrayField<__kernel_sockaddr_storage>,
}
impl Default for compat_group_filter__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for compat_group_filter__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for compat_group_filter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct scm_creds {
    pub pid: u32_,
    pub uid: kuid_t,
    pub gid: kgid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct scm_fp_list {
    pub count: core::ffi::c_short,
    pub max: core::ffi::c_short,
    pub user: *mut user_struct,
    pub fp: [*mut file; 253usize],
}
impl Default for scm_fp_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct scm_cookie {
    pub pid: *mut pid,
    pub fp: *mut scm_fp_list,
    pub creds: scm_creds,
    pub secid: u32_,
}
impl Default for scm_cookie {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn scm_detach_fds(msg: *mut msghdr, scm: *mut scm_cookie);
}
extern "C" {
    pub fn scm_detach_fds_compat(msg: *mut msghdr, scm: *mut scm_cookie);
}
extern "C" {
    pub fn __scm_send(
        sock: *mut socket,
        msg: *mut msghdr,
        scm: *mut scm_cookie,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __scm_destroy(scm: *mut scm_cookie);
}
extern "C" {
    pub fn scm_fp_dup(fpl: *mut scm_fp_list) -> *mut scm_fp_list;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sockaddr_nl {
    pub nl_family: __kernel_sa_family_t,
    pub nl_pad: core::ffi::c_ushort,
    pub nl_pid: __u32,
    pub nl_groups: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nlmsghdr {
    pub nlmsg_len: __u32,
    pub nlmsg_type: __u16,
    pub nlmsg_flags: __u16,
    pub nlmsg_seq: __u32,
    pub nlmsg_pid: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nlmsgerr {
    pub error: core::ffi::c_int,
    pub msg: nlmsghdr,
}
pub const nlmsgerr_attrs_NLMSGERR_ATTR_UNUSED: nlmsgerr_attrs = 0;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_MSG: nlmsgerr_attrs = 1;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_OFFS: nlmsgerr_attrs = 2;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_COOKIE: nlmsgerr_attrs = 3;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_POLICY: nlmsgerr_attrs = 4;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_MISS_TYPE: nlmsgerr_attrs = 5;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_MISS_NEST: nlmsgerr_attrs = 6;
pub const nlmsgerr_attrs___NLMSGERR_ATTR_MAX: nlmsgerr_attrs = 7;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_MAX: nlmsgerr_attrs = 6;
pub type nlmsgerr_attrs = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nl_pktinfo {
    pub group: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nl_mmap_req {
    pub nm_block_size: core::ffi::c_uint,
    pub nm_block_nr: core::ffi::c_uint,
    pub nm_frame_size: core::ffi::c_uint,
    pub nm_frame_nr: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nl_mmap_hdr {
    pub nm_status: core::ffi::c_uint,
    pub nm_len: core::ffi::c_uint,
    pub nm_group: __u32,
    pub nm_pid: __u32,
    pub nm_uid: __u32,
    pub nm_gid: __u32,
}
pub const NETLINK_UNCONNECTED: _bindgen_ty_110 = 0;
pub const NETLINK_CONNECTED: _bindgen_ty_110 = 1;
pub type _bindgen_ty_110 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nlattr {
    pub nla_len: __u16,
    pub nla_type: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nla_bitfield32 {
    pub value: __u32,
    pub selector: __u32,
}
pub const netlink_attribute_type_NL_ATTR_TYPE_INVALID: netlink_attribute_type = 0;
pub const netlink_attribute_type_NL_ATTR_TYPE_FLAG: netlink_attribute_type = 1;
pub const netlink_attribute_type_NL_ATTR_TYPE_U8: netlink_attribute_type = 2;
pub const netlink_attribute_type_NL_ATTR_TYPE_U16: netlink_attribute_type = 3;
pub const netlink_attribute_type_NL_ATTR_TYPE_U32: netlink_attribute_type = 4;
pub const netlink_attribute_type_NL_ATTR_TYPE_U64: netlink_attribute_type = 5;
pub const netlink_attribute_type_NL_ATTR_TYPE_S8: netlink_attribute_type = 6;
pub const netlink_attribute_type_NL_ATTR_TYPE_S16: netlink_attribute_type = 7;
pub const netlink_attribute_type_NL_ATTR_TYPE_S32: netlink_attribute_type = 8;
pub const netlink_attribute_type_NL_ATTR_TYPE_S64: netlink_attribute_type = 9;
pub const netlink_attribute_type_NL_ATTR_TYPE_BINARY: netlink_attribute_type = 10;
pub const netlink_attribute_type_NL_ATTR_TYPE_STRING: netlink_attribute_type = 11;
pub const netlink_attribute_type_NL_ATTR_TYPE_NUL_STRING: netlink_attribute_type = 12;
pub const netlink_attribute_type_NL_ATTR_TYPE_NESTED: netlink_attribute_type = 13;
pub const netlink_attribute_type_NL_ATTR_TYPE_NESTED_ARRAY: netlink_attribute_type = 14;
pub const netlink_attribute_type_NL_ATTR_TYPE_BITFIELD32: netlink_attribute_type = 15;
pub const netlink_attribute_type_NL_ATTR_TYPE_SINT: netlink_attribute_type = 16;
pub const netlink_attribute_type_NL_ATTR_TYPE_UINT: netlink_attribute_type = 17;
pub type netlink_attribute_type = core::ffi::c_uint;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_UNSPEC: netlink_policy_type_attr = 0;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_TYPE: netlink_policy_type_attr = 1;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MIN_VALUE_S: netlink_policy_type_attr = 2;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MAX_VALUE_S: netlink_policy_type_attr = 3;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MIN_VALUE_U: netlink_policy_type_attr = 4;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MAX_VALUE_U: netlink_policy_type_attr = 5;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MIN_LENGTH: netlink_policy_type_attr = 6;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MAX_LENGTH: netlink_policy_type_attr = 7;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_POLICY_IDX: netlink_policy_type_attr = 8;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE: netlink_policy_type_attr = 9;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_BITFIELD32_MASK: netlink_policy_type_attr =
    10;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_PAD: netlink_policy_type_attr = 11;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MASK: netlink_policy_type_attr = 12;
pub const netlink_policy_type_attr___NL_POLICY_TYPE_ATTR_MAX: netlink_policy_type_attr = 13;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MAX: netlink_policy_type_attr = 12;
pub type netlink_policy_type_attr = core::ffi::c_uint;
extern "C" {
    pub fn do_trace_netlink_extack(msg: *const core::ffi::c_char);
}
pub const netlink_skb_flags_NETLINK_SKB_DST: netlink_skb_flags = 8;
pub type netlink_skb_flags = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_skb_parms {
    pub creds: scm_creds,
    pub portid: __u32,
    pub dst_group: __u32,
    pub flags: __u32,
    pub sk: *mut sock,
    pub nsid_is_set: bool_,
    pub nsid: core::ffi::c_int,
}
impl Default for netlink_skb_parms {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn netlink_table_grab();
}
extern "C" {
    pub fn netlink_table_ungrab();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_kernel_cfg {
    pub groups: core::ffi::c_uint,
    pub flags: core::ffi::c_uint,
    pub input: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff)>,
    pub cb_mutex: *mut mutex,
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(net: *mut net, group: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub unbind:
        ::core::option::Option<unsafe extern "C" fn(net: *mut net, group: core::ffi::c_int)>,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, groups: *mut core::ffi::c_ulong),
    >,
}
impl Default for netlink_kernel_cfg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __netlink_kernel_create(
        net: *mut net,
        unit: core::ffi::c_int,
        module: *mut module,
        cfg: *mut netlink_kernel_cfg,
    ) -> *mut sock;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_ext_ack {
    pub _msg: *const core::ffi::c_char,
    pub bad_attr: *const nlattr,
    pub policy: *mut nla_policy,
    pub miss_nest: *const nlattr,
    pub miss_type: u16_,
    pub cookie: [u8_; 20usize],
    pub cookie_len: u8_,
    pub _msg_buf: [core::ffi::c_char; 80usize],
}
impl Default for netlink_ext_ack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn netlink_kernel_release(sk: *mut sock);
}
extern "C" {
    pub fn __netlink_change_ngroups(sk: *mut sock, groups: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_change_ngroups(sk: *mut sock, groups: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn __netlink_clear_multicast_users(sk: *mut sock, group: core::ffi::c_uint);
}
extern "C" {
    pub fn netlink_ack(
        in_skb: *mut sk_buff,
        nlh: *mut nlmsghdr,
        err: core::ffi::c_int,
        extack: *const netlink_ext_ack,
    );
}
extern "C" {
    pub fn netlink_has_listeners(sk: *mut sock, group: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_strict_get_check(skb: *mut sk_buff) -> bool_;
}
extern "C" {
    pub fn netlink_unicast(
        ssk: *mut sock,
        skb: *mut sk_buff,
        portid: __u32,
        nonblock: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_broadcast(
        ssk: *mut sock,
        skb: *mut sk_buff,
        portid: __u32,
        group: __u32,
        allocation: gfp_t,
    ) -> core::ffi::c_int;
}
pub type netlink_filter_fn = ::core::option::Option<
    unsafe extern "C" fn(
        dsk: *mut sock,
        skb: *mut sk_buff,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
extern "C" {
    pub fn netlink_broadcast_filtered(
        ssk: *mut sock,
        skb: *mut sk_buff,
        portid: __u32,
        group: __u32,
        allocation: gfp_t,
        filter: netlink_filter_fn,
        filter_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_set_err(
        ssk: *mut sock,
        portid: __u32,
        group: __u32,
        code: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_register_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_unregister_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_getsockbyfilp(filp: *mut file) -> *mut sock;
}
extern "C" {
    pub fn netlink_attachskb(
        sk: *mut sock,
        skb: *mut sk_buff,
        timeo: *mut core::ffi::c_long,
        ssk: *mut sock,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_detachskb(sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn netlink_sendskb(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_callback {
    pub skb: *mut sk_buff,
    pub nlh: *const nlmsghdr,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, cb: *mut netlink_callback) -> core::ffi::c_int,
    >,
    pub done:
        ::core::option::Option<unsafe extern "C" fn(cb: *mut netlink_callback) -> core::ffi::c_int>,
    pub data: *mut core::ffi::c_void,
    pub module: *mut module,
    pub extack: *mut netlink_ext_ack,
    pub family: u16_,
    pub answer_flags: u16_,
    pub min_dump_alloc: u32_,
    pub prev_seq: core::ffi::c_uint,
    pub seq: core::ffi::c_uint,
    pub strict_check: bool_,
    pub __bindgen_anon_1: netlink_callback__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union netlink_callback__bindgen_ty_1 {
    pub ctx: [u8_; 48usize],
    pub args: [core::ffi::c_long; 6usize],
}
impl Default for netlink_callback__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for netlink_callback {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_notify {
    pub net: *mut net,
    pub portid: u32_,
    pub protocol: core::ffi::c_int,
}
impl Default for netlink_notify {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __nlmsg_put(
        skb: *mut sk_buff,
        portid: u32_,
        seq: u32_,
        type_: core::ffi::c_int,
        len: core::ffi::c_int,
        flags: core::ffi::c_int,
    ) -> *mut nlmsghdr;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_dump_control {
    pub start: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut netlink_callback) -> core::ffi::c_int,
    >,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, arg1: *mut netlink_callback) -> core::ffi::c_int,
    >,
    pub done: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut netlink_callback) -> core::ffi::c_int,
    >,
    pub extack: *mut netlink_ext_ack,
    pub data: *mut core::ffi::c_void,
    pub module: *mut module,
    pub min_dump_alloc: u32_,
}
impl Default for netlink_dump_control {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __netlink_dump_start(
        ssk: *mut sock,
        skb: *mut sk_buff,
        nlh: *const nlmsghdr,
        control: *mut netlink_dump_control,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_tap {
    pub dev: *mut net_device,
    pub module: *mut module,
    pub list: list_head,
}
impl Default for netlink_tap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn netlink_add_tap(nt: *mut netlink_tap) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_remove_tap(nt: *mut netlink_tap) -> core::ffi::c_int;
}
extern "C" {
    pub fn __netlink_ns_capable(
        nsp: *const netlink_skb_parms,
        ns: *mut user_namespace,
        cap: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn netlink_ns_capable(
        skb: *const sk_buff,
        ns: *mut user_namespace,
        cap: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn netlink_capable(skb: *const sk_buff, cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn netlink_net_capable(skb: *const sk_buff, cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn netlink_alloc_large_skb(
        size: core::ffi::c_uint,
        broadcast: core::ffi::c_int,
    ) -> *mut sk_buff;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_cmd {
    pub cmd: __u32,
    pub supported: __u32,
    pub advertising: __u32,
    pub speed: __u16,
    pub duplex: __u8,
    pub port: __u8,
    pub phy_address: __u8,
    pub transceiver: __u8,
    pub autoneg: __u8,
    pub mdio_support: __u8,
    pub maxtxpkt: __u32,
    pub maxrxpkt: __u32,
    pub speed_hi: __u16,
    pub eth_tp_mdix: __u8,
    pub eth_tp_mdix_ctrl: __u8,
    pub lp_advertising: __u32,
    pub reserved: [__u32; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_drvinfo {
    pub cmd: __u32,
    pub driver: [core::ffi::c_char; 32usize],
    pub version: [core::ffi::c_char; 32usize],
    pub fw_version: [core::ffi::c_char; 32usize],
    pub bus_info: [core::ffi::c_char; 32usize],
    pub erom_version: [core::ffi::c_char; 32usize],
    pub reserved2: [core::ffi::c_char; 12usize],
    pub n_priv_flags: __u32,
    pub n_stats: __u32,
    pub testinfo_len: __u32,
    pub eedump_len: __u32,
    pub regdump_len: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_wolinfo {
    pub cmd: __u32,
    pub supported: __u32,
    pub wolopts: __u32,
    pub sopass: [__u8; 6usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_value {
    pub cmd: __u32,
    pub data: __u32,
}
pub const tunable_id_ETHTOOL_ID_UNSPEC: tunable_id = 0;
pub const tunable_id_ETHTOOL_RX_COPYBREAK: tunable_id = 1;
pub const tunable_id_ETHTOOL_TX_COPYBREAK: tunable_id = 2;
pub const tunable_id_ETHTOOL_PFC_PREVENTION_TOUT: tunable_id = 3;
pub const tunable_id_ETHTOOL_TX_COPYBREAK_BUF_SIZE: tunable_id = 4;
pub const tunable_id___ETHTOOL_TUNABLE_COUNT: tunable_id = 5;
pub type tunable_id = core::ffi::c_uint;
pub const tunable_type_id_ETHTOOL_TUNABLE_UNSPEC: tunable_type_id = 0;
pub const tunable_type_id_ETHTOOL_TUNABLE_U8: tunable_type_id = 1;
pub const tunable_type_id_ETHTOOL_TUNABLE_U16: tunable_type_id = 2;
pub const tunable_type_id_ETHTOOL_TUNABLE_U32: tunable_type_id = 3;
pub const tunable_type_id_ETHTOOL_TUNABLE_U64: tunable_type_id = 4;
pub const tunable_type_id_ETHTOOL_TUNABLE_STRING: tunable_type_id = 5;
pub const tunable_type_id_ETHTOOL_TUNABLE_S8: tunable_type_id = 6;
pub const tunable_type_id_ETHTOOL_TUNABLE_S16: tunable_type_id = 7;
pub const tunable_type_id_ETHTOOL_TUNABLE_S32: tunable_type_id = 8;
pub const tunable_type_id_ETHTOOL_TUNABLE_S64: tunable_type_id = 9;
pub type tunable_type_id = core::ffi::c_uint;
#[repr(C)]
pub struct ethtool_tunable {
    pub cmd: __u32,
    pub id: __u32,
    pub type_id: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<*mut core::ffi::c_void>,
}
impl Default for ethtool_tunable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const phy_tunable_id_ETHTOOL_PHY_ID_UNSPEC: phy_tunable_id = 0;
pub const phy_tunable_id_ETHTOOL_PHY_DOWNSHIFT: phy_tunable_id = 1;
pub const phy_tunable_id_ETHTOOL_PHY_FAST_LINK_DOWN: phy_tunable_id = 2;
pub const phy_tunable_id_ETHTOOL_PHY_EDPD: phy_tunable_id = 3;
pub const phy_tunable_id___ETHTOOL_PHY_TUNABLE_COUNT: phy_tunable_id = 4;
pub type phy_tunable_id = core::ffi::c_uint;
#[repr(C)]
#[derive(Default)]
pub struct ethtool_regs {
    pub cmd: __u32,
    pub version: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_eeprom {
    pub cmd: __u32,
    pub magic: __u32,
    pub offset: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_eee {
    pub cmd: __u32,
    pub supported: __u32,
    pub advertised: __u32,
    pub lp_advertised: __u32,
    pub eee_active: __u32,
    pub eee_enabled: __u32,
    pub tx_lpi_enabled: __u32,
    pub tx_lpi_timer: __u32,
    pub reserved: [__u32; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_modinfo {
    pub cmd: __u32,
    pub type_: __u32,
    pub eeprom_len: __u32,
    pub reserved: [__u32; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_coalesce {
    pub cmd: __u32,
    pub rx_coalesce_usecs: __u32,
    pub rx_max_coalesced_frames: __u32,
    pub rx_coalesce_usecs_irq: __u32,
    pub rx_max_coalesced_frames_irq: __u32,
    pub tx_coalesce_usecs: __u32,
    pub tx_max_coalesced_frames: __u32,
    pub tx_coalesce_usecs_irq: __u32,
    pub tx_max_coalesced_frames_irq: __u32,
    pub stats_block_coalesce_usecs: __u32,
    pub use_adaptive_rx_coalesce: __u32,
    pub use_adaptive_tx_coalesce: __u32,
    pub pkt_rate_low: __u32,
    pub rx_coalesce_usecs_low: __u32,
    pub rx_max_coalesced_frames_low: __u32,
    pub tx_coalesce_usecs_low: __u32,
    pub tx_max_coalesced_frames_low: __u32,
    pub pkt_rate_high: __u32,
    pub rx_coalesce_usecs_high: __u32,
    pub rx_max_coalesced_frames_high: __u32,
    pub tx_coalesce_usecs_high: __u32,
    pub tx_max_coalesced_frames_high: __u32,
    pub rate_sample_interval: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_ringparam {
    pub cmd: __u32,
    pub rx_max_pending: __u32,
    pub rx_mini_max_pending: __u32,
    pub rx_jumbo_max_pending: __u32,
    pub tx_max_pending: __u32,
    pub rx_pending: __u32,
    pub rx_mini_pending: __u32,
    pub rx_jumbo_pending: __u32,
    pub tx_pending: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_channels {
    pub cmd: __u32,
    pub max_rx: __u32,
    pub max_tx: __u32,
    pub max_other: __u32,
    pub max_combined: __u32,
    pub rx_count: __u32,
    pub tx_count: __u32,
    pub other_count: __u32,
    pub combined_count: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_pauseparam {
    pub cmd: __u32,
    pub autoneg: __u32,
    pub rx_pause: __u32,
    pub tx_pause: __u32,
}
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_AUTONEG: ethtool_link_ext_state = 0;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE:
    ethtool_link_ext_state = 1;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH:
    ethtool_link_ext_state = 2;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY:
    ethtool_link_ext_state = 3;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_NO_CABLE: ethtool_link_ext_state = 4;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE: ethtool_link_ext_state = 5;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE: ethtool_link_ext_state = 6;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE:
    ethtool_link_ext_state = 7;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED:
    ethtool_link_ext_state = 8;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_OVERHEAT: ethtool_link_ext_state = 9;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_MODULE: ethtool_link_ext_state = 10;
pub type ethtool_link_ext_state = core::ffi::c_uint;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED:
    ethtool_link_ext_substate_autoneg = 1;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED:
    ethtool_link_ext_substate_autoneg = 2;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED : ethtool_link_ext_substate_autoneg = 3 ;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE : ethtool_link_ext_substate_autoneg = 4 ;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE : ethtool_link_ext_substate_autoneg = 5 ;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD:
    ethtool_link_ext_substate_autoneg = 6;
pub type ethtool_link_ext_substate_autoneg = core::ffi::c_uint;
pub const ethtool_link_ext_substate_link_training_ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED : ethtool_link_ext_substate_link_training = 1 ;
pub const ethtool_link_ext_substate_link_training_ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT : ethtool_link_ext_substate_link_training = 2 ;
pub const ethtool_link_ext_substate_link_training_ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY : ethtool_link_ext_substate_link_training = 3 ;
pub const ethtool_link_ext_substate_link_training_ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT:
    ethtool_link_ext_substate_link_training = 4;
pub type ethtool_link_ext_substate_link_training = core::ffi::c_uint;
pub const ethtool_link_ext_substate_link_logical_mismatch_ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK : ethtool_link_ext_substate_link_logical_mismatch = 1 ;
pub const ethtool_link_ext_substate_link_logical_mismatch_ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK : ethtool_link_ext_substate_link_logical_mismatch = 2 ;
pub const ethtool_link_ext_substate_link_logical_mismatch_ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS : ethtool_link_ext_substate_link_logical_mismatch = 3 ;
pub const ethtool_link_ext_substate_link_logical_mismatch_ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED : ethtool_link_ext_substate_link_logical_mismatch = 4 ;
pub const ethtool_link_ext_substate_link_logical_mismatch_ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED : ethtool_link_ext_substate_link_logical_mismatch = 5 ;
pub type ethtool_link_ext_substate_link_logical_mismatch = core::ffi::c_uint;
pub const ethtool_link_ext_substate_bad_signal_integrity_ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS : ethtool_link_ext_substate_bad_signal_integrity = 1 ;
pub const ethtool_link_ext_substate_bad_signal_integrity_ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE : ethtool_link_ext_substate_bad_signal_integrity = 2 ;
pub const ethtool_link_ext_substate_bad_signal_integrity_ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_REFERENCE_CLOCK_LOST : ethtool_link_ext_substate_bad_signal_integrity = 3 ;
pub const ethtool_link_ext_substate_bad_signal_integrity_ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_ALOS : ethtool_link_ext_substate_bad_signal_integrity = 4 ;
pub type ethtool_link_ext_substate_bad_signal_integrity = core::ffi::c_uint;
pub const ethtool_link_ext_substate_cable_issue_ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE:
    ethtool_link_ext_substate_cable_issue = 1;
pub const ethtool_link_ext_substate_cable_issue_ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE:
    ethtool_link_ext_substate_cable_issue = 2;
pub type ethtool_link_ext_substate_cable_issue = core::ffi::c_uint;
pub const ethtool_link_ext_substate_module_ETHTOOL_LINK_EXT_SUBSTATE_MODULE_CMIS_NOT_READY:
    ethtool_link_ext_substate_module = 1;
pub type ethtool_link_ext_substate_module = core::ffi::c_uint;
pub const ethtool_stringset_ETH_SS_TEST: ethtool_stringset = 0;
pub const ethtool_stringset_ETH_SS_STATS: ethtool_stringset = 1;
pub const ethtool_stringset_ETH_SS_PRIV_FLAGS: ethtool_stringset = 2;
pub const ethtool_stringset_ETH_SS_NTUPLE_FILTERS: ethtool_stringset = 3;
pub const ethtool_stringset_ETH_SS_FEATURES: ethtool_stringset = 4;
pub const ethtool_stringset_ETH_SS_RSS_HASH_FUNCS: ethtool_stringset = 5;
pub const ethtool_stringset_ETH_SS_TUNABLES: ethtool_stringset = 6;
pub const ethtool_stringset_ETH_SS_PHY_STATS: ethtool_stringset = 7;
pub const ethtool_stringset_ETH_SS_PHY_TUNABLES: ethtool_stringset = 8;
pub const ethtool_stringset_ETH_SS_LINK_MODES: ethtool_stringset = 9;
pub const ethtool_stringset_ETH_SS_MSG_CLASSES: ethtool_stringset = 10;
pub const ethtool_stringset_ETH_SS_WOL_MODES: ethtool_stringset = 11;
pub const ethtool_stringset_ETH_SS_SOF_TIMESTAMPING: ethtool_stringset = 12;
pub const ethtool_stringset_ETH_SS_TS_TX_TYPES: ethtool_stringset = 13;
pub const ethtool_stringset_ETH_SS_TS_RX_FILTERS: ethtool_stringset = 14;
pub const ethtool_stringset_ETH_SS_UDP_TUNNEL_TYPES: ethtool_stringset = 15;
pub const ethtool_stringset_ETH_SS_STATS_STD: ethtool_stringset = 16;
pub const ethtool_stringset_ETH_SS_STATS_ETH_PHY: ethtool_stringset = 17;
pub const ethtool_stringset_ETH_SS_STATS_ETH_MAC: ethtool_stringset = 18;
pub const ethtool_stringset_ETH_SS_STATS_ETH_CTRL: ethtool_stringset = 19;
pub const ethtool_stringset_ETH_SS_STATS_RMON: ethtool_stringset = 20;
pub const ethtool_stringset_ETH_SS_COUNT: ethtool_stringset = 21;
pub type ethtool_stringset = core::ffi::c_uint;
pub const ethtool_mac_stats_src_ETHTOOL_MAC_STATS_SRC_AGGREGATE: ethtool_mac_stats_src = 0;
pub const ethtool_mac_stats_src_ETHTOOL_MAC_STATS_SRC_EMAC: ethtool_mac_stats_src = 1;
pub const ethtool_mac_stats_src_ETHTOOL_MAC_STATS_SRC_PMAC: ethtool_mac_stats_src = 2;
pub type ethtool_mac_stats_src = core::ffi::c_uint;
pub const ethtool_module_power_mode_policy_ETHTOOL_MODULE_POWER_MODE_POLICY_HIGH:
    ethtool_module_power_mode_policy = 1;
pub const ethtool_module_power_mode_policy_ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO:
    ethtool_module_power_mode_policy = 2;
pub type ethtool_module_power_mode_policy = core::ffi::c_uint;
pub const ethtool_module_power_mode_ETHTOOL_MODULE_POWER_MODE_LOW: ethtool_module_power_mode = 1;
pub const ethtool_module_power_mode_ETHTOOL_MODULE_POWER_MODE_HIGH: ethtool_module_power_mode = 2;
pub type ethtool_module_power_mode = core::ffi::c_uint;
pub const ethtool_podl_pse_admin_state_ETHTOOL_PODL_PSE_ADMIN_STATE_UNKNOWN:
    ethtool_podl_pse_admin_state = 1;
pub const ethtool_podl_pse_admin_state_ETHTOOL_PODL_PSE_ADMIN_STATE_DISABLED:
    ethtool_podl_pse_admin_state = 2;
pub const ethtool_podl_pse_admin_state_ETHTOOL_PODL_PSE_ADMIN_STATE_ENABLED:
    ethtool_podl_pse_admin_state = 3;
pub type ethtool_podl_pse_admin_state = core::ffi::c_uint;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_UNKNOWN:
    ethtool_podl_pse_pw_d_status = 1;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_DISABLED:
    ethtool_podl_pse_pw_d_status = 2;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_SEARCHING:
    ethtool_podl_pse_pw_d_status = 3;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_DELIVERING:
    ethtool_podl_pse_pw_d_status = 4;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_SLEEP:
    ethtool_podl_pse_pw_d_status = 5;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_IDLE:
    ethtool_podl_pse_pw_d_status = 6;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_ERROR:
    ethtool_podl_pse_pw_d_status = 7;
pub type ethtool_podl_pse_pw_d_status = core::ffi::c_uint;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_UNKNOWN: ethtool_mm_verify_status = 0;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_INITIAL: ethtool_mm_verify_status = 1;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_VERIFYING: ethtool_mm_verify_status = 2;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_SUCCEEDED: ethtool_mm_verify_status = 3;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_FAILED: ethtool_mm_verify_status = 4;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_DISABLED: ethtool_mm_verify_status = 5;
pub type ethtool_mm_verify_status = core::ffi::c_uint;
#[repr(C)]
#[derive(Default)]
pub struct ethtool_gstrings {
    pub cmd: __u32,
    pub string_set: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_sset_info {
    pub cmd: __u32,
    pub reserved: __u32,
    pub sset_mask: __u64,
    pub data: __IncompleteArrayField<__u32>,
}
pub const ethtool_test_flags_ETH_TEST_FL_OFFLINE: ethtool_test_flags = 1;
pub const ethtool_test_flags_ETH_TEST_FL_FAILED: ethtool_test_flags = 2;
pub const ethtool_test_flags_ETH_TEST_FL_EXTERNAL_LB: ethtool_test_flags = 4;
pub const ethtool_test_flags_ETH_TEST_FL_EXTERNAL_LB_DONE: ethtool_test_flags = 8;
pub type ethtool_test_flags = core::ffi::c_uint;
#[repr(C)]
#[derive(Default)]
pub struct ethtool_test {
    pub cmd: __u32,
    pub flags: __u32,
    pub reserved: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u64>,
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_stats {
    pub cmd: __u32,
    pub n_stats: __u32,
    pub data: __IncompleteArrayField<__u64>,
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_perm_addr {
    pub cmd: __u32,
    pub size: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
pub const ethtool_flags_ETH_FLAG_TXVLAN: ethtool_flags = 128;
pub const ethtool_flags_ETH_FLAG_RXVLAN: ethtool_flags = 256;
pub const ethtool_flags_ETH_FLAG_LRO: ethtool_flags = 32768;
pub const ethtool_flags_ETH_FLAG_NTUPLE: ethtool_flags = 134217728;
pub const ethtool_flags_ETH_FLAG_RXHASH: ethtool_flags = 268435456;
pub type ethtool_flags = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_tcpip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub psrc: __be16,
    pub pdst: __be16,
    pub tos: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_ah_espip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub spi: __be32,
    pub tos: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_usrip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub l4_4_bytes: __be32,
    pub tos: __u8,
    pub ip_ver: __u8,
    pub proto: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_tcpip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub psrc: __be16,
    pub pdst: __be16,
    pub tclass: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_ah_espip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub spi: __be32,
    pub tclass: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_usrip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub l4_4_bytes: __be32,
    pub tclass: __u8,
    pub l4_proto: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_flow_union {
    pub tcp_ip4_spec: ethtool_tcpip4_spec,
    pub udp_ip4_spec: ethtool_tcpip4_spec,
    pub sctp_ip4_spec: ethtool_tcpip4_spec,
    pub ah_ip4_spec: ethtool_ah_espip4_spec,
    pub esp_ip4_spec: ethtool_ah_espip4_spec,
    pub usr_ip4_spec: ethtool_usrip4_spec,
    pub tcp_ip6_spec: ethtool_tcpip6_spec,
    pub udp_ip6_spec: ethtool_tcpip6_spec,
    pub sctp_ip6_spec: ethtool_tcpip6_spec,
    pub ah_ip6_spec: ethtool_ah_espip6_spec,
    pub esp_ip6_spec: ethtool_ah_espip6_spec,
    pub usr_ip6_spec: ethtool_usrip6_spec,
    pub ether_spec: ethhdr,
    pub hdata: [__u8; 52usize],
}
impl Default for ethtool_flow_union {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_flow_ext {
    pub padding: [__u8; 2usize],
    pub h_dest: [core::ffi::c_uchar; 6usize],
    pub vlan_etype: __be16,
    pub vlan_tci: __be16,
    pub data: [__be32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rx_flow_spec {
    pub flow_type: __u32,
    pub h_u: ethtool_flow_union,
    pub h_ext: ethtool_flow_ext,
    pub m_u: ethtool_flow_union,
    pub m_ext: ethtool_flow_ext,
    pub ring_cookie: __u64,
    pub location: __u32,
}
impl Default for ethtool_rx_flow_spec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ethtool_rxnfc {
    pub cmd: __u32,
    pub flow_type: __u32,
    pub data: __u64,
    pub fs: ethtool_rx_flow_spec,
    pub __bindgen_anon_1: ethtool_rxnfc__bindgen_ty_1,
    pub rule_locs: __IncompleteArrayField<__u32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_rxnfc__bindgen_ty_1 {
    pub rule_cnt: __u32,
    pub rss_context: __u32,
}
impl Default for ethtool_rxnfc__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_rxnfc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_rxfh_indir {
    pub cmd: __u32,
    pub size: __u32,
    pub ring_index: __IncompleteArrayField<__u32>,
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_rxfh {
    pub cmd: __u32,
    pub rss_context: __u32,
    pub indir_size: __u32,
    pub key_size: __u32,
    pub hfunc: __u8,
    pub input_xfrm: __u8,
    pub rsvd8: [__u8; 2usize],
    pub rsvd32: __u32,
    pub rss_config: __IncompleteArrayField<__u32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rx_ntuple_flow_spec {
    pub flow_type: __u32,
    pub h_u: ethtool_rx_ntuple_flow_spec__bindgen_ty_1,
    pub m_u: ethtool_rx_ntuple_flow_spec__bindgen_ty_1,
    pub vlan_tag: __u16,
    pub vlan_tag_mask: __u16,
    pub data: __u64,
    pub data_mask: __u64,
    pub action: __s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_rx_ntuple_flow_spec__bindgen_ty_1 {
    pub tcp_ip4_spec: ethtool_tcpip4_spec,
    pub udp_ip4_spec: ethtool_tcpip4_spec,
    pub sctp_ip4_spec: ethtool_tcpip4_spec,
    pub ah_ip4_spec: ethtool_ah_espip4_spec,
    pub esp_ip4_spec: ethtool_ah_espip4_spec,
    pub usr_ip4_spec: ethtool_usrip4_spec,
    pub ether_spec: ethhdr,
    pub hdata: [__u8; 72usize],
}
impl Default for ethtool_rx_ntuple_flow_spec__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_rx_ntuple_flow_spec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rx_ntuple {
    pub cmd: __u32,
    pub fs: ethtool_rx_ntuple_flow_spec,
}
impl Default for ethtool_rx_ntuple {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ethtool_flash_op_type_ETHTOOL_FLASH_ALL_REGIONS: ethtool_flash_op_type = 0;
pub type ethtool_flash_op_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_flash {
    pub cmd: __u32,
    pub region: __u32,
    pub data: [core::ffi::c_char; 128usize],
}
impl Default for ethtool_flash {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_dump {
    pub cmd: __u32,
    pub version: __u32,
    pub flag: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_get_features_block {
    pub available: __u32,
    pub requested: __u32,
    pub active: __u32,
    pub never_changed: __u32,
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_gfeatures {
    pub cmd: __u32,
    pub size: __u32,
    pub features: __IncompleteArrayField<ethtool_get_features_block>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_set_features_block {
    pub valid: __u32,
    pub requested: __u32,
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_sfeatures {
    pub cmd: __u32,
    pub size: __u32,
    pub features: __IncompleteArrayField<ethtool_set_features_block>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_ts_info {
    pub cmd: __u32,
    pub so_timestamping: __u32,
    pub phc_index: __s32,
    pub tx_types: __u32,
    pub tx_reserved: [__u32; 3usize],
    pub rx_filters: __u32,
    pub rx_reserved: [__u32; 3usize],
}
pub const ethtool_sfeatures_retval_bits_ETHTOOL_F_UNSUPPORTED__BIT: ethtool_sfeatures_retval_bits =
    0;
pub const ethtool_sfeatures_retval_bits_ETHTOOL_F_WISH__BIT: ethtool_sfeatures_retval_bits = 1;
pub const ethtool_sfeatures_retval_bits_ETHTOOL_F_COMPAT__BIT: ethtool_sfeatures_retval_bits = 2;
pub type ethtool_sfeatures_retval_bits = core::ffi::c_uint;
#[repr(C)]
pub struct ethtool_per_queue_op {
    pub cmd: __u32,
    pub sub_command: __u32,
    pub queue_mask: [__u32; 128usize],
    pub data: __IncompleteArrayField<core::ffi::c_char>,
}
impl Default for ethtool_per_queue_op {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_fecparam {
    pub cmd: __u32,
    pub active_fec: __u32,
    pub fec: __u32,
    pub reserved: __u32,
}
pub const ethtool_fec_config_bits_ETHTOOL_FEC_NONE_BIT: ethtool_fec_config_bits = 0;
pub const ethtool_fec_config_bits_ETHTOOL_FEC_AUTO_BIT: ethtool_fec_config_bits = 1;
pub const ethtool_fec_config_bits_ETHTOOL_FEC_OFF_BIT: ethtool_fec_config_bits = 2;
pub const ethtool_fec_config_bits_ETHTOOL_FEC_RS_BIT: ethtool_fec_config_bits = 3;
pub const ethtool_fec_config_bits_ETHTOOL_FEC_BASER_BIT: ethtool_fec_config_bits = 4;
pub const ethtool_fec_config_bits_ETHTOOL_FEC_LLRS_BIT: ethtool_fec_config_bits = 5;
pub type ethtool_fec_config_bits = core::ffi::c_uint;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT_Half_BIT:
    ethtool_link_mode_bit_indices = 0;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 1;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100baseT_Half_BIT:
    ethtool_link_mode_bit_indices = 2;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 3;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_1000baseT_Half_BIT:
    ethtool_link_mode_bit_indices = 4;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_1000baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 5;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_Autoneg_BIT:
    ethtool_link_mode_bit_indices = 6;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_TP_BIT: ethtool_link_mode_bit_indices = 7;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_AUI_BIT: ethtool_link_mode_bit_indices =
    8;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_MII_BIT: ethtool_link_mode_bit_indices =
    9;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_FIBRE_BIT: ethtool_link_mode_bit_indices =
    10;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_BNC_BIT: ethtool_link_mode_bit_indices =
    11;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 12;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_Pause_BIT: ethtool_link_mode_bit_indices =
    13;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_Asym_Pause_BIT:
    ethtool_link_mode_bit_indices = 14;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_2500baseX_Full_BIT:
    ethtool_link_mode_bit_indices = 15;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_Backplane_BIT:
    ethtool_link_mode_bit_indices = 16;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_1000baseKX_Full_BIT:
    ethtool_link_mode_bit_indices = 17;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT:
    ethtool_link_mode_bit_indices = 18;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseKR_Full_BIT:
    ethtool_link_mode_bit_indices = 19;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseR_FEC_BIT:
    ethtool_link_mode_bit_indices = 20;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT:
    ethtool_link_mode_bit_indices = 21;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT:
    ethtool_link_mode_bit_indices = 22;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT:
    ethtool_link_mode_bit_indices = 23;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT:
    ethtool_link_mode_bit_indices = 24;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT:
    ethtool_link_mode_bit_indices = 25;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT:
    ethtool_link_mode_bit_indices = 26;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT:
    ethtool_link_mode_bit_indices = 27;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT:
    ethtool_link_mode_bit_indices = 28;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT:
    ethtool_link_mode_bit_indices = 29;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT:
    ethtool_link_mode_bit_indices = 30;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_25000baseCR_Full_BIT:
    ethtool_link_mode_bit_indices = 31;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_25000baseKR_Full_BIT:
    ethtool_link_mode_bit_indices = 32;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_25000baseSR_Full_BIT:
    ethtool_link_mode_bit_indices = 33;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT:
    ethtool_link_mode_bit_indices = 34;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT:
    ethtool_link_mode_bit_indices = 35;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT:
    ethtool_link_mode_bit_indices = 36;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT:
    ethtool_link_mode_bit_indices = 37;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT:
    ethtool_link_mode_bit_indices = 38;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT:
    ethtool_link_mode_bit_indices = 39;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT:
    ethtool_link_mode_bit_indices = 40;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_1000baseX_Full_BIT:
    ethtool_link_mode_bit_indices = 41;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseCR_Full_BIT:
    ethtool_link_mode_bit_indices = 42;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseSR_Full_BIT:
    ethtool_link_mode_bit_indices = 43;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseLR_Full_BIT:
    ethtool_link_mode_bit_indices = 44;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT:
    ethtool_link_mode_bit_indices = 45;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseER_Full_BIT:
    ethtool_link_mode_bit_indices = 46;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_2500baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 47;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_5000baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 48;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_FEC_NONE_BIT:
    ethtool_link_mode_bit_indices = 49;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_FEC_RS_BIT:
    ethtool_link_mode_bit_indices = 50;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_FEC_BASER_BIT:
    ethtool_link_mode_bit_indices = 51;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseKR_Full_BIT:
    ethtool_link_mode_bit_indices = 52;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseSR_Full_BIT:
    ethtool_link_mode_bit_indices = 53;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseCR_Full_BIT:
    ethtool_link_mode_bit_indices = 54;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT:
    ethtool_link_mode_bit_indices = 55;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseDR_Full_BIT:
    ethtool_link_mode_bit_indices = 56;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT:
    ethtool_link_mode_bit_indices = 57;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT:
    ethtool_link_mode_bit_indices = 58;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT:
    ethtool_link_mode_bit_indices = 59;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT:
    ethtool_link_mode_bit_indices = 60;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT:
    ethtool_link_mode_bit_indices = 61;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT:
    ethtool_link_mode_bit_indices = 62;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT:
    ethtool_link_mode_bit_indices = 63;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT:
    ethtool_link_mode_bit_indices = 64;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT:
    ethtool_link_mode_bit_indices = 65;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT:
    ethtool_link_mode_bit_indices = 66;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100baseT1_Full_BIT:
    ethtool_link_mode_bit_indices = 67;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_1000baseT1_Full_BIT:
    ethtool_link_mode_bit_indices = 68;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT:
    ethtool_link_mode_bit_indices = 69;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT:
    ethtool_link_mode_bit_indices = 70;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT:
    ethtool_link_mode_bit_indices = 71;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT:
    ethtool_link_mode_bit_indices = 72;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT:
    ethtool_link_mode_bit_indices = 73;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_FEC_LLRS_BIT:
    ethtool_link_mode_bit_indices = 74;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseKR_Full_BIT:
    ethtool_link_mode_bit_indices = 75;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseSR_Full_BIT:
    ethtool_link_mode_bit_indices = 76;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT:
    ethtool_link_mode_bit_indices = 77;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseCR_Full_BIT:
    ethtool_link_mode_bit_indices = 78;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseDR_Full_BIT:
    ethtool_link_mode_bit_indices = 79;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT:
    ethtool_link_mode_bit_indices = 80;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT:
    ethtool_link_mode_bit_indices = 81;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT:
    ethtool_link_mode_bit_indices = 82;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT:
    ethtool_link_mode_bit_indices = 83;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT:
    ethtool_link_mode_bit_indices = 84;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT:
    ethtool_link_mode_bit_indices = 85;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT:
    ethtool_link_mode_bit_indices = 86;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT:
    ethtool_link_mode_bit_indices = 87;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT:
    ethtool_link_mode_bit_indices = 88;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT:
    ethtool_link_mode_bit_indices = 89;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100baseFX_Half_BIT:
    ethtool_link_mode_bit_indices = 90;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100baseFX_Full_BIT:
    ethtool_link_mode_bit_indices = 91;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT1L_Full_BIT:
    ethtool_link_mode_bit_indices = 92;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseCR8_Full_BIT:
    ethtool_link_mode_bit_indices = 93;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseKR8_Full_BIT:
    ethtool_link_mode_bit_indices = 94;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseDR8_Full_BIT:
    ethtool_link_mode_bit_indices = 95;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseDR8_2_Full_BIT:
    ethtool_link_mode_bit_indices = 96;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseSR8_Full_BIT:
    ethtool_link_mode_bit_indices = 97;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseVR8_Full_BIT:
    ethtool_link_mode_bit_indices = 98;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT1S_Full_BIT:
    ethtool_link_mode_bit_indices = 99;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT1S_Half_BIT:
    ethtool_link_mode_bit_indices = 100;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT1S_P2MP_Half_BIT:
    ethtool_link_mode_bit_indices = 101;
pub const ethtool_link_mode_bit_indices___ETHTOOL_LINK_MODE_MASK_NBITS:
    ethtool_link_mode_bit_indices = 102;
pub type ethtool_link_mode_bit_indices = core::ffi::c_uint;
pub const ethtool_reset_flags_ETH_RESET_MGMT: ethtool_reset_flags = 1;
pub const ethtool_reset_flags_ETH_RESET_IRQ: ethtool_reset_flags = 2;
pub const ethtool_reset_flags_ETH_RESET_DMA: ethtool_reset_flags = 4;
pub const ethtool_reset_flags_ETH_RESET_FILTER: ethtool_reset_flags = 8;
pub const ethtool_reset_flags_ETH_RESET_OFFLOAD: ethtool_reset_flags = 16;
pub const ethtool_reset_flags_ETH_RESET_MAC: ethtool_reset_flags = 32;
pub const ethtool_reset_flags_ETH_RESET_PHY: ethtool_reset_flags = 64;
pub const ethtool_reset_flags_ETH_RESET_RAM: ethtool_reset_flags = 128;
pub const ethtool_reset_flags_ETH_RESET_AP: ethtool_reset_flags = 256;
pub const ethtool_reset_flags_ETH_RESET_DEDICATED: ethtool_reset_flags = 65535;
pub const ethtool_reset_flags_ETH_RESET_ALL: ethtool_reset_flags = 4294967295;
pub type ethtool_reset_flags = core::ffi::c_uint;
#[repr(C)]
#[derive(Default)]
pub struct ethtool_link_settings {
    pub cmd: __u32,
    pub speed: __u32,
    pub duplex: __u8,
    pub port: __u8,
    pub phy_address: __u8,
    pub autoneg: __u8,
    pub mdio_support: __u8,
    pub eth_tp_mdix: __u8,
    pub eth_tp_mdix_ctrl: __u8,
    pub link_mode_masks_nwords: __s8,
    pub transceiver: __u8,
    pub master_slave_cfg: __u8,
    pub master_slave_state: __u8,
    pub rate_matching: __u8,
    pub reserved: [__u32; 7usize],
    pub link_mode_masks: __IncompleteArrayField<__u32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_ethtool_rx_flow_spec {
    pub flow_type: u32_,
    pub h_u: ethtool_flow_union,
    pub h_ext: ethtool_flow_ext,
    pub m_u: ethtool_flow_union,
    pub m_ext: ethtool_flow_ext,
    pub ring_cookie: compat_u64,
    pub location: u32_,
}
impl Default for compat_ethtool_rx_flow_spec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct compat_ethtool_rxnfc {
    pub cmd: u32_,
    pub flow_type: u32_,
    pub data: compat_u64,
    pub fs: compat_ethtool_rx_flow_spec,
    pub rule_cnt: u32_,
    pub rule_locs: __IncompleteArrayField<u32_>,
}
impl Default for compat_ethtool_rxnfc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ethtool_phys_id_state_ETHTOOL_ID_INACTIVE: ethtool_phys_id_state = 0;
pub const ethtool_phys_id_state_ETHTOOL_ID_ACTIVE: ethtool_phys_id_state = 1;
pub const ethtool_phys_id_state_ETHTOOL_ID_ON: ethtool_phys_id_state = 2;
pub const ethtool_phys_id_state_ETHTOOL_ID_OFF: ethtool_phys_id_state = 3;
pub type ethtool_phys_id_state = core::ffi::c_uint;
pub const ETH_RSS_HASH_TOP_BIT: _bindgen_ty_111 = 0;
pub const ETH_RSS_HASH_XOR_BIT: _bindgen_ty_111 = 1;
pub const ETH_RSS_HASH_CRC32_BIT: _bindgen_ty_111 = 2;
pub const ETH_RSS_HASH_FUNCS_COUNT: _bindgen_ty_111 = 3;
pub type _bindgen_ty_111 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_ethtool_ringparam {
    pub rx_buf_len: u32_,
    pub tcp_data_split: u8_,
    pub tx_push: u8_,
    pub rx_push: u8_,
    pub cqe_size: u32_,
    pub tx_push_buf_len: u32_,
    pub tx_push_buf_max_len: u32_,
}
pub const ethtool_supported_ring_param_ETHTOOL_RING_USE_RX_BUF_LEN: ethtool_supported_ring_param =
    1;
pub const ethtool_supported_ring_param_ETHTOOL_RING_USE_CQE_SIZE: ethtool_supported_ring_param = 2;
pub const ethtool_supported_ring_param_ETHTOOL_RING_USE_TX_PUSH: ethtool_supported_ring_param = 4;
pub const ethtool_supported_ring_param_ETHTOOL_RING_USE_RX_PUSH: ethtool_supported_ring_param = 8;
pub const ethtool_supported_ring_param_ETHTOOL_RING_USE_TX_PUSH_BUF_LEN:
    ethtool_supported_ring_param = 16;
pub const ethtool_supported_ring_param_ETHTOOL_RING_USE_TCP_DATA_SPLIT:
    ethtool_supported_ring_param = 32;
pub type ethtool_supported_ring_param = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_link_ext_state_info {
    pub link_ext_state: ethtool_link_ext_state,
    pub __bindgen_anon_1: ethtool_link_ext_state_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_link_ext_state_info__bindgen_ty_1 {
    pub autoneg: ethtool_link_ext_substate_autoneg,
    pub link_training: ethtool_link_ext_substate_link_training,
    pub link_logical_mismatch: ethtool_link_ext_substate_link_logical_mismatch,
    pub bad_signal_integrity: ethtool_link_ext_substate_bad_signal_integrity,
    pub cable_issue: ethtool_link_ext_substate_cable_issue,
    pub module: ethtool_link_ext_substate_module,
    pub __link_ext_substate: u32_,
}
impl Default for ethtool_link_ext_state_info__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_link_ext_state_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_link_ext_stats {
    pub link_down_events: u64_,
}
#[repr(C)]
#[derive(Default)]
pub struct ethtool_link_ksettings {
    pub base: ethtool_link_settings,
    pub link_modes: ethtool_link_ksettings__bindgen_ty_1,
    pub lanes: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_link_ksettings__bindgen_ty_1 {
    pub supported: [core::ffi::c_ulong; 2usize],
    pub advertising: [core::ffi::c_ulong; 2usize],
    pub lp_advertising: [core::ffi::c_ulong; 2usize],
}
extern "C" {
    pub fn __ethtool_get_link_ksettings(
        dev: *mut net_device,
        link_ksettings: *mut ethtool_link_ksettings,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_ethtool_coalesce {
    pub use_cqe_mode_tx: u8_,
    pub use_cqe_mode_rx: u8_,
    pub tx_aggr_max_bytes: u32_,
    pub tx_aggr_max_frames: u32_,
    pub tx_aggr_time_usecs: u32_,
}
extern "C" {
    pub fn ethtool_intersect_link_masks(
        dst: *mut ethtool_link_ksettings,
        src: *mut ethtool_link_ksettings,
    );
}
extern "C" {
    pub fn ethtool_convert_legacy_u32_to_link_mode(dst: *mut core::ffi::c_ulong, legacy_u32: u32_);
}
extern "C" {
    pub fn ethtool_convert_link_mode_to_legacy_u32(
        legacy_u32: *mut u32_,
        src: *const core::ffi::c_ulong,
    ) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_eth_mac_stats {
    pub src: ethtool_mac_stats_src,
    pub __bindgen_anon_1: ethtool_eth_mac_stats__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_eth_mac_stats__bindgen_ty_1 {
    pub __bindgen_anon_1: ethtool_eth_mac_stats__bindgen_ty_1__bindgen_ty_1,
    pub stats: ethtool_eth_mac_stats__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_eth_mac_stats__bindgen_ty_1__bindgen_ty_1 {
    pub FramesTransmittedOK: u64_,
    pub SingleCollisionFrames: u64_,
    pub MultipleCollisionFrames: u64_,
    pub FramesReceivedOK: u64_,
    pub FrameCheckSequenceErrors: u64_,
    pub AlignmentErrors: u64_,
    pub OctetsTransmittedOK: u64_,
    pub FramesWithDeferredXmissions: u64_,
    pub LateCollisions: u64_,
    pub FramesAbortedDueToXSColls: u64_,
    pub FramesLostDueToIntMACXmitError: u64_,
    pub CarrierSenseErrors: u64_,
    pub OctetsReceivedOK: u64_,
    pub FramesLostDueToIntMACRcvError: u64_,
    pub MulticastFramesXmittedOK: u64_,
    pub BroadcastFramesXmittedOK: u64_,
    pub FramesWithExcessiveDeferral: u64_,
    pub MulticastFramesReceivedOK: u64_,
    pub BroadcastFramesReceivedOK: u64_,
    pub InRangeLengthErrors: u64_,
    pub OutOfRangeLengthField: u64_,
    pub FrameTooLongErrors: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_eth_mac_stats__bindgen_ty_1__bindgen_ty_2 {
    pub FramesTransmittedOK: u64_,
    pub SingleCollisionFrames: u64_,
    pub MultipleCollisionFrames: u64_,
    pub FramesReceivedOK: u64_,
    pub FrameCheckSequenceErrors: u64_,
    pub AlignmentErrors: u64_,
    pub OctetsTransmittedOK: u64_,
    pub FramesWithDeferredXmissions: u64_,
    pub LateCollisions: u64_,
    pub FramesAbortedDueToXSColls: u64_,
    pub FramesLostDueToIntMACXmitError: u64_,
    pub CarrierSenseErrors: u64_,
    pub OctetsReceivedOK: u64_,
    pub FramesLostDueToIntMACRcvError: u64_,
    pub MulticastFramesXmittedOK: u64_,
    pub BroadcastFramesXmittedOK: u64_,
    pub FramesWithExcessiveDeferral: u64_,
    pub MulticastFramesReceivedOK: u64_,
    pub BroadcastFramesReceivedOK: u64_,
    pub InRangeLengthErrors: u64_,
    pub OutOfRangeLengthField: u64_,
    pub FrameTooLongErrors: u64_,
}
impl Default for ethtool_eth_mac_stats__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_eth_mac_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_eth_phy_stats {
    pub src: ethtool_mac_stats_src,
    pub __bindgen_anon_1: ethtool_eth_phy_stats__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_eth_phy_stats__bindgen_ty_1 {
    pub __bindgen_anon_1: ethtool_eth_phy_stats__bindgen_ty_1__bindgen_ty_1,
    pub stats: ethtool_eth_phy_stats__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_eth_phy_stats__bindgen_ty_1__bindgen_ty_1 {
    pub SymbolErrorDuringCarrier: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_eth_phy_stats__bindgen_ty_1__bindgen_ty_2 {
    pub SymbolErrorDuringCarrier: u64_,
}
impl Default for ethtool_eth_phy_stats__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_eth_phy_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_eth_ctrl_stats {
    pub src: ethtool_mac_stats_src,
    pub __bindgen_anon_1: ethtool_eth_ctrl_stats__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_eth_ctrl_stats__bindgen_ty_1 {
    pub __bindgen_anon_1: ethtool_eth_ctrl_stats__bindgen_ty_1__bindgen_ty_1,
    pub stats: ethtool_eth_ctrl_stats__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_eth_ctrl_stats__bindgen_ty_1__bindgen_ty_1 {
    pub MACControlFramesTransmitted: u64_,
    pub MACControlFramesReceived: u64_,
    pub UnsupportedOpcodesReceived: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_eth_ctrl_stats__bindgen_ty_1__bindgen_ty_2 {
    pub MACControlFramesTransmitted: u64_,
    pub MACControlFramesReceived: u64_,
    pub UnsupportedOpcodesReceived: u64_,
}
impl Default for ethtool_eth_ctrl_stats__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_eth_ctrl_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_pause_stats {
    pub src: ethtool_mac_stats_src,
    pub __bindgen_anon_1: ethtool_pause_stats__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_pause_stats__bindgen_ty_1 {
    pub __bindgen_anon_1: ethtool_pause_stats__bindgen_ty_1__bindgen_ty_1,
    pub stats: ethtool_pause_stats__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_pause_stats__bindgen_ty_1__bindgen_ty_1 {
    pub tx_pause_frames: u64_,
    pub rx_pause_frames: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_pause_stats__bindgen_ty_1__bindgen_ty_2 {
    pub tx_pause_frames: u64_,
    pub rx_pause_frames: u64_,
}
impl Default for ethtool_pause_stats__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_pause_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_fec_stats {
    pub corrected_blocks: ethtool_fec_stats_ethtool_fec_stat,
    pub uncorrectable_blocks: ethtool_fec_stats_ethtool_fec_stat,
    pub corrected_bits: ethtool_fec_stats_ethtool_fec_stat,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_fec_stats_ethtool_fec_stat {
    pub total: u64_,
    pub lanes: [u64_; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_rmon_hist_range {
    pub low: u16_,
    pub high: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rmon_stats {
    pub src: ethtool_mac_stats_src,
    pub __bindgen_anon_1: ethtool_rmon_stats__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_rmon_stats__bindgen_ty_1 {
    pub __bindgen_anon_1: ethtool_rmon_stats__bindgen_ty_1__bindgen_ty_1,
    pub stats: ethtool_rmon_stats__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_rmon_stats__bindgen_ty_1__bindgen_ty_1 {
    pub undersize_pkts: u64_,
    pub oversize_pkts: u64_,
    pub fragments: u64_,
    pub jabbers: u64_,
    pub hist: [u64_; 10usize],
    pub hist_tx: [u64_; 10usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_rmon_stats__bindgen_ty_1__bindgen_ty_2 {
    pub undersize_pkts: u64_,
    pub oversize_pkts: u64_,
    pub fragments: u64_,
    pub jabbers: u64_,
    pub hist: [u64_; 10usize],
    pub hist_tx: [u64_; 10usize],
}
impl Default for ethtool_rmon_stats__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ethtool_rmon_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_module_eeprom {
    pub offset: u32_,
    pub length: u32_,
    pub page: u8_,
    pub bank: u8_,
    pub i2c_address: u8_,
    pub data: *mut u8_,
}
impl Default for ethtool_module_eeprom {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_module_power_mode_params {
    pub policy: ethtool_module_power_mode_policy,
    pub mode: ethtool_module_power_mode,
}
impl Default for ethtool_module_power_mode_params {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_mm_state {
    pub verify_time: u32_,
    pub max_verify_time: u32_,
    pub verify_status: ethtool_mm_verify_status,
    pub tx_enabled: bool_,
    pub tx_active: bool_,
    pub pmac_enabled: bool_,
    pub verify_enabled: bool_,
    pub tx_min_frag_size: u32_,
    pub rx_min_frag_size: u32_,
}
impl Default for ethtool_mm_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_mm_cfg {
    pub verify_time: u32_,
    pub verify_enabled: bool_,
    pub tx_enabled: bool_,
    pub pmac_enabled: bool_,
    pub tx_min_frag_size: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_mm_stats {
    pub MACMergeFrameAssErrorCount: u64_,
    pub MACMergeFrameSmdErrorCount: u64_,
    pub MACMergeFrameAssOkCount: u64_,
    pub MACMergeFragCountRx: u64_,
    pub MACMergeFragCountTx: u64_,
    pub MACMergeHoldCount: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rxfh_param {
    pub hfunc: u8_,
    pub indir_size: u32_,
    pub indir: *mut u32_,
    pub key_size: u32_,
    pub key: *mut u8_,
    pub rss_context: u32_,
    pub rss_delete: u8_,
    pub input_xfrm: u8_,
}
impl Default for ethtool_rxfh_param {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_ops {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub supported_coalesce_params: u32_,
    pub supported_ring_params: u32_,
    pub get_drvinfo: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_drvinfo),
    >,
    pub get_regs_len:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> core::ffi::c_int>,
    pub get_regs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_regs,
            arg3: *mut core::ffi::c_void,
        ),
    >,
    pub get_wol: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_wolinfo),
    >,
    pub set_wol: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_wolinfo) -> core::ffi::c_int,
    >,
    pub get_msglevel: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub set_msglevel:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u32_)>,
    pub nway_reset:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> core::ffi::c_int>,
    pub get_link: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub get_link_ext_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_link_ext_state_info,
        ) -> core::ffi::c_int,
    >,
    pub get_link_ext_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, stats: *mut ethtool_link_ext_stats),
    >,
    pub get_eeprom_len:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> core::ffi::c_int>,
    pub get_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> core::ffi::c_int,
    >,
    pub set_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> core::ffi::c_int,
    >,
    pub get_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_coalesce,
            arg3: *mut kernel_ethtool_coalesce,
            arg4: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub set_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_coalesce,
            arg3: *mut kernel_ethtool_coalesce,
            arg4: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub get_ringparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_ringparam,
            arg3: *mut kernel_ethtool_ringparam,
            arg4: *mut netlink_ext_ack,
        ),
    >,
    pub set_ringparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_ringparam,
            arg3: *mut kernel_ethtool_ringparam,
            arg4: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub get_pause_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, pause_stats: *mut ethtool_pause_stats),
    >,
    pub get_pauseparam: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_pauseparam),
    >,
    pub set_pauseparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_pauseparam,
        ) -> core::ffi::c_int,
    >,
    pub self_test: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_test, arg3: *mut u64_),
    >,
    pub get_strings: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, stringset: u32_, arg2: *mut u8_),
    >,
    pub set_phys_id: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ethtool_phys_id_state,
        ) -> core::ffi::c_int,
    >,
    pub get_ethtool_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_stats, arg3: *mut u64_),
    >,
    pub begin:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> core::ffi::c_int>,
    pub complete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub get_priv_flags: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub set_priv_flags: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: u32_) -> core::ffi::c_int,
    >,
    pub get_sset_count: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub get_rxnfc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_rxnfc,
            rule_locs: *mut u32_,
        ) -> core::ffi::c_int,
    >,
    pub set_rxnfc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_rxnfc) -> core::ffi::c_int,
    >,
    pub flash_device: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_flash) -> core::ffi::c_int,
    >,
    pub reset: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut u32_) -> core::ffi::c_int,
    >,
    pub get_rxfh_key_size:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub get_rxfh_indir_size:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub get_rxfh: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_rxfh_param,
        ) -> core::ffi::c_int,
    >,
    pub set_rxfh: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_rxfh_param,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub get_channels: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_channels),
    >,
    pub set_channels: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_channels,
        ) -> core::ffi::c_int,
    >,
    pub get_dump_flag: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_dump) -> core::ffi::c_int,
    >,
    pub get_dump_data: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_dump,
            arg3: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub set_dump: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_dump) -> core::ffi::c_int,
    >,
    pub get_ts_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_ts_info) -> core::ffi::c_int,
    >,
    pub get_module_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_modinfo) -> core::ffi::c_int,
    >,
    pub get_module_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> core::ffi::c_int,
    >,
    pub get_eee: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_eee) -> core::ffi::c_int,
    >,
    pub set_eee: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_eee) -> core::ffi::c_int,
    >,
    pub get_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub set_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *const core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub get_per_queue_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u32_,
            arg3: *mut ethtool_coalesce,
        ) -> core::ffi::c_int,
    >,
    pub set_per_queue_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u32_,
            arg3: *mut ethtool_coalesce,
        ) -> core::ffi::c_int,
    >,
    pub get_link_ksettings: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_link_ksettings,
        ) -> core::ffi::c_int,
    >,
    pub set_link_ksettings: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_link_ksettings,
        ) -> core::ffi::c_int,
    >,
    pub get_fec_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, fec_stats: *mut ethtool_fec_stats),
    >,
    pub get_fecparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_fecparam,
        ) -> core::ffi::c_int,
    >,
    pub set_fecparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_fecparam,
        ) -> core::ffi::c_int,
    >,
    pub get_ethtool_phy_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_stats, arg3: *mut u64_),
    >,
    pub get_phy_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub set_phy_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *const core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub get_module_eeprom_by_page: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            page: *const ethtool_module_eeprom,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub get_eth_phy_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, phy_stats: *mut ethtool_eth_phy_stats),
    >,
    pub get_eth_mac_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, mac_stats: *mut ethtool_eth_mac_stats),
    >,
    pub get_eth_ctrl_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, ctrl_stats: *mut ethtool_eth_ctrl_stats),
    >,
    pub get_rmon_stats: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            rmon_stats: *mut ethtool_rmon_stats,
            ranges: *mut *const ethtool_rmon_hist_range,
        ),
    >,
    pub get_module_power_mode: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            params: *mut ethtool_module_power_mode_params,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub set_module_power_mode: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            params: *const ethtool_module_power_mode_params,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub get_mm: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            state: *mut ethtool_mm_state,
        ) -> core::ffi::c_int,
    >,
    pub set_mm: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            cfg: *mut ethtool_mm_cfg,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub get_mm_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, stats: *mut ethtool_mm_stats),
    >,
}
impl ethtool_ops {
    #[inline]
    pub fn cap_link_lanes_supported(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cap_link_lanes_supported(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_rss_ctx_supported(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cap_rss_ctx_supported(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_rss_sym_xor_supported(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cap_rss_sym_xor_supported(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cap_link_lanes_supported: u32_,
        cap_rss_ctx_supported: u32_,
        cap_rss_sym_xor_supported: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cap_link_lanes_supported: u32 =
                unsafe { ::core::mem::transmute(cap_link_lanes_supported) };
            cap_link_lanes_supported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cap_rss_ctx_supported: u32 =
                unsafe { ::core::mem::transmute(cap_rss_ctx_supported) };
            cap_rss_ctx_supported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cap_rss_sym_xor_supported: u32 =
                unsafe { ::core::mem::transmute(cap_rss_sym_xor_supported) };
            cap_rss_sym_xor_supported as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ethtool_check_ops(ops: *const ethtool_ops) -> core::ffi::c_int;
}
#[repr(C)]
pub struct ethtool_rx_flow_rule {
    pub rule: *mut flow_rule,
    pub priv_: __IncompleteArrayField<core::ffi::c_ulong>,
}
impl Default for ethtool_rx_flow_rule {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rx_flow_spec_input {
    pub fs: *const ethtool_rx_flow_spec,
    pub rss_ctx: u32_,
}
impl Default for ethtool_rx_flow_spec_input {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn ethtool_rx_flow_rule_create(
        input: *const ethtool_rx_flow_spec_input,
    ) -> *mut ethtool_rx_flow_rule;
}
extern "C" {
    pub fn ethtool_rx_flow_rule_destroy(rule: *mut ethtool_rx_flow_rule);
}
extern "C" {
    pub fn ethtool_virtdev_validate_cmd(cmd: *const ethtool_link_ksettings) -> bool_;
}
extern "C" {
    pub fn ethtool_virtdev_set_link_ksettings(
        dev: *mut net_device,
        cmd: *const ethtool_link_ksettings,
        dev_speed: *mut u32_,
        dev_duplex: *mut u8_,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ethtool_phy_ops {
    pub get_sset_count:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device) -> core::ffi::c_int>,
    pub get_strings: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, data: *mut u8_) -> core::ffi::c_int,
    >,
    pub get_stats: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            stats: *mut ethtool_stats,
            data: *mut u64_,
        ) -> core::ffi::c_int,
    >,
    pub get_plca_cfg: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, plca_cfg: *mut phy_plca_cfg) -> core::ffi::c_int,
    >,
    pub set_plca_cfg: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            plca_cfg: *const phy_plca_cfg,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub get_plca_status: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            plca_st: *mut phy_plca_status,
        ) -> core::ffi::c_int,
    >,
    pub start_cable_test: ::core::option::Option<
        unsafe extern "C" fn(
            phydev: *mut phy_device,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub start_cable_test_tdr: ::core::option::Option<
        unsafe extern "C" fn(
            phydev: *mut phy_device,
            extack: *mut netlink_ext_ack,
            config: *const phy_tdr_config,
        ) -> core::ffi::c_int,
    >,
}
extern "C" {
    pub fn ethtool_set_ethtool_phy_ops(ops: *const ethtool_phy_ops);
}
extern "C" {
    pub fn ethtool_params_from_link_mode(
        link_ksettings: *mut ethtool_link_ksettings,
        link_mode: ethtool_link_mode_bit_indices,
    );
}
extern "C" {
    pub fn ethtool_get_phc_vclocks(
        dev: *mut net_device,
        vclock_index: *mut *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ethtool_op_get_link(dev: *mut net_device) -> u32_;
}
extern "C" {
    pub fn ethtool_op_get_ts_info(
        dev: *mut net_device,
        eti: *mut ethtool_ts_info,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ethtool_get_ts_info_by_layer(
        dev: *mut net_device,
        info: *mut ethtool_ts_info,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ethtool_sprintf(data: *mut *mut u8_, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn ethtool_puts(data: *mut *mut u8_, str_: *const core::ffi::c_char);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_forced_speed_map {
    pub speed: u32_,
    pub caps: [core::ffi::c_ulong; 2usize],
    pub cap_arr: *const u32_,
    pub arr_size: u32_,
}
impl Default for ethtool_forced_speed_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn ethtool_forced_speed_maps_init(maps: *mut ethtool_forced_speed_map, size: u32_);
}
extern "C" {
    pub fn linkmode_resolve_pause(
        local_adv: *const core::ffi::c_ulong,
        partner_adv: *const core::ffi::c_ulong,
        tx_pause: *mut bool_,
        rx_pause: *mut bool_,
    );
}
extern "C" {
    pub fn linkmode_set_pause(advertisement: *mut core::ffi::c_ulong, tx: bool_, rx: bool_);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mii_ioctl_data {
    pub phy_id: __u16,
    pub reg_num: __u16,
    pub val_in: __u16,
    pub val_out: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mii_if_info {
    pub phy_id: core::ffi::c_int,
    pub advertising: core::ffi::c_int,
    pub phy_id_mask: core::ffi::c_int,
    pub reg_num_mask: core::ffi::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub dev: *mut net_device,
    pub mdio_read: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            phy_id: core::ffi::c_int,
            location: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub mdio_write: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            phy_id: core::ffi::c_int,
            location: core::ffi::c_int,
            val: core::ffi::c_int,
        ),
    >,
}
impl Default for mii_if_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl mii_if_info {
    #[inline]
    pub fn full_duplex(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_full_duplex(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_media(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_media(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_gmii(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_gmii(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        full_duplex: core::ffi::c_uint,
        force_media: core::ffi::c_uint,
        supports_gmii: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let full_duplex: u32 = unsafe { ::core::mem::transmute(full_duplex) };
            full_duplex as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let force_media: u32 = unsafe { ::core::mem::transmute(force_media) };
            force_media as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let supports_gmii: u32 = unsafe { ::core::mem::transmute(supports_gmii) };
            supports_gmii as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn mii_link_ok(mii: *mut mii_if_info) -> core::ffi::c_int;
}
extern "C" {
    pub fn mii_nway_restart(mii: *mut mii_if_info) -> core::ffi::c_int;
}
extern "C" {
    pub fn mii_ethtool_gset(mii: *mut mii_if_info, ecmd: *mut ethtool_cmd);
}
extern "C" {
    pub fn mii_ethtool_get_link_ksettings(mii: *mut mii_if_info, cmd: *mut ethtool_link_ksettings);
}
extern "C" {
    pub fn mii_ethtool_sset(mii: *mut mii_if_info, ecmd: *mut ethtool_cmd) -> core::ffi::c_int;
}
extern "C" {
    pub fn mii_ethtool_set_link_ksettings(
        mii: *mut mii_if_info,
        cmd: *const ethtool_link_ksettings,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mii_check_gmii_support(mii: *mut mii_if_info) -> core::ffi::c_int;
}
extern "C" {
    pub fn mii_check_link(mii: *mut mii_if_info);
}
extern "C" {
    pub fn mii_check_media(
        mii: *mut mii_if_info,
        ok_to_print: core::ffi::c_uint,
        init_media: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn generic_mii_ioctl(
        mii_if: *mut mii_if_info,
        mii_data: *mut mii_ioctl_data,
        cmd: core::ffi::c_int,
        duplex_changed: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __field_overflow();
}
extern "C" {
    pub fn __bad_mask();
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct uuid_le {
    pub b: [__u8; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mei_client {
    pub max_msg_length: __u32,
    pub protocol_version: __u8,
    pub reserved: [__u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mei_connect_client_data {
    pub __bindgen_anon_1: mei_connect_client_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mei_connect_client_data__bindgen_ty_1 {
    pub in_client_uuid: uuid_le,
    pub out_client_properties: mei_client,
}
impl Default for mei_connect_client_data__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mei_connect_client_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mei_connect_client_vtag {
    pub in_client_uuid: uuid_le,
    pub vtag: __u8,
    pub reserved: [__u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mei_connect_client_data_vtag {
    pub __bindgen_anon_1: mei_connect_client_data_vtag__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mei_connect_client_data_vtag__bindgen_ty_1 {
    pub connect: mei_connect_client_vtag,
    pub out_client_properties: mei_client,
}
impl Default for mei_connect_client_data_vtag__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mei_connect_client_data_vtag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type kernel_ulong_t = core::ffi::c_ulong;
pub const PCI_ID_F_VFIO_DRIVER_OVERRIDE: _bindgen_ty_112 = 1;
pub type _bindgen_ty_112 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pci_device_id {
    pub vendor: __u32,
    pub device: __u32,
    pub subvendor: __u32,
    pub subdevice: __u32,
    pub class: __u32,
    pub class_mask: __u32,
    pub driver_data: kernel_ulong_t,
    pub override_only: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ieee1394_device_id {
    pub match_flags: __u32,
    pub vendor_id: __u32,
    pub model_id: __u32,
    pub specifier_id: __u32,
    pub version: __u32,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct usb_device_id {
    pub match_flags: __u16,
    pub idVendor: __u16,
    pub idProduct: __u16,
    pub bcdDevice_lo: __u16,
    pub bcdDevice_hi: __u16,
    pub bDeviceClass: __u8,
    pub bDeviceSubClass: __u8,
    pub bDeviceProtocol: __u8,
    pub bInterfaceClass: __u8,
    pub bInterfaceSubClass: __u8,
    pub bInterfaceProtocol: __u8,
    pub bInterfaceNumber: __u8,
    pub driver_info: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hid_device_id {
    pub bus: __u16,
    pub group: __u16,
    pub vendor: __u32,
    pub product: __u32,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ccw_device_id {
    pub match_flags: __u16,
    pub cu_type: __u16,
    pub dev_type: __u16,
    pub cu_model: __u8,
    pub dev_model: __u8,
    pub driver_info: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ap_device_id {
    pub match_flags: __u16,
    pub dev_type: __u8,
    pub driver_info: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct css_device_id {
    pub match_flags: __u8,
    pub type_: __u8,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_device_id {
    pub id: [__u8; 16usize],
    pub driver_data: kernel_ulong_t,
    pub cls: __u32,
    pub cls_msk: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pnp_device_id {
    pub id: [__u8; 8usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pnp_card_device_id {
    pub id: [__u8; 8usize],
    pub driver_data: kernel_ulong_t,
    pub devs: [pnp_card_device_id__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pnp_card_device_id__bindgen_ty_1 {
    pub id: [__u8; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct serio_device_id {
    pub type_: __u8,
    pub extra: __u8,
    pub id: __u8,
    pub proto: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hda_device_id {
    pub vendor_id: __u32,
    pub rev_id: __u32,
    pub api_version: __u8,
    pub name: *const core::ffi::c_char,
    pub driver_data: core::ffi::c_ulong,
}
impl Default for hda_device_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sdw_device_id {
    pub mfg_id: __u16,
    pub part_id: __u16,
    pub sdw_version: __u8,
    pub class_id: __u8,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_device_id {
    pub name: [core::ffi::c_char; 32usize],
    pub type_: [core::ffi::c_char; 32usize],
    pub compatible: [core::ffi::c_char; 128usize],
    pub data: *const core::ffi::c_void,
}
impl Default for of_device_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vio_device_id {
    pub type_: [core::ffi::c_char; 32usize],
    pub compat: [core::ffi::c_char; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pcmcia_device_id {
    pub match_flags: __u16,
    pub manf_id: __u16,
    pub card_id: __u16,
    pub func_id: __u8,
    pub function: __u8,
    pub device_no: __u8,
    pub prod_id_hash: [__u32; 4usize],
    pub prod_id: [*const core::ffi::c_char; 4usize],
    pub driver_info: kernel_ulong_t,
    pub cisfile: *mut core::ffi::c_char,
}
impl Default for pcmcia_device_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct input_device_id {
    pub flags: kernel_ulong_t,
    pub bustype: __u16,
    pub vendor: __u16,
    pub product: __u16,
    pub version: __u16,
    pub evbit: [kernel_ulong_t; 1usize],
    pub keybit: [kernel_ulong_t; 12usize],
    pub relbit: [kernel_ulong_t; 1usize],
    pub absbit: [kernel_ulong_t; 1usize],
    pub mscbit: [kernel_ulong_t; 1usize],
    pub ledbit: [kernel_ulong_t; 1usize],
    pub sndbit: [kernel_ulong_t; 1usize],
    pub ffbit: [kernel_ulong_t; 2usize],
    pub swbit: [kernel_ulong_t; 1usize],
    pub propbit: [kernel_ulong_t; 1usize],
    pub driver_info: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct eisa_device_id {
    pub sig: [core::ffi::c_char; 8usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct parisc_device_id {
    pub hw_type: __u8,
    pub hversion_rev: __u8,
    pub hversion: __u16,
    pub sversion: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sdio_device_id {
    pub class: __u8,
    pub vendor: __u16,
    pub device: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C, packed(2))]
#[derive(Default, Copy, Clone)]
pub struct ssb_device_id {
    pub vendor: __u16,
    pub coreid: __u16,
    pub revision: __u8,
    pub __pad: __u8,
}
#[repr(C, packed(2))]
#[derive(Default, Copy, Clone)]
pub struct bcma_device_id {
    pub manuf: __u16,
    pub id: __u16,
    pub rev: __u8,
    pub class: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct virtio_device_id {
    pub device: __u32,
    pub vendor: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hv_vmbus_device_id {
    pub guid: guid_t,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rpmsg_device_id {
    pub name: [core::ffi::c_char; 32usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct i2c_device_id {
    pub name: [core::ffi::c_char; 20usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pci_epf_device_id {
    pub name: [core::ffi::c_char; 20usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct i3c_device_id {
    pub match_flags: __u8,
    pub dcr: __u8,
    pub manuf_id: __u16,
    pub part_id: __u16,
    pub extra_info: __u16,
    pub data: *const core::ffi::c_void,
}
impl Default for i3c_device_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct spi_device_id {
    pub name: [core::ffi::c_char; 32usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct slim_device_id {
    pub manf_id: __u16,
    pub prod_code: __u16,
    pub dev_index: __u16,
    pub instance: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct apr_device_id {
    pub name: [core::ffi::c_char; 32usize],
    pub domain_id: __u32,
    pub svc_id: __u32,
    pub svc_version: __u32,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct spmi_device_id {
    pub name: [core::ffi::c_char; 32usize],
    pub driver_data: kernel_ulong_t,
}
pub const dmi_field_DMI_NONE: dmi_field = 0;
pub const dmi_field_DMI_BIOS_VENDOR: dmi_field = 1;
pub const dmi_field_DMI_BIOS_VERSION: dmi_field = 2;
pub const dmi_field_DMI_BIOS_DATE: dmi_field = 3;
pub const dmi_field_DMI_BIOS_RELEASE: dmi_field = 4;
pub const dmi_field_DMI_EC_FIRMWARE_RELEASE: dmi_field = 5;
pub const dmi_field_DMI_SYS_VENDOR: dmi_field = 6;
pub const dmi_field_DMI_PRODUCT_NAME: dmi_field = 7;
pub const dmi_field_DMI_PRODUCT_VERSION: dmi_field = 8;
pub const dmi_field_DMI_PRODUCT_SERIAL: dmi_field = 9;
pub const dmi_field_DMI_PRODUCT_UUID: dmi_field = 10;
pub const dmi_field_DMI_PRODUCT_SKU: dmi_field = 11;
pub const dmi_field_DMI_PRODUCT_FAMILY: dmi_field = 12;
pub const dmi_field_DMI_BOARD_VENDOR: dmi_field = 13;
pub const dmi_field_DMI_BOARD_NAME: dmi_field = 14;
pub const dmi_field_DMI_BOARD_VERSION: dmi_field = 15;
pub const dmi_field_DMI_BOARD_SERIAL: dmi_field = 16;
pub const dmi_field_DMI_BOARD_ASSET_TAG: dmi_field = 17;
pub const dmi_field_DMI_CHASSIS_VENDOR: dmi_field = 18;
pub const dmi_field_DMI_CHASSIS_TYPE: dmi_field = 19;
pub const dmi_field_DMI_CHASSIS_VERSION: dmi_field = 20;
pub const dmi_field_DMI_CHASSIS_SERIAL: dmi_field = 21;
pub const dmi_field_DMI_CHASSIS_ASSET_TAG: dmi_field = 22;
pub const dmi_field_DMI_STRING_MAX: dmi_field = 23;
pub const dmi_field_DMI_OEM_STRING: dmi_field = 24;
pub type dmi_field = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dmi_strmatch {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub substr: [core::ffi::c_char; 79usize],
}
impl Default for dmi_strmatch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl dmi_strmatch {
    #[inline]
    pub fn slot(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_slot(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn exact_match(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_exact_match(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slot: core::ffi::c_uchar,
        exact_match: core::ffi::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let slot: u8 = unsafe { ::core::mem::transmute(slot) };
            slot as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let exact_match: u8 = unsafe { ::core::mem::transmute(exact_match) };
            exact_match as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dmi_system_id {
    pub callback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dmi_system_id) -> core::ffi::c_int,
    >,
    pub ident: *const core::ffi::c_char,
    pub matches: [dmi_strmatch; 4usize],
    pub driver_data: *mut core::ffi::c_void,
}
impl Default for dmi_system_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct platform_device_id {
    pub name: [core::ffi::c_char; 20usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mdio_device_id {
    pub phy_id: __u32,
    pub phy_id_mask: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct zorro_device_id {
    pub id: __u32,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct isapnp_device_id {
    pub card_vendor: core::ffi::c_ushort,
    pub card_device: core::ffi::c_ushort,
    pub vendor: core::ffi::c_ushort,
    pub function: core::ffi::c_ushort,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amba_id {
    pub id: core::ffi::c_uint,
    pub mask: core::ffi::c_uint,
    pub data: *mut core::ffi::c_void,
}
impl Default for amba_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mips_cdmm_device_id {
    pub type_: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_cpu_id {
    pub vendor: __u16,
    pub family: __u16,
    pub model: __u16,
    pub steppings: __u16,
    pub feature: __u16,
    pub flags: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpu_feature {
    pub feature: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ipack_device_id {
    pub format: __u8,
    pub vendor: __u32,
    pub device: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mei_cl_device_id {
    pub name: [core::ffi::c_char; 32usize],
    pub uuid: uuid_le,
    pub version: __u8,
    pub driver_info: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rio_device_id {
    pub did: __u16,
    pub vid: __u16,
    pub asm_did: __u16,
    pub asm_vid: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mcb_device_id {
    pub device: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ulpi_device_id {
    pub vendor: __u16,
    pub product: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fsl_mc_device_id {
    pub vendor: __u16,
    pub obj_type: [core::ffi::c_char; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tb_service_id {
    pub match_flags: __u32,
    pub protocol_key: [core::ffi::c_char; 9usize],
    pub protocol_id: __u32,
    pub protocol_version: __u32,
    pub protocol_revision: __u32,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct typec_device_id {
    pub svid: __u16,
    pub mode: __u8,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tee_client_device_id {
    pub uuid: uuid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wmi_device_id {
    pub guid_string: [core::ffi::c_char; 37usize],
    pub context: *const core::ffi::c_void,
}
impl Default for wmi_device_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mhi_device_id {
    pub chan: [core::ffi::c_char; 32usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct auxiliary_device_id {
    pub name: [core::ffi::c_char; 32usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ssam_device_id {
    pub match_flags: __u8,
    pub domain: __u8,
    pub category: __u8,
    pub target: __u8,
    pub instance: __u8,
    pub function: __u8,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dfl_device_id {
    pub type_: __u16,
    pub feature_id: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ishtp_device_id {
    pub guid: guid_t,
    pub driver_data: kernel_ulong_t,
}
pub const CDX_ID_F_VFIO_DRIVER_OVERRIDE: _bindgen_ty_113 = 1;
pub type _bindgen_ty_113 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cdx_device_id {
    pub vendor: __u16,
    pub device: __u16,
    pub subvendor: __u16,
    pub subdevice: __u16,
    pub class: __u32,
    pub class_mask: __u32,
    pub override_only: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vchiq_device_id {
    pub name: [core::ffi::c_char; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_desc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct reset_control {
    _unused: [u8; 0],
}
pub const mdio_mutex_lock_class_MDIO_MUTEX_NORMAL: mdio_mutex_lock_class = 0;
pub const mdio_mutex_lock_class_MDIO_MUTEX_MUX: mdio_mutex_lock_class = 1;
pub const mdio_mutex_lock_class_MDIO_MUTEX_NESTED: mdio_mutex_lock_class = 2;
pub type mdio_mutex_lock_class = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mdio_device {
    pub dev: device,
    pub bus: *mut mii_bus,
    pub modalias: [core::ffi::c_char; 32usize],
    pub bus_match: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, drv: *mut device_driver) -> core::ffi::c_int,
    >,
    pub device_free: ::core::option::Option<unsafe extern "C" fn(mdiodev: *mut mdio_device)>,
    pub device_remove: ::core::option::Option<unsafe extern "C" fn(mdiodev: *mut mdio_device)>,
    pub addr: core::ffi::c_int,
    pub flags: core::ffi::c_int,
    pub reset_state: core::ffi::c_int,
    pub reset_gpio: *mut gpio_desc,
    pub reset_ctrl: *mut reset_control,
    pub reset_assert_delay: core::ffi::c_uint,
    pub reset_deassert_delay: core::ffi::c_uint,
}
impl Default for mdio_device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mdio_driver_common {
    pub driver: device_driver,
    pub flags: core::ffi::c_int,
}
impl Default for mdio_driver_common {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mdio_driver {
    pub mdiodrv: mdio_driver_common,
    pub probe:
        ::core::option::Option<unsafe extern "C" fn(mdiodev: *mut mdio_device) -> core::ffi::c_int>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(mdiodev: *mut mdio_device)>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(mdiodev: *mut mdio_device)>,
}
impl Default for mdio_driver {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn mdio_device_free(mdiodev: *mut mdio_device);
}
extern "C" {
    pub fn mdio_device_create(bus: *mut mii_bus, addr: core::ffi::c_int) -> *mut mdio_device;
}
extern "C" {
    pub fn mdio_device_register(mdiodev: *mut mdio_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdio_device_remove(mdiodev: *mut mdio_device);
}
extern "C" {
    pub fn mdio_device_reset(mdiodev: *mut mdio_device, value: core::ffi::c_int);
}
extern "C" {
    pub fn mdio_driver_register(drv: *mut mdio_driver) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdio_driver_unregister(drv: *mut mdio_driver);
}
extern "C" {
    pub fn mdio_device_bus_match(dev: *mut device, drv: *mut device_driver) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mdio_if_info {
    pub prtad: core::ffi::c_int,
    pub mmds: u32_,
    pub mode_support: core::ffi::c_uint,
    pub dev: *mut net_device,
    pub mdio_read: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            prtad: core::ffi::c_int,
            devad: core::ffi::c_int,
            addr: u16_,
        ) -> core::ffi::c_int,
    >,
    pub mdio_write: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            prtad: core::ffi::c_int,
            devad: core::ffi::c_int,
            addr: u16_,
            val: u16_,
        ) -> core::ffi::c_int,
    >,
}
impl Default for mdio_if_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn mdio45_probe(mdio: *mut mdio_if_info, prtad: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdio_set_flag(
        mdio: *const mdio_if_info,
        prtad: core::ffi::c_int,
        devad: core::ffi::c_int,
        addr: u16_,
        mask: core::ffi::c_int,
        sense: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdio45_links_ok(mdio: *const mdio_if_info, mmds: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdio45_nway_restart(mdio: *const mdio_if_info) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdio45_ethtool_gset_npage(
        mdio: *const mdio_if_info,
        ecmd: *mut ethtool_cmd,
        npage_adv: u32_,
        npage_lpa: u32_,
    );
}
extern "C" {
    pub fn mdio45_ethtool_ksettings_get_npage(
        mdio: *const mdio_if_info,
        cmd: *mut ethtool_link_ksettings,
        npage_adv: u32_,
        npage_lpa: u32_,
    );
}
extern "C" {
    pub fn mdio_mii_ioctl(
        mdio: *const mdio_if_info,
        mii_data: *mut mii_ioctl_data,
        cmd: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __mdiobus_read(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        regnum: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __mdiobus_write(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        regnum: u32_,
        val: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __mdiobus_modify(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        regnum: u32_,
        mask: u16_,
        set: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __mdiobus_modify_changed(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        regnum: u32_,
        mask: u16_,
        set: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdiobus_read(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        regnum: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdiobus_read_nested(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        regnum: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdiobus_write(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        regnum: u32_,
        val: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdiobus_write_nested(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        regnum: u32_,
        val: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdiobus_modify(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        regnum: u32_,
        mask: u16_,
        set: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdiobus_modify_changed(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        regnum: u32_,
        mask: u16_,
        set: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __mdiobus_c45_read(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        devad: core::ffi::c_int,
        regnum: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdiobus_c45_read(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        devad: core::ffi::c_int,
        regnum: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdiobus_c45_read_nested(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        devad: core::ffi::c_int,
        regnum: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __mdiobus_c45_write(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        devad: core::ffi::c_int,
        regnum: u32_,
        val: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdiobus_c45_write(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        devad: core::ffi::c_int,
        regnum: u32_,
        val: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdiobus_c45_write_nested(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        devad: core::ffi::c_int,
        regnum: u32_,
        val: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdiobus_c45_modify(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        devad: core::ffi::c_int,
        regnum: u32_,
        mask: u16_,
        set: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdiobus_c45_modify_changed(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        devad: core::ffi::c_int,
        regnum: u32_,
        mask: u16_,
        set: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdiobus_register_device(mdiodev: *mut mdio_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdiobus_unregister_device(mdiodev: *mut mdio_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdiobus_is_registered_device(bus: *mut mii_bus, addr: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn mdiobus_get_phy(bus: *mut mii_bus, addr: core::ffi::c_int) -> *mut phy_device;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct platform_device {
    _unused: [u8; 0],
}
pub const led_brightness_LED_OFF: led_brightness = 0;
pub const led_brightness_LED_ON: led_brightness = 1;
pub const led_brightness_LED_HALF: led_brightness = 127;
pub const led_brightness_LED_FULL: led_brightness = 255;
pub type led_brightness = core::ffi::c_uint;
pub const led_default_state_LEDS_DEFSTATE_OFF: led_default_state = 0;
pub const led_default_state_LEDS_DEFSTATE_ON: led_default_state = 1;
pub const led_default_state_LEDS_DEFSTATE_KEEP: led_default_state = 2;
pub type led_default_state = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct led_lookup_data {
    pub list: list_head,
    pub provider: *const core::ffi::c_char,
    pub dev_id: *const core::ffi::c_char,
    pub con_id: *const core::ffi::c_char,
}
impl Default for led_lookup_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct led_init_data {
    pub fwnode: *mut fwnode_handle,
    pub default_label: *const core::ffi::c_char,
    pub devicename: *const core::ffi::c_char,
    pub devname_mandatory: bool_,
}
impl Default for led_init_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn led_init_default_state_get(fwnode: *mut fwnode_handle) -> led_default_state;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct led_hw_trigger_type {
    pub dummy: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct led_classdev {
    pub name: *const core::ffi::c_char,
    pub brightness: core::ffi::c_uint,
    pub max_brightness: core::ffi::c_uint,
    pub color: core::ffi::c_uint,
    pub flags: core::ffi::c_int,
    pub work_flags: core::ffi::c_ulong,
    pub brightness_set: ::core::option::Option<
        unsafe extern "C" fn(led_cdev: *mut led_classdev, brightness: led_brightness),
    >,
    pub brightness_set_blocking: ::core::option::Option<
        unsafe extern "C" fn(
            led_cdev: *mut led_classdev,
            brightness: led_brightness,
        ) -> core::ffi::c_int,
    >,
    pub brightness_get:
        ::core::option::Option<unsafe extern "C" fn(led_cdev: *mut led_classdev) -> led_brightness>,
    pub blink_set: ::core::option::Option<
        unsafe extern "C" fn(
            led_cdev: *mut led_classdev,
            delay_on: *mut core::ffi::c_ulong,
            delay_off: *mut core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub pattern_set: ::core::option::Option<
        unsafe extern "C" fn(
            led_cdev: *mut led_classdev,
            pattern: *mut led_pattern,
            len: u32_,
            repeat: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub pattern_clear: ::core::option::Option<
        unsafe extern "C" fn(led_cdev: *mut led_classdev) -> core::ffi::c_int,
    >,
    pub dev: *mut device,
    pub groups: *mut *const attribute_group,
    pub node: list_head,
    pub default_trigger: *const core::ffi::c_char,
    pub blink_delay_on: core::ffi::c_ulong,
    pub blink_delay_off: core::ffi::c_ulong,
    pub blink_timer: timer_list,
    pub blink_brightness: core::ffi::c_int,
    pub new_blink_brightness: core::ffi::c_int,
    pub flash_resume: ::core::option::Option<unsafe extern "C" fn(led_cdev: *mut led_classdev)>,
    pub set_brightness_work: work_struct,
    pub delayed_set_value: core::ffi::c_int,
    pub delayed_delay_on: core::ffi::c_ulong,
    pub delayed_delay_off: core::ffi::c_ulong,
    pub trigger_lock: rw_semaphore,
    pub trigger: *mut led_trigger,
    pub trig_list: list_head,
    pub trigger_data: *mut core::ffi::c_void,
    pub activated: bool_,
    pub trigger_type: *mut led_hw_trigger_type,
    pub hw_control_trigger: *const core::ffi::c_char,
    pub hw_control_is_supported: ::core::option::Option<
        unsafe extern "C" fn(
            led_cdev: *mut led_classdev,
            flags: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub hw_control_set: ::core::option::Option<
        unsafe extern "C" fn(
            led_cdev: *mut led_classdev,
            flags: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub hw_control_get: ::core::option::Option<
        unsafe extern "C" fn(
            led_cdev: *mut led_classdev,
            flags: *mut core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub hw_control_get_device:
        ::core::option::Option<unsafe extern "C" fn(led_cdev: *mut led_classdev) -> *mut device>,
    pub brightness_hw_changed: core::ffi::c_int,
    pub brightness_hw_changed_kn: *mut kernfs_node,
    pub led_access: mutex,
}
impl Default for led_classdev {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn led_classdev_register_ext(
        parent: *mut device,
        led_cdev: *mut led_classdev,
        init_data: *mut led_init_data,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_led_classdev_register_ext(
        parent: *mut device,
        led_cdev: *mut led_classdev,
        init_data: *mut led_init_data,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn led_classdev_unregister(led_cdev: *mut led_classdev);
}
extern "C" {
    pub fn devm_led_classdev_unregister(parent: *mut device, led_cdev: *mut led_classdev);
}
extern "C" {
    pub fn led_classdev_suspend(led_cdev: *mut led_classdev);
}
extern "C" {
    pub fn led_classdev_resume(led_cdev: *mut led_classdev);
}
extern "C" {
    pub fn led_add_lookup(led_lookup: *mut led_lookup_data);
}
extern "C" {
    pub fn led_remove_lookup(led_lookup: *mut led_lookup_data);
}
extern "C" {
    pub fn led_get(dev: *mut device, con_id: *mut core::ffi::c_char) -> *mut led_classdev;
}
extern "C" {
    pub fn devm_led_get(dev: *mut device, con_id: *mut core::ffi::c_char) -> *mut led_classdev;
}
extern "C" {
    pub fn of_led_get(np: *mut device_node, index: core::ffi::c_int) -> *mut led_classdev;
}
extern "C" {
    pub fn led_put(led_cdev: *mut led_classdev);
}
extern "C" {
    pub fn devm_of_led_get(dev: *mut device, index: core::ffi::c_int) -> *mut led_classdev;
}
extern "C" {
    pub fn devm_of_led_get_optional(dev: *mut device, index: core::ffi::c_int)
        -> *mut led_classdev;
}
extern "C" {
    pub fn led_blink_set(
        led_cdev: *mut led_classdev,
        delay_on: *mut core::ffi::c_ulong,
        delay_off: *mut core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn led_blink_set_nosleep(
        led_cdev: *mut led_classdev,
        delay_on: core::ffi::c_ulong,
        delay_off: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn led_blink_set_oneshot(
        led_cdev: *mut led_classdev,
        delay_on: *mut core::ffi::c_ulong,
        delay_off: *mut core::ffi::c_ulong,
        invert: core::ffi::c_int,
    );
}
extern "C" {
    pub fn led_set_brightness(led_cdev: *mut led_classdev, brightness: core::ffi::c_uint);
}
extern "C" {
    pub fn led_set_brightness_sync(
        led_cdev: *mut led_classdev,
        value: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn led_update_brightness(led_cdev: *mut led_classdev) -> core::ffi::c_int;
}
extern "C" {
    pub fn led_get_default_pattern(
        led_cdev: *mut led_classdev,
        size: *mut core::ffi::c_uint,
    ) -> *mut u32_;
}
extern "C" {
    pub fn led_sysfs_disable(led_cdev: *mut led_classdev);
}
extern "C" {
    pub fn led_sysfs_enable(led_cdev: *mut led_classdev);
}
extern "C" {
    pub fn led_compose_name(
        dev: *mut device,
        init_data: *mut led_init_data,
        led_classdev_name: *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct led_trigger {
    pub name: *const core::ffi::c_char,
    pub activate: ::core::option::Option<
        unsafe extern "C" fn(led_cdev: *mut led_classdev) -> core::ffi::c_int,
    >,
    pub deactivate: ::core::option::Option<unsafe extern "C" fn(led_cdev: *mut led_classdev)>,
    pub trigger_type: *mut led_hw_trigger_type,
    pub leddev_list_lock: spinlock_t,
    pub led_cdevs: list_head,
    pub next_trig: list_head,
    pub groups: *mut *const attribute_group,
}
impl Default for led_trigger {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn led_trigger_register(trigger: *mut led_trigger) -> core::ffi::c_int;
}
extern "C" {
    pub fn led_trigger_unregister(trigger: *mut led_trigger);
}
extern "C" {
    pub fn devm_led_trigger_register(
        dev: *mut device,
        trigger: *mut led_trigger,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn led_trigger_register_simple(
        name: *const core::ffi::c_char,
        trigger: *mut *mut led_trigger,
    );
}
extern "C" {
    pub fn led_trigger_unregister_simple(trigger: *mut led_trigger);
}
extern "C" {
    pub fn led_trigger_event(trigger: *mut led_trigger, event: led_brightness);
}
extern "C" {
    pub fn led_trigger_blink(
        trigger: *mut led_trigger,
        delay_on: core::ffi::c_ulong,
        delay_off: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn led_trigger_blink_oneshot(
        trigger: *mut led_trigger,
        delay_on: core::ffi::c_ulong,
        delay_off: core::ffi::c_ulong,
        invert: core::ffi::c_int,
    );
}
extern "C" {
    pub fn led_trigger_set_default(led_cdev: *mut led_classdev);
}
extern "C" {
    pub fn led_trigger_set(
        led_cdev: *mut led_classdev,
        trigger: *mut led_trigger,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn led_trigger_remove(led_cdev: *mut led_classdev);
}
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_LINK: led_trigger_netdev_modes = 0;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_LINK_10: led_trigger_netdev_modes = 1;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_LINK_100: led_trigger_netdev_modes = 2;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_LINK_1000: led_trigger_netdev_modes = 3;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_LINK_2500: led_trigger_netdev_modes = 4;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_LINK_5000: led_trigger_netdev_modes = 5;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_LINK_10000: led_trigger_netdev_modes = 6;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_HALF_DUPLEX: led_trigger_netdev_modes = 7;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_FULL_DUPLEX: led_trigger_netdev_modes = 8;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_TX: led_trigger_netdev_modes = 9;
pub const led_trigger_netdev_modes_TRIGGER_NETDEV_RX: led_trigger_netdev_modes = 10;
pub const led_trigger_netdev_modes___TRIGGER_NETDEV_MAX: led_trigger_netdev_modes = 11;
pub type led_trigger_netdev_modes = core::ffi::c_uint;
extern "C" {
    pub fn ledtrig_disk_activity(write: bool_);
}
extern "C" {
    pub fn ledtrig_mtd_activity();
}
extern "C" {
    pub fn ledtrig_flash_ctrl(on: bool_);
}
extern "C" {
    pub fn ledtrig_torch_ctrl(on: bool_);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct led_info {
    pub name: *const core::ffi::c_char,
    pub default_trigger: *const core::ffi::c_char,
    pub flags: core::ffi::c_int,
}
impl Default for led_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct led_platform_data {
    pub num_leds: core::ffi::c_int,
    pub leds: *mut led_info,
}
impl Default for led_platform_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct led_properties {
    pub color: u32_,
    pub color_present: bool_,
    pub function: *const core::ffi::c_char,
    pub func_enum: u32_,
    pub func_enum_present: bool_,
    pub label: *const core::ffi::c_char,
}
impl Default for led_properties {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type gpio_blink_set_t = ::core::option::Option<
    unsafe extern "C" fn(
        desc: *mut gpio_desc,
        state: core::ffi::c_int,
        delay_on: *mut core::ffi::c_ulong,
        delay_off: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_led {
    pub name: *const core::ffi::c_char,
    pub default_trigger: *const core::ffi::c_char,
    pub gpio: core::ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub gpiod: *mut gpio_desc,
}
impl Default for gpio_led {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl gpio_led {
    #[inline]
    pub fn active_low(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active_low(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn retain_state_suspended(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_retain_state_suspended(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn panic_indicator(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_panic_indicator(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn default_state(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_default_state(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn retain_state_shutdown(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_retain_state_shutdown(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active_low: core::ffi::c_uint,
        retain_state_suspended: core::ffi::c_uint,
        panic_indicator: core::ffi::c_uint,
        default_state: core::ffi::c_uint,
        retain_state_shutdown: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let active_low: u32 = unsafe { ::core::mem::transmute(active_low) };
            active_low as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let retain_state_suspended: u32 =
                unsafe { ::core::mem::transmute(retain_state_suspended) };
            retain_state_suspended as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let panic_indicator: u32 = unsafe { ::core::mem::transmute(panic_indicator) };
            panic_indicator as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let default_state: u32 = unsafe { ::core::mem::transmute(default_state) };
            default_state as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let retain_state_shutdown: u32 =
                unsafe { ::core::mem::transmute(retain_state_shutdown) };
            retain_state_shutdown as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_led_platform_data {
    pub num_leds: core::ffi::c_int,
    pub leds: *const gpio_led,
    pub gpio_blink_set: gpio_blink_set_t,
}
impl Default for gpio_led_platform_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn gpio_led_register_device(
        id: core::ffi::c_int,
        pdata: *const gpio_led_platform_data,
    ) -> *mut platform_device;
}
pub const cpu_led_event_CPU_LED_IDLE_START: cpu_led_event = 0;
pub const cpu_led_event_CPU_LED_IDLE_END: cpu_led_event = 1;
pub const cpu_led_event_CPU_LED_START: cpu_led_event = 2;
pub const cpu_led_event_CPU_LED_STOP: cpu_led_event = 3;
pub const cpu_led_event_CPU_LED_HALTED: cpu_led_event = 4;
pub type cpu_led_event = core::ffi::c_uint;
extern "C" {
    pub fn ledtrig_cpu(evt: cpu_led_event);
}
extern "C" {
    pub fn led_classdev_notify_brightness_hw_changed(
        led_cdev: *mut led_classdev,
        brightness: core::ffi::c_uint,
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct led_pattern {
    pub delta_t: u32_,
    pub brightness: core::ffi::c_int,
}
pub const led_audio_LED_AUDIO_MUTE: led_audio = 0;
pub const led_audio_LED_AUDIO_MICMUTE: led_audio = 1;
pub const led_audio_NUM_AUDIO_LEDS: led_audio = 2;
pub type led_audio = core::ffi::c_uint;
extern "C" {
    pub fn ledtrig_audio_get(type_: led_audio) -> led_brightness;
}
extern "C" {
    pub fn ledtrig_audio_set(type_: led_audio, state: led_brightness);
}
pub const SOF_TIMESTAMPING_TX_HARDWARE: _bindgen_ty_114 = 1;
pub const SOF_TIMESTAMPING_TX_SOFTWARE: _bindgen_ty_114 = 2;
pub const SOF_TIMESTAMPING_RX_HARDWARE: _bindgen_ty_114 = 4;
pub const SOF_TIMESTAMPING_RX_SOFTWARE: _bindgen_ty_114 = 8;
pub const SOF_TIMESTAMPING_SOFTWARE: _bindgen_ty_114 = 16;
pub const SOF_TIMESTAMPING_SYS_HARDWARE: _bindgen_ty_114 = 32;
pub const SOF_TIMESTAMPING_RAW_HARDWARE: _bindgen_ty_114 = 64;
pub const SOF_TIMESTAMPING_OPT_ID: _bindgen_ty_114 = 128;
pub const SOF_TIMESTAMPING_TX_SCHED: _bindgen_ty_114 = 256;
pub const SOF_TIMESTAMPING_TX_ACK: _bindgen_ty_114 = 512;
pub const SOF_TIMESTAMPING_OPT_CMSG: _bindgen_ty_114 = 1024;
pub const SOF_TIMESTAMPING_OPT_TSONLY: _bindgen_ty_114 = 2048;
pub const SOF_TIMESTAMPING_OPT_STATS: _bindgen_ty_114 = 4096;
pub const SOF_TIMESTAMPING_OPT_PKTINFO: _bindgen_ty_114 = 8192;
pub const SOF_TIMESTAMPING_OPT_TX_SWHW: _bindgen_ty_114 = 16384;
pub const SOF_TIMESTAMPING_BIND_PHC: _bindgen_ty_114 = 32768;
pub const SOF_TIMESTAMPING_OPT_ID_TCP: _bindgen_ty_114 = 65536;
pub const SOF_TIMESTAMPING_LAST: _bindgen_ty_114 = 65536;
pub const SOF_TIMESTAMPING_MASK: _bindgen_ty_114 = 131071;
pub type _bindgen_ty_114 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct so_timestamping {
    pub flags: core::ffi::c_int,
    pub bind_phc: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hwtstamp_config {
    pub flags: core::ffi::c_int,
    pub tx_type: core::ffi::c_int,
    pub rx_filter: core::ffi::c_int,
}
pub const hwtstamp_flags_HWTSTAMP_FLAG_BONDED_PHC_INDEX: hwtstamp_flags = 1;
pub const hwtstamp_flags_HWTSTAMP_FLAG_LAST: hwtstamp_flags = 1;
pub const hwtstamp_flags_HWTSTAMP_FLAG_MASK: hwtstamp_flags = 1;
pub type hwtstamp_flags = core::ffi::c_uint;
pub const hwtstamp_tx_types_HWTSTAMP_TX_OFF: hwtstamp_tx_types = 0;
pub const hwtstamp_tx_types_HWTSTAMP_TX_ON: hwtstamp_tx_types = 1;
pub const hwtstamp_tx_types_HWTSTAMP_TX_ONESTEP_SYNC: hwtstamp_tx_types = 2;
pub const hwtstamp_tx_types_HWTSTAMP_TX_ONESTEP_P2P: hwtstamp_tx_types = 3;
pub const hwtstamp_tx_types___HWTSTAMP_TX_CNT: hwtstamp_tx_types = 4;
pub type hwtstamp_tx_types = core::ffi::c_uint;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_NONE: hwtstamp_rx_filters = 0;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_ALL: hwtstamp_rx_filters = 1;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_SOME: hwtstamp_rx_filters = 2;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V1_L4_EVENT: hwtstamp_rx_filters = 3;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V1_L4_SYNC: hwtstamp_rx_filters = 4;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ: hwtstamp_rx_filters = 5;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L4_EVENT: hwtstamp_rx_filters = 6;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L4_SYNC: hwtstamp_rx_filters = 7;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ: hwtstamp_rx_filters = 8;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L2_EVENT: hwtstamp_rx_filters = 9;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L2_SYNC: hwtstamp_rx_filters = 10;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ: hwtstamp_rx_filters = 11;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_EVENT: hwtstamp_rx_filters = 12;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_SYNC: hwtstamp_rx_filters = 13;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_DELAY_REQ: hwtstamp_rx_filters = 14;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_NTP_ALL: hwtstamp_rx_filters = 15;
pub const hwtstamp_rx_filters___HWTSTAMP_FILTER_CNT: hwtstamp_rx_filters = 16;
pub type hwtstamp_rx_filters = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct scm_ts_pktinfo {
    pub if_index: __u32,
    pub pkt_length: __u32,
    pub reserved: [__u32; 2usize],
}
pub const txtime_flags_SOF_TXTIME_DEADLINE_MODE: txtime_flags = 1;
pub const txtime_flags_SOF_TXTIME_REPORT_ERRORS: txtime_flags = 2;
pub const txtime_flags_SOF_TXTIME_FLAGS_LAST: txtime_flags = 2;
pub const txtime_flags_SOF_TXTIME_FLAGS_MASK: txtime_flags = 3;
pub type txtime_flags = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sock_txtime {
    pub clockid: __kernel_clockid_t,
    pub flags: __u32,
}
pub const hwtstamp_source_HWTSTAMP_SOURCE_NETDEV: hwtstamp_source = 0;
pub const hwtstamp_source_HWTSTAMP_SOURCE_PHYLIB: hwtstamp_source = 1;
pub type hwtstamp_source = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_hwtstamp_config {
    pub flags: core::ffi::c_int,
    pub tx_type: core::ffi::c_int,
    pub rx_filter: core::ffi::c_int,
    pub ifr: *mut ifreq,
    pub copied_to_user: bool_,
    pub source: hwtstamp_source,
}
impl Default for kernel_hwtstamp_config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mii_timestamper {
    pub rxtstamp: ::core::option::Option<
        unsafe extern "C" fn(
            mii_ts: *mut mii_timestamper,
            skb: *mut sk_buff,
            type_: core::ffi::c_int,
        ) -> bool_,
    >,
    pub txtstamp: ::core::option::Option<
        unsafe extern "C" fn(
            mii_ts: *mut mii_timestamper,
            skb: *mut sk_buff,
            type_: core::ffi::c_int,
        ),
    >,
    pub hwtstamp: ::core::option::Option<
        unsafe extern "C" fn(
            mii_ts: *mut mii_timestamper,
            kernel_config: *mut kernel_hwtstamp_config,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub link_state: ::core::option::Option<
        unsafe extern "C" fn(mii_ts: *mut mii_timestamper, phydev: *mut phy_device),
    >,
    pub ts_info: ::core::option::Option<
        unsafe extern "C" fn(
            mii_ts: *mut mii_timestamper,
            ts_info: *mut ethtool_ts_info,
        ) -> core::ffi::c_int,
    >,
    pub device: *mut device,
}
impl Default for mii_timestamper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mii_timestamping_ctrl {
    pub probe_channel: ::core::option::Option<
        unsafe extern "C" fn(device: *mut device, port: core::ffi::c_uint) -> *mut mii_timestamper,
    >,
    pub release_channel: ::core::option::Option<
        unsafe extern "C" fn(device: *mut device, mii_ts: *mut mii_timestamper),
    >,
}
extern "C" {
    pub fn register_mii_tstamp_controller(
        device: *mut device,
        ctrl: *mut mii_timestamping_ctrl,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_mii_tstamp_controller(device: *mut device);
}
extern "C" {
    pub fn register_mii_timestamper(
        node: *mut device_node,
        port: core::ffi::c_uint,
    ) -> *mut mii_timestamper;
}
extern "C" {
    pub fn unregister_mii_timestamper(mii_ts: *mut mii_timestamper);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct u64_stats_sync {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct local_t {
    pub a: atomic_long_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct local64_t {
    pub a: local_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct u64_stats_t {
    pub v: local64_t,
}
pub const irqreturn_IRQ_NONE: irqreturn = 0;
pub const irqreturn_IRQ_HANDLED: irqreturn = 1;
pub const irqreturn_IRQ_WAKE_THREAD: irqreturn = 2;
pub type irqreturn = core::ffi::c_uint;
pub use self::irqreturn as irqreturn_t;
extern "C" {
    pub static mut loops_per_jiffy: core::ffi::c_ulong;
}
extern "C" {
    pub fn __bad_udelay();
}
extern "C" {
    pub fn __bad_ndelay();
}
extern "C" {
    pub fn __udelay(usecs: core::ffi::c_ulong);
}
extern "C" {
    pub fn __ndelay(nsecs: core::ffi::c_ulong);
}
extern "C" {
    pub fn __const_udelay(xloops: core::ffi::c_ulong);
}
extern "C" {
    pub fn __delay(loops: core::ffi::c_ulong);
}
extern "C" {
    pub fn use_tsc_delay();
}
extern "C" {
    pub fn use_tpause_delay();
}
extern "C" {
    pub fn use_mwaitx_delay();
}
extern "C" {
    pub static mut lpj_fine: core::ffi::c_ulong;
}
extern "C" {
    pub fn calibrate_delay();
}
extern "C" {
    pub fn calibrate_delay_is_known() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn calibration_delay_done();
}
extern "C" {
    pub fn msleep(msecs: core::ffi::c_uint);
}
extern "C" {
    pub fn msleep_interruptible(msecs: core::ffi::c_uint) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn usleep_range_state(
        min: core::ffi::c_ulong,
        max: core::ffi::c_ulong,
        state: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn __iowrite32_copy(
        to: *mut core::ffi::c_void,
        from: *const core::ffi::c_void,
        count: usize,
    );
}
extern "C" {
    pub fn __ioread32_copy(
        to: *mut core::ffi::c_void,
        from: *const core::ffi::c_void,
        count: usize,
    );
}
extern "C" {
    pub fn __iowrite64_copy(
        to: *mut core::ffi::c_void,
        from: *const core::ffi::c_void,
        count: usize,
    );
}
extern "C" {
    pub fn ioremap_page_range(
        addr: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        phys_addr: phys_addr_t,
        prot: pgprot_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_ioport_map(
        dev: *mut device,
        port: core::ffi::c_ulong,
        nr: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_ioport_unmap(dev: *mut device, addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devm_ioremap(
        dev: *mut device,
        offset: resource_size_t,
        size: resource_size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_ioremap_uc(
        dev: *mut device,
        offset: resource_size_t,
        size: resource_size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_ioremap_wc(
        dev: *mut device,
        offset: resource_size_t,
        size: resource_size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_iounmap(dev: *mut device, addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn check_signature(
        io_addr: *const core::ffi::c_void,
        signature: *const core::ffi::c_uchar,
        length: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_ioremap_release(dev: *mut device, res: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devm_memremap(
        dev: *mut device,
        offset: resource_size_t,
        size: usize,
        flags: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_memunmap(dev: *mut device, addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn early_memremap_pgprot_adjust(
        phys_addr: resource_size_t,
        size: core::ffi::c_ulong,
        prot: pgprot_t,
    ) -> pgprot_t;
}
extern "C" {
    pub fn devm_arch_phys_wc_add(
        dev: *mut device,
        base: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
pub const MEMREMAP_WB: _bindgen_ty_115 = 1;
pub const MEMREMAP_WT: _bindgen_ty_115 = 2;
pub const MEMREMAP_WC: _bindgen_ty_115 = 4;
pub const MEMREMAP_ENC: _bindgen_ty_115 = 8;
pub const MEMREMAP_DEC: _bindgen_ty_115 = 16;
pub type _bindgen_ty_115 = core::ffi::c_uint;
extern "C" {
    pub fn memremap(
        offset: resource_size_t,
        size: usize,
        flags: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memunmap(addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devm_arch_io_reserve_memtype_wc(
        dev: *mut device,
        start: resource_size_t,
        size: resource_size_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut phy_basic_features: [core::ffi::c_ulong; 2usize];
}
extern "C" {
    pub static mut phy_basic_t1_features: [core::ffi::c_ulong; 2usize];
}
extern "C" {
    pub static mut phy_basic_t1s_p2mp_features: [core::ffi::c_ulong; 2usize];
}
extern "C" {
    pub static mut phy_gbit_features: [core::ffi::c_ulong; 2usize];
}
extern "C" {
    pub static mut phy_gbit_fibre_features: [core::ffi::c_ulong; 2usize];
}
extern "C" {
    pub static mut phy_gbit_all_ports_features: [core::ffi::c_ulong; 2usize];
}
extern "C" {
    pub static mut phy_10gbit_features: [core::ffi::c_ulong; 2usize];
}
extern "C" {
    pub static mut phy_10gbit_fec_features: [core::ffi::c_ulong; 2usize];
}
extern "C" {
    pub static mut phy_10gbit_full_features: [core::ffi::c_ulong; 2usize];
}
extern "C" {
    pub static mut phy_eee_cap1_features: [core::ffi::c_ulong; 2usize];
}
extern "C" {
    pub static phy_basic_ports_array: [core::ffi::c_int; 3usize];
}
extern "C" {
    pub static phy_fibre_port_array: [core::ffi::c_int; 1usize];
}
extern "C" {
    pub static phy_all_ports_features_array: [core::ffi::c_int; 7usize];
}
extern "C" {
    pub static phy_10_100_features_array: [core::ffi::c_int; 4usize];
}
extern "C" {
    pub static phy_basic_t1_features_array: [core::ffi::c_int; 3usize];
}
extern "C" {
    pub static phy_basic_t1s_p2mp_features_array: [core::ffi::c_int; 2usize];
}
extern "C" {
    pub static phy_gbit_features_array: [core::ffi::c_int; 2usize];
}
extern "C" {
    pub static phy_10gbit_features_array: [core::ffi::c_int; 1usize];
}
pub const phy_interface_t_PHY_INTERFACE_MODE_NA: phy_interface_t = 0;
pub const phy_interface_t_PHY_INTERFACE_MODE_INTERNAL: phy_interface_t = 1;
pub const phy_interface_t_PHY_INTERFACE_MODE_MII: phy_interface_t = 2;
pub const phy_interface_t_PHY_INTERFACE_MODE_GMII: phy_interface_t = 3;
pub const phy_interface_t_PHY_INTERFACE_MODE_SGMII: phy_interface_t = 4;
pub const phy_interface_t_PHY_INTERFACE_MODE_TBI: phy_interface_t = 5;
pub const phy_interface_t_PHY_INTERFACE_MODE_REVMII: phy_interface_t = 6;
pub const phy_interface_t_PHY_INTERFACE_MODE_RMII: phy_interface_t = 7;
pub const phy_interface_t_PHY_INTERFACE_MODE_REVRMII: phy_interface_t = 8;
pub const phy_interface_t_PHY_INTERFACE_MODE_RGMII: phy_interface_t = 9;
pub const phy_interface_t_PHY_INTERFACE_MODE_RGMII_ID: phy_interface_t = 10;
pub const phy_interface_t_PHY_INTERFACE_MODE_RGMII_RXID: phy_interface_t = 11;
pub const phy_interface_t_PHY_INTERFACE_MODE_RGMII_TXID: phy_interface_t = 12;
pub const phy_interface_t_PHY_INTERFACE_MODE_RTBI: phy_interface_t = 13;
pub const phy_interface_t_PHY_INTERFACE_MODE_SMII: phy_interface_t = 14;
pub const phy_interface_t_PHY_INTERFACE_MODE_XGMII: phy_interface_t = 15;
pub const phy_interface_t_PHY_INTERFACE_MODE_XLGMII: phy_interface_t = 16;
pub const phy_interface_t_PHY_INTERFACE_MODE_MOCA: phy_interface_t = 17;
pub const phy_interface_t_PHY_INTERFACE_MODE_PSGMII: phy_interface_t = 18;
pub const phy_interface_t_PHY_INTERFACE_MODE_QSGMII: phy_interface_t = 19;
pub const phy_interface_t_PHY_INTERFACE_MODE_TRGMII: phy_interface_t = 20;
pub const phy_interface_t_PHY_INTERFACE_MODE_100BASEX: phy_interface_t = 21;
pub const phy_interface_t_PHY_INTERFACE_MODE_1000BASEX: phy_interface_t = 22;
pub const phy_interface_t_PHY_INTERFACE_MODE_2500BASEX: phy_interface_t = 23;
pub const phy_interface_t_PHY_INTERFACE_MODE_5GBASER: phy_interface_t = 24;
pub const phy_interface_t_PHY_INTERFACE_MODE_RXAUI: phy_interface_t = 25;
pub const phy_interface_t_PHY_INTERFACE_MODE_XAUI: phy_interface_t = 26;
pub const phy_interface_t_PHY_INTERFACE_MODE_10GBASER: phy_interface_t = 27;
pub const phy_interface_t_PHY_INTERFACE_MODE_25GBASER: phy_interface_t = 28;
pub const phy_interface_t_PHY_INTERFACE_MODE_USXGMII: phy_interface_t = 29;
pub const phy_interface_t_PHY_INTERFACE_MODE_10GKR: phy_interface_t = 30;
pub const phy_interface_t_PHY_INTERFACE_MODE_QUSGMII: phy_interface_t = 31;
pub const phy_interface_t_PHY_INTERFACE_MODE_1000BASEKX: phy_interface_t = 32;
pub const phy_interface_t_PHY_INTERFACE_MODE_MAX: phy_interface_t = 33;
pub type phy_interface_t = core::ffi::c_uint;
extern "C" {
    pub fn phy_supported_speeds(
        phy: *mut phy_device,
        speeds: *mut core::ffi::c_uint,
        size: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phylink {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sfp_bus {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sfp_upstream_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mdio_bus_stats {
    pub transfers: u64_stats_t,
    pub errors: u64_stats_t,
    pub writes: u64_stats_t,
    pub reads: u64_stats_t,
    pub syncp: u64_stats_sync,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_package_shared {
    pub base_addr: u8_,
    pub refcnt: refcount_t,
    pub flags: core::ffi::c_ulong,
    pub priv_size: usize,
    pub priv_: *mut core::ffi::c_void,
}
impl Default for phy_package_shared {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mii_bus {
    pub owner: *mut module,
    pub name: *const core::ffi::c_char,
    pub id: [core::ffi::c_char; 61usize],
    pub priv_: *mut core::ffi::c_void,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            bus: *mut mii_bus,
            addr: core::ffi::c_int,
            regnum: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            bus: *mut mii_bus,
            addr: core::ffi::c_int,
            regnum: core::ffi::c_int,
            val: u16_,
        ) -> core::ffi::c_int,
    >,
    pub read_c45: ::core::option::Option<
        unsafe extern "C" fn(
            bus: *mut mii_bus,
            addr: core::ffi::c_int,
            devnum: core::ffi::c_int,
            regnum: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub write_c45: ::core::option::Option<
        unsafe extern "C" fn(
            bus: *mut mii_bus,
            addr: core::ffi::c_int,
            devnum: core::ffi::c_int,
            regnum: core::ffi::c_int,
            val: u16_,
        ) -> core::ffi::c_int,
    >,
    pub reset: ::core::option::Option<unsafe extern "C" fn(bus: *mut mii_bus) -> core::ffi::c_int>,
    pub stats: [mdio_bus_stats; 32usize],
    pub mdio_lock: mutex,
    pub parent: *mut device,
    pub state: mii_bus__bindgen_ty_1,
    pub dev: device,
    pub mdio_map: [*mut mdio_device; 32usize],
    pub phy_mask: u32_,
    pub phy_ignore_ta_mask: u32_,
    pub irq: [core::ffi::c_int; 32usize],
    pub reset_delay_us: core::ffi::c_int,
    pub reset_post_delay_us: core::ffi::c_int,
    pub reset_gpiod: *mut gpio_desc,
    pub shared_lock: mutex,
    pub shared: [*mut phy_package_shared; 32usize],
}
pub const mii_bus_MDIOBUS_ALLOCATED: mii_bus__bindgen_ty_1 = 1;
pub const mii_bus_MDIOBUS_REGISTERED: mii_bus__bindgen_ty_1 = 2;
pub const mii_bus_MDIOBUS_UNREGISTERED: mii_bus__bindgen_ty_1 = 3;
pub const mii_bus_MDIOBUS_RELEASED: mii_bus__bindgen_ty_1 = 4;
pub type mii_bus__bindgen_ty_1 = core::ffi::c_uint;
impl Default for mii_bus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn mdiobus_alloc_size(size: usize) -> *mut mii_bus;
}
extern "C" {
    pub fn __mdiobus_register(bus: *mut mii_bus, owner: *mut module) -> core::ffi::c_int;
}
extern "C" {
    pub fn __devm_mdiobus_register(
        dev: *mut device,
        bus: *mut mii_bus,
        owner: *mut module,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdiobus_unregister(bus: *mut mii_bus);
}
extern "C" {
    pub fn mdiobus_free(bus: *mut mii_bus);
}
extern "C" {
    pub fn devm_mdiobus_alloc_size(dev: *mut device, sizeof_priv: core::ffi::c_int)
        -> *mut mii_bus;
}
extern "C" {
    pub fn mdio_find_bus(mdio_name: *const core::ffi::c_char) -> *mut mii_bus;
}
extern "C" {
    pub fn mdiobus_scan_c22(bus: *mut mii_bus, addr: core::ffi::c_int) -> *mut phy_device;
}
pub const phy_state_PHY_DOWN: phy_state = 0;
pub const phy_state_PHY_READY: phy_state = 1;
pub const phy_state_PHY_HALTED: phy_state = 2;
pub const phy_state_PHY_ERROR: phy_state = 3;
pub const phy_state_PHY_UP: phy_state = 4;
pub const phy_state_PHY_RUNNING: phy_state = 5;
pub const phy_state_PHY_NOLINK: phy_state = 6;
pub const phy_state_PHY_CABLETEST: phy_state = 7;
pub type phy_state = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct phy_c45_device_ids {
    pub devices_in_package: u32_,
    pub mmds_present: u32_,
    pub device_ids: [u32_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct macsec_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct macsec_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_device {
    pub mdio: mdio_device,
    pub drv: *mut phy_driver,
    pub devlink: *mut device_link,
    pub phy_id: u32_,
    pub c45_ids: phy_c45_device_ids,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub rate_matching: core::ffi::c_int,
    pub state: phy_state,
    pub dev_flags: u32_,
    pub interface: phy_interface_t,
    pub possible_interfaces: [core::ffi::c_ulong; 1usize],
    pub speed: core::ffi::c_int,
    pub duplex: core::ffi::c_int,
    pub port: core::ffi::c_int,
    pub pause: core::ffi::c_int,
    pub asym_pause: core::ffi::c_int,
    pub master_slave_get: u8_,
    pub master_slave_set: u8_,
    pub master_slave_state: u8_,
    pub supported: [core::ffi::c_ulong; 2usize],
    pub advertising: [core::ffi::c_ulong; 2usize],
    pub lp_advertising: [core::ffi::c_ulong; 2usize],
    pub adv_old: [core::ffi::c_ulong; 2usize],
    pub supported_eee: [core::ffi::c_ulong; 2usize],
    pub advertising_eee: [core::ffi::c_ulong; 2usize],
    pub eee_enabled: bool_,
    pub host_interfaces: [core::ffi::c_ulong; 1usize],
    pub eee_broken_modes: u32_,
    pub phy_led_triggers: *mut phy_led_trigger,
    pub phy_num_led_triggers: core::ffi::c_uint,
    pub last_triggered: *mut phy_led_trigger,
    pub led_link_trigger: *mut phy_led_trigger,
    pub leds: list_head,
    pub irq: core::ffi::c_int,
    pub priv_: *mut core::ffi::c_void,
    pub shared: *mut phy_package_shared,
    pub skb: *mut sk_buff,
    pub ehdr: *mut core::ffi::c_void,
    pub nest: *mut nlattr,
    pub state_queue: delayed_work,
    pub lock: mutex,
    pub sfp_bus_attached: bool_,
    pub sfp_bus: *mut sfp_bus,
    pub phylink: *mut phylink,
    pub attached_dev: *mut net_device,
    pub mii_ts: *mut mii_timestamper,
    pub psec: *mut pse_control,
    pub mdix: u8_,
    pub mdix_ctrl: u8_,
    pub pma_extable: core::ffi::c_int,
    pub link_down_events: core::ffi::c_uint,
    pub phy_link_change:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device, up: bool_)>,
    pub adjust_link: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
    pub macsec_ops: *const macsec_ops,
}
impl Default for phy_device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl phy_device {
    #[inline]
    pub fn is_c45(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_c45(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_internal(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_internal(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_pseudo_fixed_link(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_pseudo_fixed_link(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_gigabit_capable(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_gigabit_capable(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_fixups(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_fixups(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn suspended(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_suspended(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn suspended_by_mdio_bus(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_suspended_by_mdio_bus(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sysfs_links(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sysfs_links(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn loopback_enabled(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_loopback_enabled(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn downshifted_rate(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_downshifted_rate(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_on_sfp_module(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_on_sfp_module(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mac_managed_pm(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mac_managed_pm(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wol_enabled(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wol_enabled(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autoneg(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autoneg(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_link(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autoneg_complete(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autoneg_complete(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn interrupts(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interrupts(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irq_suspended(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irq_suspended(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irq_rerun(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irq_rerun(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_c45: core::ffi::c_uint,
        is_internal: core::ffi::c_uint,
        is_pseudo_fixed_link: core::ffi::c_uint,
        is_gigabit_capable: core::ffi::c_uint,
        has_fixups: core::ffi::c_uint,
        suspended: core::ffi::c_uint,
        suspended_by_mdio_bus: core::ffi::c_uint,
        sysfs_links: core::ffi::c_uint,
        loopback_enabled: core::ffi::c_uint,
        downshifted_rate: core::ffi::c_uint,
        is_on_sfp_module: core::ffi::c_uint,
        mac_managed_pm: core::ffi::c_uint,
        wol_enabled: core::ffi::c_uint,
        autoneg: core::ffi::c_uint,
        link: core::ffi::c_uint,
        autoneg_complete: core::ffi::c_uint,
        interrupts: core::ffi::c_uint,
        irq_suspended: core::ffi::c_uint,
        irq_rerun: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_c45: u32 = unsafe { ::core::mem::transmute(is_c45) };
            is_c45 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_internal: u32 = unsafe { ::core::mem::transmute(is_internal) };
            is_internal as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_pseudo_fixed_link: u32 = unsafe { ::core::mem::transmute(is_pseudo_fixed_link) };
            is_pseudo_fixed_link as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_gigabit_capable: u32 = unsafe { ::core::mem::transmute(is_gigabit_capable) };
            is_gigabit_capable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_fixups: u32 = unsafe { ::core::mem::transmute(has_fixups) };
            has_fixups as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let suspended: u32 = unsafe { ::core::mem::transmute(suspended) };
            suspended as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let suspended_by_mdio_bus: u32 =
                unsafe { ::core::mem::transmute(suspended_by_mdio_bus) };
            suspended_by_mdio_bus as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sysfs_links: u32 = unsafe { ::core::mem::transmute(sysfs_links) };
            sysfs_links as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let loopback_enabled: u32 = unsafe { ::core::mem::transmute(loopback_enabled) };
            loopback_enabled as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let downshifted_rate: u32 = unsafe { ::core::mem::transmute(downshifted_rate) };
            downshifted_rate as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let is_on_sfp_module: u32 = unsafe { ::core::mem::transmute(is_on_sfp_module) };
            is_on_sfp_module as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let mac_managed_pm: u32 = unsafe { ::core::mem::transmute(mac_managed_pm) };
            mac_managed_pm as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let wol_enabled: u32 = unsafe { ::core::mem::transmute(wol_enabled) };
            wol_enabled as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let autoneg: u32 = unsafe { ::core::mem::transmute(autoneg) };
            autoneg as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let link: u32 = unsafe { ::core::mem::transmute(link) };
            link as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let autoneg_complete: u32 = unsafe { ::core::mem::transmute(autoneg_complete) };
            autoneg_complete as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let interrupts: u32 = unsafe { ::core::mem::transmute(interrupts) };
            interrupts as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let irq_suspended: u32 = unsafe { ::core::mem::transmute(irq_suspended) };
            irq_suspended as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let irq_rerun: u32 = unsafe { ::core::mem::transmute(irq_rerun) };
            irq_rerun as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct phy_tdr_config {
    pub first: u32_,
    pub last: u32_,
    pub step: u32_,
    pub pair: s8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct phy_plca_cfg {
    pub version: core::ffi::c_int,
    pub enabled: core::ffi::c_int,
    pub node_id: core::ffi::c_int,
    pub node_cnt: core::ffi::c_int,
    pub to_tmr: core::ffi::c_int,
    pub burst_cnt: core::ffi::c_int,
    pub burst_tmr: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct phy_plca_status {
    pub pst: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_led {
    pub list: list_head,
    pub phydev: *mut phy_device,
    pub led_cdev: led_classdev,
    pub index: u8_,
}
impl Default for phy_led {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_driver {
    pub mdiodrv: mdio_driver_common,
    pub phy_id: u32_,
    pub name: *mut core::ffi::c_char,
    pub phy_id_mask: u32_,
    pub features: *const core::ffi::c_ulong,
    pub flags: u32_,
    pub driver_data: *const core::ffi::c_void,
    pub soft_reset:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> core::ffi::c_int>,
    pub config_init:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> core::ffi::c_int>,
    pub probe:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> core::ffi::c_int>,
    pub get_features:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> core::ffi::c_int>,
    pub get_rate_matching: ::core::option::Option<
        unsafe extern "C" fn(phydev: *mut phy_device, iface: phy_interface_t) -> core::ffi::c_int,
    >,
    pub suspend:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> core::ffi::c_int>,
    pub resume:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> core::ffi::c_int>,
    pub config_aneg:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> core::ffi::c_int>,
    pub aneg_done:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> core::ffi::c_int>,
    pub read_status:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> core::ffi::c_int>,
    pub config_intr:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> core::ffi::c_int>,
    pub handle_interrupt:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> irqreturn_t>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device)>,
    pub match_phy_device:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> core::ffi::c_int>,
    pub set_wol: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, wol: *mut ethtool_wolinfo) -> core::ffi::c_int,
    >,
    pub get_wol: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, wol: *mut ethtool_wolinfo),
    >,
    pub link_change_notify: ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device)>,
    pub read_mmd: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            devnum: core::ffi::c_int,
            regnum: u16_,
        ) -> core::ffi::c_int,
    >,
    pub write_mmd: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            devnum: core::ffi::c_int,
            regnum: u16_,
            val: u16_,
        ) -> core::ffi::c_int,
    >,
    pub read_page:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device) -> core::ffi::c_int>,
    pub write_page: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, page: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub module_info: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            modinfo: *mut ethtool_modinfo,
        ) -> core::ffi::c_int,
    >,
    pub module_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            ee: *mut ethtool_eeprom,
            data: *mut u8_,
        ) -> core::ffi::c_int,
    >,
    pub cable_test_start:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device) -> core::ffi::c_int>,
    pub cable_test_tdr_start: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            config: *const phy_tdr_config,
        ) -> core::ffi::c_int,
    >,
    pub cable_test_get_status: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, finished: *mut bool_) -> core::ffi::c_int,
    >,
    pub get_sset_count:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device) -> core::ffi::c_int>,
    pub get_strings:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device, data: *mut u8_)>,
    pub get_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, stats: *mut ethtool_stats, data: *mut u64_),
    >,
    pub get_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            tuna: *mut ethtool_tunable,
            data: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub set_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            tuna: *mut ethtool_tunable,
            data: *const core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub set_loopback: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, enable: bool_) -> core::ffi::c_int,
    >,
    pub get_sqi:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device) -> core::ffi::c_int>,
    pub get_sqi_max:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut phy_device) -> core::ffi::c_int>,
    pub get_plca_cfg: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut phy_device, plca_cfg: *mut phy_plca_cfg) -> core::ffi::c_int,
    >,
    pub set_plca_cfg: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            plca_cfg: *const phy_plca_cfg,
        ) -> core::ffi::c_int,
    >,
    pub get_plca_status: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            plca_st: *mut phy_plca_status,
        ) -> core::ffi::c_int,
    >,
    pub led_brightness_set: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            index: u8_,
            value: led_brightness,
        ) -> core::ffi::c_int,
    >,
    pub led_blink_set: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            index: u8_,
            delay_on: *mut core::ffi::c_ulong,
            delay_off: *mut core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub led_hw_is_supported: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            index: u8_,
            rules: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub led_hw_control_set: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            index: u8_,
            rules: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub led_hw_control_get: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut phy_device,
            index: u8_,
            rules: *mut core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
}
impl Default for phy_driver {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_fixup {
    pub list: list_head,
    pub bus_id: [core::ffi::c_char; 64usize],
    pub phy_uid: u32_,
    pub phy_uid_mask: u32_,
    pub run:
        ::core::option::Option<unsafe extern "C" fn(phydev: *mut phy_device) -> core::ffi::c_int>,
}
impl Default for phy_fixup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn phy_speed_to_str(speed: core::ffi::c_int) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn phy_duplex_to_str(duplex: core::ffi::c_uint) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn phy_rate_matching_to_str(rate_matching: core::ffi::c_int) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn phy_interface_num_ports(interface: phy_interface_t) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct phy_setting {
    pub speed: u32_,
    pub duplex: u8_,
    pub bit: u8_,
}
extern "C" {
    pub fn phy_lookup_setting(
        speed: core::ffi::c_int,
        duplex: core::ffi::c_int,
        mask: *const core::ffi::c_ulong,
        exact: bool_,
    ) -> *const phy_setting;
}
extern "C" {
    pub fn phy_speeds(
        speeds: *mut core::ffi::c_uint,
        size: usize,
        mask: *mut core::ffi::c_ulong,
    ) -> usize;
}
extern "C" {
    pub fn of_set_phy_supported(phydev: *mut phy_device);
}
extern "C" {
    pub fn of_set_phy_eee_broken(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_speed_down_core(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_resolve_aneg_pause(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_resolve_aneg_linkmode(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_check_downshift(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_read_mmd(
        phydev: *mut phy_device,
        devad: core::ffi::c_int,
        regnum: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __phy_read_mmd(
        phydev: *mut phy_device,
        devad: core::ffi::c_int,
        regnum: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_write_mmd(
        phydev: *mut phy_device,
        devad: core::ffi::c_int,
        regnum: u32_,
        val: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __phy_write_mmd(
        phydev: *mut phy_device,
        devad: core::ffi::c_int,
        regnum: u32_,
        val: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_modify_changed(
        phydev: *mut phy_device,
        regnum: u32_,
        mask: u16_,
        set: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __phy_modify(
        phydev: *mut phy_device,
        regnum: u32_,
        mask: u16_,
        set: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_modify(
        phydev: *mut phy_device,
        regnum: u32_,
        mask: u16_,
        set: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __phy_modify_mmd_changed(
        phydev: *mut phy_device,
        devad: core::ffi::c_int,
        regnum: u32_,
        mask: u16_,
        set: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_modify_mmd_changed(
        phydev: *mut phy_device,
        devad: core::ffi::c_int,
        regnum: u32_,
        mask: u16_,
        set: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __phy_modify_mmd(
        phydev: *mut phy_device,
        devad: core::ffi::c_int,
        regnum: u32_,
        mask: u16_,
        set: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_modify_mmd(
        phydev: *mut phy_device,
        devad: core::ffi::c_int,
        regnum: u32_,
        mask: u16_,
        set: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_save_page(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_select_page(phydev: *mut phy_device, page: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_restore_page(
        phydev: *mut phy_device,
        oldpage: core::ffi::c_int,
        ret: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_read_paged(
        phydev: *mut phy_device,
        page: core::ffi::c_int,
        regnum: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_write_paged(
        phydev: *mut phy_device,
        page: core::ffi::c_int,
        regnum: u32_,
        val: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_modify_paged_changed(
        phydev: *mut phy_device,
        page: core::ffi::c_int,
        regnum: u32_,
        mask: u16_,
        set: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_modify_paged(
        phydev: *mut phy_device,
        page: core::ffi::c_int,
        regnum: u32_,
        mask: u16_,
        set: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_device_create(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        phy_id: u32_,
        is_c45: bool_,
        c45_ids: *mut phy_c45_device_ids,
    ) -> *mut phy_device;
}
extern "C" {
    pub fn fwnode_get_phy_id(fwnode: *mut fwnode_handle, phy_id: *mut u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn fwnode_mdio_find_device(fwnode: *mut fwnode_handle) -> *mut mdio_device;
}
extern "C" {
    pub fn fwnode_phy_find_device(phy_fwnode: *mut fwnode_handle) -> *mut phy_device;
}
extern "C" {
    pub fn device_phy_find_device(dev: *mut device) -> *mut phy_device;
}
extern "C" {
    pub fn fwnode_get_phy_node(fwnode: *const fwnode_handle) -> *mut fwnode_handle;
}
extern "C" {
    pub fn get_phy_device(
        bus: *mut mii_bus,
        addr: core::ffi::c_int,
        is_c45: bool_,
    ) -> *mut phy_device;
}
extern "C" {
    pub fn phy_device_register(phy: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_device_free(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_device_remove(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_get_c45_ids(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_init_hw(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_suspend(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_resume(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn __phy_resume(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_loopback(phydev: *mut phy_device, enable: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_sfp_attach(upstream: *mut core::ffi::c_void, bus: *mut sfp_bus);
}
extern "C" {
    pub fn phy_sfp_detach(upstream: *mut core::ffi::c_void, bus: *mut sfp_bus);
}
extern "C" {
    pub fn phy_sfp_probe(phydev: *mut phy_device, ops: *const sfp_upstream_ops)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_attach(
        dev: *mut net_device,
        bus_id: *const core::ffi::c_char,
        interface: phy_interface_t,
    ) -> *mut phy_device;
}
extern "C" {
    pub fn phy_find_first(bus: *mut mii_bus) -> *mut phy_device;
}
extern "C" {
    pub fn phy_attach_direct(
        dev: *mut net_device,
        phydev: *mut phy_device,
        flags: u32_,
        interface: phy_interface_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_connect_direct(
        dev: *mut net_device,
        phydev: *mut phy_device,
        handler: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
        interface: phy_interface_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_connect(
        dev: *mut net_device,
        bus_id: *const core::ffi::c_char,
        handler: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
        interface: phy_interface_t,
    ) -> *mut phy_device;
}
extern "C" {
    pub fn phy_disconnect(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_detach(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_start(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_stop(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_config_aneg(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn _phy_start_aneg(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_start_aneg(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_aneg_done(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_speed_down(phydev: *mut phy_device, sync: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_speed_up(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_check_valid(
        speed: core::ffi::c_int,
        duplex: core::ffi::c_int,
        features: *mut core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn phy_restart_aneg(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_reset_after_clk_enable(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_start_cable_test(
        phydev: *mut phy_device,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_start_cable_test_tdr(
        phydev: *mut phy_device,
        extack: *mut netlink_ext_ack,
        config: *const phy_tdr_config,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_attached_print(phydev: *mut phy_device, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn phy_attached_info_irq(phydev: *mut phy_device) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn phy_attached_info(phydev: *mut phy_device);
}
extern "C" {
    pub fn genphy_read_abilities(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_setup_forced(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_restart_aneg(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_check_and_restart_aneg(
        phydev: *mut phy_device,
        restart: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_config_eee_advert(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn __genphy_config_aneg(phydev: *mut phy_device, changed: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_aneg_done(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_update_link(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_read_lpa(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_read_status_fixed(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_read_status(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_read_master_slave(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_suspend(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_resume(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_loopback(phydev: *mut phy_device, enable: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_soft_reset(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_handle_interrupt_no_ack(phydev: *mut phy_device) -> irqreturn_t;
}
extern "C" {
    pub fn genphy_read_mmd_unsupported(
        phdev: *mut phy_device,
        devad: core::ffi::c_int,
        regnum: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_write_mmd_unsupported(
        phdev: *mut phy_device,
        devnum: core::ffi::c_int,
        regnum: u16_,
        val: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c37_config_aneg(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c37_read_status(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_restart_aneg(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_check_and_restart_aneg(
        phydev: *mut phy_device,
        restart: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_aneg_done(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_read_link(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_read_lpa(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_read_pma(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_pma_setup_forced(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_pma_baset1_setup_master_slave(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_an_config_aneg(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_an_disable_aneg(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_read_mdix(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_pma_read_abilities(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_pma_read_ext_abilities(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_pma_baset1_read_abilities(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_read_eee_abilities(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_pma_baset1_read_master_slave(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_read_status(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_baset1_read_status(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_config_aneg(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_loopback(phydev: *mut phy_device, enable: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_pma_resume(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_pma_suspend(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_fast_retrain(phydev: *mut phy_device, enable: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_plca_get_cfg(
        phydev: *mut phy_device,
        plca_cfg: *mut phy_plca_cfg,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_plca_set_cfg(
        phydev: *mut phy_device,
        plca_cfg: *const phy_plca_cfg,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_plca_get_status(
        phydev: *mut phy_device,
        plca_st: *mut phy_plca_status,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_eee_is_active(
        phydev: *mut phy_device,
        adv: *mut core::ffi::c_ulong,
        lp: *mut core::ffi::c_ulong,
        is_enabled: *mut bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_ethtool_get_eee(
        phydev: *mut phy_device,
        data: *mut ethtool_eee,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_ethtool_set_eee(
        phydev: *mut phy_device,
        data: *mut ethtool_eee,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_write_eee_adv(
        phydev: *mut phy_device,
        adv: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_an_config_eee_aneg(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn genphy_c45_read_eee_adv(
        phydev: *mut phy_device,
        adv: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut genphy_c45_driver: phy_driver;
}
extern "C" {
    pub fn gen10g_config_aneg(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_driver_unregister(drv: *mut phy_driver);
}
extern "C" {
    pub fn phy_drivers_unregister(drv: *mut phy_driver, n: core::ffi::c_int);
}
extern "C" {
    pub fn phy_driver_register(new_driver: *mut phy_driver, owner: *mut module)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_drivers_register(
        new_driver: *mut phy_driver,
        n: core::ffi::c_int,
        owner: *mut module,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_error(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_state_machine(work: *mut work_struct);
}
extern "C" {
    pub fn phy_queue_state_machine(phydev: *mut phy_device, jiffies: core::ffi::c_ulong);
}
extern "C" {
    pub fn phy_trigger_machine(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_mac_interrupt(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_start_machine(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_stop_machine(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_ethtool_ksettings_get(phydev: *mut phy_device, cmd: *mut ethtool_link_ksettings);
}
extern "C" {
    pub fn phy_ethtool_ksettings_set(
        phydev: *mut phy_device,
        cmd: *const ethtool_link_ksettings,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_mii_ioctl(
        phydev: *mut phy_device,
        ifr: *mut ifreq,
        cmd: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_do_ioctl(
        dev: *mut net_device,
        ifr: *mut ifreq,
        cmd: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_do_ioctl_running(
        dev: *mut net_device,
        ifr: *mut ifreq,
        cmd: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_disable_interrupts(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_request_interrupt(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_free_interrupt(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_print_status(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_get_rate_matching(
        phydev: *mut phy_device,
        iface: phy_interface_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_set_max_speed(phydev: *mut phy_device, max_speed: u32_);
}
extern "C" {
    pub fn phy_remove_link_mode(phydev: *mut phy_device, link_mode: u32_);
}
extern "C" {
    pub fn phy_advertise_supported(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_support_sym_pause(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_support_asym_pause(phydev: *mut phy_device);
}
extern "C" {
    pub fn phy_set_sym_pause(phydev: *mut phy_device, rx: bool_, tx: bool_, autoneg: bool_);
}
extern "C" {
    pub fn phy_set_asym_pause(phydev: *mut phy_device, rx: bool_, tx: bool_);
}
extern "C" {
    pub fn phy_validate_pause(phydev: *mut phy_device, pp: *mut ethtool_pauseparam) -> bool_;
}
extern "C" {
    pub fn phy_get_pause(phydev: *mut phy_device, tx_pause: *mut bool_, rx_pause: *mut bool_);
}
extern "C" {
    pub fn phy_get_internal_delay(
        phydev: *mut phy_device,
        dev: *mut device,
        delay_values: *const core::ffi::c_int,
        size: core::ffi::c_int,
        is_rx: bool_,
    ) -> s32;
}
extern "C" {
    pub fn phy_resolve_pause(
        local_adv: *mut core::ffi::c_ulong,
        partner_adv: *mut core::ffi::c_ulong,
        tx_pause: *mut bool_,
        rx_pause: *mut bool_,
    );
}
extern "C" {
    pub fn phy_register_fixup(
        bus_id: *const core::ffi::c_char,
        phy_uid: u32_,
        phy_uid_mask: u32_,
        run: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut phy_device) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_register_fixup_for_id(
        bus_id: *const core::ffi::c_char,
        run: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut phy_device) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_register_fixup_for_uid(
        phy_uid: u32_,
        phy_uid_mask: u32_,
        run: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut phy_device) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_unregister_fixup(
        bus_id: *const core::ffi::c_char,
        phy_uid: u32_,
        phy_uid_mask: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_unregister_fixup_for_id(bus_id: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_unregister_fixup_for_uid(phy_uid: u32_, phy_uid_mask: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_init_eee(phydev: *mut phy_device, clk_stop_enable: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_get_eee_err(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_ethtool_set_eee(phydev: *mut phy_device, data: *mut ethtool_eee)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_ethtool_get_eee(phydev: *mut phy_device, data: *mut ethtool_eee)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_ethtool_set_wol(
        phydev: *mut phy_device,
        wol: *mut ethtool_wolinfo,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_ethtool_get_wol(phydev: *mut phy_device, wol: *mut ethtool_wolinfo);
}
extern "C" {
    pub fn phy_ethtool_get_link_ksettings(
        ndev: *mut net_device,
        cmd: *mut ethtool_link_ksettings,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_ethtool_set_link_ksettings(
        ndev: *mut net_device,
        cmd: *const ethtool_link_ksettings,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_ethtool_nway_reset(ndev: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_package_join(
        phydev: *mut phy_device,
        base_addr: core::ffi::c_int,
        priv_size: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_package_leave(phydev: *mut phy_device);
}
extern "C" {
    pub fn devm_phy_package_join(
        dev: *mut device,
        phydev: *mut phy_device,
        base_addr: core::ffi::c_int,
        priv_size: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mdio_bus_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn mdio_bus_exit();
}
extern "C" {
    pub fn phy_ethtool_get_strings(phydev: *mut phy_device, data: *mut u8_) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_ethtool_get_sset_count(phydev: *mut phy_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_ethtool_get_stats(
        phydev: *mut phy_device,
        stats: *mut ethtool_stats,
        data: *mut u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_ethtool_get_plca_cfg(
        phydev: *mut phy_device,
        plca_cfg: *mut phy_plca_cfg,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_ethtool_set_plca_cfg(
        phydev: *mut phy_device,
        plca_cfg: *const phy_plca_cfg,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_ethtool_get_plca_status(
        phydev: *mut phy_device,
        plca_st: *mut phy_plca_status,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __phy_hwtstamp_get(
        phydev: *mut phy_device,
        config: *mut kernel_hwtstamp_config,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __phy_hwtstamp_set(
        phydev: *mut phy_device,
        config: *mut kernel_hwtstamp_config,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __phy_package_read_mmd(
        phydev: *mut phy_device,
        addr_offset: core::ffi::c_uint,
        devad: core::ffi::c_int,
        regnum: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_package_read_mmd(
        phydev: *mut phy_device,
        addr_offset: core::ffi::c_uint,
        devad: core::ffi::c_int,
        regnum: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __phy_package_write_mmd(
        phydev: *mut phy_device,
        addr_offset: core::ffi::c_uint,
        devad: core::ffi::c_int,
        regnum: u32_,
        val: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_package_write_mmd(
        phydev: *mut phy_device,
        addr_offset: core::ffi::c_uint,
        devad: core::ffi::c_int,
        regnum: u32_,
        val: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut mdio_bus_type: bus_type;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mdio_board_info {
    pub bus_id: *const core::ffi::c_char,
    pub modalias: [core::ffi::c_char; 32usize],
    pub mdio_addr: core::ffi::c_int,
    pub platform_data: *const core::ffi::c_void,
}
impl Default for mdio_board_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn mdiobus_register_board_info(
        info: *const mdio_board_info,
        n: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn phy_driver_is_genphy(phydev: *mut phy_device) -> bool_;
}
extern "C" {
    pub fn phy_driver_is_genphy_10g(phydev: *mut phy_device) -> bool_;
}
pub type insn_attr_t = core::ffi::c_uint;
pub type insn_byte_t = core::ffi::c_uchar;
pub type insn_value_t = core::ffi::c_int;
extern "C" {
    pub fn inat_get_opcode_attribute(opcode: insn_byte_t) -> insn_attr_t;
}
extern "C" {
    pub fn inat_get_last_prefix_id(last_pfx: insn_byte_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn inat_get_escape_attribute(
        opcode: insn_byte_t,
        lpfx_id: core::ffi::c_int,
        esc_attr: insn_attr_t,
    ) -> insn_attr_t;
}
extern "C" {
    pub fn inat_get_group_attribute(
        modrm: insn_byte_t,
        lpfx_id: core::ffi::c_int,
        esc_attr: insn_attr_t,
    ) -> insn_attr_t;
}
extern "C" {
    pub fn inat_get_avx_attribute(
        opcode: insn_byte_t,
        vex_m: insn_byte_t,
        vex_pp: insn_byte_t,
    ) -> insn_attr_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct insn_field {
    pub __bindgen_anon_1: insn_field__bindgen_ty_1,
    pub got: core::ffi::c_uchar,
    pub nbytes: core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union insn_field__bindgen_ty_1 {
    pub value: insn_value_t,
    pub bytes: [insn_byte_t; 4usize],
}
impl Default for insn_field__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for insn_field {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct insn {
    pub prefixes: insn_field,
    pub rex_prefix: insn_field,
    pub vex_prefix: insn_field,
    pub opcode: insn_field,
    pub modrm: insn_field,
    pub sib: insn_field,
    pub displacement: insn_field,
    pub __bindgen_anon_1: insn__bindgen_ty_1,
    pub __bindgen_anon_2: insn__bindgen_ty_2,
    pub emulate_prefix_size: core::ffi::c_int,
    pub attr: insn_attr_t,
    pub opnd_bytes: core::ffi::c_uchar,
    pub addr_bytes: core::ffi::c_uchar,
    pub length: core::ffi::c_uchar,
    pub x86_64: core::ffi::c_uchar,
    pub kaddr: *const insn_byte_t,
    pub end_kaddr: *const insn_byte_t,
    pub next_byte: *const insn_byte_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union insn__bindgen_ty_1 {
    pub immediate: insn_field,
    pub moffset1: insn_field,
    pub immediate1: insn_field,
}
impl Default for insn__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union insn__bindgen_ty_2 {
    pub moffset2: insn_field,
    pub immediate2: insn_field,
}
impl Default for insn__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for insn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn insn_init(
        insn: *mut insn,
        kaddr: *const core::ffi::c_void,
        buf_len: core::ffi::c_int,
        x86_64: core::ffi::c_int,
    );
}
extern "C" {
    pub fn insn_get_prefixes(insn: *mut insn) -> core::ffi::c_int;
}
extern "C" {
    pub fn insn_get_opcode(insn: *mut insn) -> core::ffi::c_int;
}
extern "C" {
    pub fn insn_get_modrm(insn: *mut insn) -> core::ffi::c_int;
}
extern "C" {
    pub fn insn_get_sib(insn: *mut insn) -> core::ffi::c_int;
}
extern "C" {
    pub fn insn_get_displacement(insn: *mut insn) -> core::ffi::c_int;
}
extern "C" {
    pub fn insn_get_immediate(insn: *mut insn) -> core::ffi::c_int;
}
extern "C" {
    pub fn insn_get_length(insn: *mut insn) -> core::ffi::c_int;
}
pub const insn_mode_INSN_MODE_32: insn_mode = 0;
pub const insn_mode_INSN_MODE_64: insn_mode = 1;
pub const insn_mode_INSN_MODE_KERN: insn_mode = 2;
pub const insn_mode_INSN_NUM_MODES: insn_mode = 3;
pub type insn_mode = core::ffi::c_uint;
extern "C" {
    pub fn insn_decode(
        insn: *mut insn,
        kaddr: *const core::ffi::c_void,
        buf_len: core::ffi::c_int,
        m: insn_mode,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn insn_rip_relative(insn: *mut insn) -> core::ffi::c_int;
}
pub const ARCH_SLAB_MINALIGN: usize = 8;
pub const GFP_KERNEL: gfp_t = 3264;
pub const __GFP_ZERO: gfp_t = 256;
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: core::ffi::c_uint,
    pub fp_offset: core::ffi::c_uint,
    pub overflow_arg_area: *mut core::ffi::c_void,
    pub reg_save_area: *mut core::ffi::c_void,
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_symbol {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct module_sect_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct module_notes_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct trace_event_call {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct trace_eval_map {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct static_key_mod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct static_call_mod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct maple_pnode {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct maple_enode {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct clocksource {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct uprobe {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ldt_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct page_pool {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct userfaultfd_ctx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct linux_binfmt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct memory_tier {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct msgbuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sem {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sem_queue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sem_undo {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct files_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rt_mutex_waiter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct numa_group {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ftrace_ret_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct obj_cgroup {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct gendisk {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cgroup {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct assoc_array_ptr {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct watch_list {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct key_user {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct k_clock {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tty_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct autogroup {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct taskstats {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tty_audit_buf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct request_queue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct wait_page_queue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct file_lock_context {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cdev {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xattr_handler {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fscrypt_keyring {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct unicode_map {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct block_device {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bdev_handle {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mtd_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernfs_root {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct module_param_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_group_capacity {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pm_qos {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dma_map_ops {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bus_dma_region {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct io_tlb_mem {
    pub _address: u8,
}
pub type dev_dma_attr = i32;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_flow_keys {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct time_namespace {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nla_policy {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_rule {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct phy_led_trigger {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pse_control {
    pub _address: u8,
}
